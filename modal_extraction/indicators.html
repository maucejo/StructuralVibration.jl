<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.31">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Quality and analysis indicators â€“ StructuralVibration.jl</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script><script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../modal_extraction/frf_reconstruction.html" rel="prev">
<link href="../assets/logo/doclogo.svg" rel="icon" type="image/svg+xml">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-400b18e4f718b57415d2ed5ec8a80165.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-1a140738512e4c5ea5f4258c037310e7.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>html{ scroll-behavior: smooth; }</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>

<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../assets/logo/doclogo.svg" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">StructuralVibration.jl</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Overview</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../models/index.html"> 
<span class="menu-text">Models</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../solvers/index.html"> 
<span class="menu-text">Solvers</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="../modal_extraction/index.html" aria-current="page"> 
<span class="menu-text">Modal extraction</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../signal_processing/index.html"> 
<span class="menu-text">Signal processing</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../visualization/index.html"> 
<span class="menu-text">Visualization</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/maucejo/StructuralVibration.jl"> <i class="bi bi-github" role="img" aria-label="GitHub">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../modal_extraction/indicators.html">Quality and analysis indicators</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../modal_extraction/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Primer on EMA</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../modal_extraction/sdof_methods.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Sdof methods</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../modal_extraction/mdof_methods.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Mdof methods</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../modal_extraction/frf_reconstruction.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">FRF reconstruction</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../modal_extraction/indicators.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Quality and analysis indicators</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#mode-complexity-indicators" id="toc-mode-complexity-indicators" class="nav-link active" data-scroll-target="#mode-complexity-indicators"><span class="header-section-number">1</span> Mode complexity indicators</a>
  <ul class="collapse">
  <li><a href="#mode-overcomplexity-value" id="toc-mode-overcomplexity-value" class="nav-link" data-scroll-target="#mode-overcomplexity-value"><span class="header-section-number">1.1</span> Mode Overcomplexity Value</a></li>
  <li><a href="#mode-phase-collinearity" id="toc-mode-phase-collinearity" class="nav-link" data-scroll-target="#mode-phase-collinearity"><span class="header-section-number">1.2</span> Mode Phase Collinearity</a></li>
  <li><a href="#mode-complexity-factor" id="toc-mode-complexity-factor" class="nav-link" data-scroll-target="#mode-complexity-factor"><span class="header-section-number">1.3</span> Mode Complexity Factor</a></li>
  <li><a href="#mean-phase-deviation" id="toc-mean-phase-deviation" class="nav-link" data-scroll-target="#mean-phase-deviation"><span class="header-section-number">1.4</span> Mean Phase Deviation</a></li>
  </ul></li>
  <li><a href="#correlation-indicators" id="toc-correlation-indicators" class="nav-link" data-scroll-target="#correlation-indicators"><span class="header-section-number">2</span> Correlation indicators</a>
  <ul class="collapse">
  <li><a href="#modal-assurance-criterion" id="toc-modal-assurance-criterion" class="nav-link" data-scroll-target="#modal-assurance-criterion"><span class="header-section-number">2.1</span> Modal Assurance Criterion</a></li>
  <li><a href="#coordinate-modal-assurance-criterion" id="toc-coordinate-modal-assurance-criterion" class="nav-link" data-scroll-target="#coordinate-modal-assurance-criterion"><span class="header-section-number">2.2</span> Coordinate Modal Assurance Criterion</a></li>
  <li><a href="#enhanced-coordinate-modal-assurance-criterion" id="toc-enhanced-coordinate-modal-assurance-criterion" class="nav-link" data-scroll-target="#enhanced-coordinate-modal-assurance-criterion"><span class="header-section-number">2.3</span> Enhanced Coordinate Modal Assurance Criterion</a></li>
  <li><a href="#frequency-response-assurance-criterion" id="toc-frequency-response-assurance-criterion" class="nav-link" data-scroll-target="#frequency-response-assurance-criterion"><span class="header-section-number">2.4</span> Frequency response assurance criterion</a></li>
  </ul></li>
  <li><a href="#indicator-functions" id="toc-indicator-functions" class="nav-link" data-scroll-target="#indicator-functions"><span class="header-section-number">3</span> Indicator functions</a>
  <ul class="collapse">
  <li><a href="#complex-mode-indicator-function" id="toc-complex-mode-indicator-function" class="nav-link" data-scroll-target="#complex-mode-indicator-function"><span class="header-section-number">3.1</span> Complex Mode Indicator Function</a></li>
  <li><a href="#power-spectrum-indicator-function" id="toc-power-spectrum-indicator-function" class="nav-link" data-scroll-target="#power-spectrum-indicator-function"><span class="header-section-number">3.2</span> Power spectrum indicator function</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Quality and analysis indicators</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="mode-complexity-indicators" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="mode-complexity-indicators"><span class="header-section-number">1</span> Mode complexity indicators</h2>
<p>The following indicators can be used to assess the complexity of the identified modes.</p>
<section id="mode-overcomplexity-value" class="level3" data-number="1.1">
<h3 data-number="1.1" class="anchored" data-anchor-id="mode-overcomplexity-value"><span class="header-section-number">1.1</span> Mode Overcomplexity Value</h3>
<p>The Mode Overcomplexity Value (MOV) of a mode <span class="math inline">\(i\)</span> is defined as: <span class="math display">\[
MOV_i = \frac{\sum_{n = 1}^N s_{ni} \vert\phi_{ni}\vert^2}{\sum_{n = 1}^N \vert\phi_{ni}\vert^2},
\]</span> where <span class="math inline">\(\phi_{ni}\)</span> is the mode shape value at degree of freedom <span class="math inline">\(n\)</span> for mode <span class="math inline">\(i\)</span>, and <span class="math inline">\(s_{ni}\)</span> is a weighted factor. The latter is given by: <span class="math display">\[
s_{ni} = \begin{cases}
0 &amp; \text{if } \text{Im}(-\lambda_i^2\phi_{ni}^2 c_i) &gt; 0 \\
1 &amp; \text{if } \text{Im}(-\lambda_i^2\phi_{ni}^2 c_i) \leq 0
\end{cases},
\]</span> where <span class="math inline">\(\lambda_i\)</span> is the complex eigenvalue for mode <span class="math inline">\(i\)</span>, and <span class="math inline">\(c_i\)</span> is the corresponding scaling factor.</p>
<p>A value close to 1 indicates physical modes, while a value close to 0 indicates spurious modes (or computational modes).</p>
<div class="api">
<p><strong>mov</strong></p>
<hr>
<div id="4" class="cell" data-execution_count="1">
<div class="cell-output cell-output-display" data-execution_count="1">
<div class="markdown"><pre><code class="language-julia">mov(poles, ms, ci)</code></pre>
<p>Compute the mode overcomplexity value</p>
<p>This indicator is a weighted percentage of the degrees of freedom of the response for which adding mass leads to a negative frequency shift. A value close to 1 indicates physical modes, while a low value indicates non-physical modes (numerical or noise-related)</p>
<p><strong>Inputs</strong></p>
<ul>
<li><p><code>poles</code>: Poles of the system</p>
</li>
<li><p><code>ms</code>: Mode shapes (each column corresponds to a mode)</p>
</li>
<li><p><code>ci</code>: Scaling factors associated to the mode shapes</p>
</li>
</ul>
<p><strong>Output</strong></p>
<ul>
<li><p><code>mov</code>: Mode overcomplexity values</p>
</li>
</ul>
<p><strong>Reference</strong></p>
<p>[1] M+P Analyzer manual. Rev. 5.1. 2017</p>


</div>
</div>
</div>
</div>
</section>
<section id="mode-phase-collinearity" class="level3" data-number="1.2">
<h3 data-number="1.2" class="anchored" data-anchor-id="mode-phase-collinearity"><span class="header-section-number">1.2</span> Mode Phase Collinearity</h3>
<p>The Mode Phase Collinearity (MPC) aims at determining whether a mode is real or complex. It is an indicator defined in <span class="math inline">\([0, 1]\)</span>. For a mode <span class="math inline">\(i\)</span>, it is given by: <span class="math display">\[
  MPC_i = \left(\frac{\lambda_1 - \lambda_2}{\lambda_1 + \lambda_2}\right)^2,
\]</span> where <span class="math inline">\(\lambda_1 = \frac{S_{xx} + S_{yy}}{2} + \sqrt{\left(\frac{S_{xx} - S_{yy}}{2}\right)^2 + S_{xy}^2}\)</span> and <span class="math inline">\(\lambda_2 = \frac{S_{xx} + S_{yy}}{2} - \sqrt{\left(\frac{S_{xx} - S_{yy}}{2}\right)^2 + S_{xy}^2}\)</span> are the eigenvalues of the covariance matrix <span class="math inline">\(\mathbf{S}\)</span>: <span class="math display">\[
\mathbf{S} = \begin{bmatrix}
S_{xx} &amp; S_{xy} \\
S_{xy} &amp; S_{yy}
\end{bmatrix} \text{ with } \begin{cases}
S_{xx} = \text{Re}(\tilde{\phi}_i)^T\text{Re}(\tilde{\phi}_i) \\
S_{yy} = \text{Im}(\tilde{\phi}_i)^T\text{Im}(\tilde{\phi}_i) \\
S_{xy} = \text{Re}(\tilde{\phi}_i)^T\text{Im}(\tilde{\phi}_i)
\end{cases}
\]</span> Here, <span class="math inline">\(\tilde{\phi}_i\)</span> is the corrected mode shape vector for the mode <span class="math inline">\(i\)</span> such that: <span class="math display">\[
\tilde{\phi}_{ni} = \phi_{ni} - \frac{\sum_{m = 1}^N \phi_{mi}}{N}.
\]</span></p>
<p>A value close to 1 indicates a real mode, while a value close to 0 indicates a complex mode.</p>
<div class="api">
<p><strong>mpc</strong></p>
<hr>
<div id="6" class="cell" data-execution_count="1">
<div class="cell-output cell-output-display" data-execution_count="1">
<div class="markdown"><pre><code class="language-julia">mpc(ms)</code></pre>
<p>Compute the mode phase collinearity.</p>
<p>This indicator aims to measure the complexity of a mode. Its value ranges from 0 (no collinearity) to 1 (perfect collinearity). For real modes, mpc tends towards 1.</p>
<p><strong>Input</strong></p>
<ul>
<li><p><code>ms</code>: Mode shapes (each column corresponds to a mode)</p>
</li>
</ul>
<p><strong>Output</strong></p>
<ul>
<li><p><code>mpc</code>: Mode phase collinearity values</p>
</li>
</ul>
<p><strong>References</strong></p>
<p>[1] J.-N. Juang and R. Pappa: "An eigensystem realization algorithm for modal parameter identification and model reduction", Journal of Guidance, Control, and Dynamics, Vol. 8, No. 5, Sept.-Oct. 1985, pp. 620-627.</p>
<p>[2] M+P Analyzer manual. Rev. 5.1. 2017</p>


</div>
</div>
</div>
</div>
</section>
<section id="mode-complexity-factor" class="level3" data-number="1.3">
<h3 data-number="1.3" class="anchored" data-anchor-id="mode-complexity-factor"><span class="header-section-number">1.3</span> Mode Complexity Factor</h3>
<p>The Mode Complexity Factor (MCF) for a mode <span class="math inline">\(i\)</span> is defined as: <span class="math display">\[
MCF_i = 1 - \frac{(S_{xx} - S_{yy})^2 + 4S_{xy}^2}{(S_{xx} + S_{yy})^2}
\]</span></p>
<p>A value close to 0 indicates a real mode, while a value close to 1 indicates a complex mode.</p>
</section>
<section id="mean-phase-deviation" class="level3" data-number="1.4">
<h3 data-number="1.4" class="anchored" data-anchor-id="mean-phase-deviation"><span class="header-section-number">1.4</span> Mean Phase Deviation</h3>
<p>The Mean Phase Deviation (MPD) indicator aims to measure the complexity of a mode. Its value is close to 0 for real modes, and increases as the mode becomes more complex. It is defined as: <span class="math display">\[
MPD_i = \frac{\sum_{n = 1}^N\vert\phi_{ni}\vert\; \text{acos}\left\vert\frac{\text{Re}(\phi_{ni})V_{22} - \text{Im}(\phi_{ni})V_{12}}{\sqrt{V_{12}^2 + V_{22}^2}\;\vert\phi_{ni}\vert}\right\vert}{\sum_{n = 1}^N \vert\phi_{ni}\vert},
\]</span> where <span class="math inline">\(V_{12}\)</span> and <span class="math inline">\(V_{22}\)</span> are the components of the right singular vector associated to the singular value decomposition of the 2 <span class="math inline">\(\times\)</span> 2 matrix <span class="math inline">\(\mathbf{P}\)</span> expressed as: <span class="math display">\[
\mathbf{P} = \begin{bmatrix}
\text{Re}(\tilde{\phi}_i) &amp;
\text{Im}(\tilde{\phi}_i)
\end{bmatrix}.
\]</span></p>
<p>For real modes, the indicator is close to 0, while it increases for complex modes.</p>
<div class="api">
<p><strong>mpd</strong></p>
<hr>
<div id="8" class="cell" data-execution_count="1">
<div class="cell-output cell-output-display" data-execution_count="1">
<div class="markdown"><pre><code class="language-julia">mpd(ms)</code></pre>
<p>Compute the mode phase deviation.</p>
<p>This indicator aims to measure the complexity of a mode. Its value is close to 0 for real modes, and increases as the mode becomes more complex.</p>
<p><strong>Input</strong></p>
<ul>
<li><p><code>ms</code>: Mode shapes (each column corresponds to a mode)</p>
</li>
</ul>
<p><strong>Output</strong></p>
<ul>
<li><p><code>mpd</code>: Mode phase deviation values</p>
</li>
</ul>
<p><strong>Reference</strong></p>
<p>[1] E. Reynders, J. Houbrechts and G. De Roeck. Fully automated (operational) modal analysis. Mechanical Systems and Signal Processing. 29: 228-250. 2012</p>
<p>[2] A. C. Dederichs and O. Oiseth. Experimental comparison of automatic operational modal analysis algorithms for application to long-span road bridges. Mechanical Systems and Signal Processing. 199: 110485. 2023</p>


</div>
</div>
</div>
</div>
</section>
</section>
<section id="correlation-indicators" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="correlation-indicators"><span class="header-section-number">2</span> Correlation indicators</h2>
<p>The following indicators can be used to assess the correlation between measured and reconstructed quantities.</p>
<section id="modal-assurance-criterion" class="level3" data-number="2.1">
<h3 data-number="2.1" class="anchored" data-anchor-id="modal-assurance-criterion"><span class="header-section-number">2.1</span> Modal Assurance Criterion</h3>
<p>The Modal Assurance Criterion (MAC) is a widely used indicator to quantify the correlation between two sets mode shapes. For two mode shapes <span class="math inline">\(\phi_i\)</span> and <span class="math inline">\(\psi_j\)</span> (column vectors), it is defined as: <span class="math display">\[
MAC_{ij} = \frac{\vert\psi_j^H\phi_i\vert^2}{(\phi_i^H\phi_i) (\psi_j^H\psi_j)},
\]</span> where the superscript <span class="math inline">\(H\)</span> denotes the Hermitian transpose.</p>
<p>A value close to 1 indicates a strong correlation between the two mode shapes, while a value close to 0 indicates no correlation.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>In <code>StructuralVibration.jl</code>, it is assumed that <span class="math inline">\(\phi_i\)</span> is the theoretical (or reference) mode shape, while <span class="math inline">\(\psi_j\)</span> is the experimental (or identified) mode shape.</p>
</div>
</div>
<div class="api">
<p><strong>mac</strong></p>
<hr>
<div id="10" class="cell" data-execution_count="1">
<div class="cell-output cell-output-display" data-execution_count="1">
<div class="markdown"><pre><code class="language-julia">mac(ms_exp, ms_th)</code></pre>
<p>Compute the modal assurance criterion (MAC) between experimental and theoretical mode shapes.</p>
<p><strong>Inputs</strong></p>
<ul>
<li><p><code>ms_exp</code>: Experimental mode shapes (nmes x nmodes array)</p>
</li>
<li><p><code>ms_th</code>: Theoretical mode shapes (nmes x nmodes array)</p>
</li>
</ul>
<p><strong>Output</strong></p>
<ul>
<li><p><code>mac</code>: Modal assurance criterion values (nmodes x nmodes array)</p>
</li>
</ul>
<p><strong>Reference</strong></p>
<p>[1] R. J. Allemang. The modal assurance criterion twenty years of use and abuse. Sound &amp; Vibration. 37 (8): 14-23. 2003</p>


</div>
</div>
</div>
</div>
</section>
<section id="coordinate-modal-assurance-criterion" class="level3" data-number="2.2">
<h3 data-number="2.2" class="anchored" data-anchor-id="coordinate-modal-assurance-criterion"><span class="header-section-number">2.2</span> Coordinate Modal Assurance Criterion</h3>
<p>The Coordinate Modal Assurance Criterion (COMAC) is a variant of the MAC that considers the correlation between the coordinates of two mode shapes. For a coordinate <span class="math inline">\(p\)</span> of two mode shapes <span class="math inline">\(\phi_p\)</span> and <span class="math inline">\(\psi_p\)</span> (row vectors), it is defined as: <span class="math display">\[
COMAC_p = \frac{\vert\phi_{pi}\psi_{pi}^H\vert^2}{(\phi_{pi}\phi_{pi}^H) (\psi_{pi}
\psi_{pi}^H)},
\]</span> where the superscript <span class="math inline">\(H\)</span> denotes the Hermitian transpose.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>The computation of the COMAC indicator requires that the two mode shapes have the same number of coordinates and similar scaling. For the the latter, one of the mode shapes is multiplied by the modal scaling factor: <span class="math display">\[
MSF_i = \frac{\phi_i^H\psi_i}{\phi_i^H\phi_i}.
\]</span> The previous equation assumes that <span class="math inline">\(\phi_i\)</span> is the reference mode shape to which <span class="math inline">\(\psi_i\)</span> is scaled.</p>
</div>
</div>
<p>A value close to 1 indicates a strong correlation between the two mode shapes, while a value close to 0 indicates no correlation.</p>
<div class="api">
<p><strong>comac</strong></p>
<hr>
<div id="12" class="cell" data-execution_count="1">
<div class="cell-output cell-output-display" data-execution_count="1">
<div class="markdown"><pre><code class="language-julia">comac(ms_exp, ms_th)</code></pre>
<p>Compute the coordinate modal assurance criterion (COMAC) between experimental and theoretical mode shapes.</p>
<p><strong>Inputs</strong></p>
<ul>
<li><p><code>ms_exp</code>: Experimental mode shapes (nmes x nmodes array)</p>
</li>
<li><p><code>ms_th</code>: Theoretical mode shapes (nmes x nmodes array)</p>
</li>
</ul>
<p><strong>Output</strong></p>
<ul>
<li><p><code>comac</code>: Coordinate modal assurance criterion values (nmes array)</p>
</li>
</ul>
<p><strong>Reference</strong></p>
<p>[1] R. J. Allemang. The modal assurance criterion twenty years of use and abuse. Sound &amp; Vibration. 37 (8): 14-23. 2003</p>


</div>
</div>
</div>
</div>
</section>
<section id="enhanced-coordinate-modal-assurance-criterion" class="level3" data-number="2.3">
<h3 data-number="2.3" class="anchored" data-anchor-id="enhanced-coordinate-modal-assurance-criterion"><span class="header-section-number">2.3</span> Enhanced Coordinate Modal Assurance Criterion</h3>
<p>The Enhanced Coordinate Modal Assurance Criterion (ECOMAC) extends the COMAC to take into account potential calibration scaling errors and/or sensor orientation errors by compouting the mean deviations of mode amplitudes of each coordinate. It is defined as: <span class="math display">\[
ECOMAC_p = \frac{\sum_{i=1}^N \vert \phi_{pi} - \psi_{pi} \vert}{2 N},
\]</span> where <span class="math inline">\(N\)</span> is the number of modes.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>As for the COMAC indicator, the computation of the ECOMAC indicator requires that the two mode shapes have the same number of coordinates and similar scaling.</p>
</div>
</div>
<p>Low values of the indicator indicates a strong correlation between the two mode shapes, while high values indicate very little correlation.</p>
<div class="api">
<p><strong>ecomac</strong></p>
<hr>
<div id="14" class="cell" data-execution_count="1">
<div class="cell-output cell-output-display" data-execution_count="1">
<div class="markdown"><pre><code class="language-julia">ecomac(ms_exp, ms_th)</code></pre>
<p>Compute the enhanced coordinate modal assurance criterion (eCOMAC) between experimental and theoretical mode shapes.</p>
<p><strong>Inputs</strong></p>
<ul>
<li><p><code>ms_exp</code>: Experimental mode shapes (nmes x nmodes array)</p>
</li>
<li><p><code>ms_th</code>: Theoretical mode shapes (nmes x nmodes array)</p>
</li>
</ul>
<p><strong>Output</strong></p>
<ul>
<li><p><code>ecomac</code>: Enhanced coordinate modal assurance criterion values (nmes array)</p>
</li>
</ul>
<p><strong>Reference</strong> [1] D. L. Hunt. Application of an Enhanced Coordinate Modal Assurance Criterion (ECOMAC). Proceedings of International Modal Analysis Conference, pp. 66-71, 1992.</p>
<p>[2] G. Martin, E. Balmes and T. Chancelier. Improved Modal Assurance Criterion using a quantification of identification errors per mode/sensor. Proceedings of ISMA 2014, pp. 2509-2519. 2014.</p>


</div>
</div>
</div>
</div>
</section>
<section id="frequency-response-assurance-criterion" class="level3" data-number="2.4">
<h3 data-number="2.4" class="anchored" data-anchor-id="frequency-response-assurance-criterion"><span class="header-section-number">2.4</span> Frequency response assurance criterion</h3>
<p>The Frequency Response Assurance Criterion (FRAC) is an indicator that quantifies the correlation between two frequency response functions (FRFs) over a given frequency range for a given measurement point <span class="math inline">\(p\)</span> and a given excitation point <span class="math inline">\(q\)</span>. For two FRFs <span class="math inline">\(H_{pq}(\omega)\)</span> and <span class="math inline">\(G_{pq}(\omega)\)</span>, it is defined as: <span class="math display">\[
FRAC_{pq} = \frac{\vert \sum_{\omega = \omega_1}^{\omega_2} H_{pq}(\omega) G_{pq}^\ast(\omega) \, \vert^2}{\left( \sum_{\omega = \omega_1}^{\omega_2} \vert H_{pq}(\omega) \vert^2\right) \left( \sum_{\omega = \omega_1}^{\omega_2} \vert G_{pq}(\omega) \vert^2 \right)},
\]</span> <span class="math inline">\(G_{pq}^\ast(\omega)\)</span> is the complex conjugate of <span class="math inline">\(G_{pq}(\omega)\)</span>, and <span class="math inline">\(\omega_1\)</span> and <span class="math inline">\(\omega_2\)</span> define the frequency range of interest.</p>
<div class="api">
<p><strong>frac</strong></p>
<hr>
<div id="16" class="cell" data-execution_count="1">
<div class="cell-output cell-output-display" data-execution_count="1">
<div class="markdown"><pre><code class="language-julia">frac(frf_exp, frf_th)</code></pre>
<p>Compute the frequency response assurance criterion (FRAC) between experimental and theoretical frequency response functions.</p>
<p><strong>Inputs</strong></p>
<ul>
<li><p><code>frf_exp</code>: Experimental frequency response functions (nmes x nexc x nf array</p>
</li>
<li><p><code>frf_th</code>: Theoretical frequency response functions (nmes x nexc x nf array)</p>
</li>
</ul>
<p><strong>Output</strong></p>
<ul>
<li><p><code>frac</code>: Frequency response assurance criterion values (nmes x nexc array)</p>
</li>
</ul>
<p><strong>Reference</strong></p>
<p>[1] R. J. Allemang. The modal assurance criterion twenty years of use and abuse. Sound &amp; Vibration. 37 (8): 14-23. 2003</p>


</div>
</div>
</div>
</div>
</section>
</section>
<section id="indicator-functions" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="indicator-functions"><span class="header-section-number">3</span> Indicator functions</h2>
<p>The following indicator functions can be used to estimate the number of modes of a structure.</p>
<section id="complex-mode-indicator-function" class="level3" data-number="3.1">
<h3 data-number="3.1" class="anchored" data-anchor-id="complex-mode-indicator-function"><span class="header-section-number">3.1</span> Complex Mode Indicator Function</h3>
<p>The Complex Mode Indicator Function (CMIF) is a global indicator that helps identify the number of modes in a system. It is defined as the singular values of the frequency response function (FRF) matrix <span class="math inline">\(\mathbf{H}(\omega)\)</span> over a frequency range of interest. The FRF matrix is constructed by stacking the FRFs for all measurement points and excitation points.</p>
<p>When admittance or accelerance are used, the CMIF is computed as the singular values of the imaginary part of the FRF matrix, while for mobility, the real part is used. From a general standpoint, the CMIF is given by: <span class="math display">\[
CMIF(\omega) = \mathbf{\Sigma}(\omega),
\]</span> where <span class="math inline">\(\mathbf{\Sigma}(\omega)\)</span> is the vector of singular values obtained from the singular value decomposition of the FRF matrix.</p>
<div class="api">
<p><strong>cmif</strong></p>
<hr>
<div id="18" class="cell" data-execution_count="1">
<div class="cell-output cell-output-display" data-execution_count="1">
<div class="markdown"><pre><code class="language-julia">cmif(frf; type = :dis)</code></pre>
<p>Compute the complex mode indicator function (CMIF)</p>
<p><strong>Inputs</strong></p>
<ul>
<li><p><code>frf</code>: Frequency response functions (nmes x nexc x nf array)</p>
</li>
<li><p><code>type</code>: Type of FRF (:dis for displacement, :vel for velocity, :acc for acceleration)</p>
</li>
</ul>
<p><strong>Output</strong></p>
<ul>
<li><p><code>cmif</code>: Complex mode indicator function (min(nmes, nexc) x nf array)</p>
</li>
</ul>
<p><strong>Reference</strong></p>
<p>[1] R. J. Allemang and D. L. Brown. A Complete Review of the Complex Mode  Indicator Function (CMIF) with Applications. ISMA 2006. 2006</p>


</div>
</div>
</div>
</div>
</section>
<section id="power-spectrum-indicator-function" class="level3" data-number="3.2">
<h3 data-number="3.2" class="anchored" data-anchor-id="power-spectrum-indicator-function"><span class="header-section-number">3.2</span> Power spectrum indicator function</h3>
<p>The Power Spectrum Indicator Function (PSIF) is another global indicator that helps identify the number of modes in a system. It is defined as the sum of the squared magnitudes of the FRFs over all measurement points and excitation points. The PSIF is given by: <span class="math display">\[
PSIF(\omega) = \sum_{p=1}^{N_p} \sum_{q=1}^{N_q} \vert H_{pq}(\omega) \vert^2,
\]</span> where <span class="math inline">\(N_p\)</span> is the number of measurement points, <span class="math inline">\(N_q\)</span> is the number of excitation points, and <span class="math inline">\(H_{pq}(\omega)\)</span> is the FRF between measurement point <span class="math inline">\(p\)</span> and excitation point <span class="math inline">\(q\)</span>.</p>
<div class="api">
<p><strong>psif</strong></p>
<hr>
<div id="20" class="cell" data-execution_count="1">
<div class="cell-output cell-output-display" data-execution_count="1">
<div class="markdown"><pre><code class="language-julia">psif(frf)</code></pre>
<p>Compute the power spectrum indicator function (PSIF).</p>
<p><strong>Input</strong></p>
<ul>
<li><p><code>frf</code>: Frequency response functions (nmes x nexc x nf array or nmes x nf array)</p>
</li>
</ul>
<p><strong>Output</strong></p>
<ul>
<li><p><code>psif</code>: Power spectrum indicator function (nf array)</p>
</li>
</ul>
<p><strong>Reference</strong></p>
<p>[1] M+P Analyzer manual. Rev. 5.1. 2017</p>


</div>
</div>
</div>
</div>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "î§‹";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/maucejo\.github\.io\/StructuralVibration\.jl\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../modal_extraction/frf_reconstruction.html" class="pagination-link" aria-label="FRF reconstruction">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text">FRF reconstruction</span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p>2025 Mathieu Aucejo âˆ™ Powered by <a href="https://quarto.org"><img src="../assets/logo/quarto.png" class="img-fluid" style="width:4mm"></a> and <a href="https://julialang.org"><img src="../assets/logo/julia.svg" class="img-fluid" style="width:4mm"></a></p>
</div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




<script src="../site_libs/quarto-html/zenscroll-min.js"></script>
</body></html>