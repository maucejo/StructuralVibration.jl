[
  {
    "objectID": "modal_extraction/indicators.html",
    "href": "modal_extraction/indicators.html",
    "title": "Quality and analysis indicators",
    "section": "",
    "text": "The following indicators can be used to assess the complexity of the identified modes.\n\n\nThe Mode Overcomplexity Value (MOV) of a mode \\(i\\) is defined as: \\[\nMOV_i = \\frac{\\sum_{n = 1}^N s_{ni} \\vert\\phi_{ni}\\vert^2}{\\sum_{n = 1}^N \\vert\\phi_{ni}\\vert^2},\n\\] where \\(\\phi_{ni}\\) is the mode shape value at degree of freedom \\(n\\) for mode \\(i\\), and \\(s_{ni}\\) is a weighted factor. The latter is given by: \\[\ns_{ni} = \\begin{cases}\n0 & \\text{if } \\text{Im}(-\\lambda_i^2\\phi_{ni}^2 c_i) &gt; 0 \\\\\n1 & \\text{if } \\text{Im}(-\\lambda_i^2\\phi_{ni}^2 c_i) \\leq 0\n\\end{cases},\n\\] where \\(\\lambda_i\\) is the complex eigenvalue for mode \\(i\\), and \\(c_i\\) is the corresponding scaling factor.\nA value close to 1 indicates physical modes, while a value close to 0 indicates spurious modes (or computational modes).\n\nmov\n\n\n\nmov(poles, ms, ci)\nCompute the mode overcomplexity value\nThis indicator is a weighted percentage of the degrees of freedom of the response for which adding mass leads to a negative frequency shift. A value close to 1 indicates physical modes, while a low value indicates non-physical modes (numerical or noise-related)\nInputs\n\npoles: Poles of the system\n\nms: Mode shapes (each column corresponds to a mode)\n\nci: Scaling factors associated to the mode shapes\n\n\nOutput\n\nmov: Mode overcomplexity values\n\n\nReference\n[1] M+P Analyzer manual. Rev. 5.1. 2017\n\n\n\n\n\n\n\n\n\nThe Mode Phase Collinearity (MPC) aims at determining whether a mode is real or complex. It is an indicator defined in \\([0, 1]\\). For a mode \\(i\\), it is given by: \\[\n  MPC_i = \\left(\\frac{\\lambda_1 - \\lambda_2}{\\lambda_1 + \\lambda_2}\\right)^2,\n\\] where \\(\\lambda_1 = \\frac{S_{xx} + S_{yy}}{2} + \\sqrt{\\left(\\frac{S_{xx} - S_{yy}}{2}\\right)^2 + S_{xy}^2}\\) and \\(\\lambda_2 = \\frac{S_{xx} + S_{yy}}{2} - \\sqrt{\\left(\\frac{S_{xx} - S_{yy}}{2}\\right)^2 + S_{xy}^2}\\) are the eigenvalues of the covariance matrix \\(\\mathbf{S}\\): \\[\n\\mathbf{S} = \\begin{bmatrix}\nS_{xx} & S_{xy} \\\\\nS_{xy} & S_{yy}\n\\end{bmatrix} \\text{ with } \\begin{cases}\nS_{xx} = \\text{Re}(\\tilde{\\phi}_i)^T\\text{Re}(\\tilde{\\phi}_i) \\\\\nS_{yy} = \\text{Im}(\\tilde{\\phi}_i)^T\\text{Im}(\\tilde{\\phi}_i) \\\\\nS_{xy} = \\text{Re}(\\tilde{\\phi}_i)^T\\text{Im}(\\tilde{\\phi}_i)\n\\end{cases}\n\\] Here, \\(\\tilde{\\phi}_i\\) is the corrected mode shape vector for the mode \\(i\\) such that: \\[\n\\tilde{\\phi}_{ni} = \\phi_{ni} - \\frac{\\sum_{m = 1}^N \\phi_{mi}}{N}.\n\\]\nA value close to 1 indicates a real mode, while a value close to 0 indicates a complex mode.\n\nmpc\n\n\n\nmpc(ms)\nCompute the mode phase collinearity.\nThis indicator aims to measure the complexity of a mode. Its value ranges from 0 (no collinearity) to 1 (perfect collinearity). For real modes, mpc tends towards 1.\nInput\n\nms: Mode shapes (each column corresponds to a mode)\n\n\nOutput\n\nmpc: Mode phase collinearity values\n\n\nReferences\n[1] J.-N. Juang and R. Pappa: \"An eigensystem realization algorithm for modal parameter identification and model reduction\", Journal of Guidance, Control, and Dynamics, Vol. 8, No. 5, Sept.-Oct. 1985, pp. 620-627.\n[2] M+P Analyzer manual. Rev. 5.1. 2017\n\n\n\n\n\n\n\n\n\nThe Mode Complexity Factor (MCF) for a mode \\(i\\) is defined as: \\[\nMCF_i = 1 - \\frac{(S_{xx} - S_{yy})^2 + 4S_{xy}^2}{(S_{xx} + S_{yy})^2}\n\\]\nA value close to 0 indicates a real mode, while a value close to 1 indicates a complex mode.\n\n\n\nThe Mean Phase Deviation (MPD) indicator aims to measure the complexity of a mode. Its value is close to 0 for real modes, and increases as the mode becomes more complex. It is defined as: \\[\nMPD_i = \\frac{\\sum_{n = 1}^N\\vert\\phi_{ni}\\vert\\; \\text{acos}\\left\\vert\\frac{\\text{Re}(\\phi_{ni})V_{22} - \\text{Im}(\\phi_{ni})V_{12}}{\\sqrt{V_{12}^2 + V_{22}^2}\\;\\vert\\phi_{ni}\\vert}\\right\\vert}{\\sum_{n = 1}^N \\vert\\phi_{ni}\\vert},\n\\] where \\(V_{12}\\) and \\(V_{22}\\) are the components of the right singular vector associated to the singular value decomposition of the 2 \\(\\times\\) 2 matrix \\(\\mathbf{P}\\) expressed as: \\[\n\\mathbf{P} = \\begin{bmatrix}\n\\text{Re}(\\tilde{\\phi}_i) &\n\\text{Im}(\\tilde{\\phi}_i)\n\\end{bmatrix}.\n\\]\nFor real modes, the indicator is close to 0, while it increases for complex modes.\n\nmpd\n\n\n\nmpd(ms)\nCompute the mode phase deviation.\nThis indicator aims to measure the complexity of a mode. Its value is close to 0 for real modes, and increases as the mode becomes more complex.\nInput\n\nms: Mode shapes (each column corresponds to a mode)\n\n\nOutput\n\nmpd: Mode phase deviation values\n\n\nReference\n[1] E. Reynders, J. Houbrechts and G. De Roeck. Fully automated (operational) modal analysis. Mechanical Systems and Signal Processing. 29: 228-250. 2012\n[2] A. C. Dederichs and O. Oiseth. Experimental comparison of automatic operational modal analysis algorithms for application to long-span road bridges. Mechanical Systems and Signal Processing. 199: 110485. 2023",
    "crumbs": [
      "Modal extraction",
      "Quality and analysis indicators"
    ]
  },
  {
    "objectID": "modal_extraction/indicators.html#mode-complexity-indicators",
    "href": "modal_extraction/indicators.html#mode-complexity-indicators",
    "title": "Quality and analysis indicators",
    "section": "",
    "text": "The following indicators can be used to assess the complexity of the identified modes.\n\n\nThe Mode Overcomplexity Value (MOV) of a mode \\(i\\) is defined as: \\[\nMOV_i = \\frac{\\sum_{n = 1}^N s_{ni} \\vert\\phi_{ni}\\vert^2}{\\sum_{n = 1}^N \\vert\\phi_{ni}\\vert^2},\n\\] where \\(\\phi_{ni}\\) is the mode shape value at degree of freedom \\(n\\) for mode \\(i\\), and \\(s_{ni}\\) is a weighted factor. The latter is given by: \\[\ns_{ni} = \\begin{cases}\n0 & \\text{if } \\text{Im}(-\\lambda_i^2\\phi_{ni}^2 c_i) &gt; 0 \\\\\n1 & \\text{if } \\text{Im}(-\\lambda_i^2\\phi_{ni}^2 c_i) \\leq 0\n\\end{cases},\n\\] where \\(\\lambda_i\\) is the complex eigenvalue for mode \\(i\\), and \\(c_i\\) is the corresponding scaling factor.\nA value close to 1 indicates physical modes, while a value close to 0 indicates spurious modes (or computational modes).\n\nmov\n\n\n\nmov(poles, ms, ci)\nCompute the mode overcomplexity value\nThis indicator is a weighted percentage of the degrees of freedom of the response for which adding mass leads to a negative frequency shift. A value close to 1 indicates physical modes, while a low value indicates non-physical modes (numerical or noise-related)\nInputs\n\npoles: Poles of the system\n\nms: Mode shapes (each column corresponds to a mode)\n\nci: Scaling factors associated to the mode shapes\n\n\nOutput\n\nmov: Mode overcomplexity values\n\n\nReference\n[1] M+P Analyzer manual. Rev. 5.1. 2017\n\n\n\n\n\n\n\n\n\nThe Mode Phase Collinearity (MPC) aims at determining whether a mode is real or complex. It is an indicator defined in \\([0, 1]\\). For a mode \\(i\\), it is given by: \\[\n  MPC_i = \\left(\\frac{\\lambda_1 - \\lambda_2}{\\lambda_1 + \\lambda_2}\\right)^2,\n\\] where \\(\\lambda_1 = \\frac{S_{xx} + S_{yy}}{2} + \\sqrt{\\left(\\frac{S_{xx} - S_{yy}}{2}\\right)^2 + S_{xy}^2}\\) and \\(\\lambda_2 = \\frac{S_{xx} + S_{yy}}{2} - \\sqrt{\\left(\\frac{S_{xx} - S_{yy}}{2}\\right)^2 + S_{xy}^2}\\) are the eigenvalues of the covariance matrix \\(\\mathbf{S}\\): \\[\n\\mathbf{S} = \\begin{bmatrix}\nS_{xx} & S_{xy} \\\\\nS_{xy} & S_{yy}\n\\end{bmatrix} \\text{ with } \\begin{cases}\nS_{xx} = \\text{Re}(\\tilde{\\phi}_i)^T\\text{Re}(\\tilde{\\phi}_i) \\\\\nS_{yy} = \\text{Im}(\\tilde{\\phi}_i)^T\\text{Im}(\\tilde{\\phi}_i) \\\\\nS_{xy} = \\text{Re}(\\tilde{\\phi}_i)^T\\text{Im}(\\tilde{\\phi}_i)\n\\end{cases}\n\\] Here, \\(\\tilde{\\phi}_i\\) is the corrected mode shape vector for the mode \\(i\\) such that: \\[\n\\tilde{\\phi}_{ni} = \\phi_{ni} - \\frac{\\sum_{m = 1}^N \\phi_{mi}}{N}.\n\\]\nA value close to 1 indicates a real mode, while a value close to 0 indicates a complex mode.\n\nmpc\n\n\n\nmpc(ms)\nCompute the mode phase collinearity.\nThis indicator aims to measure the complexity of a mode. Its value ranges from 0 (no collinearity) to 1 (perfect collinearity). For real modes, mpc tends towards 1.\nInput\n\nms: Mode shapes (each column corresponds to a mode)\n\n\nOutput\n\nmpc: Mode phase collinearity values\n\n\nReferences\n[1] J.-N. Juang and R. Pappa: \"An eigensystem realization algorithm for modal parameter identification and model reduction\", Journal of Guidance, Control, and Dynamics, Vol. 8, No. 5, Sept.-Oct. 1985, pp. 620-627.\n[2] M+P Analyzer manual. Rev. 5.1. 2017\n\n\n\n\n\n\n\n\n\nThe Mode Complexity Factor (MCF) for a mode \\(i\\) is defined as: \\[\nMCF_i = 1 - \\frac{(S_{xx} - S_{yy})^2 + 4S_{xy}^2}{(S_{xx} + S_{yy})^2}\n\\]\nA value close to 0 indicates a real mode, while a value close to 1 indicates a complex mode.\n\n\n\nThe Mean Phase Deviation (MPD) indicator aims to measure the complexity of a mode. Its value is close to 0 for real modes, and increases as the mode becomes more complex. It is defined as: \\[\nMPD_i = \\frac{\\sum_{n = 1}^N\\vert\\phi_{ni}\\vert\\; \\text{acos}\\left\\vert\\frac{\\text{Re}(\\phi_{ni})V_{22} - \\text{Im}(\\phi_{ni})V_{12}}{\\sqrt{V_{12}^2 + V_{22}^2}\\;\\vert\\phi_{ni}\\vert}\\right\\vert}{\\sum_{n = 1}^N \\vert\\phi_{ni}\\vert},\n\\] where \\(V_{12}\\) and \\(V_{22}\\) are the components of the right singular vector associated to the singular value decomposition of the 2 \\(\\times\\) 2 matrix \\(\\mathbf{P}\\) expressed as: \\[\n\\mathbf{P} = \\begin{bmatrix}\n\\text{Re}(\\tilde{\\phi}_i) &\n\\text{Im}(\\tilde{\\phi}_i)\n\\end{bmatrix}.\n\\]\nFor real modes, the indicator is close to 0, while it increases for complex modes.\n\nmpd\n\n\n\nmpd(ms)\nCompute the mode phase deviation.\nThis indicator aims to measure the complexity of a mode. Its value is close to 0 for real modes, and increases as the mode becomes more complex.\nInput\n\nms: Mode shapes (each column corresponds to a mode)\n\n\nOutput\n\nmpd: Mode phase deviation values\n\n\nReference\n[1] E. Reynders, J. Houbrechts and G. De Roeck. Fully automated (operational) modal analysis. Mechanical Systems and Signal Processing. 29: 228-250. 2012\n[2] A. C. Dederichs and O. Oiseth. Experimental comparison of automatic operational modal analysis algorithms for application to long-span road bridges. Mechanical Systems and Signal Processing. 199: 110485. 2023",
    "crumbs": [
      "Modal extraction",
      "Quality and analysis indicators"
    ]
  },
  {
    "objectID": "modal_extraction/indicators.html#correlation-indicators",
    "href": "modal_extraction/indicators.html#correlation-indicators",
    "title": "Quality and analysis indicators",
    "section": "2 Correlation indicators",
    "text": "2 Correlation indicators\nThe following indicators can be used to assess the correlation between measured and reconstructed quantities.\n\n2.1 Modal Assurance Criterion\nThe Modal Assurance Criterion (MAC) is a widely used indicator to quantify the correlation between two sets mode shapes. For two mode shapes \\(\\phi_i\\) and \\(\\psi_j\\) (column vectors), it is defined as: \\[\nMAC_{ij} = \\frac{\\vert\\psi_j^H\\phi_i\\vert^2}{(\\phi_i^H\\phi_i) (\\psi_j^H\\psi_j)},\n\\] where the superscript \\(H\\) denotes the Hermitian transpose.\nA value close to 1 indicates a strong correlation between the two mode shapes, while a value close to 0 indicates no correlation.\n\n\n\n\n\n\nNote\n\n\n\nIn StructuralVibration.jl, it is assumed that \\(\\phi_i\\) is the theoretical (or reference) mode shape, while \\(\\psi_j\\) is the experimental (or identified) mode shape.\n\n\n\nmac\n\n\n\nmac(ms_exp, ms_th)\nCompute the modal assurance criterion (MAC) between experimental and theoretical mode shapes.\nInputs\n\nms_exp: Experimental mode shapes (nmes x nmodes array)\n\nms_th: Theoretical mode shapes (nmes x nmodes array)\n\n\nOutput\n\nmac: Modal assurance criterion values (nmodes x nmodes array)\n\n\nReference\n[1] R. J. Allemang. The modal assurance criterion twenty years of use and abuse. Sound & Vibration. 37 (8): 14-23. 2003\n\n\n\n\n\n\n\n\n2.2 Coordinate Modal Assurance Criterion\nThe Coordinate Modal Assurance Criterion (COMAC) is a variant of the MAC that considers the correlation between the coordinates of two mode shapes. For a coordinate \\(p\\) of two mode shapes \\(\\phi_p\\) and \\(\\psi_p\\) (row vectors), it is defined as: \\[\nCOMAC_p = \\frac{\\vert\\phi_{pi}\\psi_{pi}^H\\vert^2}{(\\phi_{pi}\\phi_{pi}^H) (\\psi_{pi}\n\\psi_{pi}^H)},\n\\] where the superscript \\(H\\) denotes the Hermitian transpose.\n\n\n\n\n\n\nNote\n\n\n\nThe computation of the COMAC indicator requires that the two mode shapes have the same number of coordinates and similar scaling. For the the latter, one of the mode shapes is multiplied by the modal scaling factor: \\[\nMSF_i = \\frac{\\phi_i^H\\psi_i}{\\phi_i^H\\phi_i}.\n\\] The previous equation assumes that \\(\\phi_i\\) is the reference mode shape to which \\(\\psi_i\\) is scaled.\n\n\nA value close to 1 indicates a strong correlation between the two mode shapes, while a value close to 0 indicates no correlation.\n\ncomac\n\n\n\ncomac(ms_exp, ms_th)\nCompute the coordinate modal assurance criterion (COMAC) between experimental and theoretical mode shapes.\nInputs\n\nms_exp: Experimental mode shapes (nmes x nmodes array)\n\nms_th: Theoretical mode shapes (nmes x nmodes array)\n\n\nOutput\n\ncomac: Coordinate modal assurance criterion values (nmes array)\n\n\nReference\n[1] R. J. Allemang. The modal assurance criterion twenty years of use and abuse. Sound & Vibration. 37 (8): 14-23. 2003\n\n\n\n\n\n\n\n\n2.3 Enhanced Coordinate Modal Assurance Criterion\nThe Enhanced Coordinate Modal Assurance Criterion (ECOMAC) extends the COMAC to take into account potential calibration scaling errors and/or sensor orientation errors by compouting the mean deviations of mode amplitudes of each coordinate. It is defined as: \\[\nECOMAC_p = \\frac{\\sum_{i=1}^N \\vert \\phi_{pi} - \\psi_{pi} \\vert}{2 N},\n\\] where \\(N\\) is the number of modes.\n\n\n\n\n\n\nNote\n\n\n\nAs for the COMAC indicator, the computation of the ECOMAC indicator requires that the two mode shapes have the same number of coordinates and similar scaling.\n\n\nLow values of the indicator indicates a strong correlation between the two mode shapes, while high values indicate very little correlation.\n\necomac\n\n\n\necomac(ms_exp, ms_th)\nCompute the enhanced coordinate modal assurance criterion (eCOMAC) between experimental and theoretical mode shapes.\nInputs\n\nms_exp: Experimental mode shapes (nmes x nmodes array)\n\nms_th: Theoretical mode shapes (nmes x nmodes array)\n\n\nOutput\n\necomac: Enhanced coordinate modal assurance criterion values (nmes array)\n\n\nReference [1] D. L. Hunt. Application of an Enhanced Coordinate Modal Assurance Criterion (ECOMAC). Proceedings of International Modal Analysis Conference, pp. 66-71, 1992.\n[2] G. Martin, E. Balmes and T. Chancelier. Improved Modal Assurance Criterion using a quantification of identification errors per mode/sensor. Proceedings of ISMA 2014, pp. 2509-2519. 2014.\n\n\n\n\n\n\n\n\n2.4 Frequency response assurance criterion\nThe Frequency Response Assurance Criterion (FRAC) is an indicator that quantifies the correlation between two frequency response functions (FRFs) over a given frequency range for a given measurement point \\(p\\) and a given excitation point \\(q\\). For two FRFs \\(H_{pq}(\\omega)\\) and \\(G_{pq}(\\omega)\\), it is defined as: \\[\nFRAC_{pq} = \\frac{\\vert \\sum_{\\omega = \\omega_1}^{\\omega_2} H_{pq}(\\omega) G_{pq}^\\ast(\\omega) \\, \\vert^2}{\\left( \\sum_{\\omega = \\omega_1}^{\\omega_2} \\vert H_{pq}(\\omega) \\vert^2\\right) \\left( \\sum_{\\omega = \\omega_1}^{\\omega_2} \\vert G_{pq}(\\omega) \\vert^2 \\right)},\n\\] \\(G_{pq}^\\ast(\\omega)\\) is the complex conjugate of \\(G_{pq}(\\omega)\\), and \\(\\omega_1\\) and \\(\\omega_2\\) define the frequency range of interest.\n\nfrac\n\n\n\nfrac(frf_exp, frf_th)\nCompute the frequency response assurance criterion (FRAC) between experimental and theoretical frequency response functions.\nInputs\n\nfrf_exp: Experimental frequency response functions (nmes x nexc x nf array\n\nfrf_th: Theoretical frequency response functions (nmes x nexc x nf array)\n\n\nOutput\n\nfrac: Frequency response assurance criterion values (nmes x nexc array)\n\n\nReference\n[1] R. J. Allemang. The modal assurance criterion twenty years of use and abuse. Sound & Vibration. 37 (8): 14-23. 2003",
    "crumbs": [
      "Modal extraction",
      "Quality and analysis indicators"
    ]
  },
  {
    "objectID": "modal_extraction/indicators.html#indicator-functions",
    "href": "modal_extraction/indicators.html#indicator-functions",
    "title": "Quality and analysis indicators",
    "section": "3 Indicator functions",
    "text": "3 Indicator functions\nThe following indicator functions can be used to estimate the number of modes of a structure.\n\n3.1 Complex Mode Indicator Function\nThe Complex Mode Indicator Function (CMIF) is a global indicator that helps identify the number of modes in a system. It is defined as the singular values of the frequency response function (FRF) matrix \\(\\mathbf{H}(\\omega)\\) over a frequency range of interest. The FRF matrix is constructed by stacking the FRFs for all measurement points and excitation points.\nWhen admittance or accelerance are used, the CMIF is computed as the singular values of the imaginary part of the FRF matrix, while for mobility, the real part is used. From a general standpoint, the CMIF is given by: \\[\nCMIF(\\omega) = \\mathbf{\\Sigma}(\\omega),\n\\] where \\(\\mathbf{\\Sigma}(\\omega)\\) is the vector of singular values obtained from the singular value decomposition of the FRF matrix.\n\ncmif\n\n\n\ncmif(frf; type = :dis)\nCompute the complex mode indicator function (CMIF)\nInputs\n\nfrf: Frequency response functions (nmes x nexc x nf array)\n\ntype: Type of FRF (:dis for displacement, :vel for velocity, :acc for acceleration)\n\n\nOutput\n\ncmif: Complex mode indicator function (min(nmes, nexc) x nf array)\n\n\nReference\n[1] R. J. Allemang and D. L. Brown. A Complete Review of the Complex Mode  Indicator Function (CMIF) with Applications. ISMA 2006. 2006\n\n\n\n\n\n\n\n\n3.2 Power spectrum indicator function\nThe Power Spectrum Indicator Function (PSIF) is another global indicator that helps identify the number of modes in a system. It is defined as the sum of the squared magnitudes of the FRFs over all measurement points and excitation points. The PSIF is given by: \\[\nPSIF(\\omega) = \\sum_{p=1}^{N_p} \\sum_{q=1}^{N_q} \\vert H_{pq}(\\omega) \\vert^2,\n\\] where \\(N_p\\) is the number of measurement points, \\(N_q\\) is the number of excitation points, and \\(H_{pq}(\\omega)\\) is the FRF between measurement point \\(p\\) and excitation point \\(q\\).\n\npsif\n\n\n\npsif(frf)\nCompute the power spectrum indicator function (PSIF).\nInput\n\nfrf: Frequency response functions (nmes x nexc x nf array or nmes x nf array)\n\n\nOutput\n\npsif: Power spectrum indicator function (nf array)\n\n\nReference\n[1] M+P Analyzer manual. Rev. 5.1. 2017",
    "crumbs": [
      "Modal extraction",
      "Quality and analysis indicators"
    ]
  },
  {
    "objectID": "modal_extraction/index.html",
    "href": "modal_extraction/index.html",
    "title": "Experimental Modal Analysis",
    "section": "",
    "text": "The modal approach enables the dynamic behavior of a structure to be predicted based on knowledge of its natural modes of vibration, which are intrinsic to the system. From a practical point of view, this information can be used to determine the frequencies at which the structure is most likely to vibrate. For industry, this information is invaluable, as vibrations can cause discomfort, noise, premature wear and tear, or even damage to a system. This is where Experimental Modal Analysis (EMA) comes in Experimental identification of vibration modes can also be used to calibrate a finite element model or certify a product (e.g. ground vibration testing or regulations related to the modal behavior of the structure).\nEMA aims to estimate the natural frequencies of the system and other characteristic parameters (e.g. damping ratios and mode shapes) from the vibration measurements in order to obtain a modal model of the system under consideration. This model can then be used to determine the structure’s dynamic behaviour for a given excitation.\nTo reach these goals, it is supposed that:\nEMA is a family of inverse methods attempting to determine the modal characteristics of a structure from the responses measured at each point of the mesh.",
    "crumbs": [
      "Modal extraction",
      "Experimental Modal Analysis"
    ]
  },
  {
    "objectID": "modal_extraction/index.html#general-principles",
    "href": "modal_extraction/index.html#general-principles",
    "title": "Experimental Modal Analysis",
    "section": "1 General principles",
    "text": "1 General principles\nTo identify the modal parameters of a structure or mechanical system, EMA relies on the measurement of the structure’s transfer function matrix. By definition, the transfer function \\(H_{pq}(\\omega)\\) can be seen as the frequency response of the system at a point \\(x_p\\) to an excitation of unit amplitude at a point \\(x_q\\). Classically, the transfer function matrix (here the admittance) is given by the relation\n\\[\nH_{pq}(\\omega) = \\sum_{i = 1}^{+\\infty} \\frac{\\phi_i(x_p)\\, \\phi_i(x_q)}{M_i(\\omega_i^2 - \\omega^2 + 2j\\xi_i\\omega_i\\omega)} = \\sum_{i = 1}^{+\\infty} \\left[\\frac{{}_i R_{pq}}{j\\omega - \\lambda_i} + \\frac{{}_i R_{pq}^\\ast}{j\\omega - \\lambda_i^\\ast}\\right],\n\\] where:\n\n\\(\\lambda_i = -\\xi_i\\omega_i + j\\,\\Omega_i\\) is the pole related to the mode \\(i\\), with:\n\n\\(\\omega_i = \\vert \\lambda_i\\vert\\) is the natural angular frequency of the system\n\\(\\Omega_i = \\omega_i\\sqrt{1 - \\xi_i^2}\\) is the damped natural frequency of the mode \\(i\\)\n\\(\\xi_i = -\\frac{\\text{Re}(\\lambda_i)}{\\omega_i}\\) the modal damping factor of the mode \\(i\\) \n\n\\({}_i R_{pq} = c_i\\, \\phi_i(x_p)\\, \\phi_i(x_q)\\) is the residue of the mode \\(i\\), with:\n\n\\(\\phi_i(x_p)\\) the mode shape of the mode \\(i\\) at point \\(x_p\\)\n\\(c_i = \\frac{1}{2jM_i\\Omega_i}\\) the normalization constant of the mode shape of the mode \\(i\\)\n\n\nThe objective of an EMA is therefore to identify the residuals \\({}_i R_{pq}\\) and the poles \\(\\lambda_i\\) of the transfer function \\(H_{pq}(\\omega)\\) in order to extract, in a second step, the modal parameters of the system under study (natural angular frequencies \\(\\omega_i\\), modal damping factors \\(\\xi_i\\) and mode shapes \\(\\phi_i\\)).\nIn StructuralVibration.jl, two families of modal extraction methods are implemented:\n\nmethods based on the use of single degree of freedom (sdof) models, known as Sdof methods. These methods seek to adjust ideal transfer functions of Sdof systems to experimental curves around their resonances. These methods therefore consist of identifying the modal parameters mode by mode. To do this, the operator must select a frequency band around each resonance to perform the extraction.\nmethods based on the use of multiple degree of freedom (mdof) models, known as Mdof methods. These methods consider that the system can be represented as a multiple degree of freedom system. They are generally based on the construction of a high-order polynomial matrix whose coefficients are estimated from the measured transfer functions.",
    "crumbs": [
      "Modal extraction",
      "Experimental Modal Analysis"
    ]
  },
  {
    "objectID": "modal_extraction/index.html#sdof-methods",
    "href": "modal_extraction/index.html#sdof-methods",
    "title": "Experimental Modal Analysis",
    "section": "2 Sdof methods",
    "text": "2 Sdof methods\nThe Sdof methods are based on the assumption that the system can be represented as a single degree of freedom system. This means that the system can be described by a single natural frequency, damping ratio, and mode shape. The Sdof methods are typically used for systems that are lightly damped and for which the modes are well separated.\nFor these methods, it is assumed that the FRF (admittance) is given by: \\[\nH_{pq}(\\omega) = \\sum_{i = 1}^N\\frac{_{i}R_{pq}}{\\omega_i^2 - \\omega^2 + j\\eta_i\\omega_i^2}\n\\] where, for a mode \\(i\\), \\(_{i}R_{pq} = \\phi_i(x_p)\\phi_i(x_q)\\) is the residue, \\(\\omega_i\\) is the natural frequency, \\(\\eta_i\\) is the modal damping factor, and \\(\\phi_i(x_p)\\) is the mass-normalized mode shape at the point \\(x_p\\).\nWhen the natural frequencies of the modes are sufficiently spaced and the damping is low, one can write at a frequency \\(\\omega\\) close to the natural frequency \\(\\omega_i\\): \\[\nH_{pq}(\\omega) \\approx \\frac{\\phi_i(x_p)\\phi_i(x_q)}{\\omega_i^2 - \\omega^2 + j\\eta_i\\omega_i^2}.\n\\]\n\n\n\n\n\n\nNote\n\n\n\nOne can note that the modal damping factor \\(\\eta_i\\) is related to the damping ratio \\(\\xi_i\\) by the relation: \\[\n\\eta_i = 2\\xi_i.\n\\]\n\n\n\n2.1 Poles extraction\nStructuralDynamics.jl provides three SDOF methods for extracting the poles of a system from its frequency response function (FRF):\n\nPeak picking method\nCircle fit method\nLeast squares fit method\n\n\n2.1.1 Peak picking method\nThe peak picking method is a simple and effective way to extract the natural frequencies and damping ratios of a system. The method consists of the following steps:\n\nIdentification of natural frequencies\nThey are identified from the peaks of the amplitude of the FRF. The natural frequencies are identified as the frequencies at which the FRF has a local maximum. The local maxima are determined using Peaks.jl.\nTo check the peak detection, one can use the peaksplot function from StructuralVibration.jl (see Peaks plot for more details).\nEstimation of modal damping factors\nTo estimate the value of the damping factor for mode \\(i\\), the half power bandwidth method is used. This procedure, valid for low damping (\\(\\eta_i &lt; 0.1\\)), first determines the frequencies \\(\\omega_1\\) and \\(\\omega_2\\) such that: \\[\n\\vert H_{pq}(\\omega_1)\\vert = \\vert H_{pq}(\\omega_2)\\vert = \\frac{\\vert H_{pq}(\\omega_i)\\vert}{\\sqrt{2}},\n\\] with \\(\\omega_i \\in [\\omega_1, \\omega_2]\\).\nKnowing the values of \\(\\omega_i\\), \\(\\omega_1\\), and \\(\\omega_2\\), the damping ratio for mode \\(i\\) is determined using the formula: \\[\n\\eta_i = \\frac{\\omega_2^2 - \\omega_1^2}{2\\omega_i^2}.\n\\]\n\n\n\n\n\n\n\nNote\n\n\n\nIf we consider that the shape of a resonance peak is symmetric then \\(\\omega_i = \\frac{\\omega_1 + \\omega_2}{2}\\).\nIt comes that: \\[\n\\omega_2^2 - \\omega_1^2 \\approx 2\\omega_i(\\omega_2 - \\omega_1).\n\\]\nHence, the damping ratio can be approximated as: \\[\n\\eta_i \\approx \\frac{\\omega_2 - \\omega_1}{\\omega_i}.\n\\]\nThis formula is often given in textbooks when dealing with the half power bandwidth method.\n\n\nOnce the natural frequencies and damping ratios have been determined, the poles are recovered using the relation: \\[\n\\lambda_i = -\\xi_i \\omega_i + j\\omega_i\\sqrt{1 - \\xi_i^2}.\n\\]\n\n\n\n\n\n\nWarning\n\n\n\nThanks to its extreme simplicity, this method allows for quick analysis. However, this method generally does not provide satisfactory results, as it relies on measuring the resonance peak, which is very difficult to measure precisely. This is why this method is mainly applicable to lightly damped structures with well-separated modes, whose transfer functions have been measured with good frequency resolution.\n\n\n\n\n2.1.2 Circle fit method\nThe circle fit method is a more sophisticated method for extracting the natural frequencies and damping ratios of a system. It allows for more accurate results than the peak picking method. It is based on the fact that the admittance forms a circle (Nyquist circle) when plotted in the complex plane (see Figure 1). Indeed, assuming that the modes are mass-normalized, it can be shown that: \\[\nRe\\left[H_{pq}(\\omega)\\right]^2 + \\left(Im\\left[H_{pq}(\\omega)\\right] + \\frac{\\Phi_i(x_p)\\Phi_i(x_q)}{2\\eta_i\\omega_i^2}\\right)^2 = \\left(\\frac{\\Phi_i(x_p)\\Phi_i(x_q)}{2\\eta_i\\omega_i^2}\\right)^2,\n\\] which is the equation of a circle of radius \\(R = \\frac{\\vert\\Phi_i(x_p)\\Phi_i(x_q)\\vert}{2\\eta_i\\omega_i^2}\\) and center \\((x_c,y_c) = \\Bigl(0,-\\frac{\\Phi_i(x_p)\\Phi_i(x_q)}{2\\eta_i\\omega_i^2}\\Bigr)\\).\n\n\n\n\n\n\nFigure 1: Typical Nyquist circle of an admittance \\(H_{pq}(\\omega)\\)\n\n\n\nThe circle fit method consists of the following steps:\n\nIdentification of natural frequencies\nTo identify the natural frequency of a mode \\(i\\), we start by parameterizing the Nyquist circle by defining the angles \\(\\psi\\) and \\(\\theta\\) as shown in Figure 1. Mathematically, it can then be shown that: \\[\n\\omega_i^2 = \\frac{\\omega_1^2\\tan\\frac{\\theta_2}{2} - \\omega_2^2\\tan\\frac{\\theta_1}{2}}{\\tan\\frac{\\theta_2}{2} - \\tan\\frac{\\theta_1}{2}},\n\\] where \\(\\omega_1\\) and \\(\\omega_2\\) are the angular frequencies such that \\(\\omega_1 &lt; \\omega_i &lt; \\omega_2\\), while \\(\\theta_1\\) and \\(\\theta_2\\) are the corresponding angles of the Nyquist circle.\nEstimation of modal damping factors\nThe damping ratio is estimated using the following formula: \\[\n\\eta_i = \\frac{\\omega_2^2 - \\omega_1^2}{\\omega_i^2}\\frac{1}{\\tan\\frac{\\theta_1}{2} - \\tan\\frac{\\theta_2}{2}}.\n\\]\n\n\n\n\n\n\n\nNote\n\n\n\nGenerally, the angles \\(\\theta_1\\) and \\(\\theta_2\\) are chosen so that: \\[\n\\theta_1 = \\frac{\\pi}{2} \\text{ and } \\theta_2 = -\\frac{\\pi}{2}.\n\\]\nIn doing so, we have: \\[\n\\omega_i^2 = \\frac{\\omega_1^2 + \\omega_2^2}{2} \\text{ and } \\eta_i = \\frac{\\omega_2^2 - \\omega_1^2}{2\\omega_i^2}.\n\\]\n\n\n\n\n2.1.3 Least squares fit method\nThe least squares fit method is based on the idea of fitting the frequency response function (FRF) around the resonance peaks using a least squares approach1.\nWhen the natural frequencies of the modes are sufficiently spaced and the damping is low, one can write at a frequency \\(\\omega\\) close to the natural frequency \\(f_i\\): \\[\nH_{pq}(f) \\approx \\frac{{}_i A_{pq}}{f_i^2 - f^2 + 2j\\xi_i f_i f}.\n\\]\nThe least squares fit method consists of the following steps:\n\nDefinition of the system matrices\nTo construct the system matrices, we start by rewriting the previous equation as: \\[\nH_{pq}(f) \\left(f_i^2 - f^2 + 2j\\xi_i f_i f\\right) - {}_i A_{pq} = 0.\n\\]\nThis equation can be rewritten as: \\[\n\\begin{bmatrix}\nH_{pq}(f) & 2jfH_{pq}(f) & -1\n\\end{bmatrix} \\begin{bmatrix}\nf_i^2 \\\\\n\\xi_i f_i \\\\\n_{i}A_{pq}\n\\end{bmatrix} = f^2 H_{pq}(f).\n\\]\nIf we consider \\(M\\) frequency points around the resonance peak, we can construct the following system of equations: \\[\n\\begin{bmatrix}\nH_{pq}(f_1) & 2jf_1H_{pq}(f_1) & -1 \\\\\nH_{pq}(f_2) & 2jf_2H_{pq}(f_2) & -1 \\\\\n\\vdots & \\vdots & \\vdots \\\\\nH_{pq}(f_M) & 2jf_MH_{pq}(f_M) & -1\n\\end{bmatrix} \\begin{bmatrix}\nf_i^2 \\\\\n\\xi_i f_i \\\\\n_{i}A_{pq}\n\\end{bmatrix} = \\begin{bmatrix}\nf_1^2 H_{pq}(f_1) \\\\\nf_2^2 H_{pq}(f_2) \\\\\n\\vdots \\\\\nf_M^2 H_{pq}(f_M)\n\\end{bmatrix}.\n\\]\nLeast squares solution\nThe least squares solution of the previous system of equations is given by: \\[\n\\begin{bmatrix}\nf_i^2 \\\\\n\\xi_i f_i \\\\\n_{i}A_{pq}\n\\end{bmatrix} = \\left(\\mathbf{A}^H\\mathbf{A}\\right)^{-1}\\mathbf{A}^H\\mathbf{b},\n\\] where \\(\\mathbf{A}\\) is the matrix on the left-hand side of the system of equations, \\(\\mathbf{b}\\) is the vector on the right-hand side, and \\(\\mathbf{A}^H\\) is the conjugate transpose of \\(\\mathbf{A}\\).\n\n\n\n\n\n\n\nNote\n\n\n\nIn practice, the least squares solution is not directly computed using complex numbers, as this can lead to numerical issues. Instead, the real and imaginary parts are separated to solve a real system of double size.\n\n\n\n\n\n2.2 Mode shape extraction\nThe mode shapes are extracted from the admittance matrix at the resonance frequency \\(\\omega_i\\). In this situation, the admittance matrix is defined as: \\[\n\\mathbf{H} = \\frac{1}{j\\eta_i\\omega_i^2}\n  \\begin{bmatrix}\n    \\Phi_i(x_1)^2 & \\Phi_i(x_1)\\Phi_i(x_2) & \\ldots\\ & \\Phi_i(x_1)\\Phi_i(x_N) \\\\\n    \\Phi_i(x_2)\\Phi_i(x_1) & \\Phi_i(x_2)^2 &  & \\Phi_i(x_2)\\Phi_i(x_N) \\\\\n    \\vdots & & \\ddots & \\vdots \\\\\n    \\Phi_i(x_N)\\Phi_i(x_1) & \\ldots & \\ldots & \\Phi_i(x_N)^2\n  \\end{bmatrix},\n\\]\nwhere \\(\\omega_i\\) and \\(\\eta_i\\) have been determined using the peak picking method or the circle fit method.\nTo determine the mode shapes from the knowledge of a column \\(q\\) (or a row \\(p\\)), proceed as follows:\n\nFrom the measurement of an input admittance (diagonal term of the admittance matrix), the mode shape value at point \\(x_q\\) is obtained: \\[\n\\Phi_i(x_q)^2 = -\\eta_i\\omega_i^2 \\text{Im}(H_{qq}(\\omega_i)).\n\\]\nFrom the cross-admittances (off-diagonal terms of the admittance matrix), the mode shape value at a point \\(x_p\\) is calculated: \\[\n\\Phi_i(x_p)\\Phi_i(x_q) = -\\eta_i\\omega_i^2 \\text{Im}(H_{pq}(\\omega_i))\n\\]",
    "crumbs": [
      "Modal extraction",
      "Experimental Modal Analysis"
    ]
  },
  {
    "objectID": "modal_extraction/index.html#mdof-methods",
    "href": "modal_extraction/index.html#mdof-methods",
    "title": "Experimental Modal Analysis",
    "section": "3 Mdof methods",
    "text": "3 Mdof methods\nThe Mdof methods are based on the assumption that the system can be represented as a multiple degree of freedom system. They are generally based on the construction of a high-order polynomial matrix whose coefficients are estimated from the measured FRFs. As for the SDOF methods, the estimation of the modal parameters is divided into two steps:\n\nestimation of the poles of the system to extract the natural frequencies and modal damping ratios,\nestimation of the residues to extract the mode shapes.\n\n\n3.1 Poles extraction\nThe poles of the system are then obtained as the roots of the characteristic polynomial associated with this polynomial matrix. Three methods are implemented in this package:\n\nthe Least-Squares Complex Exponential (LSCE) method\nthe Least-Squares Complex Frequency-domain (LSCF) method\nthe Polyreference Least-Squares Complex Frequency-domain (pLSCF) method\n\n\n3.1.1 LSCE method\nThe LSCE method is based on the assumption that the system can be modeled as a sum of complex exponentials in the time domain. The impulse response function (IRF) between an output \\(o\\) (\\(o = 1, \\ldots, n_o\\)) and an input \\(i\\) (\\(i = 1, \\ldots, n_i\\)) can be modeled as: \\[\nh_{oi}(t) = \\sum_{k = 1}^n \\left(c_k e^{\\lambda_k t} + c_k^\\ast e^{-\\lambda_k^\\ast t}\\right) = 2 Re\\left(\\sum_{k = 1}^n c_k e^{\\lambda_k t}\\right).\n\\]\nWhen sampling the IRF at a sampling period \\(T_s\\), one obtains the following discrete-time model: \\[\nh_{oi}[m] = 2 Re\\left(\\sum_{k = 1}^n c_k z_k^m\\right) \\text{ with } z_k = e^{\\lambda_k T_s},\n\\]\nfor \\(m = 0, 1, \\ldots, 2n\\), (\\(n\\) is the model order). According to the Prony’s method, the poles \\(\\lambda_k\\) can be calculated from the roots of the following characteristic polynomial: \\[\n\\sum_{m = 0}^{2n} \\beta_m z_k^m = 0 \\text{ with } \\beta_{2n} = 1.\n\\]\nThe coefficients \\(\\beta_l\\) of the characteristic polynomial can be estimated from the sampled IRF \\(h_{oi}[m]\\). Todo so, one first multiply \\(h_{oi}[m]\\) by the corresponding coefficients \\(\\beta_m\\) and then sums the resulting equations for \\(m = 0, 1, \\ldots, 2n\\). This leads to the following homogeneous set of equations: \\[\n\\sum_{m = 0}^{2n} \\beta_m h_{oi}[m] = 2 Re\\left(\\sum_{k = 1}^{n} c_k \\sum_{m = 0}^{2n} \\beta_m z_k^m\\right).\n\\]\nWhen \\(z_k\\) is a root of the characteristic polynomial, the right-hand side of the previous equation is equal to zero. Therefore, one can estimate the coefficients \\(\\beta_m\\) by solving the following set of linear equations: \\[\n\\sum_{m = 0}^{2n} \\beta_m h_{oi}[m] = 0.\n\\]\nThe previous equation can be derived using different set of data points, \\(h_{oi}[m]\\), \\(h_{oi}[m+1]\\), \\(\\ldots\\), \\(h_{oi}[m + 2n]\\) to obtain an overdetermined set of linear equations that can be solved in the least-squares sense2. In this package, the coefficients \\(\\beta_m\\) are estimated by solving the following set of equations: \\[\n\\begin{bmatrix}\nh_{oi}[0] & h_{oi}[1] & \\ldots & h_{oi}[2n-1] \\\\\nh_{oi}[1] & h_{oi}[2] & \\ldots & h_{oi}[2n] \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\nh_{oi}[2n-1] & h_{oi}[2n] & \\ldots & h_{oi}[4n-2]\n\\end{bmatrix}\n\\begin{bmatrix}\n\\beta_0 \\\\\n\\beta_1 \\\\\n\\vdots \\\\\n\\beta_{2n-1}\n\\end{bmatrix}\n= -\\begin{bmatrix}\nh_{oi}[2n] \\\\\nh_{oi}[2n+1] \\\\\n\\vdots \\\\\nh_{oi}[4n-1]\n\\end{bmatrix}\n\\]\nOnce the coefficients \\(\\beta_m\\) are estimated, the poles \\(\\lambda_k\\) can be obtained from the roots \\(z_k\\) of the characteristic polynomial.\n\n\n3.1.2 LSCF method\nAccording to Guillaume et al. 3, the transfer function between an output \\(o\\) (\\(o = 1, \\ldots, n_o\\)) and an input \\(i\\) (\\(i = 1, \\ldots, n_i\\)) can be modeled in the frequency domain as: \\[\n\\widehat{H}_k(\\omega) = \\frac{N_k(\\omega)}{d(\\omega)},\n\\]\nwhere \\(k = 1, \\ldots, n_o n_i\\) (\\(k = (o - 1) n_i + i\\)). Here, \\(N_k(\\omega)\\) is the \\(k\\)-th element of the numerator matrix defined as: \\[\nN_k(\\omega) = \\mathbf{\\Omega}(\\omega)^T \\boldsymbol{\\beta}_k,\n\\]\nwhile \\(d(\\omega)\\) is the common denominator polynomial defined as: \\[\nd(\\omega) = \\mathbf{\\Omega}(\\omega)^T \\boldsymbol{\\alpha}.\n\\]\nIn the previous equations, \\(\\mathbf{\\Omega}(\\omega)\\) is the vector of polynomial basis functions defined as: \\[\n\\mathbf{\\Omega}(\\omega)^T = [1, \\Omega_1(\\omega), \\ldots, \\Omega_n(\\omega)] \\text{ with } \\Omega_n(\\omega) = \\exp(-i\\omega n T_s),\n\\]\nwhere \\(n\\) is the order of the denominator polynomial (a.k.a the model order) and \\(T_s\\) is the sampling period. The vectors \\(\\boldsymbol{\\beta}_k\\) and \\(\\boldsymbol{\\alpha}\\) contain the coefficients of the numerator and denominator polynomials, respectively.\nBased on the previous formulation of the FRFs, the LSCF method consists in estimating the coefficients of the numerator \\(\\boldsymbol{\\beta}_k\\) and denominator \\(\\boldsymbol{\\alpha}\\) polynomials by minimizing the following functional: \\[\nJ(\\boldsymbol{\\theta}) = \\sum_{k=1}^{n_o n_i} \\sum_{j=1}^{n_f} \\left| W_k(\\omega_j)\\left[H_k(\\omega_j) d(\\omega_j) - N_k(\\omega_j)\\right] \\right|^2,\n\\]\nwhere \\(\\boldsymbol{\\theta} = [\\boldsymbol{\\beta}_1^T, \\ldots, \\boldsymbol{\\beta}_{n_o n_i}^T, \\boldsymbol{\\alpha}^T]^T\\) is the vector of unknown parameters to be estimated, \\(H_k(\\omega_j)\\) is the measured FRF at frequency \\(\\omega_j\\), \\(n_f\\) is the number of frequency lines used for the identification and \\(W_k(\\omega_j)\\) is an arbitrary weighting function. In the package, a unitary weighting function is used, i.e. \\(W_k(\\omega_j) = 1\\).\nThe poles of the transfer function are obtained from the roots of the characteristic polynomial associated with the denominator polynomial \\(d(\\omega)\\), which are computed after having estimated the coefficients \\(\\boldsymbol{\\alpha}\\) as the argument of the minimum of the functional \\(J(\\boldsymbol{\\theta})\\) (see Ref. [2] for details).\n\n\n3.1.3 pLSCF method\nThe pLSCF method is an extension of the LSCF method that makes it possible to take into account multiple reference sensors simultaneously (see Ref. [3] for details). When using only one reference sensor, the pLSCF method is equivalent to the LSCF method.\nIn this approach, the transfer function \\(\\widehat{\\mathbf{H}}_o(\\omega) \\in \\mathbb{C}^{1 \\times n_i}\\) between an output \\(o\\) (\\(o = 1, \\ldots, n_o\\)) and a set of \\(n_i\\) inputs can be modeled in the frequency domain as: \\[\n\\widehat{\\mathbf{H}}_o(\\omega) = \\mathbf{N}_o(\\omega) \\mathbf{D}(\\omega)^{-1},\n\\]\nwhere \\(\\mathbf{N}_o(\\omega) \\in \\mathbb{C}^{1 \\times n_i}\\) is the numerator matrix defined as: \\[\n\\mathbf{N}_o(\\omega) = \\mathbf{\\Omega}(\\omega)^T \\boldsymbol{\\beta}_o,\n\\]\nwhile \\(\\mathbf{D}(\\omega) \\in \\mathbb{C}^{n_i \\times n_i}\\) is the denominator matrix defined as: \\[\n\\mathbf{D}(\\omega) = \\mathbf{\\Omega}(\\omega)^T \\boldsymbol{\\alpha}.\n\\]\nBased on the previous formulation of the FRFs, the pLSCF method consists in estimating the coefficients of the numerator \\(\\boldsymbol{\\beta}_o\\) and denominator \\(\\boldsymbol{\\alpha}\\) polynomials. To this end, one defines the weighted error between the measured and modeled FRFs as: \\[\n\\boldsymbol{\\varepsilon}_o(\\omega_j, \\boldsymbol{\\theta}) = W_o(\\omega_j)\\left[\\mathbf{H}_o(\\omega_j) \\mathbf{D}(\\omega_j) - \\mathbf{N}_o(\\omega_j)\\right]\n\\]\nThen, an error matrix \\(\\mathbf{E}_o(\\boldsymbol{\\theta}) \\in \\mathbb{C}^{n_f \\times n_i}\\) is constructed by stacking the weighted errors \\(\\boldsymbol{\\varepsilon}_o(\\omega_j, \\boldsymbol{\\theta}) \\in \\mathbb{C}^{1 \\times n_i}\\) for all frequency lines, that is: \\[\n\\mathbf{E}_o(\\boldsymbol{\\theta}) = \\begin{bmatrix}\n\\boldsymbol{\\varepsilon}_o(\\omega_1, \\boldsymbol{\\theta}) \\\\\n\\vdots \\\\\n\\boldsymbol{\\varepsilon}_o(\\omega_{n_f}, \\boldsymbol{\\theta})\n\\end{bmatrix}\n\\]\nFinally, the coefficients of the numerator and denominator polynomials are estimated by minimizing the following functional: \\[\nJ(\\boldsymbol{\\theta}) = \\sum_{o=1}^{n_o} \\Vert\\mathbf{E}_o(\\boldsymbol{\\theta})\\Vert^2.\n\\]\nThe poles of the transfer function are obtained from the characteristic polynomial associated with the denominator matrix \\(\\mathbf{D}(\\omega)\\), by computing the eigenvalues of the so-called companion matrix4.\n\n\n3.1.4 Stabilization diagram\nWhen carrying out an EMA, the main question that arises is how many modes (or, more precisely, poles) are contained within the frequency band of interest. Analyzing the frequency response functions (transfer functions) provides an initial estimate. However, it is difficult to distinguish between multiple or nearby modes.\nThe stabilisation diagram is a fundamental EMA tool as it provides a clear and concise presentation of the poles of the system under study. The idea is to adjust the transfer function model by increasing the number of poles and displaying the results on a graph. Broadly speaking, increasing the order of the model (i.e. the number of poles) causes the true vibration modes to converge to a stable value, whereas the numerical modes appear inconsistently or randomly on the graph. Thus, as the poles converge to stable ones, markers appear on the graph to indicate the identified poles, as the order of the model is gradually increased. The selection of poles is generally based on the stability of natural frequencies, modal damping and/or mode shapes, moving from a model order \\(n\\) to an order \\(n + 1\\). In this package, the stability of the natural frequencies and damping ratios is used to identify the physical poles of the system. The stability criterion is set to 1% for the natural frequencies and 5% for the damping ratios, following common practice in the EMA field.\nIn StructuralVibration.jl, the stabilization diagram can be obtained using the stabilization function along with any of the Mdof methods described above. The identified stable poles can then be visualized using the stabilization_plot function (see Stabilization plot). The stabilization function returns an StabilizationAnalysis structure that contains all the information related to the stabilization analysis, which allows the user to manually select the appropriate poles and to further analyze (e.g. by using quality and analysis indicators) and visualize the results.\n\n\n\n3.2 Mode shape extraction\nOnce the poles of the system have been identified using one of the Mdof methods described above, the residues can be computed to extract the mode shapes. In this package, the residues are computed using a least-squares approach based on the formulation of the FRFs as a sum of rational functions. The FRF between an output \\(p\\) (\\(p = 1, \\ldots, n_o\\)) and an input \\(q\\) (\\(q = 1, \\ldots, n_i\\)) can be expressed as: \\[\nH_{pq}(\\omega) = \\sum_{i = 1}^n \\left(\\frac{{}_iR_{pq}}{j\\omega - \\lambda_i} + \\frac{{}_iR_{pq}^\\ast}{j\\omega - \\lambda_i^\\ast}\\right),\n\\]\nwhere \\(R_{k, pq}\\) is the residue associated with the pole \\(\\lambda_k\\).\nAt a frequency line \\(\\omega\\), the previous equation can be rewritten in matrix form as: \\[\nH_{pq}(\\omega) = \\begin{bmatrix}\n\\frac{1}{j\\omega - \\lambda_1} & \\ldots & \\frac{1}{j\\omega - \\lambda_n} & \\frac{1}{j\\omega - \\lambda_1^\\ast} & \\ldots & \\frac{1}{j\\omega - \\lambda_n^\\ast}\n\\end{bmatrix}\n\\begin{bmatrix}\n{}_1R_{pq} \\\\\n\\vdots \\\\\n{}_nR_{pq} \\\\\n{}_1R_{pq}^\\ast \\\\\n\\vdots \\\\\n{}_nR_{pq}^\\ast\n\\end{bmatrix}\n\\]\nRepeating the previous equation for all frequency lines leads to the following system of equations: \\[\n\\begin{bmatrix}\nH_{pq}(\\omega_1) \\\\\nH_{pq}(\\omega_2) \\\\\n\\vdots \\\\\nH_{pq}(\\omega_{n_f})\n\\end{bmatrix}\n= \\begin{bmatrix}\n\\frac{1}{j\\omega_1 - \\lambda_1} & \\ldots & \\frac{1}{j\\omega_1 - \\lambda_n} & \\frac{1}{j\\omega_1 - \\lambda_1^\\ast} & \\ldots & \\frac{1}{j\\omega_1 - \\lambda_n^\\ast} \\\\\n\\frac{1}{j\\omega_2 - \\lambda_1} & \\ldots & \\frac{1}{j\\omega_2 - \\lambda_n} & \\frac{1}{j\\omega_2 - \\lambda_1^\\ast} & \\ldots & \\frac{1}{j\\omega_2 - \\lambda_n^\\ast} \\\\\n\\vdots & \\vdots & \\vdots & \\vdots & \\vdots & \\vdots & \\vdots & \\vdots \\\\\n\\frac{1}{j\\omega_{n_f} - \\lambda_1} & \\ldots & \\frac{1}{j\\omega_{n_f} - \\lambda_n} & \\frac{1}{j\\omega_{n_f} - \\lambda_1^\\ast} & \\ldots & \\frac{1}{j\\omega_{n_f} - \\lambda_n^\\ast}\n\\end{bmatrix}\n\\begin{bmatrix}\n{}_1R_{pq} \\\\\n\\vdots \\\\\n{}_nR_{pq} \\\\\n{}_1R_{pq}^\\ast \\\\\n\\vdots \\\\\n{}_nR_{pq}^\\ast\n\\end{bmatrix}\n\\]\nThis system of equations can be solved in the least-squares sense to estimate the residues \\({}_iR_{pq}\\). This procedure is implemented in the mode_residues function.\nFrom the estimated residues, the mode shapes can be extracted using the following relation: \\[\n{}_iR_{pq} = c_i \\phi_{p,i} \\phi_{q,i},\n\\]\nwhere \\(c_i\\) is a scaling factor, \\(\\phi_{p,i}\\) (resp. nd \\(\\phi_{q,i}\\)) is the \\(p\\)-th (resp. \\(q\\)-th) component of the mode shape associated with the \\(i\\)-th mode.\nTo solve for the mode shapes, a collocated measurement is required, i.e. \\(p = q\\). Thus, the mode shape components can be obtained as: \\[\n\\phi_{p,i} = \\sqrt{\\frac{{}_iR_{pp}}{c_i}} \\; \\text{ and } \\; \\phi_{q,i} = \\frac{{}_iR_{pq}}{\\sqrt{c_i\\; {}_iR_{pp}}}.\n\\]\nHere, the scaling factors \\(c_i\\) can be computed based on a normalization criterion. In this package, the scaling factors are computed such that the modal mass of each mode shape is equal to one (mass normalization). The mode shapes can then be extracted using the modeshape_extraction function.\nAt this stage, it is important to note that the mode shapes are complex-valued. If the modes are known to be real (after checking the Mode complexity indicators), a real-normalization transformation can be applied to the mode shapes5. Here, we adopt the widely used approach based on the computation of the phase angle that minimizes the imaginary part of the mode shape.\nGiven a complex mode shape \\(\\boldsymbol{\\Psi}_i\\), the real-normalized mode shape \\(\\bar{\\boldsymbol{\\Psi}}_i^{real}\\) is obtained as:\n\\[\n\\bar{\\boldsymbol{\\Psi}}_i^{real} = \\Re\\left(\\boldsymbol{\\Psi}_i e^{-j\\theta_i}\\right),\n\\] where \\(\\theta_i\\) is the phase angle between the real and imaginary parts of the mode shape. This angle is computed from the coefficient (gradient) of the straight line that best fits the points \\((\\Re(\\Psi_k), \\Im(\\Psi_k))\\) for. This procedure is implemented in the real_normalization function.",
    "crumbs": [
      "Modal extraction",
      "Experimental Modal Analysis"
    ]
  },
  {
    "objectID": "modal_extraction/index.html#frf-reconstruction",
    "href": "modal_extraction/index.html#frf-reconstruction",
    "title": "Experimental Modal Analysis",
    "section": "4 FRF reconstruction",
    "text": "4 FRF reconstruction\nFrom the identified modal parameters (poles and residues), it is possible to reconstruct the frequency response functions (FRFs) of the system under study using the frf_reconstruction function. This function implements the following relation for a number \\(M\\) of identified modes:\n\\[\nH_{pq}(\\omega) = \\sum_{i = 1}^{M} \\left[\\frac{{}_i R_{pq}}{(j\\omega - \\lambda_i)} + \\frac{{}_i R_{pq}^\\ast}{(j\\omega - \\lambda_i^\\ast)}\\right],\n\\]\nwhere:\n\n\\(\\lambda_i = -\\xi_i + j\\,\\Omega_i\\) is the pole related to the mode \\(i\\), with:\n\n\\(\\Omega_i = \\omega_i\\sqrt{1 - \\xi_i^2}\\) is the damped natural frequency of the mode \\(i\\), with \\(\\omega_i = \\vert \\lambda_i\\vert\\).\n\\(\\xi_i = -\\frac{\\text{Re}(\\lambda_i)}{\\omega_i}\\) the modal damping factor of the mode \\(i\\) \n\n\\({}_i R_{pq} = c_i\\, \\phi_i(x_p)\\, \\phi_i(x_q)\\) is the residue of the mode \\(i\\), with:\n\n\\(\\phi_i(x_p)\\) the mode shape of the mode \\(i\\) at point \\(x_p\\)\n\\(c_i = \\frac{1}{2jM_i\\Omega_i}\\) the normalization constant of the mode shape of the mode \\(i\\)\n\n\nIn practice, however, the reconstructed FRF may not perfectly match the experimental FRF due to the unmodeled contribution of the modes outside the frequency range of interest. To account for this, it is common to include lower and upper residuals in the FRF reconstruction. This means that the admittance matrix can be expressed as: \\[\nH_{pq}(\\omega) = \\sum_{i = 1}^{M} \\left[\\frac{{}_i R_{pq}}{(j\\omega - \\lambda_i)} + \\frac{{}_i R_{pq}^\\ast}{(j\\omega - \\lambda_i^\\ast)}\\right] - \\frac{L_{pq}}{\\omega^2} + U_{pq},\n\\]\nwhere \\(L_{pq}\\) and \\(U_{pq}\\) are the lower and upper residuals, respectively. These residuals can be computed using the compute_residuals function.\n\n\n\n\n\n\nNote\n\n\n\nTheoretically, the residuals can be computed in conjunction with the estimation of the residues using a least-squares approach. However, we observed that this often leads to inaccurate estimates of the residuals. Therefore, in StructuralVibration.jl, the computation of the residuals is performed separately after estimating the residues and poles.\n\n\nFinally, when only real mode shapes are available, it is possible to compute the residues from the modal parameters using the mode2residues function. This function implements the following relation: \\[\n{}_i R_{pq} = c_i\\, \\phi_i(x_p)\\, \\phi_i(x_q),\n\\]\nwhere \\(\\phi_i(x_p)\\) is the mode shape of the mode \\(i\\) at point \\(x_p\\) and \\(c_i = \\frac{1}{2jM_i\\Omega_i}\\) is the normalization constant of the mode shape of the mode \\(i\\). Here, \\(M_i = 1\\), since the mode shapes are mass-normalized. during the extraction process. –&gt;",
    "crumbs": [
      "Modal extraction",
      "Experimental Modal Analysis"
    ]
  },
  {
    "objectID": "modal_extraction/index.html#api",
    "href": "modal_extraction/index.html#api",
    "title": "Experimental Modal Analysis",
    "section": "5 API",
    "text": "5 API\nData types\n\nEMAProblem\n\n\n\nEMAProblem(frf, freq; frange, type_frf)\nData structure defining the inputs for EMA modal extraction methods.\nConstructor parameters\n\nfrf::Array{Complex, 3}: 3D FRF matrix (array nm x ne x nf)\n\nfreq::AbstractArray{Real}: Vector of frequency values (Hz)\n\nfrange::Vector{Real}: Frequency range for analysis (default: [freq[1], freq[end]])\n\ntype_frf::Symbol: Type of FRF used in the analysis\n\n:dis: Admittance (default)\n\n:vel: Mobility\n\n:acc: Accelerance\n\n\n\n\nFields\n\nfrf::Array{Complex, 3}: 3D admittance matrix (array nm x ne x nf)\n\nfreq::AbstractArray{Real}: Vector of frequency values (Hz)\n\ntype_frf::Symbol: Type of FRF used in the analysis\n\n\nNote The FRF is internally converted to admittance if needed.\n\n\n\n\n\n\n\nAutoEMASdofProblem\n\n\n\nAutoEMASdofProblem(prob, alg; dpi, idx_m, idx_e, width, min_prom, max_prom, pks_indices)\nStructure containing the input data for automatic experimental modal analysis using Sdof methods\nFields\n\nprob::EMASdofProblem: EMA-SDOF problem containing FRF data and frequency vector\n\nalg::SdofModalExtraction: Method to extract the poles\n\nPeakPicking: Peak picking method (default)\n\nCircleFit: Circle fitting method\n\nLSFit: Least squares fitting method\n\n\n\ndpi::Vector{Int}: Driving point indices - default = [1, 1]\n\ndpi[1]: Driving point index on the measurement mesh\n\ndpi[2]: Driving point index on the excitation mesh\n\n\n\nidx_m::AbstractArray{Int}: Indices of measurement DOFs used for residues computation (default: all measurement DOFs)\n\nidx_e::AbstractArray{Int}: Indices of excitation DOFs used for residues computation (default: all excitation DOFs)\n\nwidth::Int: Half-width of the peaks (default: 1)\n\nmin_prom::Real: Minimum peak prominence (default: 0.)\n\nmax_prom::Real: Maximum peak prominence (default: Inf)\n\npks_indices::Vector{Int}: Predefined peak indices (default: empty vector)\n\n\n\n\n\n\n\n\n\nAutoEMAMdofProblem\n\n\n\nAutoEMAMdofProblem(prob, dpi, method; modetype)\nStructure containing the input data for automatic experimental modal analysis using Mdof methods\nFields\n\nprob::EMAProblem: EMA problem containing FRF data and frequency vector\n\norder::Int: Model order (number of poles to extract)\n\ndpi::Vector{Int}: Driving point indices - default = [1, 1]\n\ndpi[1]: Driving point index on the measurement mesh\n\ndpi[2]: Driving point index on the excitation mesh\n\n\n\nalg::MdofEMA: Method to extract the poles\n\nLSCE: Least Squares Complex Exponential method\n\nLSCF`: Least Squares Complex Frequency method (default)\n\nPLSCF: Polyreference Least Squares Complex Frequency method\n\n\n\nmodetype::Symbol: Type of mode shapes to extract\n\n:real: Real mode shapes (default)\n\n:complex: Complex mode shapes\n\n\n\n\n\n\n\n\n\n\n\nEMASolution\n\n\n\nEMASolution(poles, ms, ci, res, lr, ur)\nStructure containing the solution of the automatic experimental modal analysis using Mdof methods\nFields\n\npoles::Vector{Complex}: Extracted poles\n\nms::AbstractArray{Real}: Mode shapes\n\nci::Vector{Complex}: Scaling constants for each mode\n\nres::AbstractArray{Complex}: Residues for each mode\n\nlr::Matrix{Complex}: Lower residual\n\nur::Matrix{Complex}: Upper residual\n\n\n\n\n\n\n\n\n\nStabilizationAnalysis\n\n\n\nStabilizationAnalysis(prob, poles, modefn, mode_stabfn, mode_stabdr)\nData structure summarizing the results of the stabilization analysis.\nFields\n\nprob::MdofProblem: EMA-MDOF problem containing FRF data and frequency vector\n\nfrange::Vector{Real}: Frequency range used for the stabilization analysis\n\npoles::Vector{Vector{Complex}}: Vector of vectors containing extracted poles at each model order\n\nmodefn::Matrix{Real}: Matrix containing the natural frequencies (useful for plotting)\n\nmode_stabfn::Matrix{Bool}: Matrix indicating the stability of natural frequencies\n\nmode_stabdr::Matrix{Bool}: Matrix indicating the stability of damping ratios\n\n\nNote\nThis structure is returned by the stabilization function after performing a stabilization diagram analysis and used by stabilization_plot for visualization.\n\n\n\n\n\n\n\nPeakPicking\n\n\n\nPeakPicking\nPeak picking method for Sdof modal extraction\nFields\n\nnothing\n\n\nReference\n[1] D. J. Inman, \"Engineering Vibration\", 4th Edition, Pearson, 2013.\n\n\n\n\n\n\n\nCircleFit\n\n\n\nPeakPicking\nCircle fitting method for Sdof modal extraction\nFields\n\nnothing\n\n\nReference\n[1] D. J. Inman, \"Engineering Vibration\", 4th Edition, Pearson, 2013.\n\n\n\n\n\n\n\nLSFit\n\n\n\nLSFit\nLeast squares fitting method for Sdof modal extraction\nFields\n\nnothing\n\n\nReference [1] A. Brandt, \"Noise and Vibration Analysis: Signal Analysis and Experimental Procedures\", Wiley, 2011.\n\n\n\n\n\n\n\nLSCE\n\n\n\nLSCE\nLeast Squares Complex Exponential method for Mdof modal extraction\nFields\n\nnothing\n\n\nReference\n[1] D. L. Brown, R. J. Allemang, Ray Zimmerman and M. Mergeay. \"Parameter Estimation Techniques for Modal Analysis\". SAE Transactions, vol. 88, pp. 828-846, 1979.\n\n\n\n\n\n\n\nLSCF\n\n\n\nLSCF\nLeast Squares Complex Frequency method for Mdof modal extraction\nFields\n\nnothing\n\n\nReference\n[1] P. Guillaume, P. Verboven, S. Vanlanduit, H. Van der Auweraer, and B. Peeters, \"A poly-reference implementation of the least-squares complex frequency-domain estimator\". In Proceedings of IMAC XXI. Kissimmee, FL, 2003.\n[2] El-Kafafy M., Guillaume P., Peeters B., Marra F., Coppotelli G. (2012).Advanced Frequency-Domain Modal Analysis for Dealing with Measurement Noise and Parameter Uncertainty. In: Allemang R., De Clerck J., Niezrecki C., Blough J. (eds) Topics in Modal Analysis I, Volume 5. Conference Proceedings of the Society for Experimental Mechanics Series. Springer, New York, NY\n\n\n\n\n\n\n\npLSCF\n\n\n\npLSCF\nPolyreference Least Squares Complex Frequency method for Mdof modal extraction\nFields\n\nnothing\n\n\nReference\n[1] P. Guillaume, P. Verboven, S. Vanlanduit, H. Van der Auweraer, and B. Peeters, \"A poly-reference implementation of the least-squares complex frequency-domain estimator\". In Proceedings of IMAC XXI. Kissimmee, FL, 2003.\n[2] El-Kafafy M., Guillaume P., Peeters B., Marra F., Coppotelli G. (2012).Advanced Frequency-Domain Modal Analysis for Dealing with Measurement Noise and Parameter Uncertainty. In: Allemang R., De Clerck J., Niezrecki C., Blough J. (eds) Topics in Modal Analysis I, Volume 5. Conference Proceedings of the Society for Experimental Mechanics Series. Springer, New York, NY\n\n\n\n\n\n\nRelated functions\n\npoles_extraction\n\n\n\npoles_extraction(prob::EMAProblem, alg; width, min_prom, max_prom, pks_indices)\npoles_extraction(prob::MdofProblem, order, alg; stabdiag)\nExtract poles from the Bode diagram fitting method\nInputs\n\nprob::EMAProblem or prob::MdofProblem: EMA problem containing FRF data and frequency vector\n\norder: Order of the model (only for Mdof methods)\n\nalg: Algorithm to extract the poles\n\nSdof methods:\n\nPeakPicking: Peak picking method (default for Sdof methods)\n\nCircleFit: Circle fitting method\n\nLSFit: Least squares fitting method\n\n\n\nMdof methods:\n\nLSCF: Least Squares Complex Frequency method (default for Mdof methods)\n\nPLSCF: Polyreference Least Squares Complex Frequency method\n\nLSCE: Least Squares Complex Exponential method (only for Mdof methods)\n\n\n\n\n\nstabdiag::Bool: Boolean to indicate the function is used to build a stability diagram (Only for Mdof methods, default: false)\n\nwidth::Int: Half-width of the peaks (only for Sdof methods, default: 1)\n\nmin_prom::Real: Minimum peak prominence (only for Sdof methods, default: 0. dB)\n\nmax_prom::Real: Maximum peak prominence (only for Sdof methods, default: Inf)\n\npks_indices::Vector{Int}: Indices of peaks to consider (only for Sdof methods, default: empty vector)\n\n\nOutputs\n\npoles: Vector of extracted complex poles\n\n\nNote\n\nFor Sdof methods, the natural frequencies and damping ratios are extracted from each FRF (each row of the matrix) and then averaged. The number of FRF used for averaging are those having the maximum (and same) number of peaks detected.\n\n\n\n\n\n\n\n\n\nmodeshape_extraction\n\n\n\nmodeshape_extraction(prob, poles, alg; dpi)\nmodeshape_extraction(residues, poles, alg; dpi, modetype)\nExtract mode shapes using Sdof approximation\nInputs\n\nprob::EMAProblem: EMA problem containing FRF data and frequency vector\n\npoles: Vector of complex poles\n\nalg::SdofModalExtraction or alg::MdofEMA: Modal extraction algorithm\n\ndpi: Driving point indices - default = [1, 1]\n\ndpi[1]: Driving point index on the measurement mesh\n\ndpi[2]: Driving point index on the excitation mesh\n\n\n\nmodetype: Type of mode shape (only for Mdof methods)\n\n:emac: EMA - Complex mode shapes (default)\n\n:emar: EMA - Real mode shapes\n\n:oma: OMA\n\n\n\n\nOutput\n\nms: Mode shapes\n\nci: Scaling factors vector (only for Mdof methods)\n\n\nNote\n\nIf the number of measurement points is less than the number of excitation points, the mode shapes are estimated at the excitation points (roving hammer test). Otherwise, the mode shapes are estimated at the measurement points (roving accelerometer test).\n\nThe alg argument is here for performing multiple dispatch but is not used in the function.\n\n\nReferences [1] M. Géradin and D. J. Rixen. \"Mechanical Vibrations: Theory and Application to Structural Dynamics\". 3rd. Edition, Wiley, 2015.\n[2] C. Ranieri and G. Fabbrocino. \"Operational Modal Analysis of Civil Engineering Structures: An Introduction and Guide for Applications\". Springer, 2014.\n\n\n\n\n\n\n\nmodal2poles\n\n\n\nmodal2poles(fn, ξn)\nConvert natural frequencies and damping ratios to complex poles.\nInputs\n\nfn: Vector of natural frequencies (Hz)\n\nξn: Vector of damping ratios\n\n\nOutput\n\npoles: Vector of complex poles\n\n\n\n\n\n\n\n\n\npoles2modal\n\n\n\npoles2modal(poles)\nConvert complex poles to natural frequencies and damping ratios.\nInput\n\npoles: Vector of complex poles\n\n\nOutputs\n\nfn: Vector of natural frequencies (Hz)\n\nξn: Vector of damping ratios\n\n\n\n\n\n\n\n\n\nreal_normalization\n\n\n\nreal_normalization(Ψ)\nConverts the complex modes to real modes\nInput\n\nΨ: Complex modes\n\n\nOutput\n\nϕn: Real modes\n\n\nReference\n[1] E. Hiremaglur. \"Real-Normalization of Experimental Complex Modal Vectors with Modal Vector Contamination\". MS Thesis. University of Cincinnati, 2014.\n\n\n\n\n\n\n\nsolve\n\n\n\nsolve(prob_ema::AutoEMASdofProblem)\nsolve(prob_ema::AutoEMAMdofProblem, order::Int; stabdiag, weighting)\nSolve automatically experimental modal analysis problem using Sdof or Mdof methods\nInputs\n\nprob_ema: Structure containing the input data for automatic experimental modal analysis using Sdof methods\n\n\nOutputs\n\nsol::EMASolution: Structure containing the solution of the automatic experimental modal analysis using Sdof or Mdof methods\n\n\n\n\n\n\n\n\n\nfrf_reconstruction\n\n\n\nfrf_reconstruction(res, poles, freq; lr, ur, type)\nReconstruct a frequency response function (FRF) from its residues and poles.\nInputs\n\nres::Array{Complex, 3}: Residues corresponding to each pole\n\npoles::Vector{Complex}: Poles extracted from the FRF\n\nfreq: Frequency vector\n\nlr::Matrix{Complex, 2}: Lower residuals (default: zeros)\n\nur::Matrix{Complex, 2}: Upper residuals (default: zeros)\n\ntype::Symbol: Type of FRF to reconstruct\n\n:dis: displacement (default)\n\n:vel: velocity\n\n:acc: acceleration\n\n\n\n\nOutput\n\nH_rec::Array{Complex, 3}: Reconstructed FRF\n\n\n\n\n\n\n\n\n\ncompute_residuals\n\n\n\ncompute_residuals(prob, res, poles)\nCompute lower and upper residuals of a frequency response function (FRF) given its residues and poles.\nInputs\n\nprob::EMAProblem: Structure containing FRF data and frequency vector\n\nres::Array{Complex, 3}: Residues corresponding to each pole\n\npoles::Vector{Complex}: Poles extracted from the FRF\n\n\nOutputs\n\nlr::Matrix{Complex, 2}: Lower residuals\n\nur::Matrix{Complex, 2}: Upper residuals\n\n\n\n\ncompute_residuals(prob, res, poles)\nCompute lower and upper residuals of a half-spectrum given its residues and poles.\nInputs\n\nprob::OMAProblem: Structure containing half-spectrum data and frequency vector\n\nres::Array{Complex, 3}: Residues corresponding to each pole\n\npoles::Vector{T}: Poles extracted from the half-spectrum\n\n\nOutputs\n\nlr::Matrix{Complex, 2}: Lower residuals\n\nur::Matrix{Complex, 2}: Upper residuals\n\n\n\n\n\n\n\n\n\nmode2residues\n\n\n\nmode2residues(ms, poles, idx_m, idx_e)\nCompute the mode residues from mode shapes and poles.\nInputs\n\nms::Matrix{Complex, 2}: Mode shapes matrix\n\npoles::Vector{Complex}: Poles extracted from the FRF\n\nidx_m::Vector{Int}: Indices of measurement locations\n\nidx_e::Vector{Int}: Indices of excitation locations\n\n\nOutput\n\nres::Array{Complex, 3}: Residues corresponding to each pole\n\nci::Vector{Complex}: Scaling constants for each mode\n\n\nNote The mode shapes are supposed to be real and mass-normalized.",
    "crumbs": [
      "Modal extraction",
      "Experimental Modal Analysis"
    ]
  },
  {
    "objectID": "modal_extraction/index.html#example",
    "href": "modal_extraction/index.html#example",
    "title": "Experimental Modal Analysis",
    "section": "6 Example",
    "text": "6 Example\n\n6.1 Data preparation and FRF calculation\n\n# Structure parameters of the beam\nL = 1.        # Length\nb = 0.03      # Width\nh = 0.01      # Thickness\nS = b*h       # Cross-section area\nIz = b*h^3/12 # Moment of inertia\n\n# Material parameters\nE = 2.1e11  # Young's modulus\nρ = 7850.   # Density\nξ = 0.01    # Damping ratio\n\n# Mesh\nxexc = 0:0.05:L\nxm = xexc[2]\n\n# Mode calculation - Simply supported boundary conditions\nbeam = Beam(L, S, Iz, E, ρ)\nfmax = 500.\n\nωn, kn = modefreq(beam, 2fmax)\nms_exc = modeshape(beam, kn, xexc)\nms_m = modeshape(beam, kn, xm)\n\n# FRF calculation\nfreq = 1.:0.1:fmax\nprob = ModalFRFProblem(ωn, ξ, freq, ms_m, ms_exc)\nH = solve(prob).u\n\n\n\n6.2 Sdof methods\n\n6.2.1 Peak detection checking\n\nHabs_dB = 20log10.(abs.(H[1, 2, :]))\npeaks_plot(freq, Habs_dB, xlabel = \"Frequency (Hz)\", ylabel = \"Admittance (dB, ref: 1 m/N)\")\n\n\n\n\n\n\n6.2.2 Modes extraction\n\n# Natural frequencies and damping ratios extraction\nprob_sdof = EMAProblem(H, freq)\npoles_pp = poles_extraction(prob_sdof, PeakPicking())\npoles_cf = poles_extraction(prob_sdof, CircleFit())\npoles_lsf = poles_extraction(prob_sdof, LSFit())\n\n# Mode shape extraction\ndpi = [1, 2]\nms_id = modeshape_extraction(prob_sdof, poles_pp, PeakPicking(), dpi = dpi)\n\n\n\n\n\n\n\n\n\n\n\n6.2.3 FRF reconstruction\n\n# Computation of the mode residues\nres_pp = mode2residues(ms_id, poles_pp, [2], 1:21)[1]\n\n# FRF reconstruction - without residuals\nH_sdof = frf_reconstruction(res_pp, poles_pp, freq)\n\n# FRF reconstruction - with residuals\nlr, ur = compute_residuals(prob_sdof, res_pp, poles_pp)\nH_sdof2 = frf_reconstruction(res_pp, poles_pp, freq, lr = lr, ur = ur)\n\n\n\n\n\n\n\n\n6.2.4 Automatic Sdof EMA\nprob_ema = AutoEMASdofProblem(prob_sdof, PeakPicking(), dpi = dpi, idx_m = [2], idx_e = 1:21)\nsol_ema = solve(prob_ema)\nfn_ema, ξn_ema = poles2modal(sol_ema.poles)\nms_ema = sol_ema.ms\n\n\n\n6.3 Mdof methods\n\n6.3.1 Poles extraction\n\n# EMA problem\nprob_mdof = EMAProblem(H, freq)\n\n# Poles extraction\norder = 10 # Model order\np_lsce = poles_extraction(prob_mdof, order, LSCE())\np_lscf = poles_extraction(prob_mdof, order, LSCF())\np_plscf = poles_extraction(prob_mdof, order, pLSCF())\n\n# Stabilization diagram analysis using the LSCF method\nstab = stabilization(prob_mdof, order, LSCF())\n\n# Visualization of the stabilization diagram\nstabilization_plot(stab)\n\n\n\n\n\n\n\n\n\n\n\n6.3.2 Mode shape extraction\n\n# Driving point indices\ndpi = [1, 2]\n\n# Computation of the mode residues\nres = mode_residues(prob_mdof, p_lscf)\n\n# Extraction of the mode shapes\nms_est = modeshape_extraction(res, p_lscf, LSCF(), dpi = dpi, modetype = :emar)[1]\n\n# Convert to real mode shapes\nms_est_real = real_normalization(ms_est)\n\n\n\n\n\n\n\n\n6.3.3 FRF reconstruction\n\n# Problem definition\nprob_mdof = EMAProblem(H, freq)\n\n# Poles extraction using the Least-Squares Complex Frequency-domain method\npoles_lscf = poles_extraction(prob_mdof, 20, LSCF())\n\n# Residues extraction\nres_lscf = mode_residues(prob_mdof, poles_lscf)\n\n# FRF reconstruction - without residuals\nH_mdof = frf_reconstruction(res_lscf, poles_lscf, freq)\n\n# FRF reconstruction - with residuals\nlr, ur = compute_residuals(prob_mdof, res_lscf, poles_lscf)\nH_mdof2 = frf_reconstruction(res_lscf, poles_lscf, freq, lr = lr, ur = ur)\n\n\n\n\n\n\n\n\n6.3.4 Automatic Mdof EMA\nprob_ema = AutoEMAMdofProblem(prob_mdof, order, dpi, LSCF())\nsol_ema = solve(prob_ema)\nfn_ema, ξn_ema = poles2modal(sol_ema.poles)\nms_ema = sol_ema.ms",
    "crumbs": [
      "Modal extraction",
      "Experimental Modal Analysis"
    ]
  },
  {
    "objectID": "modal_extraction/index.html#footnotes",
    "href": "modal_extraction/index.html#footnotes",
    "title": "Experimental Modal Analysis",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nA. Brandt. “Noise and Vibration Analysis: Signal Analysis and Experimental Procedures”, Wiley, 2011.↩︎\nD. Brown, R. Allemang and R. Zimmerman and M. Mergeay. “Parameter estimation techniques for modal analysis”. SAE Technical Paper 790221, 1979.↩︎\nP. Guillaume, P. Verboven, S. Vanlanduit, H. Van der Auweraer and B. Peeters, “A poly-reference implementation of the least-squares complex frequency-domain estimator”. Proceedings of the 21st International Modal Analysis Conference, IMAC, 2003.↩︎\nM. El-Kafafy, P. Guillaume, B. Peeters, F. Marra, G. Coppotelli. “Advanced Frequency-Domain Modal Analysis for Dealing with Measurement Noise and Parameter Uncertainty”. In: Allemang R., De Clerck J., Niezrecki C., Blough J. (eds) Topics in Modal Analysis I, Volume 5. Conference Proceedings of the Society for Experimental Mechanics Series. 2012.↩︎\nE. Hiremaglur. “Real-Normalization of Experimental Complex Modal Vectors with Modal Vector Contamination”. MS Thesis. University of Cincinnati, 2014.↩︎",
    "crumbs": [
      "Modal extraction",
      "Experimental Modal Analysis"
    ]
  },
  {
    "objectID": "signal_processing/noise.html",
    "href": "signal_processing/noise.html",
    "title": "Noise estimation & denoising",
    "section": "",
    "text": "Noise estimation and denoising are important steps in signal processing, especially in the context of structural vibration analysis. Noise can obscure the underlying signal, making it difficult to extract meaningful information. For instance, in inverse problems, noise can significantly affects the accuracy of the estimated solution when the system is ill-posed. Another example is Kalman filtering for which the noise covariance matrix is a key parameter.\nStructuralVibration.jl provides a set of tools for estimating noise in signals and for denoising them. The implemented methods can be applied to real or complex signals.\nHere, it is assumed that the noise is additive and Gaussian. This means that the noisy signal on a sensor \\(i\\), \\(\\mathbf{y}_i\\), can thus be modeled as the sum of a noise-free signal \\(\\mathbf{x}_i\\) and a noise term \\(\\mathbf{n}_i\\): \\[\n\\mathbf{y}_i = \\mathbf{x}_i + \\mathbf{n}_i,\n\\] where \\(\\mathbf{n}_i\\) is a zero-mean Gaussian noise with covariance matrix \\(\\mathbf{R}_i\\). A common assumption is that the noise covariance matrix is isotropic, implying that: \\[\n\\mathbf{R}_i = \\sigma_i^2 \\mathbf{I}_n,\n\\] where \\(\\sigma_i^2\\) is the noise variance on the channel \\(i\\) and \\(\\mathbf{I}\\) is the identity matrix of size \\(n\\) (the number of samples in the signal).",
    "crumbs": [
      "Signal processing",
      "Noise estimation & denoising"
    ]
  },
  {
    "objectID": "signal_processing/noise.html#noise-estimation",
    "href": "signal_processing/noise.html#noise-estimation",
    "title": "Noise estimation & denoising",
    "section": "1 Noise estimation",
    "text": "1 Noise estimation\nNoise estimation is the process of quantifying the level of noise present in a signal. This can be done using various methods, such as statistical analysis, spectral analysis, or model-based approaches. In StructuralVibration.jl, two main strategies are available for noise estimation:\n\nRegularization-based : These methods involve the resolution of an optimization problem.\nFiltering-based : These methods are based on a careful analysis of the statistics of a noisy signal and do not involve optimization.\n\n\n1.1 Estimation methods\n\n1.1.1 Regularization-based noise estimation\nRegularization-based noise estimation methods involve solving an optimization problem to estimate the noise variance associated to each measurement channel. The optimization problem is typically formulated as a minimization of a cost function that balances the fidelity to the data and a regularization term.\nFrom a general perspective, the denoising problem can be formulated as: \\[\n\\widehat{\\mathbf{x}}_i = \\underset{\\mathbf{x}_i}{\\text{argmin}} \\Vert \\mathbf{y}_i - \\mathbf{x}_i \\Vert_2^2 + \\lambda \\Vert \\mathbf{D} \\mathbf{x}_i \\Vert_2^2,\n\\] where \\(\\mathbf{D}\\) is generally the second order finite difference operator, \\(\\lambda\\) is a regularization parameter.\nThe solution of the previous optimization problem is given by: \\[\n\\widehat{\\mathbf{x}}_i = \\left( \\mathbf{I} + \\lambda \\mathbf{D}^\\mathsf{T} \\mathbf{D} \\right)^{-1} \\mathbf{y}_i,\n\\]\nA classical estimator of the noise variance is the biased sample variance given by: \\[\n\\widehat{\\sigma}_i^2 = \\frac{1}{n} \\Vert \\mathbf{y}_i - \\widehat{\\mathbf{x}}_i \\Vert_2^2.\n\\]\nThe main point here is to find an appropriate regularization parameter \\(\\lambda\\). In the literature, several methods have been proposed to estimate the regularization parameter. In this package, the following methods are implemented:\n\nGeneralized Cross Validation (GCV)1\nL-curve method2\n\n\n\n\n\n\n\nNote\n\n\n\nIn practice, this estimator can be computed without computing the denoised signal \\(\\widehat{\\mathbf{x}}_i\\) explicitly. To do so, the implementation makes use of the discrete cosine transform (DCT).\n\n\n\n\n1.1.2 Filtering-based noise estimation\nHeuristic-based noise estimation methods are based on a careful analysis of the statistics of a noisy signal and often rely on the assumption that the noise is Gaussian. These methods do not involve optimization and are typically faster than regularization-based methods. They can be used to estimate the noise variance directly from the noisy signal. StructuralVibration.jl implements the method proposed John D’Errico in the Matlab function estimatenoise.m3\n\n\n\n1.2 API\nData types\n\nGCVEst\n\n\n\nGCVEst\nGeneralized Cross-Validation (GCV) noise estimation\nThis method has been proposed by Garcia in [1]\nFields\n\nnothing\n\n\nReference\n[1] Garcia, D. (2010). Robust smoothing of gridded data in one and higher dimensions with missing values. Computational Statistics and Data Analysis, 54(5), 1167-1178\n\n\n\n\n\n\n\nLCurveEst\n\n\n\nLCurveEst\nL-curve noise estimation\nThis method is based on the method proposed by Hansen in [1]\nFields\n\nnothing\n\n\nReference\n[1] Hansen, P. C. (1999). The L-curve and its use in the numerical treatment of inverse problems. Computational Inverse Problems in Electrocardiology, 119-142\n\n\n\n\n\n\n\nDerricoEst\n\n\n\nDerricoEst\nD'Errico noise estimation\nThis method has been proposed by John D'Errico in [1]\nFields\n\nnothing\n\n\nReference\n[1] John D'Errico (2023). Estimatenoise, MATLAB Central File Exchange. Retrieved December 7, 2023. (https://www.mathworks.com/matlabcentral/fileexchange/16683-estimatenoise)\n\n\n\n\n\n\nRelated function\n\nvarest\n\n\n\nvarest(x, method::NoiseEstimation; batch_size = 0, summary = mean)\nEstimates the noise variance of a signal x using a given method\nInputs\n\nx: Signal\n\nmethod: Noise estimation method\n\nBayesianEst: Bayesian noise estimation (To be implemented)\n\nGCVEst: Generalized Cross-Validation (GCV) noise estimation\n\nLCurveEst: L-curve noise estimation\n\nDerricoEst: D'Errico noise estimation\n\n\n\nbatch_size::Int: Batch size for batch processing (default = 0)\n\nsummary: Summary function for batch processing (default = mean)\n\n\n\n\n\n\n\n\n\n\n1.3 Example\n\n# Beam definition\nL = 1.\nb = 3e-2\nh = 1e-2\nE = 2.1e11\nρ = 7850.\nξn = 1e-2\nS = b*h\nIz = b*h^3/12.\n\nbeam = Beam(L, S, Iz, E, ρ)\n\n# Measurement mesh\nΔx = 5e-2\nNpoint = 20\nXm = LinRange(Δx, L - Δx, Npoint)\n\n# Modes calculation\nωn, kn = modefreq(beam, 2000.)\nϕm = modeshape(beam, kn, Xm)\nϕe = modeshape(beam, kn, Xm[13])\n\n# Modal model\nKn, Mn, Cn = modal_matrices(ωn, ξn)\n\n# Excitation\ntmax = 0.5\nnt = 10_000\nt = LinRange(0., tmax, nt)\n\nharmo = SineWave(1e4, 0., tmax, 2π*10.)\nF = excitation(harmo, t)\nFn = ϕe'*F'\n\n# Solution calculation\nu0 = (zeros(length(ωn)), zeros(length(ωn)))\nprob = DirectTimeProblem(Kn, Mn, Cn, Fn, u0, t)\nu = ϕm*solve(prob).u\n\n# Signal corruption - Additive Gaussian White Noise\nSNR_ref = 25.\ny = agwn(u, SNR_ref)\n\n# Variance estimation - Average over all channels\nv1 = varest(y, GCVEst())\nSNR_est1 = mean(estimated_SNR(y, v1))\n\nv2 = varest(y, LCurveEst())\nSNR_est2 = mean(estimated_SNR(y, v2))\n\nv3 = varest(y, DerricoEst())\nSNR_est3 = mean(estimated_SNR(y, v3))\n\n\n\n\n\nNoise variance estimation\n\n\nReference\nGCV\nL-curve\nD'Errico\n\n\n25.0 dB\n25.16 dB\n25.1 dB\n25.05 dB",
    "crumbs": [
      "Signal processing",
      "Noise estimation & denoising"
    ]
  },
  {
    "objectID": "signal_processing/noise.html#signal-denoising",
    "href": "signal_processing/noise.html#signal-denoising",
    "title": "Noise estimation & denoising",
    "section": "2 Signal denoising",
    "text": "2 Signal denoising\nSignal denoising is the process of removing noise from a signal to recover the underlying clean signal. This can be done using various methods, such as filtering, wavelet transforms, or model-based approaches. In StructuralVibration.jl, the denoising process is typically performed using the same methods as those used for noise estimation. As for noise estimation, the proposed methods can be applied to real or complex signals.\n\n2.1 Denoising methods\nStructuralVibration.jl proposes two main methods for denoising signals:\n\nRegularization-based denoising: This method involves solving an optimization problem to estimate the noise-free signal. The optimization problem is typically formulated as a minimization of a cost function that balances the fidelity to the data and a regularization term.\nFiltering-based denoising: This method is based on the implementation of a Kalman filter, which is a recursive algorithm that estimates the state of a dynamic system from a series of noisy measurements.\n\n\n2.1.1 Regularization-based denoising\nRegularization-based denoising consists in solving the minimization problem defined in Section 1.1.1. This implies a proper estimation of the regularization parameter \\(\\lambda\\). Similar to the noise estimation process, two methods are available for estimating the regularization parameter, namely GCV and L-curve methods.\n\n\n2.1.2 Filtering-based denoising\nAs stated above, filtering-based denoising is based on the implementation of a Kalman filter. For denoising problems, the Kalman filter is based on the following state-space model: \\[\n\\begin{cases}\n\\mathbf{x}_{k+1} = \\mathbf{x}_k + \\mathbf{w}_k \\\\\n\\mathbf{y}_k = \\mathbf{x}_k + \\mathbf{n}_k\n\\end{cases},\n\\] where \\(\\mathbf{x}_k\\) is the state vector (clean signal) at time \\(k\\), \\(\\mathbf{y}_k\\) is the measurement vector at time \\(k\\), \\(\\mathbf{w}_k\\) is the process noise, and \\(\\mathbf{n}_k\\) is the measurement noise. The process noise is assumed to be zero-mean Gaussian with constant covariance matrix \\(\\mathbf{Q}\\), and the measurement noise is assumed to be zero-mean Gaussian with constant covariance matrix \\(\\mathbf{R}\\).\nPractically, a Kalman filter is implemented in two steps:\n\nPrediction step: The state vector and its covariance matrix are predicted based on the knowledge of the solution at the previous step. \\[\n\\begin{align*}\n\\widetilde{\\mathbf{x}}_{k} &= \\widehat{\\mathbf{x}}_{k-1} \\\\\n\\widetilde{\\mathbf{P}}_{k} &= \\widehat{\\mathbf{P}}_{k-1} + \\mathbf{Q}\n\\end{align*},\n\\] where \\(\\widetilde{\\mathbf{x}}_{k}\\) is the predicted state vector, \\(\\widehat{\\mathbf{x}}_{k-1}\\) is the estimated state vector at step \\(k-1\\), \\(\\widetilde{\\mathbf{P}}_{k}\\) is the predicted covariance matrix, and \\(\\widehat{\\mathbf{P}}_{k-1}\\) is the estimated covariance matrix at step \\(k-1\\).\nUpdate step: The state vector and its covariance matrix are updated based on the measurement at the current step. \\[\n\\begin{align*}\n\\mathbf{i}_k &= \\mathbf{y}_k - \\widetilde{\\mathbf{x}}_{k} \\\\\n\\mathbf{S}_k &= \\widetilde{\\mathbf{P}}_{k} + \\mathbf{R} \\\\\n\\mathbf{K}_{k} &= \\widetilde{\\mathbf{P}}_{k} \\mathbf{S}_k^{-1} \\\\\n\\widehat{\\mathbf{x}}_{k} &= \\widetilde{\\mathbf{x}}_{k} + \\mathbf{K}_{k} \\mathbf{i}_k \\\\\n\\widehat{\\mathbf{P}}_{k} &= \\left( \\mathbf{I} - \\mathbf{K}_{k}\\right) \\widetilde{\\mathbf{P}}_{k}\n\\end{align*},\n\\] where \\(\\widehat{\\mathbf{x}}_{k}\\) is the updated state vector, \\(\\widehat{\\mathbf{P}}_{k}\\) is the updated covariance matrix and \\(\\mathbf{K}_{k}\\) is the Kalman gain, \\(\\mathbf{i}_k\\) is the innovation vector and \\(\\mathbf{S}_k\\) is the innovation covariance matrix.\n\nFor a successful denoising process, the Kalman filter requires a proper tuning of the noise covariance matrices \\(\\mathbf{Q}\\) and \\(\\mathbf{R}\\) as wel as a proper initialization of the state vector and its covariance matrix.\nHere, the measurement noise covariance matrix \\(\\mathbf{R}\\) is estimated using the methods described in the previous section. The process noise covariance matrix \\(\\mathbf{Q}\\) is assumed to be isotropic and its variance \\(\\sigma_x^2\\) results from the resolution of the following optimization problem: \\[\n\\widehat{\\sigma}_x^2 = \\underset{\\sigma_x^2}{\\text{argmin}} \\sum_{i = 1}^N \\left[\\log|\\mathbf{S}_k| + \\mathbf{i}_k^\\mathsf{T}\\mathbf{S}_k^{-1}\\mathbf{i}_k\\right],\n\\] where \\(N\\) is the length of the measurement sequence.\nIn addition to the filtering step, a smoothing step can be added. In the present case, a Rauch-Tung-Striebel (RTS) smoother is used. From a practical point of view, the RTS smoother is implemented as a post-processing step that uses the Kalman filter output to improve the estimate of the state vector. The RTS smoother is based on the following equations: \\[\n\\begin{align*}\n\\widehat{\\mathbf{x}}_k^s &= \\widehat{\\mathbf{x}}_k + \\mathbf{K}_k \\left( \\widehat{\\mathbf{x}}_{k+1}^s - \\widehat{\\mathbf{x}}_k \\right) \\\\\n\\widehat{\\mathbf{P}}_k^s &= \\widehat{\\mathbf{P}}_k + \\mathbf{K}_k \\left( \\widehat{\\mathbf{P}}_{k+1}^s - \\widehat{\\mathbf{P}}_k \\right) \\mathbf{K}_k^\\mathsf{T} \\\\\n\\mathbf{K}_k &= \\widehat{\\mathbf{P}}_k (\\widehat{\\mathbf{P}}_k + \\mathbf{Q})^{-1} \\\\\n\\end{align*},\n\\] where \\(\\widehat{\\mathbf{x}}_k^s\\) is the smoothed state vector, \\(\\widehat{\\mathbf{P}}_k^s\\) is the smoothed covariance matrix, and \\(\\mathbf{K}_k\\) is the Kalman gain.\n\n\n\n2.2 API\nData types\n\nGCVDenoising\n\n\n\nGCVDenoising()\nRegularization-based denoising method using the GCV method for estimating the regularization parameter\nFields\n\nnothing\n\n\nReference\n[1] Garcia, D. (2010). Robust smoothing of gridded data in one and higher dimensions with missing values. Computational Statistics and Data Analysis, 54(5), 1167-1178\n\n\n\n\n\n\n\nLCurveDenoising\n\n\n\nLCurveDenoising()\nRegularization-based denoising method using the L-curve method for estimating the regularization parameter\nFields\n\nnothing\n\n\nReference\n[1] Hansen, P. C. (1999). The L-curve and its use in the numerical treatment of inverse problems. Computational Inverse Problems in Electrocardiology, 119-142\n\n\n\n\n\n\n\nKalmanDenoising\n\n\n\nKalmanDenoising(; rts = false)\nKalman filter denoising method\nFields\n\nrts: Flag to enable the Rauch-Tung-Striebel smoother\n\n\n\n\n\n\n\n\nRelated function\n\ndenoising\n\n\n\ndenoising(y::AbstractArray, alg)\nDenoises a signal y\nInputs\n\ny: Noisy signal\n\nalg: Denoising method\n\nBayesDenoising: Bayesian Regularization denoising method (to be implemented)\n\nGCVDenoising: GCV denoising method\n\nLCurveDenoising: L-curve denoising method\n\nKalmanDenoising: Kalman filter denoising method\n\n\n\n\nOutput\n\nx: Denoised signal\n\n\n\n\n\n\n\n\n\n\n2.3 Example\n\n# Beam definition\nL = 1.\nb = 3e-2\nh = 1e-2\nE = 2.1e11\nρ = 7850.\nξn = 1e-2\nS = b*h\nIz = b*h^3/12.\n\nbeam = Beam(L, S, Iz, E, ρ)\n\n# Measurement mesh\nΔx = 5e-2\nNpoint = 20\nXm = LinRange(Δx, L - Δx, Npoint)\n\n# Modes calculation\nωn, kn = modefreq(beam, 2000.)\nϕm = modeshape(beam, kn, Xm)\nϕe = modeshape(beam, kn, Xm[13])\n\n# Modal model\nKn, Mn, Cn = modal_matrices(ωn, ξn)\n\n# Problem definition & solution\ntmax = 0.1\nnt = 5_000\nt = LinRange(0., tmax, nt)\n\nharmo = SineWave(1e4, 0., tmax, 2π*10.)\nF = excitation(harmo, t)\nFn = ϕe'*F'\n\nu0 = (zeros(length(ωn)), zeros(length(ωn)))\nprob = DirectTimeProblem(Kn, Mn, Cn, Fn, u0, t)\nsol = solve(prob)\n\nu = ϕm*sol.u\n\n# Gaussian White Noise\nsnr_dB = 10.\ny = agwn(u, snr_dB)\n\n# Regularization denoising\nyc_gcv = denoising(y, GCVDenoising())\nyc_lcurve = denoising(y, LCurveDenoising())\n\n# Kalman denoising\nyc_kalman = denoising(y, KalmanDenoising())\nyc_rts = denoising(y, KalmanDenoising(rts = true))",
    "crumbs": [
      "Signal processing",
      "Noise estimation & denoising"
    ]
  },
  {
    "objectID": "signal_processing/noise.html#footnotes",
    "href": "signal_processing/noise.html#footnotes",
    "title": "Noise estimation & denoising",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nD. Garcia. “Robust smoothing of gridded data in one and higher dimensions with missing values”. Computational Statistics & Data Analysis, 54(5), pp. 1167-1178, 2010.↩︎\nP. C. Hansen. “The L-curve and its use in the numerical treatment of inverse problems”. Computational Inverse Problems in Electrocardiology, pp. 119-142, 2001.↩︎\nJohn D’Errico. “Estimatenoise”, MATLAB Central File Exchange. Retrieved December 7, 2023. Link↩︎",
    "crumbs": [
      "Signal processing",
      "Noise estimation & denoising"
    ]
  },
  {
    "objectID": "signal_processing/index.html",
    "href": "signal_processing/index.html",
    "title": "Digital Signal Processing",
    "section": "",
    "text": "StructuralVibration.jl provides a set of functions complementing the DSP.jl to simulate the signal processing pipelines used in structural dynamics applications, such as modal analysis, system identification, and vibration data processing. They can for instance be used to simulate or to process experimental data, which can then be used to validate new algorithms (direct or inverse methods) and to benchmark with existing ones.",
    "crumbs": [
      "Signal processing",
      "Digital Signal Processing"
    ]
  },
  {
    "objectID": "signal_processing/index.html#window-functions",
    "href": "signal_processing/index.html#window-functions",
    "title": "Digital Signal Processing",
    "section": "1 Window functions",
    "text": "1 Window functions\nThe DSP.jl package provides a set of window functions that can be used to reduce spectral leakage in the frequency domain. The StructuralVibration.jl package exports the window functions defined in DSP.jl and provides additional ones for the sake of completeness.\n\n1.1 Windows from DSP.jl\n\n1.1.1 Rectangular window\nThe rectangular window is the simplest window function, which does not modify the signal. It is defined as: \\[\nw[n] = 1,\n\\] for \\(n \\in [0, N-1]\\), where \\(N\\) is the length of the window.\nThe rectangular window is generally not recommended for spectral analysis, as it introduces significant spectral leakage. It is mainly used for testing purposes or when no windowing is required (such as impact testing for sufficiently long acquisition duration).\n\n1.1.1.1 API\n\nrect\n\n\n\nrect\nRectangular window\nExported from DSP.jl\n\n\n\n\n\n\n\n\n1.1.1.2 Example\n\nrectwin = rect(1024)\n\n\n\n\n\n\n\n\n\n1.1.2 Hann(ing) window\nThe Hann window is a raised cosine window that tapers the signal at both ends. It is defined as: \\[\nw[n] = \\frac{1}{2} \\left[1 - \\cos\\left(\\frac{2\\pi n}{N-1}\\right)\\right],\n\\] where \\(N\\) is the length of the window and \\(n \\in [0, N-1]\\).\n\n1.1.2.1 API\n\nhann\n\n\n\nhann\nHann(ing) window\nExported from DSP.jl\n\n\n\n\n\n\n\n\n1.1.2.2 Example\n\nhannwin = hanning(1024)\n\n\n\n\n\n\n\n\n\n1.1.3 Hamming window\nThe Hamming window is a raised cosine window that tapers the signal at both ends. It is defined as: \\[\nw[n] = 0.54 - 0.46 \\cos\\left(\\frac{2\\pi n}{N-1}\\right),\n\\] where \\(N\\) is the length of the window and \\(n \\in [0, N-1]\\).\n\n1.1.3.1 API\n\nhamming\n\n\n\nhamming\nHamming window\nExported from DSP.jl\n\n\n\n\n\n\n\n\n1.1.3.2 Example\n\nhammwin = hamming(1024)\n\n\n\n\n\n\n\n\n\n1.1.4 Tukey window\nThe Tukey window (also known as the cosine-tapered window) is defined by a tapering parameter \\(\\alpha \\in [0,1]\\), which controls the proportion of the window that is tapered. The window is defined as:\n\\[\n\\begin{align*}\n& w[n] = \\frac{1}{2} \\left[1 - \\cos\\left(\\frac{2\\pi n}{\\alpha(N-1)}\\right)\\right], & 0 \\leq n &lt; \\frac{\\alpha(N-1)}{2} \\\\\n& w[n] = 1,  & \\frac{\\alpha(N-1)}{2} \\leq n \\leq \\frac{(N-1)}{2} \\\\\n& w[N-1 - n] = w[n], & 0 \\leq n \\leq \\frac{\\alpha(N-1)}{2} \\\\\n\\end{align*}\n\\]\nWhen \\(\\alpha = 0\\), the Tukey window becomes a rectangular window, and when \\(\\alpha = 1\\), it becomes equivalent to a Hann window.\n\n1.1.4.1 API\n\ntukey\n\n\n\ntukey\nTukey window\nExported from DSP.jl\n\n\n\n\n\n\n\n\n1.1.4.2 Example\n\ntukeywin = tukey(1024, 0.5)\n\n\n\n\n\n\n\n\n\n1.1.5 Cosine window\nThe cosine window is a raised cosine window that tapers the signal at both ends. It is defined as: \\[\nw[n] = \\cos\\left(\\frac{\\pi n}{N-1} - \\frac{\\pi}{2}\\right),\n\\] where \\(N\\) is the length of the window and \\(n \\in [0, N-1]\\).\n\n1.1.5.1 API\n\ncosine\n\n\n\ncosine\nCosine window\nExported from DSP.jl\n\n\n\n\n\n\n\n\n1.1.5.2 Example\n\ncoswin = cosine(1024)\n\n\n\n\n\n\n\n\n\n1.1.6 Lanczos window\nThe Lanczos window is a raised cosine window that tapers the signal at both ends. It is defined as: \\[\nw[n] = \\text{sinc}\\left(\\frac{2n}{N-1} - 1\\right),\n\\] where \\(N\\) is the length of the window and \\(n \\in [0, N-1]\\).\n\n1.1.6.1 API\n\nlanczos\n\n\n\nlanczos\nLanczos window\nExported from DSP.jl\n\n\n\n\n\n\n\n\n1.1.6.2 Example\n\nlanczoswin = lanczos(1024)\n\n\n\n\n\n\n\n\n\n1.1.7 Triangular window\nThe triangular window is a simple window function that tapers the signal at both ends. It is defined as: \\[\nw[n] = 1 - \\frac{|2n - (N-1)|}{L},\n\\] where \\(L = N/N+1\\) if \\(N\\) is even/odd and \\(n \\in [0, N-1]\\).\n\n1.1.7.1 API\n\ntriang\n\n\n\ntriang\nTriangle window\nExported from DSP.jl\n\n\n\n\n\n\n\ntriangwin = triang(1024)\n\n\n\n\n\n\n\n\n\n1.1.8 Bartlett window\nThe Bartlett window is a triangular window that tapers the signal at both ends. It is defined as: \\[\nw[n] = \\left(1 - \\frac{|n - L|}{L}\\right),\n\\] where \\(L = \\frac{N-1}{2}\\) and \\(n \\in [0, N-1]\\).\n\n1.1.8.1 API\n\nbartlett\n\n\n\nbartlett\nBartlett window\nExported from DSP.jl\n\n\n\n\n\n\n\n\n1.1.8.2 Example\n\nbartlettwin = bartlett(1024)\n\n\n\n\n\n\n\n\n\n1.1.9 Bartlett-Hann window\nThe Bartlett-Hann window is a raised cosine window that tapers the signal at both ends. It is defined as: \\[\nw[n] = 0.62 - 0.48 \\left|\\frac{n}{N-1} - 0.5\\right| + 0.38 \\cos\\left(2\\pi\\left[\\frac{n}{N-1} - 0.5\\right]\\right),\n\\] where \\(n \\in [0, N-1]\\).\n\n1.1.9.1 API\n\nbartlett_hann\n\n\n\nbartlett_hann\nBartlett-Hann window\nExported from DSP.jl\n\n\n\n\n\n\n\n\n1.1.9.2 Example\n\nbarthannwin = bartlett_hann(1024)\n\n\n\n\n\n\n\n\n\n1.1.10 Gaussian window\nThe Gaussian window is a raised cosine window that tapers the signal at both ends. It is defined as: \\[\nw[n] = \\text{exp}\\left(-\\frac{(n - \\mu)^2}{2\\sigma^2}\\right),\n\\] where \\(\\mu = \\frac{N-1}{2}\\) is the center of the window, \\(\\sigma\\) is the standard deviation, and \\(n \\in [0, N-1]\\).\n\n1.1.10.1 API\n\ngaussian\n\n\n\ngaussian\nGaussian window\nExported from DSP.jl\n\n\n\n\n\n\n\n\n1.1.10.2 Example\n\ngaussianwin = gaussian(1024, 0.2)\n\n\n\n\n\n\n\n\n\n1.1.11 Blackman window\nThe Blackman window is a raised cosine window that tapers the signal at both ends. It is defined as: \\[\nw[n] = 0.42 - 0.5 \\cos\\left(\\frac{2\\pi n}{N-1}\\right) + 0.08 \\cos\\left(\\frac{4\\pi n}{N-1}\\right),\n\\] where \\(n \\in [0, N-1]\\).\n\n1.1.11.1 API\n\nblackman\n\n\n\nblackman\nBlackman window\nExported from DSP.jl\n\n\n\n\n\n\n\n\n1.1.11.2 Example\n\nblackmanwin = blackman(1024)\n\n\n\n\n\n\n\n\n\n1.1.12 Kaiser window\nThe Kaiser window is a raised cosine window that tapers the signal at both ends. It is defined as: \\[\nw[n] = I_0\\left(\\pi\\alpha \\sqrt{1 - \\left(\\frac{2n}{N-1} - 1\\right)^2}\\right) / I_0(\\pi\\alpha),\n\\] where \\(I_0\\) is the modified Bessel function of the first kind, \\(\\beta\\) is a parameter that controls the shape of the window, and \\(n \\in [0, N-1]\\).\n\n1.1.12.1 API\n\nkaiser\n\n\n\nkaiser\nKaiser window\nExported from DSP.jl\n\n\n\n\n\n\n\n\n1.1.12.2 Example\n\nkaiserwin = kaiser(1024, 0.5)\n\n\n\n\n\n\n\n\n\n1.1.13 DPSS window\nThe DPSS (Discrete Prolate Spheroidal Sequences) window maximizes the energy concentration in the main lobe. It has no closed form expression and depends on two parameters: the length of the window \\(N\\) and the time-half-bandwidth product \\(Nw\\) which controls the energy concentration in the main lobe.\n\n1.1.13.1 API\n\ndpss\n\n\n\ndpss\nDPSS window\nExported from DSP.jl\n\n\n\n\n\n\n\n\n1.1.13.2 Example\n\ndpsswin = dpss(1024, 4, 1)\n\n\n\n\n\n\n\n\n\n\n1.2 Additional window functions\n\n1.2.1 Exponential window\nAn exponential window is a window function that tapers the signal exponentially. It is defined as: \\[\nw[n] = \\text{exp}\\left(-\\frac{\\tau n}{N-1}\\right),\n\\] where \\(n \\in [0, N-1]\\), \\(\\tau = -\\log(p)\\) is the time constant, and \\(p\\) is the percentage of the original value by the end of the acquisition block.\n\n1.2.1.1 API\n\nexponential\n\n\n\nexponential(N, exponential_end = 0.01)\nCreate an exponential window. exponential_end = 1 is a uniform window.\nInputs\n\nN: Number of points\n\nexponential_end: End value of the exponential window (0 &lt; exponential_end &lt;= 1)\n\n\nOutput\n\nw: Exponential window\n\n\n\n\n\n\n\n\n\n\n1.2.1.2 Example\n\nexponentialwin = exponential(1024, 0.1)\n\n\n\n\n\n\n\n\n\n1.2.2 Force window\nThe force window is a window function particularly useful in impact testing, where the input signal is a short impulse. The force window is the product of two distinct windows. The first one, denoted \\(w_1[n]\\), is a rectangular window whose end is tapered by a cosine function, namely: \\[\nw_1[n] = \\begin{cases}\n1, & 0 \\leq n &lt; L \\\\\n\\cos\\left(\\frac{\\pi}{2}\\left(\\frac{n - L}{M - L}\\right)\\right), & L \\leq n &lt; M \\\\\n0, & M \\leq n &lt; N\n\\end{cases},\n\\] where \\(n \\in [0, N-1]\\), \\(L = pN\\) is the width of the window, \\(M = N\\text{min}(1, L/N + 0.04)\\) is the index of the end of the cosine tapering part of the window, and \\(p\\) is the percentage of the length of the data acquisition block.\nThe second one, denoted \\(w_2[n]\\), is the exponentital window defined above. Hence, the force window is defined as: \\[\nw[n] = w_1[n] \\cdot w_2[n],\n\\] where \\(w_2[n] = \\text{exp}\\left(-\\frac{\\tau n}{N-1}\\right)\\), with \\(\\tau = -\\log(p)\\).\n\n1.2.2.1 API\n\nforce\n\n\n\nforce(N, width = 0.1, exponential_end = 0.01)\nCreate a force window according to Ref.[1].  For modal testing the exponential_end should be the same in the force and in the exponential window.\nInputs\n\nN: Number of points\n\nwidth: Width (fraction) of the force window (between 0 and 1)\n\nexponential_end: End value of the exponential window (0 &lt; exponential_end &lt;= 1)\n\n\nOutput\n\nw: Force window\n\n\nNote\nexponential_end = 1 does not apply any exponential decay.\nReference\n[1] W. A. Fladung and R. W. Rost. Cause and effect of applying the exponential window to an impact force signal. In Proceedings of IMAC XIV. Orlando, United States. 1996.\n\n\n\n\n\n\n\n\n1.2.2.2 Example\n\nforcewin = force(1024, 0.2, 1.)\nforce_expwin = force(1024, 0.2, 0.01)\n\n\n\n\n\n\n\n\n\n1.2.3 Flat-top window\nThe flat-top window is a window function that window is a partially negative-valued window that has minimal scalloping loss in the frequency domain. It is defined as: \\[\nw[n] = a_0 - a_1\\cos\\left(\\frac{2\\pi n}{N-1}\\right) + a_2\\cos\\left(\\frac{4\\pi n}{N-1}\\right) - a_3\\cos\\left(\\frac{6\\pi n}{N-1}\\right) + a_4\\cos\\left(\\frac{8\\pi n}{N-1}\\right),\n\\] where \\(n \\in [0, N-1]\\) and \\(a_0 = 0.21557895\\), \\(a_1 = 0.41663158\\), \\(a_2 = 0.277263158\\), \\(a_3 = 0.083578947\\), and \\(a_4 = 0.006947368\\).\n\n1.2.3.1 API\n\nflattop\n\n\n\nflattop(N)\nCreate a flat top window\nInput\n\nN: Number of points\n\n\nOutput\n\nw: Flattop window\n\n\n\n\n\n\n\n\n\n\n1.2.3.2 Example\n\nflattopwin = flattop(1024)\n\n\n\n\n\n\n\n\n\n1.2.4 Nuttall window\nThe Nutall window is a window function that returns a Nuttall four-term symmetric Blackman-Harris window. It produces slightly lower sidelobes than Blackman-Harris window. It is defined as: \\[\nw[n] = a_0 - a_1\\cos\\left(\\frac{2\\pi n}{N-1}\\right) + a_2\\cos\\left(\\frac{4\\pi n}{N-1}\\right) - a_3\\cos\\left(\\frac{6\\pi n}{N-1}\\right),\n\\] where \\(n \\in [0, N-1]\\) and \\(a_0 = 0.355768\\), \\(a_1 = 0.487396\\), \\(a_2 = 0.144232\\), and \\(a_3 = 0.012604\\).\n\n1.2.4.1 API\n\nnuttall\n\n\n\nnuttall(N)\nCreate a Nuttall window\nInput\n\nN: Number of points\n\n\nOutput\n\nw: Nuttall window\n\n\n\n\n\n\n\n\n\n\n1.2.4.2 Example\n\nnuttallwin = nuttall(1024)\n\n\n\n\n\n\n\n\n\n1.2.5 Blackman-Nuttall window\nThe Blackman-Nuttall window is a window function that is a modified version of the exact Blackman window. It is defined as: \\[\nw[n] = a_0 - a_1\\cos\\left(\\frac{2\\pi n}{N-1}\\right) + a_2\\cos\\left(\\frac{4\\pi n}{N-1}\\right) - a_3\\cos\\left(\\frac{6\\pi n}{N-1}\\right),\n\\] where \\(n \\in [0, N-1]\\) and \\(a_0 = 0.3635819\\), \\(a_1 = 0.4891775\\), \\(a_2 = 0.1365995\\), and \\(a_3 = 0.0106411\\).\n\n1.2.5.1 API\n\nblackman_nuttall\n\n\n\nblackman_nuttall(N)\nCreate a Blackman-Nuttall window\nInput\n\nN: Number of points\n\n\nOutput\n\nw: Blackman-Nutall window\n\n\n\n\n\n\n\n\n\n\n1.2.5.2 Example\n\nblackman_nuttallwin = blackman_nuttall(1024)\n\n\n\n\n\n\n\n\n\n1.2.6 Blackman-Harris window\nThe Blackman-Harris window is a window function that is another modified version of the exact Blackman window. It is defined as: \\[\nw[n] = a_0 - a_1\\cos\\left(\\frac{2\\pi n}{N-1}\\right) + a_2\\cos\\left(\\frac{4\\pi n}{N-1}\\right) - a_3\\cos\\left(\\frac{6\\pi n}{N-1}\\right),\n\\] where \\(n \\in [0, N-1]\\) and \\(a_0 = 0.35875\\), \\(a_1 = 0.48829\\), \\(a_2 = 0.14128\\), and \\(a_3 = 0.01168\\).\n\n1.2.6.1 API\n\nblackman_harris\n\n\n\nblackman_harris(N)\nCreate a Blackman-Harris window\nInput\n\nN: Number of points\n\n\nOutput\n\nw: Blackman-Harris window\n\n\n\n\n\n\n\n\n\n\n1.2.6.2 Example\n\nblackman_harriswin = blackman_harris(1024)\n\n\n\n\n\n\n\n\n\n1.2.7 Parzen window\nThe parzen window is a window function is defined as: \\[\nw[n] = \\begin{cases}\n1 - 6\\left(\\frac{2|n - M|}{N}\\right)^2\\left(1 - \\frac{2|n - M|}{N}\\right) &  0 \\leq |n - M| \\leq \\frac{M}{2}\\\\\n2\\left(1 - \\frac{2|n - M|}{N}\\right)^3 & \\frac{M}{2} &lt; |n - M| \\leq M\\\\\n\\end{cases}\n\\] where \\(M = \\frac{N - 1}{2}\\) and \\(n \\in [0, N-1]\\).\n\n1.2.7.1 API\n\nparzen\n\n\n\nparzen(N)\nCreate a Parzen window\nInput\n\nN: Number of points\n\n\nOutput\n\nw: Parzen window\n\n\n\n\n\n\n\n\n\n\n1.2.7.2 Example\n\nparzenwin = parzen(1024)\n\n\n\n\n\n\n\n\n\n1.2.8 Planck-taper window\nThe Planck-taper window is a window function that is defined as: \\[\nw[n] = \\begin{cases}\n0, & n = 0 \\\\\n(1 + \\text{exp}\\left(\\frac{\\epsilon N}{n} - \\frac{\\epsilon N}{\\epsilon N - n}\\right)), & 1 \\leq n &lt; \\epsilon N \\\\\n1, & \\epsilon N \\leq n &lt; N/2 \\\\\nw[N - n], & 0 \\leq n &lt; N/2 \\\\\n\\end{cases},\n\\] where \\(n \\in [0, N-1]\\) and \\(\\epsilon\\) is a parameter, defined in [0, 1] that controls the amount of tapering\n\n1.2.8.1 API\n\nplanck\n\n\n\nplanck(N, ϵ = 0.25)\nCreate a Planck-taper window\nInputs\n\nN: Number of points\n\nϵ: Parameter controlling the tapering\n\n\nOutput\n\nw: Planck-taper window\n\n\n\n\n\n\n\n\n\n\n1.2.8.2 Example\n\nplanckwin = planck(1024, 0.1)\n\n\n\n\n\n\n\n\n\n1.2.9 Flat triangular window\nThe flat triangular window is a window function that is defined as: \\[\nw[n] = \\begin{cases}\n1 & 0 \\leq n &lt; L \\\\\n\\frac{N - n}{N - L} & L \\leq n \\leq N \\\\\n\\end{cases},\n\\] where \\(n \\in [0, N-1]\\) and \\(L = pN\\) is the width of the flat part of the window, with \\(p\\) being the percentage of the length of the data acquisition block.\n\n1.2.9.1 API\n\nplanck\n\n\n\nflattri(N, width = 0.5)\nCreate a flat triangular window\nInputs\n\nN: Number of points\n\nwidth: Width (fraction) of the flat part of the window (between 0 and 1)\n\n\nOutput\n\nw: Flat triangle window\n\n\n\n\n\n\n\n\n\n\n1.2.9.2 Example\n\nflattriwin = flattri(1024, 0.25)\n\n\n\n\n\n\n\n\n\n\n1.3 Choice of a window function\nThe choice of a window function depends on the application and the desired properties of the window1 2 3. Here are some general guidelines for the main windows used in structural dynamics applications:\n\nRectangular window: This window is suitable for signals which are periodic in the acquisition window or for non-periodic signals which tend to 0 whithin the time window (such as impact testing).\nHann window: This window is suitable for noisy signals. It is generally used with random signal due to its moderate impact on the frequency resolution and amplitude accuracy of porcessed signals.\nHamming window: This window is used in case of noisy measured signals as the Hann windows. However, contrary to the Hann window, the Hamming window doesn’t reach zero at its both ends.\nTukey window: This window is generally used to analyze transient data due to its shape, since it limits the alteration of the amplitude of transient signals.\nBlackman-Harris window: This window is suitable for periodic measurement signals.\nFlat-top window: This window is suitable for a calibration purposes (good reproduction of the amplitude height) and for measurements with sine excitation. However, it is not suitable for very noisy measurement signals.\nForce window: This window is an effective mechanism for reducing noise on the input channel when the input signal is impulsive.\nExponential window: This window is suitable for transient signals that decay to zero, such as acceleration signal in impact testing.",
    "crumbs": [
      "Signal processing",
      "Digital Signal Processing"
    ]
  },
  {
    "objectID": "signal_processing/index.html#anti-aliasing-filter",
    "href": "signal_processing/index.html#anti-aliasing-filter",
    "title": "Digital Signal Processing",
    "section": "2 Anti-aliasing filter",
    "text": "2 Anti-aliasing filter\nAnti-aliasing filtering is a technique used to prevent aliasing, which occurs when high-frequency components of a signal are misrepresented as lower-frequency components due to insufficient sampling. The anti_alias function in StructuralVibration.jl applies a high-order low-pass filter to the signal whose cut-off frequency is the Nyquist frequency. The proposed filter is designed using the Remez exchange algorithm implemented in DSP.jl.\n\n2.1 API\n\nanti_alias\n\n\n\nanti_alias(signal, fc; fs = 2fc)\nApply an anti-aliasing filter to a signal\nInputs\n\nsignal: Signal to be filtered\n\nfc: Cut-off frequency\n\nfs: Sampling rate\n\n\nOutput\n\nsignal: Filtered signal\n\n\n\n\n\n\n\n\n\n\n2.2 Example\n\n# Time parameters\nΔt = 1e-4\nt = 0.:Δt:10.\nfs = 1/Δt\n\n# Signal\nnt = length(t)\ny = randn(nt)\n\n# filtered signal\nyf = anti_alias(y, 2500., fs = fs)",
    "crumbs": [
      "Signal processing",
      "Digital Signal Processing"
    ]
  },
  {
    "objectID": "signal_processing/index.html#function-estimation",
    "href": "signal_processing/index.html#function-estimation",
    "title": "Digital Signal Processing",
    "section": "3 Function estimation",
    "text": "3 Function estimation\nSeveral functions can be estimated from the time domain data when operating in the frequency domain.\nThe StructuralVibration.jl package provides functions to estimate some of the most common functions used in structural dynamics applications. All the functions listed below are based on the Welch’s method and include the option to use a window function (+ its correction factor) to reduce spectral leakage and signal overlapping to reduce the variance of the estimated function or to compensate for the windowing effect.\n\n3.1 Acquisition parameters\nWhen acquiring data, the user has to define the sample rate \\(f_s\\) and the block size \\(b_s\\). The sample rate is the number of samples per second (in Hz), and the block size is the number of samples in each block. The block size is usually a power of 2, which allows for efficient computation of the FFT. From these two parameters, it is posiible to define the following parameters:\n\nSampling period: The sampling period (in s) is the time between two consecutive samples. It is defined as: \\[\n\\Delta t = \\frac{1}{f_s}.\n\\]\nAcquisition duration: The acquisition duration (in s) is the time taken to acquire a block of data. It is defined as: \\[\nT = b_s \\Delta t = \\frac{b_s}{f_s}.\n\\]\nFrequency resolution: The frequency resolution (in Hz) is the smallest frequency difference that can be resolved in the frequency domain. It is defined as: \\[\n\\Delta f = \\frac{f_s}{b_s}.\n\\]\nMaximum frequency: The maximum frequency (in Hz) is the highest frequency that can be resolved in the frequency domain and satisfying the Nyquist theorem. It is defined as: \\[\nf_{max} = \\frac{f_s}{2.56}.\n\\]\n\nAll these parameters are implemented in the FFTParameters struct, which is used in the functions to estimate the functions listed below.\n\nFFTParameters\n\n\n\nFFTParameters\nStructure to store the time and frequency parameters for the FFT analysis\nConstructor\n\nfs::Real: Sampling rate of the signal\n\nbs::Real: Block size of the signal\n\npow2::Bool: Flag for finding the next power of 2\n\n\nFields\n\nt::AbstractRange: Time vector\n\ndt::Float64: Time step\n\ntspan::Tuple{Float64, Float64}: Time span\n\nfreq::AbstractRange: Frequency vector\n\ndf::Float64: Frequency resolution\n\nfreq_span::Tuple{Float64, Float64}: Frequency span\n\nfs::Int: Sampling rate\n\nbs::Int: Block size\n\n\n\n\n\n\n\n\n\n\n3.2 Response spectrum\nThe response spectrum is basically the Fourier transform of the response of a system to a given input.\n\n3.2.1 API\n\nspectrum\n\n\n\nspectrum(input_signal, bs, window = hanning; fs = 1, overlap = 0.5,\n         nfft = bs)\nEstimation of the spectrum of a signal\nInputs\n\ninput_signal::Vector{Real}: Input signal\n\nbs::Int: Block size\n\nwindow: Window function (default: hanning)\n\nfs::Int: Sampling rate\n\noverlap: Overlap ratio between the segments\n\nnfft::Int: Number of FFT points (default: bs)\n\n\nOutputs\n\ny: Signal spectrum\n\nfreq: Frequency range\n\n\n\n\n\n\n\n\n\n\n3.2.2 Example\n\n# Structural parameters\nm = 1.\nf0 = 25.\nξ = 0.1\n\nsdof = Sdof(m, f0, ξ)\n\n# Acquisition parameters\nsample_rate = 256\nblock_size = 1024\nfft_params = FFTParameters(sample_rate, block_size)\nfreq = fft_params.freq\nt = fft_params.t\n\n# Excitation signal generation\nF0 = 10.\nchirp = SweptSine(F0, t[1], 0.8t[end], freq[1], freq[end], zero_end = true)\nx = excitation(chirp, t)\n\n# Reference signal\nprob = SdofForcedTimeProblem(sdof, [0., 0.], t, x)\ny = solve(prob).u\n\n# Frequency domain\nFx = Fx = rfft(x)[1:length(freq)]/block_size\nFx[2:end] .*= 2.\n\n# Response spectrum\nprob_y = SdofFrequencyProblem(sdof, freq, Fx)\nu = solve(prob_y).u\n\n# Spectrum stimation\nuest = spectrum(y, block_size, rect, fs = sample_rate)[1]\n\n\n\n\n\n\n\n\n\n3.3 Autopower & Cross Spectral Density functions\nAutopower functions are used to estimate the power of a signal in the frequency domain. StructuralVibration.jl allows to compute the following autopower functions:\n\nAutopower Spectrum\nAutopower Linear\nAutopower Power Spectral Density (PSD)\nAutopower Energy Spectral Density (ESD)\n\nCross Spectral Density (CSD) functions are used to estimate the relationship between two signals in the frequency domain. StructuralVibration.jl allows to compute the following CSD functions using various scaling options:\n\nCross Spectral Density (CSD)\nCross Linear\nCross Power Spectral Density (CPSD)\nCross Energy Spectral Density (CESD)\n\n\n\n\n\n\n\nNote\n\n\n\nFor a detailed discussion on the differences between these functions, please refer to this excellent blogpost The Autopower function… Demystified!.\n\n\n\n3.3.1 API\n\nwelch\n\n\n\nwelch(input_signal, bs, window = hanning; fs = 1,\n      overlap = 0.5, nfft = bs, scaling = :psd)\nEstimation of one-sided Autopower functions of a signal using the Welch method\nInputs\n\ninput_signal::AbstractVector: Input signal\n\nbs::Int: Block size\n\nwindow: Window function (default: hanning)\n\nfs::Int: Sampling rate (default: 1)\n\noverlap: Overlap ratio between the segments (default: 0.5)\n\nnfft::Int: Number of FFT points (default: bs)\n\nscaling: Scale of the PSD - see https://community.sw.siemens.com/s/article/the-autopower-function-demystified for more information\n\n:psd (default) - Power Spectral Density\n\n:esd - Autopower Energy Spectral Density\n\n:spectrum - Autopower spectrum\n\n:linear - Autopower linear\n\n\n\n\nOutputs\n\npxx: Autopower\n\nfreq: Frequency range\n\n\nNotes\n\nThe welchfunction is already implemented inDSP.jlunder the namewelch_pgram. The functionwelch` is implemented here for pedagogical purposes.\n\nThe welch function is equivalent to calling csd(x, x, ...).\n\n\n\n\n\n\n\n\n\ncsd\n\n\n\ncsd(x::AbstractMatrix, y::AbstractMatrix, bs, window_x = hanning, window_y = window_x; fs = 1, overlap = 0.5, nfft = bs, scaling = :psd)\n\ncsd(x::AbstractVector, y::AbstractVector, bs, window_x = hanning, window_y = window_x; fs = 1, overlap = 0.5, nfft = bs, scaling = :psd)\nEstimation of the one-sided Cross-spectral density between two signals\nInputs\n\nx::AbstractVector or AbstractMatrix: First signal\n\ny::AbstractVector or AbstractMatrix: Second signal\n\nbs::Int: Block size\n\nwindow_x: Window function for the first signal (default: hanning)\n\nwindow_y: Window function for the second signal (default: same as window_x)\n\nfs::Int: Sampling rate (default: 1)\n\noverlap: Overlap ratio between the segments\n\nnfft::Int: Number of FFT points (default: bs)\n\nscaling: Scale of the CSD\n\n:psd (default) - Power Spectral Density\n\n:esd - Energy Spectral Density\n\n:spectrum - Spectrum\n\n:linear - Linear\n\n\n\n\nOutputs\n\npxy: Cross-spectral density\n\nfreq: Frequency range\n\n\nNotes\n\ncsd(x, x, ...) = welch(x, ...) if x is a vector.\n\n\n\n\n\n\n\n\n\n\n3.3.2 Example\nThis example is based on the one provided in the DSP.jl documentation. It generates a signal composed of two sine waves at 100 Hz and 150 Hz with amplitudes equal to 1 and 2 respectively, and then estimates the power spectral density using the Welch method.\n\n# Acquisition parameters\nfs = 1000\nbs = 100\n\nfft_params = FFTParameters(fs, bs)\nfreq = fft_params.freq\nt = (1:fs)/fs\n\n# Signal generation\nf = [100 150]                      # 100Hz & 150Hz frequencies\nA = [1; 2]                         # Amplitudes\nx = sin.(2π*f.*t)*A + randn(1000)\n\n# PSD estimation from DSP.jl\npsd = DSP.welch_pgram(x, bs; fs = fs, window = hamming)\npxx_ref = DSP.power(psd)\n\n# PSD estimation from StructuralVibration.jl\npxx = welch(x, bs, hamming, fs = fs)[1]\npxx_csd = csd(x, x, bs, hamming, fs = fs)[1]\n\n\n\n\n\n\n\n\n\n3.4 Frequency Response Function\nThe frequency response function (FRF) is the relation between an input \\(x\\) and the resulting output \\(y\\) of a linear and time-invariant system. Independent of the input, it is an intrinsic property of the system describing its dynamic behavior w.r.t. the frequency.\nIn practice, the FRF is computed from estimators. In StructuralVibration.jl, the following estimators are implemented:\n\nH1 estimator: It is the most common estimator used in structural dynamics. It assumes that the noise only affects the output signal. It is defined as: \\[\nH_1(\\omega) = \\frac{S_{yx}(\\omega)}{S_{xx}(\\omega)},\n\\] where \\(S_{yx}(\\omega)\\) is the cross-power spectral density between the input and output signals, and \\(S_{xx}(\\omega)\\) is the power spectral density of the input signal.\n\nGenerally, the H1 estimator estimates the anti-resonances better than the resonances4. Furthermore, as the number of averages increases, the H1 estimator converges to the true FRF.\n\nH2 estimator: It is used when the noise is assumed to affect the input signal only. It is defined as: \\[\nH_2(\\omega) = \\frac{S_{yy}(\\omega)}{S_{yx}(\\omega)},\n\\] where \\(S_{yy}(\\omega)\\) is the power spectral density of the output signal.\n\nContrary to the H1 estimator, the H2 estimator estimates the resonances better than the anti-resonances.\n\nH3 estimator: It is used when the noise is assumed to affect both the input and output signals. It is defined as the arithmetic mean of the H1 and H2 estimators: \\[\nH_3(\\omega) = \\frac{H_1(\\omega) + H_2(\\omega)}{2}.\n\\]\n\nThis estimator offers a good compromise between the H1 and H2 estimators, but it is not as commonly used as the H1 and H2 estimators.\n\nHv estimate: It is used when the noise is assumed to affect both the input and output signals. It is defined as the geometric mean of the H1 and H2 estimators: \\[\nH_v(\\omega) = \\sqrt{H_1(\\omega) H_2(\\omega)}.\n\\]\n\nIt generally provides the best overall estimate of the FRF, because the geometric mean is less sensitive to outliers than the arithmetic mean.\nThese estimators are generally completed by other information such as the coherence function, which an averaged function that how much the output is linearly related to the input. In this sense, it can be an indicator of the quality of the FRF estimate. It can also serve to check the repeatability of individual FRF estimates. It is expressed as: \\[\n\\gamma^2(\\omega) = \\frac{S_{yx}^2(\\omega)}{S_{xx}(\\omega) S_{yy}(\\omega)} = \\frac{H_1(\\omega)}{H_2(\\omega)},\n\\] where \\(S_{yx}(\\omega)\\) is the cross-power spectral density between the input and output signals, and \\(S_{xx}(\\omega)\\) and \\(S_{yy}(\\omega)\\) are the power spectral densities of the input and output signals respectively.\n\n\n\n\n\n\nNote\n\n\n\nIn absence of averaging, the coherence is equal to 1 over all the frequency range!\n\n\n\n3.4.1 API\n\ntfestimate\n\n\n\ntfestimate(input_signal::AbstractMatrix, output_signal::AbstractMatrix, bs::Int, window_input = hanning, window_output = window_input; fs::Int = 1, overlap = 0., type = :h1)\n\ntfestimate(input_signal::AbstractVector, output_signal::AbstractVector, bs::Int, window_input = hanning, window_output = window_input; fs::Int = 1, overlap = 0., type = :h1)\nEstimation of the one-sided transfer function between two signals\nInputs\n\ninput_signal::AbstractVector or AbstractMatrix: Input signal\n\noutput_signal::AbstractVector or AbstractMatrix: Output signal\n\nbs::Int Block size\n\nwindow_input: Window function for the input signal (default: hanning)\n\nwindow_output: Window function for the output signal (default: same as window_input)\n\nfs::Int: Sampling rate (default: 1)\n\noverlap::Real: Overlap ratio between the segments (default: 0.)\n\nnfft::Int: Number of FFT points (default: bs)\n\ntype::Symbol: Type of transfer function to estimate\n\n:h1 (default)\n\n:h2\n\n:h3 - h3 = (h1 + h2)/2\n\n:hv - hv = sqrt(h1*h2)\n\n\n\n\nOutputs\n\nH: Transfer function\n\nfreq: Frequency range\n\ncoh: Coherence\n\n\n\n\n\n\n\n\n\n\n3.4.2 Example\n\n# Structural parameters\nm = 1.\nf0 = 25.\nξ = 0.1\n\nsdof = Sdof(m, f0, ξ)\n\n# Acquisition parameters for one block\nsample_rate = 256\nblock_size = 1024\nfft_params = FFTParameters(sample_rate, block_size)\n\n# Reference FRF\nfreq = fft_params.freq\nprob_frf = SdofFRFProblem(sdof, freq)\nH = solve(prob_frf).u\n\n# Signal generation - Input signal\nnblocks = 5\ntb = fft_params.t\ndt = fft_params.dt\nt = tb[1]:dt:(nblocks*(tb[end] + dt) - dt)\n\nF0 = 10.\nchirp = SweptSine(F0, tb[1], 0.8tb[end], freq[1], freq[end], zero_end = true)\nx = repeat(excitation(chirp, tb), outer = nblocks)\n\n# Signal generation - Output signal\nprob = SdofForcedTimeProblem(sdof, [0., 0.], t, x)\ny = solve(prob).u\n\n# FRF estimation\nwin(x) = tukey(x, 0.25)\nH1 = tfestimate(x, y, block_size, win, fs = sample_rate)[1]",
    "crumbs": [
      "Signal processing",
      "Digital Signal Processing"
    ]
  },
  {
    "objectID": "signal_processing/index.html#footnotes",
    "href": "signal_processing/index.html#footnotes",
    "title": "Digital Signal Processing",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nM+P International, “M+P Analyzer. User Manual Revision 5.1”. 2017.↩︎\nPolytec, “Polytec Scanning Vibrometer, Theory Manual”. 2019.↩︎\nP. Avitabile, “Modal Testing: A practioner’s guide”. John Wiley & Sons. 2018.↩︎\nSimcenter Testing Knowledge. “What is a Frequency Response Function (FRF)?”. 2020. link↩︎",
    "crumbs": [
      "Signal processing",
      "Digital Signal Processing"
    ]
  },
  {
    "objectID": "overview/release_notes.html",
    "href": "overview/release_notes.html",
    "title": "Release Notes",
    "section": "",
    "text": "Breaking changes\n\nRefactor poles_extraction function to add scaling::Function argument for peak picking methods to specify the scaling of the FRF magnitude used for peak detection",
    "crumbs": [
      "Overview",
      "Release Notes"
    ]
  },
  {
    "objectID": "overview/release_notes.html#section",
    "href": "overview/release_notes.html#section",
    "title": "Release Notes",
    "section": "",
    "text": "Breaking changes\n\nRefactor poles_extraction function to add scaling::Function argument for peak picking methods to specify the scaling of the FRF magnitude used for peak detection",
    "crumbs": [
      "Overview",
      "Release Notes"
    ]
  },
  {
    "objectID": "overview/release_notes.html#v1.4.1",
    "href": "overview/release_notes.html#v1.4.1",
    "title": "Release Notes",
    "section": "v1.4.1",
    "text": "v1.4.1\nDocumentation\n\nUpdate documentation for FSDD method in OMA modal extraction.\nUpdate FSDD method to take into account the fact that the number of outputs is different from the number of references.",
    "crumbs": [
      "Overview",
      "Release Notes"
    ]
  },
  {
    "objectID": "overview/release_notes.html#v1.4.0",
    "href": "overview/release_notes.html#v1.4.0",
    "title": "Release Notes",
    "section": "v1.4.0",
    "text": "v1.4.0\nDocumentation\n\nAdd examples of time solvers with DifferentialEquations.jl integration.w\n\nNew features\n\nAdd FSDD method to mode_extraction function for modal parameter extraction using the Frequency-spatial Domain Decomposition (FSDD) method.\n\nBreaking changes\n\nRefactor FreeModalTimeProblem, HarmonicModalTimeProblem and ForcedModalTimeProblem constructors to simplify handling of modal data.\n\nBug fixes\n\nFix bugs in eigenmode function.\nFix bugs in solve function for DirectTimeProblem.",
    "crumbs": [
      "Overview",
      "Release Notes"
    ]
  },
  {
    "objectID": "overview/release_notes.html#v1.3.0",
    "href": "overview/release_notes.html#v1.3.0",
    "title": "Release Notes",
    "section": "v1.3.0",
    "text": "v1.3.0\nNew features\n\nAdd pks_indices argument to AutoEMASdofProblem and poles_extraction function to specify the indices of peaks to consider during pole extraction using Sdof methods.\npeaksplot is renamed to peaks_plot to avoid name conflict with the peaksplot function from Peaks.jl.\nAdd ods to compute Operational Deflection Shapes (ODS) using either the response spectrum or the cross-spectral density matrix.\n\nBreaking changes\n\nRename c2r_modeshape function to real_normalization for clarity.\nSdof EMA methods now take a pks_indices argument to specify the indices of peaks to consider during pole extraction and bypass automatic peak detection.",
    "crumbs": [
      "Overview",
      "Release Notes"
    ]
  },
  {
    "objectID": "overview/release_notes.html#v1.2.0",
    "href": "overview/release_notes.html#v1.2.0",
    "title": "Release Notes",
    "section": "v1.2.0",
    "text": "v1.2.0\nMinor changes\n\nFix bugs in eigenmode function for state-space models.\nFix bugs in comac function.\n\nBreaking changes\n\nChange PLSCF algorithm name to pLSCF in poles_extraction function.\nRemove ismat argument from solve function of DirectFRFProblem, ModalFRFProblem, StateSpaceFRFProblem and StateSpaceModalFRFProblem. The output FRF is now always returned as a 3D array with dimensions (no. outputs, no. inputs, no. frequencies).\nRemove ismat argument from impulse_response function for modal time solvers. The output is now always returned as a 3D array with dimensions (no. dofs, no. dofs, no. frequencies).\nAdd progress argument to stabilization function to control the display of the progress bar during stabilization analysis.\nAdd width, min_prom and max_prom arguments to poles_extraction function and AutoEMASdofProblem to specify the half-width of the peaks and the minimum and maximum peak prominence for pole extraction methods.\nAdd peaksplot to visualization functions to inspect peak detection in pole extraction methods.",
    "crumbs": [
      "Overview",
      "Release Notes"
    ]
  },
  {
    "objectID": "overview/release_notes.html#v1.1.4",
    "href": "overview/release_notes.html#v1.1.4",
    "title": "Release Notes",
    "section": "v1.1.4",
    "text": "v1.1.4\n\nAdd linkxaxes! function in stabilization_plot to link x-axes of poles and indicator plots when zooming.",
    "crumbs": [
      "Overview",
      "Release Notes"
    ]
  },
  {
    "objectID": "overview/release_notes.html#v1.1.3",
    "href": "overview/release_notes.html#v1.1.3",
    "title": "Release Notes",
    "section": "v1.1.3",
    "text": "v1.1.3\n\nSolve some type instability issues in Modal extraction functions.",
    "crumbs": [
      "Overview",
      "Release Notes"
    ]
  },
  {
    "objectID": "overview/release_notes.html#v1.1.2",
    "href": "overview/release_notes.html#v1.1.2",
    "title": "Release Notes",
    "section": "v1.1.2",
    "text": "v1.1.2\n\nAdd ToeplitzMatrices packages to compute the Hankel matrix in LSCE.",
    "crumbs": [
      "Overview",
      "Release Notes"
    ]
  },
  {
    "objectID": "overview/release_notes.html#v1.1.1",
    "href": "overview/release_notes.html#v1.1.1",
    "title": "Release Notes",
    "section": "v1.1.1",
    "text": "v1.1.1\n\nMinor bug fix in msf function.",
    "crumbs": [
      "Overview",
      "Release Notes"
    ]
  },
  {
    "objectID": "overview/release_notes.html#v1.1.0",
    "href": "overview/release_notes.html#v1.1.0",
    "title": "Release Notes",
    "section": "v1.1.0",
    "text": "v1.1.0\nBreaking changes\n\nWindow functions\n\nAdd flattri function to generate a flat-triangular window\n\nModal extraction\n\nStructure simplification. EMASdofProblem and EMAMdofProblem structures are now EMAProblem\nStructure simplification. EMASdofSolution and EMAMdofSolution structures are now EMASolution\nAdd xcorr function to compute the cross-correlation matrix of a signal or between two signals\nAdd psd_from_tf function to compute the full Power Spectral Density (PSD) matrix of multiple signals from transfer function estimates and input PSDs\nAdd half_psd function to compute the half Power Spectral Density (PSD) matrix from the full PSD matrix or from time-domain signals\nRename EMAMdofStabilization structure to StabilizationAnalysis for clarity and generality\ndpi argument of modeshape_extraction function is now passed as keyword arguments instead of positional arguments (for both Sdof and Mdof methods)\ntype argument argument of modeshape_extraction function (Mdof methods) has been renamed to modetype for clarity\nAdd OMAProblem structure to perform Operational Modal Analysis (OMA)\nAdd modes_extraction function for OMAProblem to extract modal parameters using Covariance-based SSI (CovSSI) and Data-based SSI (DataSSI) methods\nAdd halfspec_reconstruction function to reconstruct half-spectrum from extracted modal parameters from residues and poles for OMA and EMA-based methods\nAdd compute_residuals function for OMAProblem to compute the lower and upper residuals of the half-spectrum\nAdd display_poles argument to stabilization_plot function to choose which poles to display in the stabilization diagram plot",
    "crumbs": [
      "Overview",
      "Release Notes"
    ]
  },
  {
    "objectID": "overview/release_notes.html#v1.0.0",
    "href": "overview/release_notes.html#v1.0.0",
    "title": "Release Notes",
    "section": "v1.0.0",
    "text": "v1.0.0\nBreaking changes\n\nSdof solvers\n\nRefactor SdofHarmonicTimeProblem, SdofForcedTimeProblem and SdofFrequencyProblem to comply with DifferentialEquations.jl conventions\n\n\nNew features\n\nSignal processing\n\nAdd csd function to compute the Cross Spectral Density (CSD) between two signals or between multiple input and output signals\nAdd support for matrix inputs in tfestimate function to compute the Frequency Response Function (FRF) between multiple input and output signals\nRefactor tfestimate, welch, csd and spectrum functions to accept window functions instead of pre-computed window vectors\nAdd nfft parameter to tfestimate, welch, csd and spectrum functions to specify the number of FFT points to be used\n\nModal extraction\n\nAdd LSFit() method for modal parameter extraction using least squares fitting of the frequency response function around the resonance peak\nAdd AutoEMASdofProblem and AutoEMAMdofProblem structures and solve functions to perform automatic modal extraction based on Sdof or Mdof approximations\nSolutions of AutoEMA problems are stored in EMASdofSolution or EMAMdofSolution structures containing the poles and the modal parameters\nAdd poles_extraction function to extract system poles using different Mdof methods:\n\nLeast-Squares Complex Exponential (LSCE) method\nLeast-Squares Complex Frequency-domain (LSCF) method\nPolyreference Least-Squares Complex Frequency-domain (pLSCF) method\n\nAdd modeshape_extraction function to extract mode shapes from residues and poles using Mdof methods\nAdd stabilization function to perform stabilization diagram analysis using Mdof methods\nAdd stabilization_plot function to visualize stabilization diagrams\nStabilization results are now stored in the EMAMdofStabilization structure for plotting and further analysis\nAdd frf_reconstruction function to reconstruct FRFs from extracted modal parameters\nAdd compute_residuals function to compute the lower and upper residuals of the FRF\nAdd mode2residues function to compute residues from real modes information\nAdd modal extraction indicators:\n\nModal Overlap Factor (MOF)\nMode Overcomplexity Value (MOV)\nMode Phase Collinearity (MPC)\nMode Complexity Factor (MCF)\nMode Phase Deviation (MPD)\nModal Scale Factor (MSF)\nModal Assurance Criterion (MAC)\nCoordinate Modal Assurance Criterion (COMAC)\nEnhanced Coordinate Modal Assurance Criterion (ECOMAC)\nFrequency Response Assurance Criterion (FRAC)\nComplex Mode Indicator Function (CMIF)\nPower Spectrum Indicator Function (PSIF)\n\nUtils\n\nAdd modal2poles and poles2modal functions to convert between modal parameters and system poles",
    "crumbs": [
      "Overview",
      "Release Notes"
    ]
  },
  {
    "objectID": "overview/release_notes.html#v0.3.0",
    "href": "overview/release_notes.html#v0.3.0",
    "title": "Release Notes",
    "section": "v0.3.0",
    "text": "v0.3.0\nBreaking change\n\nModify the implementation of the force window following PR #5. Thanks to @JakeZw for proposing this PR.",
    "crumbs": [
      "Overview",
      "Release Notes"
    ]
  },
  {
    "objectID": "overview/release_notes.html#v0.2.0",
    "href": "overview/release_notes.html#v0.2.0",
    "title": "Release Notes",
    "section": "v0.2.0",
    "text": "v0.2.0\nBreaking change\n\nRefactor of the visualization extension following issue #3. Theming has been removed from the plotting functions (function theme_choice is now exported).",
    "crumbs": [
      "Overview",
      "Release Notes"
    ]
  },
  {
    "objectID": "overview/release_notes.html#v0.1.2",
    "href": "overview/release_notes.html#v0.1.2",
    "title": "Release Notes",
    "section": "v0.1.2",
    "text": "v0.1.2\n\nBug fix in OneDMesh (solved issue #2)",
    "crumbs": [
      "Overview",
      "Release Notes"
    ]
  },
  {
    "objectID": "overview/release_notes.html#v0.1.1",
    "href": "overview/release_notes.html#v0.1.1",
    "title": "Release Notes",
    "section": "v0.1.1",
    "text": "v0.1.1\n\nBug fixes in State space solvers",
    "crumbs": [
      "Overview",
      "Release Notes"
    ]
  },
  {
    "objectID": "overview/release_notes.html#v0.1.0",
    "href": "overview/release_notes.html#v0.1.0",
    "title": "Release Notes",
    "section": "v0.1.0",
    "text": "v0.1.0\n\nInitial release of the package",
    "crumbs": [
      "Overview",
      "Release Notes"
    ]
  },
  {
    "objectID": "models/noise.html",
    "href": "models/noise.html",
    "title": "Noise models",
    "section": "",
    "text": "In real-world applications, the noise is always present in the measured data. The noise can be due to various reasons such as the sensor noise, the environmental noise, the quantization noise, etc. The noise can be modeled as a random process. The package implements various type of noise in order to cover a wide range of practical situations.",
    "crumbs": [
      "Models",
      "Noise models"
    ]
  },
  {
    "objectID": "models/noise.html#additive-gaussian-white-noise",
    "href": "models/noise.html#additive-gaussian-white-noise",
    "title": "Noise models",
    "section": "1 Additive Gaussian White noise",
    "text": "1 Additive Gaussian White noise\nWhen a signal, real or complex, \\(x\\) is corrupted by an additive Gaussian white noise \\(n\\), the measured signal \\(y\\) can be written as: \\[\n    y = x + n\n\\] where \\(n \\sim \\mathcal{N}(n| 0, \\sigma^2)\\)\n\nagwn\n\n\n\nagwn(x, snr_dB; rst = true)\nAdds a Gaussian White Noise (AGWN) to a signal x with a given SNR.\nInputs\n\nx: Signal (Real or Complex)\n\nsnr_dB: signal to noise ratio [dB]\n\nrst: Reset the random number generator - Bool\n\n\nOutput\n\ny: Noisy signal\n\n\n\n\n\n\n\n\n\n# Noiseless signal\nΔt = 1e-4\nt = 0:Δt:1\nx = sin.(2π*5*t)\n\n# Signal to noise ratio\nsnr_dB = 25.\n\n# Noisy signal\ny = agwn(x, snr_dB)",
    "crumbs": [
      "Models",
      "Noise models"
    ]
  },
  {
    "objectID": "models/noise.html#additive-colored-noise",
    "href": "models/noise.html#additive-colored-noise",
    "title": "Noise models",
    "section": "2 Additive Colored noise",
    "text": "2 Additive Colored noise\nWhen a signal, real or complex, \\(x\\) is corrupted by an additive colored noise \\(n\\), the measured signal \\(y\\) can be written as: \\[\n    y = x + n,\n\\] where \\(n\\) is a colored noise defined as in Excitation models - Colored noise.\n\nacn - Real signal\n\n\n\nacn(x, snr_dB, fs, color = :pink; frange = Float64[], rst = true)\nAdds a Colored Noise (ACN) to a signal x with a given SNR in the time domain\nInputs\n\nx: Signal\n\nsnr_dB: Signal to noise ratio [dB]\n\nfs: Sampling frequency [Hz]\n\ncolor: Color of the noise\n\n:white\n\n:pink (default)\n\n:blue\n\n:brown\n\n:purple\n\n\n\nfrange: Frequencies used to defined the bandpass filter applied to the colored noise\n\nrst: Reset the random number generator\n\n\nOutput\n\ny: Noisy signal\n\n\n\n\n\n\n\n\n\nacn - Complex signal\n\n\n\nacn(x, snr_dB, freq, color = :pink; rst = true)\nAdds a complex Random Colored Noise (ACN) to a signal x with a given SNR in the frequency domain\nInputs\n\nx::VecOrMat{Real}: Signal\n\nsnr_dB: Signal to noise ratio [dB]\n\nfreq::AbstractVector: Frequency range of interest\n\ncolor: Color of the noise\n\n:white\n\n:pink (default)\n\n:blue\n\n:brown\n\n:purple\n\n\n\nrst::Bool: Reset the random number generator\n\n\nOutput\n\ny: Noisy signal\n\n\n\n\nacn(x, snr_dB, fs, color = :pink; frange = Float64[], rst = true)\nAdds a Colored Noise (ACN) to a signal x with a given SNR in the time domain\nInputs\n\nx: Signal\n\nsnr_dB: Signal to noise ratio [dB]\n\nfs: Sampling frequency [Hz]\n\ncolor: Color of the noise\n\n:white\n\n:pink (default)\n\n:blue\n\n:brown\n\n:purple\n\n\n\nfrange: Frequencies used to defined the bandpass filter applied to the colored noise\n\nrst: Reset the random number generator\n\n\nOutput\n\ny: Noisy signal\n\n\n\n\n\n\n\n\n\n# Noiseless signal\nΔt = 1e-4\nfs = 1/Δt\nt = 0:Δt:1\nx = sin.(2π*5*t)\n\n# Signal to noise ratio\nsnr_dB = 25.\n\n# Noisy signal\ny = acn(x, snr_dB, fs, :blue)",
    "crumbs": [
      "Models",
      "Noise models"
    ]
  },
  {
    "objectID": "models/noise.html#multiplicative-gaussian-white-noise",
    "href": "models/noise.html#multiplicative-gaussian-white-noise",
    "title": "Noise models",
    "section": "3 Multiplicative Gaussian White noise",
    "text": "3 Multiplicative Gaussian White noise\nWhen a signal, real or complex, \\(x\\) is corrupted by a multiplicative Gaussian white noise \\(n\\), the measured signal \\(y\\) can be written as: \\[\n    y = (1 + n)x\n\\]\n\nmgwn\n\n\n\nmgwn(x, snr_dB; rst = true)\nAdds a multiplicative Gaussian White Noise (MGWN) to a signal x with a given SNR\nInputs\n\nx: Signal\n\nsnr_dB: Signal to noise ratio [dB]\n\nrst: Reset the random number generator\n\n\nOutput\n\ny: Noisy signal\n\n\n\n\n\n\n\n\n\n# Noiseless signal\nΔt = 1e-4\nt = 0:Δt:1\nx = sin.(2π*5*t)\n\n# Signal to noise ratio\nsnr_dB = 25.\n\n# Noisy signal\ny = mgwn(x, snr_dB)",
    "crumbs": [
      "Models",
      "Noise models"
    ]
  },
  {
    "objectID": "models/noise.html#mixed-noise",
    "href": "models/noise.html#mixed-noise",
    "title": "Noise models",
    "section": "4 Mixed noise",
    "text": "4 Mixed noise\nWhen a signal, real or complex, \\(x\\) is corrupted by a mixed noise \\(n\\), the measured signal \\(y\\) can be written as: \\[\n    y = (1 + n_m)x + n_a\n\\] where \\(n_m\\) is a multiplicative Gaussian white noise and \\(n_a\\) is an additive Gaussian white noise.\n\nmixed_noise\n\n\n\nmixed_noise(x, snr_dB; rst = true)\nAdds both additive and multiplicative Gaussian White Noise to a signal x with a given SNR\nInputs\n\nx: Signal\n\nsnr_dB: Signal to noise ratio [dB]\n\nrst: Reset the random number generator\n\n\nOutput\n\ny: Noisy signal\n\n\n\n\n\n\n\n\n\n# Noiseless signal\nΔt = 1e-4\nt = 0:Δt:1\nx = sin.(2π*5*t)\n\n# Signal to noise ratio\nsnr_dB = 25.\n\n# Noisy signal\ny = mixed_noise(x, snr_dB)",
    "crumbs": [
      "Models",
      "Noise models"
    ]
  },
  {
    "objectID": "models/excitation.html",
    "href": "models/excitation.html",
    "title": "Excitation models",
    "section": "",
    "text": "To define an excitation, two steps must be followed:\n\nInitialize an excitation type:\nexc_type = MyExcitation(params...)\nCompute the excitation signal corresponding to the given excitation type over a given duration t (See Section 2 for details):\nF = excitation(exc_type, t)\n\n\n\nThe rectangular signal is defined by the following equation: \\[\nF(t) = \\begin{cases}\nF_0 & \\text{if } t \\in [t_\\text{start}, t_\\text{start} + T] \\\\\n0 & \\text{otherwise}\n\\end{cases},\n\\] where \\(F_0\\) is the amplitude of the signal, \\(t_\\text{start}\\) is the start time of the signal, and \\(T\\) is the duration of the signal.\n\nRectangle\n\n\n\nRectangle(F, tstart, duration)\nStruct to define a rectangular excitation signal\nFields\n\nF::Real: Amplitude of the force [N]\n\ntstart::Real: Starting time of the excitation [s]\n\nduration::Real: Duration of the excitation [s]\n\n\n\n\n\n\n\n\n\n# Time parameters\nΔt = 1e-3\nt = 0.:Δt:10.\n\n# Excitation parameters\nF0 = 1.\ntstart = 2.5\nduration = 5.\n\n# Initialize Rectangle type\nrect = Rectangle(F0, tstart, duration)\n\n# Compute the excitation\nF_rect = excitation(rect, t)\n\n\n\n\n\n\n\n\n\nThe triangle signal is defined by the following equation: \\[\nF(t) = \\begin{cases}\n\\frac{2F_0}{T}\\left(t - t_\\text{start}\\right) & \\text{if } t \\in [t_\\text{start}, t_m] \\\\\nF_0 - \\frac{2F_0}{T}(t - t_m) & \\text{if } t \\in [t_m, t_\\text{start} + T] \\\\\n0 & \\text{otherwise}\n\\end{cases},\n\\] where \\(F_0\\) is the amplitude of the signal, \\(t_\\text{start}\\) is the start time of the signal, \\(T\\) is the duration of the signal and \\(t_m = t_\\text{start} + T/2\\) is the time at which the signal reaches its maximum value.\n\nTriangle\n\n\n\nTriangle(F, tstart, duration)\nStruct to define a triangular excitation signal\nFields\n\nF::Real: Amplitude of the force [N]\n\ntstart::Real: Starting time of the excitation [s]\n\nduration::Real: Duration of the excitation [s]\n\n\n\n\n\n\n\n\n\n# Time parameters\nΔt = 1e-3\nt = 0.:Δt:10.\n\n# Excitation parameters\nF0 = 1.\ntstart = 2.5\nduration = 5.\n\n# Initialize Triangle type\ntri = Triangle(F0, tstart, duration)\n\n# Compute the excitation\nF_tri = excitation(tri, t)\n\n\n\n\n\n\n\n\n\nThe hammer impact signal is supposed to have the shape of a Gamma distribution \\[\nF(t) = \\begin{cases}\nF_0\\left(\\frac{t_h}{p\\theta}\\right)^p \\text{exp}\\left(-\\frac{t_h}{\\theta} + p\\right), & \\text{if } t \\geq t_\\text{start} \\\\\n0, & \\text{otherwise}\n\\end{cases},\n\\] where \\(F_0\\) is the amplitude of the signal, \\(t_h = t - t_\\text{start}\\) is the time since the impact, \\(p\\) is the shape parameter, and \\(\\theta\\) is the scale parameter.\n\nHammer\n\n\n\nHammer(F, tstart, k, θ)\nStruct to define a hammer impact excitation signal\nFields\n\nF::Real: Amplitude of the force [N]\n\ntstart::Real: Starting time of the excitation [s]\n\np::Real: Shape parameter\n\nθ::Real: Intensity parameter [s]\n\n\n\n\n\n\n\n\n\n# Time parameters\nΔt = 1e-5\nt = 0.:Δt:0.05\n\n# Excitation parameters\nF0 = 1.\ntstart = 0.01\nk = 9.7\nθ = 6e-4\n\n# Initialize Hammer type\nhammer = Hammer(F0, tstart, k, θ)\n\n# Compute the excitation\nF_hammer = excitation(hammer, t)\n\n\n\n\n\n\n\n\n\nThe smooth rectangular signal (custom Tukey window) is defined by the following equation: \\[\nF(t) = \\begin{cases}\n\\frac{F_0}{2}\\left[1 - \\cos\\left(\\frac{2\\pi (t - t_\\text{start})}{\\alpha T}\\right)\\right] & \\text{if } t \\in [t_\\text{start}, t_\\text{start} + t_\\text{rise}] \\\\\nF_0 & \\text{if } t \\in [t_\\text{start} + t_\\text{rise}, t_\\text{start} + t_\\text{rise} + T_\\text{rect}] \\\\\n\\frac{F_0}{2}\\left[1 - \\cos\\left(\\frac{2\\pi (t - t_\\text{start} - t_\\text{rise} - T_\\text{rect})}{\\alpha T}\\right)\\right] & \\text{if } t \\in [t_\\text{start} + t_\\text{rise} + T_\\text{rect}, t_\\text{start} + T] \\\\\n\\end{cases},\n\\] where \\(F_0\\) is the amplitude of the signal, \\(t_\\text{start}\\) is the start time of the signal, \\(T\\) is the duration of the signal, \\(t_\\text{rise}\\) is the duration to reach \\(F_0\\) and \\(\\alpha = \\frac{2t_\\text{rise}}{T}\\) and \\(T_\\text{rect} = T - 2t_\\text{rise}\\) is the duration of the rectangular part of the signal.\n\nSmoothRect\n\n\n\nSmoothRect(F, tstart, tr, duration)\nStruct to define a smooth rectangular excitation signal\nFields\n\nF::Real: Amplitude of the force [N]\n\ntstart::Real: Starting time of the excitation [s]\n\nduration::Real: Duration of the excitation [s]\n\ntrise::Real: Rise time from 0 to F [s]\n\n\nNote: SmoothRect is actually a custom Tukey window for which the coefficient α is computed to satisfy the trise given by the user\n\n\n\n\n\n\n\n# Time parameters\nΔt = 1e-3\nt = 0.:Δt:10.\n\n# Excitation parameters\nF0 = 1.\ntstart = 2.5\nduration = 5.\ntrise = 1.\n\n# Initialize SmoothRect type\nsrect = SmoothRect(F0, tstart, duration, trise)\n\n# Compute the excitation\nF_srect = excitation(srect, t)\n\n\n\n\n\n\n\n\n\nThe sine signal is defined by the following equation: \\[\nF(t) = \\begin{cases}\nF_0 \\sin\\left(\\omega (t - t_\\text{start}) + \\theta\\right), & \\text{if } t \\in [t_\\text{start}, t_\\text{start} + T] \\\\\n0, & \\text{otherwise}\n\\end{cases},\n\\] where \\(F_0\\) is the amplitude of the signal, \\(\\omega\\) is the angular frequency of the signal, and \\(\\theta\\) is the phase of the signal.\n\n\n\n\n\n\nNoteZero-end signal\n\n\n\n\n\nSometimes it is necessary to have a signal that ends at zero. In this case, the duration of the signal must be adjusted to ensure that the signal ends at zero. To do so, one have to find the smallest integer \\(n\\) such that at \\(t = t_\\text{start} + T\\): \\[\n\\sin(\\omega T + \\theta) = 0 \\Rightarrow \\omega T + \\theta = 2\\pi n \\Rightarrow n = \\frac{\\omega T + \\theta}{2\\pi}.\n\\]\nOnce \\(n\\) is found, the duration of the signal must be adjusted to: \\[\nT_\\text{new} = \\frac{2\\pi n - \\theta}{\\omega}.\n\\]\n\n\n\n\nSineWave\n\n\n\nSineWave(F, tstart, duration, freq; zero_end = true)\nStruct to define a sine wave excitation signal\nConstructor parameters\n\nF::Real: Amplitude of the force [N]\n\ntstart::Real: Starting time of the excitation [s]\n\nduration::Real: Duration of the excitation [s]\n\nfreq::Real: Frequency of the excitation [Hz]\n\nzero_end::Bool: Boolean to set the excitation to 0 at the end of the duration (default = true)\n\n\nFields\n\nF::Real: Amplitude of the force [N]\n\ntstart::Real: Starting time of the excitation [s]\n\nduration::Real: Duration of the excitation [s]\n\nω::Real: Frequency of the excitation [Hz]\n\nzero_end::Bool: Boolean to set the excitation to 0 at the end of the duration (default = true)\n\n\n\n\n\n\n\n\n\n# Time parameters\nΔt = 1e-3\nt = 0.:Δt:10.\n\n# Excitation parameters\nF0 = 1.\ntstart = 2.5\nduration = 5.\nf = 2.\n\n# Initialize HaverSine type\nsine = SineWave(F0, tstart, duration, f, zero_end = true)\n\n# Compute the excitation\nF_sine = excitation(sine, t)\n\n\n\n\n\n\n\n\n\nThe half-sine signal is defined by the following equation: \\[\nF(t) = \\begin{cases}\nF_0 \\sin(\\frac{\\pi (t - t_\\text{start}}{T}) & \\text{if } t \\in [t_\\text{start}, t_\\text{start} + T] \\\\\n0 & \\text{otherwise}\n\\end{cases},\n\\] where \\(F_0\\) is the amplitude of the signal, \\(t_\\text{start}\\) is the start time of the signal, and \\(T\\) is the duration of the signal.\n\nHalfSine\n\n\n\nHalfSine(F, tstart, duration)\nStruct to define a half sine excitation signal\nFields\n\nF::Real: Amplitude of the force [N]\n\ntstart::Real: Starting time of the excitation [s]\n\nduration::Real: Duration of the excitation [s]\n\n\n\n\n\n\n\n\n\n# Time parameters\nΔt = 1e-3\nt = 0.:Δt:10.\n\n# Excitation parameters\nF0 = 1.\ntstart = 2.5\nduration = 5.\n\n# Initialize HalfSine type\nhsine = HalfSine(F0, tstart, duration)\n\n# Compute the excitation\nF_hsine = excitation(hsine, t)\n\n\n\n\n\n\n\n\n\nThe haversine (or versed sine) signal is defined by the following equation: \\[\nF(t) = \\begin{cases}\nF_0\\left(1 - cos(\\frac{2\\pi t}{T}\\right) & \\text{if } t \\in [t_\\text{start}, t_\\text{start} + T] \\\\\n0 & \\text{otherwise}\n\\end{cases},\n\\] where \\(F_0\\) is the amplitude of the signal, \\(t_\\text{start}\\) is the start time of the signal, and \\(T\\) is the duration of the signal.\n\nHaverSine\n\n\n\nHaverSine(F, tstart, duration)\nStruct to define a Haversine (or versed sine) excitation signal\nFields\n\nF::Real: Amplitude of the force [N]\n\ntstart::Real: Starting time of the excitation [s]\n\nduration::Real: Duration of the excitation [s]\n\n\n\n\n\n\n\n\n\n# Time parameters\nΔt = 1e-3\nt = 0.:Δt:10.\n\n# Excitation parameters\nF0 = 1.\ntstart = 2.5\nduration = 5.\n\n# Initialize HaverSine type\nhaversine = HaverSine(F0, tstart, duration)\n\n# Compute the excitation\nF_haversine = excitation(haversine, t)\n\n\n\n\n\n\n\n\n\nThe swept sine signal is defined by the following equation: \\[\nF(t) = \\begin{cases}\nF_0 \\sin(\\theta(t)) & \\text{if } t \\in [t_\\text{start}, t_\\text{start} + T] \\\\\n0 & \\text{otherwise}\n\\end{cases},\n\\] where \\(F_0\\) is the amplitude of the signal, \\(t_\\text{start}\\) is the start time of the signal, \\(T\\) is the duration of the signal and \\(\\theta(t)\\) is the instantaneous phase.\nThe instantaneous phase is given by: \\[\n\\theta(t) = \\theta_0 + 2\\pi\\int_0^t f(\\tau) d\\tau,\n\\] where \\(f(\\tau)\\) is the instantaneous frequency of the signal at time \\(\\tau\\) and \\(\\theta_0\\) is the initial phase (set to 0 here).\nIn this package, three possible types of swept sine signals are available:\n\nLinear swept sine: \\[\nf(t) = f_\\text{start} + \\beta(t - t_\\text{start}) \\Rightarrow \\theta(t) = 2\\pi\\left(f_\\text{start}(t - t_\\text{start}) + \\frac{\\beta (t - t_\\text{start})^2}{2}\\right),\n\\] where:\n\n\\(\\beta = \\frac{f_\\text{end} - f_\\text{start}}{T}\\)\n\\(f_\\text{start}\\): Initial frequency of the signal at \\(t_\\text{start}\\)\n\\(f_\\text{end}\\): Final frequency of the signal at \\(t_\\text{start} + T\\)\n\nQuadratic swept sine: \\[\nf(t) = f_\\text{start} + \\beta (t - t_\\text{start})^2 \\Rightarrow \\theta(t) = 2\\pi\\left(f_\\text{start}(t - t_\\text{start}) + \\frac{\\beta (t - t_\\text{start})^3}{3}\\right),\n\\] where \\(\\beta = \\frac{f_\\text{end} - f_\\text{start}}{T^2}\\).\nLogarithmic swept sine: \\[\nf(t) = f_\\text{start}\\beta^{t - t_\\text{start}} \\Rightarrow \\theta(t) = \\frac{2\\pi f_\\text{start}}{\\log(\\beta)}\\left(\\beta^{t - t_\\text{start}} - 1\\right),\n\\] where \\(\\beta = \\left(\\frac{f_\\text{end}}{f_\\text{start}}\\right)^{1/T}\\).\n\n\n\n\n\n\n\nNoteZero-end signal\n\n\n\n\n\nSimilarly to the sine signal, the duration of the signal must be adjusted to ensure that the signal ends at zero. To do so, one have to find the smallest integer \\(n\\) such that at \\(t = t_\\text{start} + T\\): \\[\n  \\theta(t) = 2\\pi n.\n\\]\nIn doing so, we have for:\n\nLinear swept sine: \\[\nn = (f_\\text{start} + f_\\text{end})\\frac{T}{2} \\Rightarrow T_\\text{new} = \\frac{2n}{f_\\text{start} + f_\\text{end}}.\n\\]\nQuadratic swept sine: \\[\nn = (2f_\\text{start} + f_\\text{end})\\frac{T}{3} \\Rightarrow T_\\text{new} = \\frac{3n}{2f_\\text{start} + f_\\text{end}}.\n\\]\nLogarithmic swept sine: \\[\nn = \\frac{f_\\text{end} - f_\\text{start}}{\\log(f_\\text{end}/f_\\text{start})}T \\Rightarrow T_\\text{new} = \\frac{n\\log(f_\\text{end}/f_\\text{start})}{f_\\text{end} - f_\\text{start}}.\n\\]\n\n\n\n\n\nSweptSine\n\n\n\nSweptSine(F, tstart, duration, fstart, fend, type)\nStruct to define a swept sine excitation signal\nFields\n\nF::Real: Amplitude of the force [N]\n\ntstart::Real: Starting time of the excitation [s]\n\nduration::Real: Duration of the excitation [s]\n\nfstart::Real: Starting frequency [Hz]\n\nfend::Real: Ending frequency [Hz]\n\ntype::Symbol: Type of sweep\n\n:lin - linear (default)\n\n:quad - quadratic\n\n:log - logarithmic\n\n\n\nzero_end::Bool: Boolean to set the excitation to 0 at the end of the duration (default = true)\n\n\n\n\n\n\n\n\n\n# Time parameters\nΔt = 1e-3\nt = 0.:Δt:10.\n\n# Excitation parameters\nF0 = 1.\ntstart = 2.5\nduration = 5.\nfstart = 1.\nfend = 6.\ntype_swept = :lin\n\n# Initialize SweptSine type\nchirp = SweptSine(F0, tstart, duration, fstart, fend, type_swept, zero_end = true)\n\n# Compute the excitation\nF_chirp = excitation(chirp, t)\n\n\n\n\n\n\n\n\n\nThe Gaussian pulse signal is defined by the following equation: \\[\nF(t) = \\begin{cases}\nF_0 \\exp\\left(-\\frac{t_p^2}{2\\sigma^2}\\right) \\cos(2\\pi f_c t_p), & \\text{if } t \\geq t_\\text{start} \\\\\n0, & \\text{otherwise}\n\\end{cases},\n\\] where \\(F_0\\) is the amplitude of the signal, \\(t_\\text{start}\\) is the start time of the signal, \\(\\sigma\\) is the standard deviation of the signal, and \\(f_c\\) is the carrier frequency. Here \\(t_p = t - t_\\text{start} - T/2\\) so that the Gaussian pulse reaches its maximum value at \\(t = t_\\text{start} + T/2\\).\n\n\n\n\n\n\nNoteVariance calibration\n\n\n\n\n\nThe design of the Gaussian pulse assumes that it tends to zero when \\(t = t_\\text{start} + T\\). This requirement implies that the standard deviation \\(\\sigma\\) must be chosen such that the Gaussian pulse is zero at \\(t = t_\\text{start} + T\\). This condition can only be satisfied within some precision. More precisely, the idea is to find the quantile \\(n\\) such that \\(T = n\\sigma\\). Consequently, if we assume that \\(F(t_\\text{start} + T) = 10^{-p}\\) (with \\(p\\) a given precision), we have: \\[\nn = 2\\sqrt{2(p\\log 10 + \\log F_0)} \\Rightarrow \\sigma = \\frac{T}{n}.\n\\]\n\n\n\n\nGaussianPulse\n\n\n\nGaussianPulse(F, tstart, duration, fc)\nStruct to define a Gaussian pulse excitation signal\nFields\n\nF::Real: Amplitude of the force [N]\n\ntstart::Real: Starting time of the excitation [s]\n\nduration::Real: Duration of the excitation [s]\n\nfc::Real: Center frequency of the pulse [Hz]\n\nprecision::Real: Precision of the pulse (default = 4.)\n\n\nNote\nThe precision parameter calibrates the standard deviation of the pulse, so that the duration = n x σ, within some precision. If n = 1.96 then the confidence interval of the Gaussian distribution is 95%. To do so, we compute n so that at t = duration = n x σ , the amplitude of F x exp(-0.5*(t - duration/2)^2/sigma^2) = 10^(-precision)\n\n\n\n\n\n\n\n# Time parameters\nΔt = 1e-3\nt = 0.:Δt:10.\n\n# Excitation parameters\nF0 = 1.\ntstart = 2.5\nduration = 5.\nfc = 2.\n\n# Initialize GaussianPulse type\ngpulse = GaussianPulse(F0, tstart, duration, fc)\n\n# Compute the excitation\nF_gpulse = excitation(gpulse, t)\n\n\n\n\n\n\n\n\n\nColored noise is a random signal that has a power spectral density that is not (necessarily) flat over a given frequency range. In practice, colored noise is also refered to as “power-law noise” since its power spectral density is proportional to \\(f^{-\\alpha}\\) (\\(f\\): frequency) and its spectrum is proportional to \\(f^{-\\alpha/2}\\).\nIn this package, five types of colored noise are available:\n\nWhite noise: \\(\\alpha = 0\\)\nPink noise: \\(\\alpha = 1\\)\nBlue noise: \\(\\alpha = -1\\)\nBrown noise: \\(\\alpha = 2\\)\nPurple noise: \\(\\alpha = -2\\)\n\nThe general procedure to generate a colored noise signal is as follows:\n\nGenerate a white noise signal and compute its FFT\nMultiply the FFT by \\(f^{-\\alpha/2}\\) to obtain the colored noise\nCompute the inverse FFT to obtain the colored noise signal\n\nAdditional steps can be added such as:\n\nNormalization: Ensure that the colored noise has the desired variance and preserves the energy of the white noise\nFiltering: Obtain a band-limited colored noise\n\n\nColoredNoise\n\n\n\nColoredNoise(F, color)\nStruct to define a colored noise excitation signal\nFields\n\nF::Real: Mean amplitude of the force [N]\n\ntstart::Real: Starting time of the excitation [s]\n\nduration::Real: Duration of the excitation [s]\n\nσ::Real: Target standard deviation of the colored noise\n\ncolor::Symbol: Color of the noise\n\n:white (default)\n\n:pink\n\n:blue\n\n:brown\n\n:purple\n\n\n\nfrange::AbstractVector: Frequencies used to defined the bandpass filter applied to the colored noise\n\n\n\n\n\n\n\n\n\n# Time parameters\nΔt = 1e-4\nt = 0.:Δt:10.\nnt = length(t)\nfs = 1/Δt\n\n# Excitation parameters\nF0 = 1.\ntstart = 0.\nduration = 10.\nσ = 1.\n\n# Initialize ColoredNoise type\nexc_white = ColoredNoise(F0, tstart, duration, σ, color = :white)\nexc_pink = ColoredNoise(F0, tstart, duration, σ, color = :pink)\nexc_blue = ColoredNoise(F0, tstart, duration, σ, color = :blue)\nexc_brown = ColoredNoise(F0, tstart, duration, σ, color = :brown)\nexc_purple = ColoredNoise(F0, tstart, duration, σ, color = :purple)\n\n# Compute the spectrum of the colored noise\nfreq = rfftfreq(nt, fs)\nS_white = rfft(excitation(exc_white, t))\nS_pink = rfft(excitation(exc_pink, t))\nS_blue = rfft(excitation(exc_blue, t))\nS_brown = rfft(excitation(exc_brown, t))\nS_purple = rfft(excitation(exc_purple, t))",
    "crumbs": [
      "Models",
      "Excitation models"
    ]
  },
  {
    "objectID": "models/excitation.html#available-models",
    "href": "models/excitation.html#available-models",
    "title": "Excitation models",
    "section": "",
    "text": "To define an excitation, two steps must be followed:\n\nInitialize an excitation type:\nexc_type = MyExcitation(params...)\nCompute the excitation signal corresponding to the given excitation type over a given duration t (See Section 2 for details):\nF = excitation(exc_type, t)\n\n\n\nThe rectangular signal is defined by the following equation: \\[\nF(t) = \\begin{cases}\nF_0 & \\text{if } t \\in [t_\\text{start}, t_\\text{start} + T] \\\\\n0 & \\text{otherwise}\n\\end{cases},\n\\] where \\(F_0\\) is the amplitude of the signal, \\(t_\\text{start}\\) is the start time of the signal, and \\(T\\) is the duration of the signal.\n\nRectangle\n\n\n\nRectangle(F, tstart, duration)\nStruct to define a rectangular excitation signal\nFields\n\nF::Real: Amplitude of the force [N]\n\ntstart::Real: Starting time of the excitation [s]\n\nduration::Real: Duration of the excitation [s]\n\n\n\n\n\n\n\n\n\n# Time parameters\nΔt = 1e-3\nt = 0.:Δt:10.\n\n# Excitation parameters\nF0 = 1.\ntstart = 2.5\nduration = 5.\n\n# Initialize Rectangle type\nrect = Rectangle(F0, tstart, duration)\n\n# Compute the excitation\nF_rect = excitation(rect, t)\n\n\n\n\n\n\n\n\n\nThe triangle signal is defined by the following equation: \\[\nF(t) = \\begin{cases}\n\\frac{2F_0}{T}\\left(t - t_\\text{start}\\right) & \\text{if } t \\in [t_\\text{start}, t_m] \\\\\nF_0 - \\frac{2F_0}{T}(t - t_m) & \\text{if } t \\in [t_m, t_\\text{start} + T] \\\\\n0 & \\text{otherwise}\n\\end{cases},\n\\] where \\(F_0\\) is the amplitude of the signal, \\(t_\\text{start}\\) is the start time of the signal, \\(T\\) is the duration of the signal and \\(t_m = t_\\text{start} + T/2\\) is the time at which the signal reaches its maximum value.\n\nTriangle\n\n\n\nTriangle(F, tstart, duration)\nStruct to define a triangular excitation signal\nFields\n\nF::Real: Amplitude of the force [N]\n\ntstart::Real: Starting time of the excitation [s]\n\nduration::Real: Duration of the excitation [s]\n\n\n\n\n\n\n\n\n\n# Time parameters\nΔt = 1e-3\nt = 0.:Δt:10.\n\n# Excitation parameters\nF0 = 1.\ntstart = 2.5\nduration = 5.\n\n# Initialize Triangle type\ntri = Triangle(F0, tstart, duration)\n\n# Compute the excitation\nF_tri = excitation(tri, t)\n\n\n\n\n\n\n\n\n\nThe hammer impact signal is supposed to have the shape of a Gamma distribution \\[\nF(t) = \\begin{cases}\nF_0\\left(\\frac{t_h}{p\\theta}\\right)^p \\text{exp}\\left(-\\frac{t_h}{\\theta} + p\\right), & \\text{if } t \\geq t_\\text{start} \\\\\n0, & \\text{otherwise}\n\\end{cases},\n\\] where \\(F_0\\) is the amplitude of the signal, \\(t_h = t - t_\\text{start}\\) is the time since the impact, \\(p\\) is the shape parameter, and \\(\\theta\\) is the scale parameter.\n\nHammer\n\n\n\nHammer(F, tstart, k, θ)\nStruct to define a hammer impact excitation signal\nFields\n\nF::Real: Amplitude of the force [N]\n\ntstart::Real: Starting time of the excitation [s]\n\np::Real: Shape parameter\n\nθ::Real: Intensity parameter [s]\n\n\n\n\n\n\n\n\n\n# Time parameters\nΔt = 1e-5\nt = 0.:Δt:0.05\n\n# Excitation parameters\nF0 = 1.\ntstart = 0.01\nk = 9.7\nθ = 6e-4\n\n# Initialize Hammer type\nhammer = Hammer(F0, tstart, k, θ)\n\n# Compute the excitation\nF_hammer = excitation(hammer, t)\n\n\n\n\n\n\n\n\n\nThe smooth rectangular signal (custom Tukey window) is defined by the following equation: \\[\nF(t) = \\begin{cases}\n\\frac{F_0}{2}\\left[1 - \\cos\\left(\\frac{2\\pi (t - t_\\text{start})}{\\alpha T}\\right)\\right] & \\text{if } t \\in [t_\\text{start}, t_\\text{start} + t_\\text{rise}] \\\\\nF_0 & \\text{if } t \\in [t_\\text{start} + t_\\text{rise}, t_\\text{start} + t_\\text{rise} + T_\\text{rect}] \\\\\n\\frac{F_0}{2}\\left[1 - \\cos\\left(\\frac{2\\pi (t - t_\\text{start} - t_\\text{rise} - T_\\text{rect})}{\\alpha T}\\right)\\right] & \\text{if } t \\in [t_\\text{start} + t_\\text{rise} + T_\\text{rect}, t_\\text{start} + T] \\\\\n\\end{cases},\n\\] where \\(F_0\\) is the amplitude of the signal, \\(t_\\text{start}\\) is the start time of the signal, \\(T\\) is the duration of the signal, \\(t_\\text{rise}\\) is the duration to reach \\(F_0\\) and \\(\\alpha = \\frac{2t_\\text{rise}}{T}\\) and \\(T_\\text{rect} = T - 2t_\\text{rise}\\) is the duration of the rectangular part of the signal.\n\nSmoothRect\n\n\n\nSmoothRect(F, tstart, tr, duration)\nStruct to define a smooth rectangular excitation signal\nFields\n\nF::Real: Amplitude of the force [N]\n\ntstart::Real: Starting time of the excitation [s]\n\nduration::Real: Duration of the excitation [s]\n\ntrise::Real: Rise time from 0 to F [s]\n\n\nNote: SmoothRect is actually a custom Tukey window for which the coefficient α is computed to satisfy the trise given by the user\n\n\n\n\n\n\n\n# Time parameters\nΔt = 1e-3\nt = 0.:Δt:10.\n\n# Excitation parameters\nF0 = 1.\ntstart = 2.5\nduration = 5.\ntrise = 1.\n\n# Initialize SmoothRect type\nsrect = SmoothRect(F0, tstart, duration, trise)\n\n# Compute the excitation\nF_srect = excitation(srect, t)\n\n\n\n\n\n\n\n\n\nThe sine signal is defined by the following equation: \\[\nF(t) = \\begin{cases}\nF_0 \\sin\\left(\\omega (t - t_\\text{start}) + \\theta\\right), & \\text{if } t \\in [t_\\text{start}, t_\\text{start} + T] \\\\\n0, & \\text{otherwise}\n\\end{cases},\n\\] where \\(F_0\\) is the amplitude of the signal, \\(\\omega\\) is the angular frequency of the signal, and \\(\\theta\\) is the phase of the signal.\n\n\n\n\n\n\nNoteZero-end signal\n\n\n\n\n\nSometimes it is necessary to have a signal that ends at zero. In this case, the duration of the signal must be adjusted to ensure that the signal ends at zero. To do so, one have to find the smallest integer \\(n\\) such that at \\(t = t_\\text{start} + T\\): \\[\n\\sin(\\omega T + \\theta) = 0 \\Rightarrow \\omega T + \\theta = 2\\pi n \\Rightarrow n = \\frac{\\omega T + \\theta}{2\\pi}.\n\\]\nOnce \\(n\\) is found, the duration of the signal must be adjusted to: \\[\nT_\\text{new} = \\frac{2\\pi n - \\theta}{\\omega}.\n\\]\n\n\n\n\nSineWave\n\n\n\nSineWave(F, tstart, duration, freq; zero_end = true)\nStruct to define a sine wave excitation signal\nConstructor parameters\n\nF::Real: Amplitude of the force [N]\n\ntstart::Real: Starting time of the excitation [s]\n\nduration::Real: Duration of the excitation [s]\n\nfreq::Real: Frequency of the excitation [Hz]\n\nzero_end::Bool: Boolean to set the excitation to 0 at the end of the duration (default = true)\n\n\nFields\n\nF::Real: Amplitude of the force [N]\n\ntstart::Real: Starting time of the excitation [s]\n\nduration::Real: Duration of the excitation [s]\n\nω::Real: Frequency of the excitation [Hz]\n\nzero_end::Bool: Boolean to set the excitation to 0 at the end of the duration (default = true)\n\n\n\n\n\n\n\n\n\n# Time parameters\nΔt = 1e-3\nt = 0.:Δt:10.\n\n# Excitation parameters\nF0 = 1.\ntstart = 2.5\nduration = 5.\nf = 2.\n\n# Initialize HaverSine type\nsine = SineWave(F0, tstart, duration, f, zero_end = true)\n\n# Compute the excitation\nF_sine = excitation(sine, t)\n\n\n\n\n\n\n\n\n\nThe half-sine signal is defined by the following equation: \\[\nF(t) = \\begin{cases}\nF_0 \\sin(\\frac{\\pi (t - t_\\text{start}}{T}) & \\text{if } t \\in [t_\\text{start}, t_\\text{start} + T] \\\\\n0 & \\text{otherwise}\n\\end{cases},\n\\] where \\(F_0\\) is the amplitude of the signal, \\(t_\\text{start}\\) is the start time of the signal, and \\(T\\) is the duration of the signal.\n\nHalfSine\n\n\n\nHalfSine(F, tstart, duration)\nStruct to define a half sine excitation signal\nFields\n\nF::Real: Amplitude of the force [N]\n\ntstart::Real: Starting time of the excitation [s]\n\nduration::Real: Duration of the excitation [s]\n\n\n\n\n\n\n\n\n\n# Time parameters\nΔt = 1e-3\nt = 0.:Δt:10.\n\n# Excitation parameters\nF0 = 1.\ntstart = 2.5\nduration = 5.\n\n# Initialize HalfSine type\nhsine = HalfSine(F0, tstart, duration)\n\n# Compute the excitation\nF_hsine = excitation(hsine, t)\n\n\n\n\n\n\n\n\n\nThe haversine (or versed sine) signal is defined by the following equation: \\[\nF(t) = \\begin{cases}\nF_0\\left(1 - cos(\\frac{2\\pi t}{T}\\right) & \\text{if } t \\in [t_\\text{start}, t_\\text{start} + T] \\\\\n0 & \\text{otherwise}\n\\end{cases},\n\\] where \\(F_0\\) is the amplitude of the signal, \\(t_\\text{start}\\) is the start time of the signal, and \\(T\\) is the duration of the signal.\n\nHaverSine\n\n\n\nHaverSine(F, tstart, duration)\nStruct to define a Haversine (or versed sine) excitation signal\nFields\n\nF::Real: Amplitude of the force [N]\n\ntstart::Real: Starting time of the excitation [s]\n\nduration::Real: Duration of the excitation [s]\n\n\n\n\n\n\n\n\n\n# Time parameters\nΔt = 1e-3\nt = 0.:Δt:10.\n\n# Excitation parameters\nF0 = 1.\ntstart = 2.5\nduration = 5.\n\n# Initialize HaverSine type\nhaversine = HaverSine(F0, tstart, duration)\n\n# Compute the excitation\nF_haversine = excitation(haversine, t)\n\n\n\n\n\n\n\n\n\nThe swept sine signal is defined by the following equation: \\[\nF(t) = \\begin{cases}\nF_0 \\sin(\\theta(t)) & \\text{if } t \\in [t_\\text{start}, t_\\text{start} + T] \\\\\n0 & \\text{otherwise}\n\\end{cases},\n\\] where \\(F_0\\) is the amplitude of the signal, \\(t_\\text{start}\\) is the start time of the signal, \\(T\\) is the duration of the signal and \\(\\theta(t)\\) is the instantaneous phase.\nThe instantaneous phase is given by: \\[\n\\theta(t) = \\theta_0 + 2\\pi\\int_0^t f(\\tau) d\\tau,\n\\] where \\(f(\\tau)\\) is the instantaneous frequency of the signal at time \\(\\tau\\) and \\(\\theta_0\\) is the initial phase (set to 0 here).\nIn this package, three possible types of swept sine signals are available:\n\nLinear swept sine: \\[\nf(t) = f_\\text{start} + \\beta(t - t_\\text{start}) \\Rightarrow \\theta(t) = 2\\pi\\left(f_\\text{start}(t - t_\\text{start}) + \\frac{\\beta (t - t_\\text{start})^2}{2}\\right),\n\\] where:\n\n\\(\\beta = \\frac{f_\\text{end} - f_\\text{start}}{T}\\)\n\\(f_\\text{start}\\): Initial frequency of the signal at \\(t_\\text{start}\\)\n\\(f_\\text{end}\\): Final frequency of the signal at \\(t_\\text{start} + T\\)\n\nQuadratic swept sine: \\[\nf(t) = f_\\text{start} + \\beta (t - t_\\text{start})^2 \\Rightarrow \\theta(t) = 2\\pi\\left(f_\\text{start}(t - t_\\text{start}) + \\frac{\\beta (t - t_\\text{start})^3}{3}\\right),\n\\] where \\(\\beta = \\frac{f_\\text{end} - f_\\text{start}}{T^2}\\).\nLogarithmic swept sine: \\[\nf(t) = f_\\text{start}\\beta^{t - t_\\text{start}} \\Rightarrow \\theta(t) = \\frac{2\\pi f_\\text{start}}{\\log(\\beta)}\\left(\\beta^{t - t_\\text{start}} - 1\\right),\n\\] where \\(\\beta = \\left(\\frac{f_\\text{end}}{f_\\text{start}}\\right)^{1/T}\\).\n\n\n\n\n\n\n\nNoteZero-end signal\n\n\n\n\n\nSimilarly to the sine signal, the duration of the signal must be adjusted to ensure that the signal ends at zero. To do so, one have to find the smallest integer \\(n\\) such that at \\(t = t_\\text{start} + T\\): \\[\n  \\theta(t) = 2\\pi n.\n\\]\nIn doing so, we have for:\n\nLinear swept sine: \\[\nn = (f_\\text{start} + f_\\text{end})\\frac{T}{2} \\Rightarrow T_\\text{new} = \\frac{2n}{f_\\text{start} + f_\\text{end}}.\n\\]\nQuadratic swept sine: \\[\nn = (2f_\\text{start} + f_\\text{end})\\frac{T}{3} \\Rightarrow T_\\text{new} = \\frac{3n}{2f_\\text{start} + f_\\text{end}}.\n\\]\nLogarithmic swept sine: \\[\nn = \\frac{f_\\text{end} - f_\\text{start}}{\\log(f_\\text{end}/f_\\text{start})}T \\Rightarrow T_\\text{new} = \\frac{n\\log(f_\\text{end}/f_\\text{start})}{f_\\text{end} - f_\\text{start}}.\n\\]\n\n\n\n\n\nSweptSine\n\n\n\nSweptSine(F, tstart, duration, fstart, fend, type)\nStruct to define a swept sine excitation signal\nFields\n\nF::Real: Amplitude of the force [N]\n\ntstart::Real: Starting time of the excitation [s]\n\nduration::Real: Duration of the excitation [s]\n\nfstart::Real: Starting frequency [Hz]\n\nfend::Real: Ending frequency [Hz]\n\ntype::Symbol: Type of sweep\n\n:lin - linear (default)\n\n:quad - quadratic\n\n:log - logarithmic\n\n\n\nzero_end::Bool: Boolean to set the excitation to 0 at the end of the duration (default = true)\n\n\n\n\n\n\n\n\n\n# Time parameters\nΔt = 1e-3\nt = 0.:Δt:10.\n\n# Excitation parameters\nF0 = 1.\ntstart = 2.5\nduration = 5.\nfstart = 1.\nfend = 6.\ntype_swept = :lin\n\n# Initialize SweptSine type\nchirp = SweptSine(F0, tstart, duration, fstart, fend, type_swept, zero_end = true)\n\n# Compute the excitation\nF_chirp = excitation(chirp, t)\n\n\n\n\n\n\n\n\n\nThe Gaussian pulse signal is defined by the following equation: \\[\nF(t) = \\begin{cases}\nF_0 \\exp\\left(-\\frac{t_p^2}{2\\sigma^2}\\right) \\cos(2\\pi f_c t_p), & \\text{if } t \\geq t_\\text{start} \\\\\n0, & \\text{otherwise}\n\\end{cases},\n\\] where \\(F_0\\) is the amplitude of the signal, \\(t_\\text{start}\\) is the start time of the signal, \\(\\sigma\\) is the standard deviation of the signal, and \\(f_c\\) is the carrier frequency. Here \\(t_p = t - t_\\text{start} - T/2\\) so that the Gaussian pulse reaches its maximum value at \\(t = t_\\text{start} + T/2\\).\n\n\n\n\n\n\nNoteVariance calibration\n\n\n\n\n\nThe design of the Gaussian pulse assumes that it tends to zero when \\(t = t_\\text{start} + T\\). This requirement implies that the standard deviation \\(\\sigma\\) must be chosen such that the Gaussian pulse is zero at \\(t = t_\\text{start} + T\\). This condition can only be satisfied within some precision. More precisely, the idea is to find the quantile \\(n\\) such that \\(T = n\\sigma\\). Consequently, if we assume that \\(F(t_\\text{start} + T) = 10^{-p}\\) (with \\(p\\) a given precision), we have: \\[\nn = 2\\sqrt{2(p\\log 10 + \\log F_0)} \\Rightarrow \\sigma = \\frac{T}{n}.\n\\]\n\n\n\n\nGaussianPulse\n\n\n\nGaussianPulse(F, tstart, duration, fc)\nStruct to define a Gaussian pulse excitation signal\nFields\n\nF::Real: Amplitude of the force [N]\n\ntstart::Real: Starting time of the excitation [s]\n\nduration::Real: Duration of the excitation [s]\n\nfc::Real: Center frequency of the pulse [Hz]\n\nprecision::Real: Precision of the pulse (default = 4.)\n\n\nNote\nThe precision parameter calibrates the standard deviation of the pulse, so that the duration = n x σ, within some precision. If n = 1.96 then the confidence interval of the Gaussian distribution is 95%. To do so, we compute n so that at t = duration = n x σ , the amplitude of F x exp(-0.5*(t - duration/2)^2/sigma^2) = 10^(-precision)\n\n\n\n\n\n\n\n# Time parameters\nΔt = 1e-3\nt = 0.:Δt:10.\n\n# Excitation parameters\nF0 = 1.\ntstart = 2.5\nduration = 5.\nfc = 2.\n\n# Initialize GaussianPulse type\ngpulse = GaussianPulse(F0, tstart, duration, fc)\n\n# Compute the excitation\nF_gpulse = excitation(gpulse, t)\n\n\n\n\n\n\n\n\n\nColored noise is a random signal that has a power spectral density that is not (necessarily) flat over a given frequency range. In practice, colored noise is also refered to as “power-law noise” since its power spectral density is proportional to \\(f^{-\\alpha}\\) (\\(f\\): frequency) and its spectrum is proportional to \\(f^{-\\alpha/2}\\).\nIn this package, five types of colored noise are available:\n\nWhite noise: \\(\\alpha = 0\\)\nPink noise: \\(\\alpha = 1\\)\nBlue noise: \\(\\alpha = -1\\)\nBrown noise: \\(\\alpha = 2\\)\nPurple noise: \\(\\alpha = -2\\)\n\nThe general procedure to generate a colored noise signal is as follows:\n\nGenerate a white noise signal and compute its FFT\nMultiply the FFT by \\(f^{-\\alpha/2}\\) to obtain the colored noise\nCompute the inverse FFT to obtain the colored noise signal\n\nAdditional steps can be added such as:\n\nNormalization: Ensure that the colored noise has the desired variance and preserves the energy of the white noise\nFiltering: Obtain a band-limited colored noise\n\n\nColoredNoise\n\n\n\nColoredNoise(F, color)\nStruct to define a colored noise excitation signal\nFields\n\nF::Real: Mean amplitude of the force [N]\n\ntstart::Real: Starting time of the excitation [s]\n\nduration::Real: Duration of the excitation [s]\n\nσ::Real: Target standard deviation of the colored noise\n\ncolor::Symbol: Color of the noise\n\n:white (default)\n\n:pink\n\n:blue\n\n:brown\n\n:purple\n\n\n\nfrange::AbstractVector: Frequencies used to defined the bandpass filter applied to the colored noise\n\n\n\n\n\n\n\n\n\n# Time parameters\nΔt = 1e-4\nt = 0.:Δt:10.\nnt = length(t)\nfs = 1/Δt\n\n# Excitation parameters\nF0 = 1.\ntstart = 0.\nduration = 10.\nσ = 1.\n\n# Initialize ColoredNoise type\nexc_white = ColoredNoise(F0, tstart, duration, σ, color = :white)\nexc_pink = ColoredNoise(F0, tstart, duration, σ, color = :pink)\nexc_blue = ColoredNoise(F0, tstart, duration, σ, color = :blue)\nexc_brown = ColoredNoise(F0, tstart, duration, σ, color = :brown)\nexc_purple = ColoredNoise(F0, tstart, duration, σ, color = :purple)\n\n# Compute the spectrum of the colored noise\nfreq = rfftfreq(nt, fs)\nS_white = rfft(excitation(exc_white, t))\nS_pink = rfft(excitation(exc_pink, t))\nS_blue = rfft(excitation(exc_blue, t))\nS_brown = rfft(excitation(exc_brown, t))\nS_purple = rfft(excitation(exc_purple, t))",
    "crumbs": [
      "Models",
      "Excitation models"
    ]
  },
  {
    "objectID": "models/excitation.html#sec-exc-api",
    "href": "models/excitation.html#sec-exc-api",
    "title": "Excitation models",
    "section": "2 excitation function",
    "text": "2 excitation function\n\nexcitation\n\n\n\nexcitation(type, t)\nComputes different types of excitation signals\nInputs\n\ntype : Excitation type\n\nTriangle\n\nRectangle\n\nHammer\n\nSmoothRect\n\nSineWave\n\nHalfSine\n\nHaverSine\n\nSweptSine\n\nGaussianPulse\n\nColoredNoise\n\n\n\nt: Time vector\n\n\nOutput\n\nF: Excitation signal",
    "crumbs": [
      "Models",
      "Excitation models"
    ]
  },
  {
    "objectID": "solvers/index.html",
    "href": "solvers/index.html",
    "title": "Sdof solvers",
    "section": "",
    "text": "The package provides a set of solvers to compute the time response of a single-degree-of-freedom (sdof) system.\n\n\nThe free response of a sdof system is the response of the system when it is subjected to initial conditions only. This means that the displacement of the mass is solution of the following ordinary differential equation: \\[\n\\begin{cases}\n  \\ddot x(t) + 2 \\xi\\omega_0\\dot x(t) + \\omega_0^2 x(t) = 0 \\\\\n  x(0) = x_0 \\\\\n  \\dot x(0) = v_0\n\\end{cases}.\n\\]\nDepending on the value of the damping ratio \\(\\xi\\) and \\(\\omega_0 &gt; 0\\), the system can have 4 different types of free response:\n\nan undamped motion when \\(\\xi = 0\\). In this case, the free response is: \\[\nx(t) = x_0\\cos\\omega_0 t + \\frac{v_0}{\\omega_0}\\sin\\omega_0 t\n\\]\nan underdamped motion when \\(0 &lt; \\xi &lt; 1\\). In this case, the free response is: \\[\nx(t) = \\left[x_0\\cos\\Omega_0 t + \\frac{v_0 + \\xi\\Omega_0 x_0}{\\Omega_0}\\sin\\Omega_0 t\\right]e^{-\\xi\\omega_0 t}\n\\] where \\(\\Omega_0 = \\omega_0\\sqrt{1 - \\xi^2}\\).\na critically damped motion when \\(\\xi = 1\\). In this case, the free response is: \\[\nx(t) = \\left[x_0 + (v_0 + \\omega_0 x_0)t\\right]e^{-\\omega_0 t}\n\\]\nan overdamped motion when \\(\\xi &gt; 1\\). In this case, the free response is: \\[\nx(t) = \\left[x_0\\text{cosh}(\\beta t) + \\frac{v_0 + \\xi\\omega_0 x_0}{\\beta}\\text{sinh}\\beta t\\right]e^{-\\xi\\omega_0 t},\n\\] where \\(\\beta = \\omega_0\\sqrt{\\xi^2 - 1}\\).\n\nFinally, if \\(\\omega = 0\\), the mass is free from constraints and the free response is: \\[\nx(t) = x_0 + v_0 t.\n\\]\n\n\nData type\n\nSdofFreeTimeProblem\n\n\n\nSdofFreeTimeProblem(sdof, u0, t)\nStructure containing the data of a time problem for a sdof system\nFields\n\nsdof::Sdof: Sdof structure\n\nu0::AbstractVector: Initial conditions\n\nx0: Initial displacement [m]\n\nv0: Initial velocity [m/s]\n\n\n\nt::AbstractRange: Time points at which to evaluate the response\n\n\n\n\n\n\n\n\nRelated function\n\nsolve\n\n\n\nsolve(prob::SdofFreeTimeProblem)\nCompute the free response of a single degree of freedom (Sdof) system.\nInput\n\nprob: Structure containing the parameters of the Sdof problem\n\n\nOutput\n\nsol: The response of the system at the given time points\n\nu: Displacement solution\n\ndu: Velocity solution\n\nddu: Acceleration solution\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Structural parameters\nm = 1.\nf0 = 1.\n\n# Time vector\nt = 0.:0.01:10.\n\n# Initial conditions\nu0 = [1., -2.]\n\n# Undamped system\nsdof_nd = Sdof(m, f0, 0.)\nprob_nd = SdofFreeTimeProblem(sdof_nd, u0, t)\nx_nd = solve(prob_nd).u\n\n# Underdamped system\nsdof_ud = Sdof(m, f0, 0.1)\nprob_ud = SdofFreeTimeProblem(sdof_ud, u0, t)\nx_ud = solve(prob_ud).u\n\n# Critically damped system\nsdof_cd = Sdof(m, f0, 1.)\nprob_cd = SdofFreeTimeProblem(sdof_cd, u0, t)\nx_cd = solve(prob_cd).u\n\n# Overdamped system\nsdof_od = Sdof(m, f0, 1.2)\nprob_od = SdofFreeTimeProblem(sdof_od, u0, t)\nx_od = solve(prob_od).u;\n\n\n\n\n\n\n\n\n\n\nThe forced response of a sdof system is the response of the system is the solution of the following ordinary differential equation: \\[\n\\begin{cases}\n  \\ddot x(t) + 2 \\xi\\omega_0\\dot x(t) + \\omega_0^2 x(t) = \\displaystyle\\frac{\\text{rhs}(t)}{m} \\\\\n  x(0) = x_0 \\\\\n  \\dot x(0) = v_0\n\\end{cases},\n\\] where \\(\\text{rhs}(t)\\) is the right-hand side of the equation and its expression depends on the type of excitation: \\[\n\\text{rhs}(t) = \\begin{cases}\nf(t) & \\text{for an external force excitation} \\\\\nm\\omega_0^2 x_b(t) + 2\\xi\\omega_0m\\dot x_b(t) & \\text{for a base excitation}\n\\end{cases}.\n\\]\nFinally, the solution of the forced response is expressed as the sum of two terms, since: \\[\nx(t) = x_h(t) + x_p(t),\n\\] where \\(x_h(t)\\) is the homogeneous solution of the equation and \\(x_p(t)\\) is the particular solution of the equation.\n\n\nWhen the excitation is harmonic, the resolution process is the following:\n\nCompute the particular solution of the equation. The particular solution is a harmonic function of the same frequency as the excitation.\nExpress the general solution of the homogeneous equation.\nCompute the remaining constants using the initial conditions. These constants depends on \\(x_p(0)\\) and \\(\\dot x_p(0)\\).\n\n\n\nData type\n\nSdofHarmonicTimeProblem\n\n\n\nSdofHarmonicTimeProblem(sdof, u0, t, F, ω, type_exc)\nStructure containing the data of a time problem for a sdof system subject to a harmonic excitation\nConstructor parameters\n\nsdof::Sdof: Sdof structure\n\nF: Amplitude of the force excitation [N] or base motion [m]\n\nf: Frequency of the excitation [Hz]\n\nu0::AbstractVector: Initial conditions\n\nx0: Initial displacement [m]\n\nv0: Initial velocity [m/s]\n\n\n\nt::AbstractRange: Time points at which to evaluate the response\n\ntype_exc::Symbol: Type of excitation\n\n:force: External force (default)\n\n:base: Base motion\n\n\n\n\nFields\n\nsdof::Sdof: Sdof structure\n\nF: Amplitude of the force excitation [N] or base motion [m]\n\nω: Frequency of the excitation [rad/s]\n\nu0::AbstractVector: Initial conditions\n\nx0: Initial displacement [m]\n\nv0: Initial velocity [m/s]\n\n\n\nt::AbstractRange: Time points at which to evaluate the response\n\ntype_exc::Symbol: Type of excitation\n\n:force: External force (default)\n\n:base: Base motion\n\n\n\n\n\n\n\n\n\n\nRelated function\n\nsolve\n\n\n\nsolve(prob::SdofHarmonicTimeProblem)\nComputes the forced response of a single degree of freedom (Sdof) system due to an harmonic external force or base motion\nInputs\n\nprob: Structure containing the parameters of the Sdof harmonic problem\n\n\nOutput\n\nsol: The response of the system at the given time points\n\nu: Displacement solution\n\ndu: Velocity solution\n\nddu: Acceleration solution\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Structural parameters\nm = 1.\nf0 = 1.\nξ = 0.1\n\n# Instantiation of the Sdof object\nsdof = Sdof(m, f0, ξ)\n\n# Harmonic excitation - Force amplitude + excitation frequency\nF0 = 10.\nf = 2.\n\n# Instantiation of the problem\nt = 0.:0.01:10.\nu0 = [1., -2.]\nprob = SdofHarmonicTimeProblem(sdof, u0, t, F0, f, :force)\n\n# Solve the problem\nx_harmo = solve(prob).u\n\n\n\n\n\n\n\n\n\n\nFor an arbitrary excitation, the solution is given by: \\[\nx(t) = x_\\text{free}(t) + \\int_0^t rhs(t - τ)h(τ)dτ,\n\\] where \\(x_\\text{free}(t)\\) is the free response of the system and \\(h(t)\\) is the impulse response of the system.\n\n\nData type\n\nSdofForcedTimeProblem\n\n\n\nSdofForcedTimeProblem(sdof, u0, t, F, ω, type_exc)\nStructure containing the data of a time problem for a sdof system subject to an arbitrary excitation\nFields\n\nsdof::Sdof: Sdof structure\n\nF::AbstractVector: Amplitude of the force excitation [N] or base motion [m]\n\nu0::AbstractVector: Initial conditions\n\nx0: Initial displacement [m]\n\nv0: Initial velocity [m/s]\n\n\n\nt::AbstractRange: Time points at which to evaluate the response\n\ntype_exc::Symbol: Type of excitation\n\n:force: External force (default)\n\n:base: Base motion\n\n\n\n\n\n\n\n\n\n\nRelated function\n\nsolve\n\n\n\nsolve(prob::SdofForcedTimeProblem)\nComputes the forced response of a single degree of freedom (Sdof) system due to an arbitrary external force or base motion\nInputs\n\nprob: Structure containing the parameters of the Sdof forced problem\n\nmethod: Method to compute the Duhamel's integral\n\n:filt: Filtering using the Z-transform of the impulse response (default)\n\n:interp: Interpolation + Gaussian quadrature\n\n:conv: Convolution product\n\n\n\n\nOutput\n\nsol: The response of the system at the given time points\n\nu: Displacement solution\n\ndu: Velocity solution\n\nddu: Acceleration solution\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Structural parameters\nm = 1.\nf0 = 1.\nξ = 0.1\n\n# Instantiation of the Sdof object\nsdof = Sdof(m, f0, ξ)\n\n# Haversine excitation signal\nF0 = 10.\ntstart = 0.5\nduration = 2.\nhaversine = HaverSine(F0, tstart, duration)\n\nt = 0.:0.01:10.\nF = excitation(haversine, t)\n\n# Instantiation of the problem\nu0 = [1, -2]\nprob = SdofForcedTimeProblem(sdof, u0, t, F, :force)\n\n# Solve the problem\nx_arb_filt = solve(prob, method = :filt).u\nx_arb_interp = solve(prob, method = :interp).u\nx_arb_conv = solve(prob, method = :conv).u;\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe impulse response of a sdof system is the response of the system when it is subjected to an impulse excitation. The impulse response is the solution of the following ordinary differential equation: \\[\n\\overset{..}{h}(t) + 2\\xi\\omega_0\\overset{.}{h}(t) + \\omega_0^2 h(t) = \\frac{\\delta(t)}{m}.\n\\]\nIt can be shown that the impulse response can be computed by solving the following problem: \\[\n\\begin{cases}\n\\overset{..}{h}(t) + 2\\xi\\omega_0\\overset{.}{h}(t) + \\omega_0^2 h(t) = 0 & \\forall t &gt; 0 \\\\\nh(t) = 0 & \\text{at } t = 0 \\\\\n\\overset{.}{h}(t) = \\displaystyle\\frac{1}{m} & \\text{at } t = 0\n\\end{cases}.\n\\]\n\nimpulse_response\n\n\n\nimpulse_response(sdof, t)\nCompute the impulse response of a single degree of freedom (Sdof) system\nInputs\n\nsdof: Sdof structure\n\nt: Time points at which to evaluate the response\n\n\nOutput\n\nh: Impulse response\n\n\n\n\n\n\n\n\n\n# Structural parameters\nm = 1.\nf0 = 1.\nξ = 0.1\n\nt = 0.:0.01:10.\n\n# Instantiation of the Sdof object\nsdof = Sdof(m, f0, ξ)\n\nh = impulse_response(sdof, t)\n\n\n\n\n\n\n\n\n\nThe shock response spectrum (SRS) is a graph of the peak acceleration response of a sdof system subjected to a base acceleration with respect to the frequency. The SRS is computed by solving the following problem: \\[\n\\ddot z(t) + 2\\xi\\omega_0\\dot z(t) + \\omega_0^2 z(t) = -\\ddot x_b(t),\n\\] where \\(z(t) = x(t) - x_b(t)\\) is the relative displacement of the system with respect to the base.\nTo compute the SRS, the following steps are performed at a given frequency \\(f\\):\n\nInstantiate a Sdof type\nsdof = Sdof(1., f, ξ)\nCompute the time response of the relative displacement \\(z(t)\\) due to a base acceleration for \\(z(0) = 0\\) and \\(\\dot z(0) = 0\\).\nCompute the acceleration \\(\\ddot x(t)\\) of the system: \\[\nx(t) = -2\\xi\\omega_0\\dot z(t) - \\omega_0^2 z(t)\n\\]\nExtract the primary or secondary part of the acceleration (i.e. until or after the end of the excitation signal).\nCompute either:\n\nThe peak acceleration of the system such that: \\[\nSRS(f) = \\max\\left(|\\ddot x(t)|\\right)\n\\]\nThe maximum positive acceleration of the system such that: \\[\nSRS(f) = \\max\\left(\\max(\\ddot x(t), 0)\\right)\n\\]\nThe maximum negative acceleration of the system such that: \\[\nSRS(f) = \\max\\left(\\max(-\\ddot x(t), 0)\\right)\n\\]\n\n\nSeveral algorithms are available to compute the SRS:\n\n:Basic: the SRS is computed by following the steps mentioned above. It is not the most efficient algorithm but it is the most versatile.\n:RecursiveInt: the SRS is computed using a recursive integration algorithm.\n:RecursiveFilt: the SRS is computed using a recursive filtering algorithm.\n:Smallwood: the SRS is computed using the Smallwood algorithm.\n\nFor the last three algorithms, more details and references can be found Mathworks - Introduction to SRS\n\nsrs\n\n\n\nsrs(base_acc::ArbitraryExc, freq, t, ξ = 0.05,\n    type = (instance = :primary, amplitude = :abs), alg = :Smallwood)\nCompute the Shock Response Spectrum (SRS)\nInputs\n\nbase_acc::ArbitraryExc: Base acceleration type - see excitation function for detatils\n\nfreq: Vector of frequencies [Hz]\n\nt: Time points at which to evaluate the response\n\nξ: Damping ratio (default = 0.05)\n\ntype: Type of SRS\n\ninstance: Instance of the SRS\n\n:primary: Primary instance (default)\n\n:secondary: Secondary instance\n\n\n\namplitude: Amplitude used of the computing SRS\n\n:abs: Maximum absolute amplitude (default)\n\n:pos: Maximum positive amplitude\n\n:neg: Maximum negative amplitude\n\n\n\n\n\nalg: Algorithm to compute the SRS\n\n:Basic: Basic algorithm\n\n:RecursiveInt: Recursive integration algorithm\n\n:RecursiveFilt: Recursive filtering algorithm\n\n:Smallwood: Smallwood algorithm (default)\n\n\n\n\nOutput\n\nsrs: Vector of the SRS values\n\n\nNote\n\nPrimary instance - response of the system during the application of the base acceleration\n\nSecondary instance - response of the system after the application of the base acceleration\n\n\n\n\n\n\n\n\n\n# Definition of the base acceleration\nt = 0.:1e-5:0.5\nbase_acc = HalfSine(10., 0., 1e-3)\n\n# Compute the SRS\nf = 50.:25:1e3\nsrs_basic = srs(base_acc, f, t)\nsrs_rec_int = srs(base_acc, f, t, alg = :RecursiveInt)\nsrs_rec_filt = srs(base_acc, f, t, alg = :RecursiveFilt)\nsrs_smallwood = srs(base_acc, f, t, alg = :Smallwood)",
    "crumbs": [
      "Solvers",
      "Sdof solvers"
    ]
  },
  {
    "objectID": "solvers/index.html#time-domain-solvers",
    "href": "solvers/index.html#time-domain-solvers",
    "title": "Sdof solvers",
    "section": "",
    "text": "The package provides a set of solvers to compute the time response of a single-degree-of-freedom (sdof) system.\n\n\nThe free response of a sdof system is the response of the system when it is subjected to initial conditions only. This means that the displacement of the mass is solution of the following ordinary differential equation: \\[\n\\begin{cases}\n  \\ddot x(t) + 2 \\xi\\omega_0\\dot x(t) + \\omega_0^2 x(t) = 0 \\\\\n  x(0) = x_0 \\\\\n  \\dot x(0) = v_0\n\\end{cases}.\n\\]\nDepending on the value of the damping ratio \\(\\xi\\) and \\(\\omega_0 &gt; 0\\), the system can have 4 different types of free response:\n\nan undamped motion when \\(\\xi = 0\\). In this case, the free response is: \\[\nx(t) = x_0\\cos\\omega_0 t + \\frac{v_0}{\\omega_0}\\sin\\omega_0 t\n\\]\nan underdamped motion when \\(0 &lt; \\xi &lt; 1\\). In this case, the free response is: \\[\nx(t) = \\left[x_0\\cos\\Omega_0 t + \\frac{v_0 + \\xi\\Omega_0 x_0}{\\Omega_0}\\sin\\Omega_0 t\\right]e^{-\\xi\\omega_0 t}\n\\] where \\(\\Omega_0 = \\omega_0\\sqrt{1 - \\xi^2}\\).\na critically damped motion when \\(\\xi = 1\\). In this case, the free response is: \\[\nx(t) = \\left[x_0 + (v_0 + \\omega_0 x_0)t\\right]e^{-\\omega_0 t}\n\\]\nan overdamped motion when \\(\\xi &gt; 1\\). In this case, the free response is: \\[\nx(t) = \\left[x_0\\text{cosh}(\\beta t) + \\frac{v_0 + \\xi\\omega_0 x_0}{\\beta}\\text{sinh}\\beta t\\right]e^{-\\xi\\omega_0 t},\n\\] where \\(\\beta = \\omega_0\\sqrt{\\xi^2 - 1}\\).\n\nFinally, if \\(\\omega = 0\\), the mass is free from constraints and the free response is: \\[\nx(t) = x_0 + v_0 t.\n\\]\n\n\nData type\n\nSdofFreeTimeProblem\n\n\n\nSdofFreeTimeProblem(sdof, u0, t)\nStructure containing the data of a time problem for a sdof system\nFields\n\nsdof::Sdof: Sdof structure\n\nu0::AbstractVector: Initial conditions\n\nx0: Initial displacement [m]\n\nv0: Initial velocity [m/s]\n\n\n\nt::AbstractRange: Time points at which to evaluate the response\n\n\n\n\n\n\n\n\nRelated function\n\nsolve\n\n\n\nsolve(prob::SdofFreeTimeProblem)\nCompute the free response of a single degree of freedom (Sdof) system.\nInput\n\nprob: Structure containing the parameters of the Sdof problem\n\n\nOutput\n\nsol: The response of the system at the given time points\n\nu: Displacement solution\n\ndu: Velocity solution\n\nddu: Acceleration solution\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Structural parameters\nm = 1.\nf0 = 1.\n\n# Time vector\nt = 0.:0.01:10.\n\n# Initial conditions\nu0 = [1., -2.]\n\n# Undamped system\nsdof_nd = Sdof(m, f0, 0.)\nprob_nd = SdofFreeTimeProblem(sdof_nd, u0, t)\nx_nd = solve(prob_nd).u\n\n# Underdamped system\nsdof_ud = Sdof(m, f0, 0.1)\nprob_ud = SdofFreeTimeProblem(sdof_ud, u0, t)\nx_ud = solve(prob_ud).u\n\n# Critically damped system\nsdof_cd = Sdof(m, f0, 1.)\nprob_cd = SdofFreeTimeProblem(sdof_cd, u0, t)\nx_cd = solve(prob_cd).u\n\n# Overdamped system\nsdof_od = Sdof(m, f0, 1.2)\nprob_od = SdofFreeTimeProblem(sdof_od, u0, t)\nx_od = solve(prob_od).u;\n\n\n\n\n\n\n\n\n\n\nThe forced response of a sdof system is the response of the system is the solution of the following ordinary differential equation: \\[\n\\begin{cases}\n  \\ddot x(t) + 2 \\xi\\omega_0\\dot x(t) + \\omega_0^2 x(t) = \\displaystyle\\frac{\\text{rhs}(t)}{m} \\\\\n  x(0) = x_0 \\\\\n  \\dot x(0) = v_0\n\\end{cases},\n\\] where \\(\\text{rhs}(t)\\) is the right-hand side of the equation and its expression depends on the type of excitation: \\[\n\\text{rhs}(t) = \\begin{cases}\nf(t) & \\text{for an external force excitation} \\\\\nm\\omega_0^2 x_b(t) + 2\\xi\\omega_0m\\dot x_b(t) & \\text{for a base excitation}\n\\end{cases}.\n\\]\nFinally, the solution of the forced response is expressed as the sum of two terms, since: \\[\nx(t) = x_h(t) + x_p(t),\n\\] where \\(x_h(t)\\) is the homogeneous solution of the equation and \\(x_p(t)\\) is the particular solution of the equation.\n\n\nWhen the excitation is harmonic, the resolution process is the following:\n\nCompute the particular solution of the equation. The particular solution is a harmonic function of the same frequency as the excitation.\nExpress the general solution of the homogeneous equation.\nCompute the remaining constants using the initial conditions. These constants depends on \\(x_p(0)\\) and \\(\\dot x_p(0)\\).\n\n\n\nData type\n\nSdofHarmonicTimeProblem\n\n\n\nSdofHarmonicTimeProblem(sdof, u0, t, F, ω, type_exc)\nStructure containing the data of a time problem for a sdof system subject to a harmonic excitation\nConstructor parameters\n\nsdof::Sdof: Sdof structure\n\nF: Amplitude of the force excitation [N] or base motion [m]\n\nf: Frequency of the excitation [Hz]\n\nu0::AbstractVector: Initial conditions\n\nx0: Initial displacement [m]\n\nv0: Initial velocity [m/s]\n\n\n\nt::AbstractRange: Time points at which to evaluate the response\n\ntype_exc::Symbol: Type of excitation\n\n:force: External force (default)\n\n:base: Base motion\n\n\n\n\nFields\n\nsdof::Sdof: Sdof structure\n\nF: Amplitude of the force excitation [N] or base motion [m]\n\nω: Frequency of the excitation [rad/s]\n\nu0::AbstractVector: Initial conditions\n\nx0: Initial displacement [m]\n\nv0: Initial velocity [m/s]\n\n\n\nt::AbstractRange: Time points at which to evaluate the response\n\ntype_exc::Symbol: Type of excitation\n\n:force: External force (default)\n\n:base: Base motion\n\n\n\n\n\n\n\n\n\n\nRelated function\n\nsolve\n\n\n\nsolve(prob::SdofHarmonicTimeProblem)\nComputes the forced response of a single degree of freedom (Sdof) system due to an harmonic external force or base motion\nInputs\n\nprob: Structure containing the parameters of the Sdof harmonic problem\n\n\nOutput\n\nsol: The response of the system at the given time points\n\nu: Displacement solution\n\ndu: Velocity solution\n\nddu: Acceleration solution\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Structural parameters\nm = 1.\nf0 = 1.\nξ = 0.1\n\n# Instantiation of the Sdof object\nsdof = Sdof(m, f0, ξ)\n\n# Harmonic excitation - Force amplitude + excitation frequency\nF0 = 10.\nf = 2.\n\n# Instantiation of the problem\nt = 0.:0.01:10.\nu0 = [1., -2.]\nprob = SdofHarmonicTimeProblem(sdof, u0, t, F0, f, :force)\n\n# Solve the problem\nx_harmo = solve(prob).u\n\n\n\n\n\n\n\n\n\n\nFor an arbitrary excitation, the solution is given by: \\[\nx(t) = x_\\text{free}(t) + \\int_0^t rhs(t - τ)h(τ)dτ,\n\\] where \\(x_\\text{free}(t)\\) is the free response of the system and \\(h(t)\\) is the impulse response of the system.\n\n\nData type\n\nSdofForcedTimeProblem\n\n\n\nSdofForcedTimeProblem(sdof, u0, t, F, ω, type_exc)\nStructure containing the data of a time problem for a sdof system subject to an arbitrary excitation\nFields\n\nsdof::Sdof: Sdof structure\n\nF::AbstractVector: Amplitude of the force excitation [N] or base motion [m]\n\nu0::AbstractVector: Initial conditions\n\nx0: Initial displacement [m]\n\nv0: Initial velocity [m/s]\n\n\n\nt::AbstractRange: Time points at which to evaluate the response\n\ntype_exc::Symbol: Type of excitation\n\n:force: External force (default)\n\n:base: Base motion\n\n\n\n\n\n\n\n\n\n\nRelated function\n\nsolve\n\n\n\nsolve(prob::SdofForcedTimeProblem)\nComputes the forced response of a single degree of freedom (Sdof) system due to an arbitrary external force or base motion\nInputs\n\nprob: Structure containing the parameters of the Sdof forced problem\n\nmethod: Method to compute the Duhamel's integral\n\n:filt: Filtering using the Z-transform of the impulse response (default)\n\n:interp: Interpolation + Gaussian quadrature\n\n:conv: Convolution product\n\n\n\n\nOutput\n\nsol: The response of the system at the given time points\n\nu: Displacement solution\n\ndu: Velocity solution\n\nddu: Acceleration solution\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Structural parameters\nm = 1.\nf0 = 1.\nξ = 0.1\n\n# Instantiation of the Sdof object\nsdof = Sdof(m, f0, ξ)\n\n# Haversine excitation signal\nF0 = 10.\ntstart = 0.5\nduration = 2.\nhaversine = HaverSine(F0, tstart, duration)\n\nt = 0.:0.01:10.\nF = excitation(haversine, t)\n\n# Instantiation of the problem\nu0 = [1, -2]\nprob = SdofForcedTimeProblem(sdof, u0, t, F, :force)\n\n# Solve the problem\nx_arb_filt = solve(prob, method = :filt).u\nx_arb_interp = solve(prob, method = :interp).u\nx_arb_conv = solve(prob, method = :conv).u;\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe impulse response of a sdof system is the response of the system when it is subjected to an impulse excitation. The impulse response is the solution of the following ordinary differential equation: \\[\n\\overset{..}{h}(t) + 2\\xi\\omega_0\\overset{.}{h}(t) + \\omega_0^2 h(t) = \\frac{\\delta(t)}{m}.\n\\]\nIt can be shown that the impulse response can be computed by solving the following problem: \\[\n\\begin{cases}\n\\overset{..}{h}(t) + 2\\xi\\omega_0\\overset{.}{h}(t) + \\omega_0^2 h(t) = 0 & \\forall t &gt; 0 \\\\\nh(t) = 0 & \\text{at } t = 0 \\\\\n\\overset{.}{h}(t) = \\displaystyle\\frac{1}{m} & \\text{at } t = 0\n\\end{cases}.\n\\]\n\nimpulse_response\n\n\n\nimpulse_response(sdof, t)\nCompute the impulse response of a single degree of freedom (Sdof) system\nInputs\n\nsdof: Sdof structure\n\nt: Time points at which to evaluate the response\n\n\nOutput\n\nh: Impulse response\n\n\n\n\n\n\n\n\n\n# Structural parameters\nm = 1.\nf0 = 1.\nξ = 0.1\n\nt = 0.:0.01:10.\n\n# Instantiation of the Sdof object\nsdof = Sdof(m, f0, ξ)\n\nh = impulse_response(sdof, t)\n\n\n\n\n\n\n\n\n\nThe shock response spectrum (SRS) is a graph of the peak acceleration response of a sdof system subjected to a base acceleration with respect to the frequency. The SRS is computed by solving the following problem: \\[\n\\ddot z(t) + 2\\xi\\omega_0\\dot z(t) + \\omega_0^2 z(t) = -\\ddot x_b(t),\n\\] where \\(z(t) = x(t) - x_b(t)\\) is the relative displacement of the system with respect to the base.\nTo compute the SRS, the following steps are performed at a given frequency \\(f\\):\n\nInstantiate a Sdof type\nsdof = Sdof(1., f, ξ)\nCompute the time response of the relative displacement \\(z(t)\\) due to a base acceleration for \\(z(0) = 0\\) and \\(\\dot z(0) = 0\\).\nCompute the acceleration \\(\\ddot x(t)\\) of the system: \\[\nx(t) = -2\\xi\\omega_0\\dot z(t) - \\omega_0^2 z(t)\n\\]\nExtract the primary or secondary part of the acceleration (i.e. until or after the end of the excitation signal).\nCompute either:\n\nThe peak acceleration of the system such that: \\[\nSRS(f) = \\max\\left(|\\ddot x(t)|\\right)\n\\]\nThe maximum positive acceleration of the system such that: \\[\nSRS(f) = \\max\\left(\\max(\\ddot x(t), 0)\\right)\n\\]\nThe maximum negative acceleration of the system such that: \\[\nSRS(f) = \\max\\left(\\max(-\\ddot x(t), 0)\\right)\n\\]\n\n\nSeveral algorithms are available to compute the SRS:\n\n:Basic: the SRS is computed by following the steps mentioned above. It is not the most efficient algorithm but it is the most versatile.\n:RecursiveInt: the SRS is computed using a recursive integration algorithm.\n:RecursiveFilt: the SRS is computed using a recursive filtering algorithm.\n:Smallwood: the SRS is computed using the Smallwood algorithm.\n\nFor the last three algorithms, more details and references can be found Mathworks - Introduction to SRS\n\nsrs\n\n\n\nsrs(base_acc::ArbitraryExc, freq, t, ξ = 0.05,\n    type = (instance = :primary, amplitude = :abs), alg = :Smallwood)\nCompute the Shock Response Spectrum (SRS)\nInputs\n\nbase_acc::ArbitraryExc: Base acceleration type - see excitation function for detatils\n\nfreq: Vector of frequencies [Hz]\n\nt: Time points at which to evaluate the response\n\nξ: Damping ratio (default = 0.05)\n\ntype: Type of SRS\n\ninstance: Instance of the SRS\n\n:primary: Primary instance (default)\n\n:secondary: Secondary instance\n\n\n\namplitude: Amplitude used of the computing SRS\n\n:abs: Maximum absolute amplitude (default)\n\n:pos: Maximum positive amplitude\n\n:neg: Maximum negative amplitude\n\n\n\n\n\nalg: Algorithm to compute the SRS\n\n:Basic: Basic algorithm\n\n:RecursiveInt: Recursive integration algorithm\n\n:RecursiveFilt: Recursive filtering algorithm\n\n:Smallwood: Smallwood algorithm (default)\n\n\n\n\nOutput\n\nsrs: Vector of the SRS values\n\n\nNote\n\nPrimary instance - response of the system during the application of the base acceleration\n\nSecondary instance - response of the system after the application of the base acceleration\n\n\n\n\n\n\n\n\n\n# Definition of the base acceleration\nt = 0.:1e-5:0.5\nbase_acc = HalfSine(10., 0., 1e-3)\n\n# Compute the SRS\nf = 50.:25:1e3\nsrs_basic = srs(base_acc, f, t)\nsrs_rec_int = srs(base_acc, f, t, alg = :RecursiveInt)\nsrs_rec_filt = srs(base_acc, f, t, alg = :RecursiveFilt)\nsrs_smallwood = srs(base_acc, f, t, alg = :Smallwood)",
    "crumbs": [
      "Solvers",
      "Sdof solvers"
    ]
  },
  {
    "objectID": "solvers/index.html#frequency-domain-solvers",
    "href": "solvers/index.html#frequency-domain-solvers",
    "title": "Sdof solvers",
    "section": "2 Frequency domain solvers",
    "text": "2 Frequency domain solvers\nThe package provides solvers for computing the Frequency Response Function (FRF) and the response spectrum of a sdof system.\n\n2.1 Frequency Response Function\nThe Frequency Response Function (FRF) of a sdof system is the ratio of the steady-state response \\(X(\\omega)\\) of the system to an external excitation \\(F(\\omega)\\) or an external base motion \\(X_b(\\omega)\\). The FRF is computed from the following equation: \\[\nH(\\omega) = \\begin{cases}\n\\displaystyle\\frac{1}{m(\\omega_0^2 - \\omega^2 + 2j\\xi\\omega\\omega_0)} & \\text{for a force excitation} \\\\\n\\displaystyle\\frac{\\omega_0^2 + 2j\\xi\\omega\\omega_0}{\\omega_0^2 - \\omega^2 + 2j\\xi\\omega\\omega_0} & \\text{for a base excitation}\n\\end{cases},\n\\] where \\(j\\) is the imaginary unit.\n\n2.1.1 API\nData type\n\nSdofFRFProblem\n\n\n\nSdofFRFProblem(sdof, freq, type_exc, type_resp)\nStructure containing the data for computing the FRF a sdof system\nFields\n\nsdof::Sdof: Sdof structure\n\nfreq::AbstractRange: Vector of frequencies [Hz]\n\ntype_exc::Symbol: Type of excitation\n\n:force: External force (default)\n\n:base: Base motion\n\n\n\ntype_resp::Symbol: Type of response\n\n:dis: Admittance (default)\n\n:vel: Mobility\n\n:acc: Accelerance\n\n\n\n\n\n\n\n\n\n\nRelated function\n\nsolve\n\n\n\nsolve(prob::SdofFRFProblem)\nCompute the FRF of a single degree of freedom (Sdof) system\nInputs\n\nprob: Structure containing the parameters of the Sdof FRF problem\n\n\nOutput\n\nsol: Solution of the FRF problem\n\nu: FRF of the system\n\n\n\n\n\n\n\n\n\n\n\n\n2.1.2 Example\n\n# Structural parameters\nm = 1.\nf0 = 10.\nξ = 0.01\n\n# Instantiation of the Sdof object\nsdof = Sdof(m, f0, ξ)\n\n# Definition of the frequency range\nf = 1.:0.1:30.\n\n# Instantiation of the problem - Force excitation\nprob = SdofFRFProblem(sdof, f)\n\n# Solve the problem\nH = solve(prob).u\n\n\n\n\n\n\n\n\n\n2.2 Response spectrum\nThe response spectrum of a sdof system is the frequency response of the system to an external force \\(F(\\omega)\\) or a base motion \\(X_b(\\omega)\\) with respect to the frequency. The response spectrum \\(Y(\\omega)\\) is computed from the following equation: \\[\nY(\\omega) = \\begin{cases}\n\\displaystyle\\frac{F(\\omega)}{m(\\omega_0^2 - \\omega^2 + 2j\\xi\\omega\\omega_0)} & \\text{for a force excitation} \\\\\n\\displaystyle\\frac{(\\omega_0^2 + 2j\\xi\\omega\\omega_0) X_b(\\omega)}{\\omega_0^2 - \\omega^2 + 2j\\xi\\omega\\omega_0} & \\text{for a base excitation}\n\\end{cases}.\n\\]\n\n2.2.1 API\nData type\n\nSdofFRFProblem\n\n\n\nSdofFrequencyProblem(sdof, F, type_exc, type_resp)\nStructure containing the data for computing the frequency response of a sdof system\nFields\n\nsdof::Sdof: Sdof structure\n\nfreq::AbstractRange: Vector of frequencies [Hz]\n\nF::AbstractVector: Vector of the force excitation [N] or base motion [m]\n\ntype_exc::Symbol: Type of excitation\n\n:force: External force (default)\n\n:base: Base motion\n\n\n\ntype_resp::Symbol: Type of response\n\n:dis: Displacement spectrum(default)\n\n:vel: Velocity spectrum\n\n:acc: Acceleration spectrum\n\n\n\n\n\n\n\n\n\n\nRelated function\n\nsolve\n\n\n\nsolve(prob::SdofFRFProblem)\nCompute the FRF of a single degree of freedom (Sdof) system\nInputs\n\nprob: Structure containing the parameters of the Sdof FRF problem\n\n\nOutput\n\nsol: Solution of the FRF problem\n\nu: FRF of the system\n\n\n\n\n\n\n\n\n\n\n\n\n2.2.2 Example\n\n# Structural parameters\nm = 1.\nf0 = 10.\nξ = 0.01\n\n# Instantiation of the Sdof object\nsdof = Sdof(m, f0, ξ)\n\n# Definition of the frequency range\nf = 1.:0.1:30.\n\n# Instantiation of the problem - Force excitation\nF = fill(10., length(f))\nprob = SdofFrequencyProblem(sdof, f, F)\n\n# Solve the problem\ny = solve(prob).u",
    "crumbs": [
      "Solvers",
      "Sdof solvers"
    ]
  },
  {
    "objectID": "solvers/frequency_solvers.html",
    "href": "solvers/frequency_solvers.html",
    "title": "Frequency-domain solvers",
    "section": "",
    "text": "From a general perspective, the frequency-domain solvers are used to analyze the dynamic response of structures subjected to harmonic loads. In the frequency domain, Mdof systems are described at a given angular frequency \\(\\omega\\) by the following equation: \\[\n\\left(\\mathbf{K} + j\\omega\\mathbf{C} - \\omega^2\\mathbf{M}\\right) \\mathbf{x}(\\omega) = \\mathbf{F}(\\omega).\n\\]",
    "crumbs": [
      "Solvers",
      "Frequency-domain solvers"
    ]
  },
  {
    "objectID": "solvers/frequency_solvers.html#frequency-response-function",
    "href": "solvers/frequency_solvers.html#frequency-response-function",
    "title": "Frequency-domain solvers",
    "section": "1 Frequency response function",
    "text": "1 Frequency response function\nThe Frequency response function (FRF) is computed by assuming a unit harmonic load at the \\(i\\)-th degree of freedom (DOF) and zero loads at all other DOFs, meaning that \\(\\mathbf{F}(\\omega) = \\mathbf{I}\\).\nConsequently, broadly speaking, the FRF is defined by: \\[\n\\mathbf{H}(\\omega) = \\left(\\mathbf{K} + j\\omega\\mathbf{C} - \\omega^2\\mathbf{M}\\right)^{-1}.\n\\] This method is known as the direct method.\nAlternatively, the FRF can be computed using the modal method, which is based on the eigenvalue decomposition of the system matrices. The modal method is more efficient for large systems, as it reduces the problem to a smaller number of modes. In this case and assuming a modal damping ratio, the FRF is computed as: \\[\n\\mathbf{H}(\\omega) = \\mathbf{\\Phi}\\left(\\mathbf{\\Omega}^2 - \\omega^2\\mathbf{I} + 2j\\omega\\mathbf{\\Xi}\\right)^{-1}\\mathbf{\\Phi}^T,\n\\] where \\(\\mathbf{\\Phi}\\) is the mass-normalized mode shapes matrix and \\(\\mathbf{\\Omega}^2 = \\text{diag}(\\omega_1^2, \\dots, \\omega_n^2)\\) and \\(\\mathbf{\\Xi} = \\text{diag}(\\xi_1\\omega_1, \\dots, \\xi_n\\omega_n)\\).\n\n\n\n\n\n\nNote\n\n\n\nAs explained in State-Space solvers - Section 2.1, the FRF can be computed for a given set of response dofs and a given set of excitation dofs by introducing the appropriate selection matrices \\(\\mathbf{S}_o\\) and \\(\\mathbf{S}_e\\). In this case, the FRF is given by: \\[\n\\mathbf{H}_{oe}(\\omega) = \\mathbf{S}_o\\mathbf{H}(\\omega)\\mathbf{S}_e.\n\\]\n\n\n\n1.1 API\nData types\n\nDirectFRFProblem\n\n\n\nDirectFRFProblem(K, M, C, freq, So, Se)\nStructure containing the data feeding the direct solver for calculating an FRF\nFields\n\nK::AbstractMatrix: Stiffness matrix\n\nM::AbstractMatrix: Mass matrix\n\nC::AbstractMatrix: Damping matrix\n\nfreq::AbtractRange: Frequencies of interest\n\nSo::AbstractMatrix: Selection matrix for observation points\n\nSe::AbstractMatrix: Selection matrix for excitation points\n\n\n\n\n\n\n\n\n\nModalFRFProblem\n\n\n\nModalFRFProblem(ωn, ξn, freq, ϕo, ϕe)\nStructure containing the data feeding the modal solver for calculating an FRF\nFields\n\nωn::Vector{Real}: Natural angular frequencies\n\nξn::Vector{Real}: Modal damping ratios\n\nfreq::AbstractRange: Frequencies of interest\n\nϕe::AbstractMatrix: Mode shapes at excitation points\n\nϕo::AbstractMatrix: Mode shapes at observation points\n\n\nNote The mode shapes must be mass-normalized\n\n\n\n\n\n\nRelated function\n\nsolve\n\n\n\nsolve(prob::DirectFRFProblem; type = :dis, progress = true)\nsolve(prob::ModalFRFProblem; type = :dis, progress = true)\nComputes the FRF matrix by direct or modal approach\nInputs\n\nprob: Structure containing the problem data\n\ntype: Type of FRF to compute\n\n:dis: Admittance (default)\n\n:vel: Mobility\n\n:acc: Accelerance\n\n\n\n\nOutput\n\nsol: Solution of the problem\n\nu: FRF matrix\n\n\n\n\n\n\n\n\n\n\n\n\n1.2 Example\n\n# Structural parameters\nM = Diagonal([2., 1.])\nK = [6. -2.; -2. 4.]\nξ = 0.05\n\nω, Φ = eigenmode(K, M)\nC = modal_damping_matrix(M, ω, ξ, Φ)\n\n# Frequency vector\nfreq = 0.01:0.001:1.\n\nprob_frf = DirectFRFProblem(K, M, C, freq)\nH_direct = solve(prob_frf).u\n\n# Problem definition - Case 2 - Modal\nprob_frf_modal = ModalFRFProblem(ω, ξ, freq, Φ, Φ)\nH_modal = solve(prob_frf_modal).u",
    "crumbs": [
      "Solvers",
      "Frequency-domain solvers"
    ]
  },
  {
    "objectID": "solvers/frequency_solvers.html#response-spectrum",
    "href": "solvers/frequency_solvers.html#response-spectrum",
    "title": "Frequency-domain solvers",
    "section": "2 Response spectrum",
    "text": "2 Response spectrum\nSimilarly to the FRF, the response spectrum is a complex function that describes the steady-state response of a system to a sinusoidal input. At a given angular frequency \\(\\omega\\), it is expressed as : \\[\n\\mathbf{x}(\\omega) = \\left(\\mathbf{K} + j\\omega\\mathbf{C} - \\omega^2\\mathbf{M}\\right)^{-1} \\mathbf{F}(\\omega).\n\\] or equivalently from the modes of the system: \\[\n\\mathbf{x}(\\omega) = \\mathbf{\\Phi}\\left(\\mathbf{\\Omega}^2 - \\omega^2\\mathbf{I} + 2j\\omega\\mathbf{\\Omega}\\right)^{-1}\\mathbf{L},\n\\] where \\(\\mathbf{L} = \\mathbf{\\Phi}^\\mathsf{T}\\mathbf{F}(\\omega)\\) is the modal participation factor matrix1.\n\n2.1 API\nData types\n\nDirectFreqProblem\n\n\n\nDirectFreqProblem(K, M, C, F, freq, So)\nStructure containing the data feeding the direct solver for calculating the modal frequencies\nFields\n\nK::AbstractMatrix: Stiffness matrix\n\nM::AbstractMatrix: Mass matrix\n\nC::AbstractMatrix: Damping matrix\n\nF::AbstractMatrix: Force matrix\n\nfreq::AbstractRange: Frequencies of interest\n\nSo::AbstractMatrix: Selection matrix for observation points\n\n\n\n\n\n\n\n\n\nModalFreqProblem\n\n\n\nModalFreqProblem(ωn, ξn, Fn, freq, ϕo)\nStructure containing the data feeding the modal solver for calculating the frequency response by modal approach\nFields\n\nωn::Vector{Real}: Natural angular frequencies\n\nξn::Vector{Real}: Modal damping ratios\n\nLn::AbstractMatrix: Modal participation factors\n\nfreq::AbstractRange: Frequencies of interest\n\nϕo::Matrix{Real}: Mode shapes at observation points\n\n\n\n\n\n\n\n\nRelated function\n\nsolve\n\n\n\nsolve(prob::DirectFreqProblem, type = :dis, progress = true)\nsolve(prob::ModalFreqProblem, type = :dis, progress = true)\nComputes the frequency response by direct or modal approach\nInputs\n\nprob: Structure containing the problem data\n\ntype: Type of response to compute\n\n:dis: Displacement (default)\n\n:vel: Velocity\n\n:acc: Acceleration\n\n\n\nprogress: Show progress bar (default = true)\n\n\nOutput\n\nsol: Solution of the problem\n\nu: Response spectrum matrix\n\n\n\n\n\n\n\n\n\n\n\n\n2.2 Example\n\n# Structural parameters\nM = Diagonal([2., 1.])\nK = [6. -2.; -2. 4.]\nξ = 0.05\n\nω, Φ = eigenmode(K, M)\nC = modal_damping_matrix(M, ω, ξ, Φ)\n\n# Frequency vector\nfreq = 0.01:0.001:1.\n\n# Force matrix\nF = zeros(2, length(freq))\nF[1, :] .= 10.\n\n# Problem definition - Case 1 - Direct\nprob_freq = DirectFreqProblem(K, M, C, F, freq)\ny_freq = solve(prob_freq).u\n\n# Problem definition - Case 2 - Modal\nprob_freq_modal = ModalFreqProblem(ω, ξ, Φ'F, freq, Φ)\ny_freq_modal = solve(prob_freq_modal).u",
    "crumbs": [
      "Solvers",
      "Frequency-domain solvers"
    ]
  },
  {
    "objectID": "solvers/frequency_solvers.html#footnotes",
    "href": "solvers/frequency_solvers.html#footnotes",
    "title": "Frequency-domain solvers",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nThe expression of the modal participation factor matrix is the same as the modal force matrix, because the mode shapes are assumed to be mass-normalized.↩︎",
    "crumbs": [
      "Solvers",
      "Frequency-domain solvers"
    ]
  },
  {
    "objectID": "references/index.html",
    "href": "references/index.html",
    "title": "List of references",
    "section": "",
    "text": "This section provides a list of references useful to understand and deepen the concepts and methods implemented in the StructuralVibration.jl package.",
    "crumbs": [
      "References",
      "List of references"
    ]
  },
  {
    "objectID": "references/index.html#vibration-theory",
    "href": "references/index.html#vibration-theory",
    "title": "List of references",
    "section": "Vibration theory",
    "text": "Vibration theory\n[1] M. Géradin and D. Rixen, Mechanical vibrations: Theory and aplication to structural dynamics, 3rd edition, Wiley, 2015.\n[2] R. D. Blevins, Formulas for natural frequency and mode shape, Van Nostrand Reinhold Co, 1979.\n[3] W. J. Bottega, Engineering vibrations, Taylor & Francis, 2006.\n[4] W. T. Thomson, Theory of vibration with applications, 4th edition, Chapman & Hall, 1993.\n[5] L. Meirovitch, Fundamentals of vibrations, McGraw-Hill, 2001.\n[6] S. Graham Kelly, Fundamentals of mechanical vibrations, 2nd edition, McGraw-Hill, 2000.\n[7] A. W. Leissa and M. S. Qatu, Vibration of continuous systems, McGraw-Hill, 2011.\n[8] C. W. de Silva, Vibration: Fundamentals and practice, CRC Press, 2000.\n[9] D. J. Inman, Engineering vibrations, 4th edition, Pearson, 2014.\n[10] J.-L. Guyader, Vibration in continuous media, ISTE Ltd, 2006.",
    "crumbs": [
      "References",
      "List of references"
    ]
  },
  {
    "objectID": "references/index.html#experimental-techniques",
    "href": "references/index.html#experimental-techniques",
    "title": "List of references",
    "section": "Experimental techniques",
    "text": "Experimental techniques\n[1] A. Brandt, Noise and Vibration Analysis: Signal analysis and experimental procedures, Wiley, 2010.\n[2] R. Brincker and C. Ventura, Introduction to Operational Modal Analysis, Wiley, 2015.\n[3] J. He and Z.-F. Fu, Modal Analysis, Butterworth-Heinemann, 2001.\n[4] P. Avitabile, Modal Testing: A practitioner’s guide, Wiley, 2018.\n[5] C. Rainieri and G. Fabbrocino, Operational modal analysis of civil engineering structures: An introduction and guide for applications, Springer, 2014.\n[6] D. J. Ewins, Modal testing: Theory, practice and application, 2nd edition, Research Studies Press, 2000.",
    "crumbs": [
      "References",
      "List of references"
    ]
  },
  {
    "objectID": "visualization/index.html",
    "href": "visualization/index.html",
    "title": "Visualization extensions",
    "section": "",
    "text": "StructuralVibration.jl is accompanied by an extension SVMakieExt.jl providing visualization capabilities. The extension provides a set of functions to visualize the results of the structural dynamics analysis.\nTo use one of these extensions, you need to import the desired plotting package by running the following command:",
    "crumbs": [
      "Visualization",
      "Visualization extensions"
    ]
  },
  {
    "objectID": "visualization/index.html#bode-plot",
    "href": "visualization/index.html#bode-plot",
    "title": "Visualization extensions",
    "section": "1 Bode plot",
    "text": "1 Bode plot\nA Bode plot is a graph of the magnitude and phase of a transfer function versus frequency.\n\nbode_plot\n\n\n\nbode_plot(freq, y...; lw = 1., xlabel = \"Frequency (Hz)\", xscale = identity,\n          axis_tight = true, isdeg = false, layout = :vertical,\n          ref_dB = 1., legend = (active = false, position = :rt, entry = \" \"))\nPlot Bode diagram of a frequency response or a FRF.\nInputs\n\nfreq: Frequency range of interest\n\ny: Frequency response or FRF\n\nlw: Line width\n\nxlabel: x-axis label\n\nxscale: x-axis scale (default: :log)\n\naxis_tight: Tight axis (default: false)\n\nisdeg: Phase in degrees (default: false)\n\nlayout: Layout of the plot (default: :vertical)\n\nref_dB: Reference value for magnitude (default: 1.)\n\nlegend: Legend parameters (default: (active = false, position = :rt, entry = \" \"))\n\n\nOutput\n\nfig: Figure\n\n\n\n\n\n\n\n\n\n# Initialize a Sdof type\nm = 1.\nf0 = 10.\nξ = 0.01\nsdof = Sdof(m, f0, ξ)\n\n# Computation parameters\nfreq = 1.:0.01:30.\n\n# Compute the FRF\nprob_frf = SdofFRFProblem(sdof, freq)\nH = solve(prob_frf).u\n\n# Bode plot\nbode_plot(freq, H)",
    "crumbs": [
      "Visualization",
      "Visualization extensions"
    ]
  },
  {
    "objectID": "visualization/index.html#nyquist-plot",
    "href": "visualization/index.html#nyquist-plot",
    "title": "Visualization extensions",
    "section": "2 Nyquist plot",
    "text": "2 Nyquist plot\nThe Nyquist plot is either a 2D or 3D plot. In 2D, it is a graph of the imaginary part versus the real part of the transfer function. In 3D, it is a graph of the imaginary part versus the real part of the transfer function and the frequency.\n\n2.1 2D plot\n\nnyquist_plot\n\n\n\nnyquist_plot(y)\nPlot Nyquist diagram\nInputs\n\ny: Complex data vector\n\n\nOutput\n\nfig: Figure\n\n\n\n\n\n\n\n\n\nnyquist_plot(H)\n\n\n\n\n\n\n2.2 3D plot\n\nnyquist_plot\n\n\n\nnyquist_plot(freq, y, xlab = \"Frequency (Hz)\";\n             projection = false)\nPlot Nyquist diagram in 3D\nInputs\n\nfreq: Frequency range\n\ny: Complex vector\n\nylabel: y-axis label\n\nprojection: Projection of the curve on the xy, yz, and xz planes (default: false)\n\non the xy plane: (freq, real(y))\n\non the yz plane: (imag(y), freq)\n\non the xz plane: (real(y), imag(y))\n\n\n\n\nOutput\n\nfig: Figure\n\n\n\n\n\n\n\n\n\nnyquist_plot(freq, H, projection = true)",
    "crumbs": [
      "Visualization",
      "Visualization extensions"
    ]
  },
  {
    "objectID": "visualization/index.html#waterfall-plot",
    "href": "visualization/index.html#waterfall-plot",
    "title": "Visualization extensions",
    "section": "3 Waterfall plot",
    "text": "3 Waterfall plot\nA waterfall plot is a 3D plot with a partial curtain along the y-axis.\n\nwaterfall_plot\n\n\n\nwaterfall_plot(x, y, z; zmin = minimum(z), lw = 1.,\n               colorline = :auto, colmap = :viridis, colorband = (:white, 1.),\n               xlabel = \"x\", ylabel = \"y\", zlabel = \"z\", edge = true,\n               axis_tight = false, xlim = [minimum(x), maximum(x)],\n               ylim = [minimum(y), maximum(y)], zlim = [zmin, maximum(z)])\nPlot a waterfall plot.\nInputs\n\nx: x-axis values\n\ny: y-axis values\n\nz: z-axis values\n\nzmin: minimum value of z-axis\n\nlw::Real: linewidth\n\ncolorline: color of the lines\n\ncolmap: Name of the colormap\n\ncolorband: Tuple defining the color of the band\n\ncolor : Color\n\nalpha : Alpha value for transparency\n\n\n\nxlabel: x-axis label\n\nylabel: y-axis label\n\nzlabel: z-axis label\n\nedge: Display edges (default: true)\n\naxis_tight: Tight axis (default: false)\n\nxlim: x-axis limits\n\nylim: y-axis limits\n\nzlim: z-axis limits\n\n\nOutput\n\nfig: Figure\n\n\n\n\n\n\n\n\nx = range(0., 2π, 100)\ny = range(0., 1., 5)\n\nnx = length(x)\nny = length(y)\nz = zeros(ny, nx)\n\nfor i in eachindex(y)\n    z[i, :] = sin.(i*x/2.)\nend\n\nwaterfall_plot(x, y, z, xlim = [-0.1, 2π + 0.1], ylim = [-0.1, 1.1])",
    "crumbs": [
      "Visualization",
      "Visualization extensions"
    ]
  },
  {
    "objectID": "visualization/index.html#stabilization-plot",
    "href": "visualization/index.html#stabilization-plot",
    "title": "Visualization extensions",
    "section": "4 Stabilization plot",
    "text": "4 Stabilization plot\nThe stabilization plot is used in the context of the modal analysis to plot the Stabilization diagram.\n\nstabilization_plot\n\n\n\nstabilization_plot(stab::StabilizationAnalysis, indicator; display_poles)\nPlot stabilization diagram for EMA-MDOF pole stability analysis.\nInputs\n\nstab: EMA-MDOF stabilization data\n\nindicator: Indicator to plot\n\n:psif : Power spectrum indicator function (default)\n\n:cmif : Complex mode indicator function\n\n\n\ndisplay_poles: Vector of Bool to choose which poles to display\n\ndisplay_poles[1] : Stable in frequency and damping (default: true)\n\ndisplay_poles[2] : Stable in frequency but not stable in damping (default: true)\n\ndisplay_poles[3] : Not stable in frequency (default: true)\n\n\n\n\nOutput\n\nfig: Figure\n\n\n\n\n\n\n\n\nExamples of stabilization plot can be found in the Modal extraction documentation.",
    "crumbs": [
      "Visualization",
      "Visualization extensions"
    ]
  },
  {
    "objectID": "visualization/index.html#peaks-plot",
    "href": "visualization/index.html#peaks-plot",
    "title": "Visualization extensions",
    "section": "5 Peaks plot",
    "text": "5 Peaks plot\nThe peaks plot is used to visualize the peak detection of a given function. It is a useful tool to define the parameters of the peak detection algorithm use to extract the poles using Sdof methods.\n\npeaks_plot\n\n\n\npeaks_plot(x, y; width = 5, min_prom = 0., max_prom = Inf,\n          xlabel = \"x\", ylabel = \"y\")\nPlot data with detected peaks.\nInputs\n\nx: x-axis values\n\ny: y-axis values\n\nwidth: Half-width of the peaks (default: 1)\n\nmin_prom: Minimum peak prominence (default: 0.)\n\nmax_prom: Maximum peak prominence (default: Inf)\n\nxlabel: x-axis label\n\nylabel: y-axis label\n\n\nOutput\n\nfig: Figure\n\n\n\n\n\n\n\n\n\n# Signal used in Peaks.jl package documentation\nT = 1/25\nt = 0:T:23\n\ny = 3sinpi.(0.1t) + 2sinpi.(0.2t) + sinpi.(0.6t)\npeaks_plot(t, y)",
    "crumbs": [
      "Visualization",
      "Visualization extensions"
    ]
  },
  {
    "objectID": "visualization/index.html#sv-plot",
    "href": "visualization/index.html#sv-plot",
    "title": "Visualization extensions",
    "section": "6 SV plot",
    "text": "6 SV plot\nThe SV plot (for StructuralVibration plot) is a general function for 2D plotting. It is a helper function aiming at simplifying the plotting process.\n\nsv_plot\n\n\n\nsv_plot(x, y...; lw = 1., xscale = identity, yscale = identity,\n        axis_tight = true, title = \" \", xlabel = \"x\", ylabel = \"y\",\n        legend = (active = false, position = :right, orientation = :vertical, entry = \" \"))\nPlot a 2D plot.\nInputs\n\nx: x-axis values\n\ny: y-axis values\n\nlw: linewidth\n\nxscale: x-axis scale (default: identity)\n\nyscale: y-axis scale (default: identity)\n\naxis_tight: Tight axis (default: true)\n\ntitle: Title of the plot (default: \" \")\n\nxlabel: x-axis label\n\nylabel: y-axis label\n\nlegend: Legend parameters\n\nactive : Bool\n\nposition : Symbol\n\nentry : String\n\n\n\n\nOutput\n\nfig: Figure\n\n\n\n\n\n\n\n\n\nx = range(0., 2π, 100)\nz_sv = ntuple(i -&gt; sin.(i*x/2), 5)\n\n# SV plot\nsv_plot(x, z_sv..., lw = 2., legend = (active = true,))",
    "crumbs": [
      "Visualization",
      "Visualization extensions"
    ]
  },
  {
    "objectID": "visualization/index.html#theming",
    "href": "visualization/index.html#theming",
    "title": "Visualization extensions",
    "section": "7 Theming",
    "text": "7 Theming\nStructuralVibration.jl provides a set of themes for the plotting functions. The themes are defined in the theme_choice function.\n\ntheme_choice\n\n\n\ntheme_choice(name::Symbol; fonts = Makie.theme(:fonts),\n             titlesize = 20., labelsize = 18., ticklabelsize = 14.)\nChoose the theme for the plots.\nInputs\n\nname: Name of the theme\n\n:makie\n\n:sv\n\n\n\nfonts: Fonts of the figure (default: Makie.theme(:fonts))\n\ntitlesize: Title size (default: 20.)\n\nlabelsize: Label size (default: 18.)\n\nticklabelsize: Tick label size (default: 14.)\n\n\nOutput\n\ntheme: Theme\n\n\n\n\n\n\n\n\n\nwith_theme(theme_choice(:makie)) do\n    sv_plot(x, z_sv..., lw = 2., legend = (active = true,), title = \":makie theme\")\nend\n\n\n\n\n\nwith_theme(theme_choice(:makie)) do\n    sv_plot(x, z_sv..., lw = 2., legend = (active = true,), title = \":sv theme\")\nend",
    "crumbs": [
      "Visualization",
      "Visualization extensions"
    ]
  },
  {
    "objectID": "solvers/direct_time_solvers.html",
    "href": "solvers/direct_time_solvers.html",
    "title": "Direct-time integration solvers",
    "section": "",
    "text": "Similarly to the previous section, the aim is to describe the direct time solvers available for solving Mdof systems. As a remainder, the equation of motion of the system is given by: \\[\n\\mathbf{M} \\ddot{\\mathbf{x}}(t) + \\mathbf{C} \\dot{\\mathbf{x}}(t) + \\mathbf{K} \\mathbf{x}(t) = \\mathbf{F}(t)\n\\] where \\(\\mathbf{M}\\) is the mass matrix, \\(\\mathbf{C}\\) is the damping matrix, \\(\\mathbf{K}\\) is the stiffness matrix, \\(\\mathbf{x}(t)\\) is the displacement vector, and \\(\\mathbf{F}(t)\\) is the vector of external forces.\nDirect-time integration solvers are used to solve the previous equation in the time domain. In Julia , we have the option of using DifferentialEquations.jl which provides a wide range of solvers for solving differential equations.\nThe StructuralVibration package provides its own set of fixed-step linear second-order ODE solvers for pedagogical purposes and for the sake of completeness of the package. It should also be noted that some of the solvers implemented in the package are not available in DiffentialEquations.jl. This is the case of the solvers of the Newmark family, which are widely used in structural dynamics.\nThe solvers available in the StructuralVibration package are:",
    "crumbs": [
      "Solvers",
      "Direct-time integration solvers"
    ]
  },
  {
    "objectID": "solvers/direct_time_solvers.html#api",
    "href": "solvers/direct_time_solvers.html#api",
    "title": "Direct-time integration solvers",
    "section": "1 API",
    "text": "1 API\nData types\n\nDirectTimeProblem\n\n\n\nDirectTimeProblem(K, M, C, F, u0, t)\nDirectTimeProblem(K, M, C, u0, t)\nStructure containing data for the time solver\nConstructor\n\nK::AbstractMatrix: Stiffness matrix\n\nM::AbstractMatrix: Mass matrix\n\nC:AbstractMatrix: Damping matrix\n\nF::AbstractMatrix: External force matrix\n\nu0::Tuple: Initial conditions\n\nu0[1]: Initial displacement (or modal displacement)\n\nu0[2]: Initial velocity (or modal velocity)\n\n\n\nt::AbstractVector: Time points at which to evaluate the response\n\n\nFields\n\nK: Stiffness matrix\n\nM: Mass matrix\n\nC: Damping matrix\n\nF: External force matrix\n\nu0: Initial conditions\n\nu0[1]: Initial displacement\n\nu0[2]: Initial velocity\n\n\n\nh::Real: Time step\n\n\nNote\n\nIf F is not provided, it is assumed to be a zero matrix\n\n\n\n\n\n\n\n\n\nCentralDiff\n\n\n\nCentralDiff()\nCentral difference time solver\n\n\n\n\n\n\n\nRK4\n\n\n\nRK4()\nFourth-order Runge-Kutta time solver\n\n\n\n\n\n\n\nNewmark\n\n\n\nNewmark(; γ0 = 0.5, β0 = 0.25)\nNewmark time solver\n\n\n\n\n\n\n\nHHT\n\n\n\nHHT(; γ0 = 0.5, β0 = 0.25, ρ = 1., αf = Inf)\nHilber-Hughes-Taylor time solver\n\n\n\n\n\n\n\nWBZ\n\n\n\nWBZ(; γ0 = 0.5, β0 = 0.25, ρ = 1., αm = Inf)\nWood-Bossak-Zienkiewicz time solver\n\n\n\n\n\n\n\nFoxGoodwin\n\n\n\nFoxGoodwin()\nFox-Goodwin time solver\n\n\n\n\n\n\n\nMidPoint\n\n\n\nMidPoint()\nMid-point rule time solver\n\n\n\n\n\n\n\nGeneralizedAlpha\n\n\n\nGeneralizedAlpha(; γ0 = 0.5, β0 = 0.25, ρ = 1., αf = Inf, αm = Inf)\nGeneralized-α time solver\n\n\n\n\n\n\nRelated function\n\nsolve\n\n\n\nsolve(prob::DirectTimeProblem, alg; progress = true)\nDirect time integration solver\nInputs\n\nprob: DirectTimeProblem structure\n\nalg: Numerical integration algorithm\n\nCentralDiff(): Central difference\n\nRK4(): Fourth-order Runge-Kutta\n\nNewmark(): Newmark\n\nHHT(): Hilber-Hughes-Taylor\n\nWBZ(): Wood-Bossak-Zienkiewicz\n\nGeneralizedAlpha(): Generalized-α (default)\n\nMidPoint(): Mid-point rule\n\n\n\nprogress: Show progress bar\n\n\nOutput\n\nsol: Solution structure containing the response of the system at the given time points\n\nu: Displacement\n\ndu: Velocity\n\nddu: Acceleration",
    "crumbs": [
      "Solvers",
      "Direct-time integration solvers"
    ]
  },
  {
    "objectID": "solvers/direct_time_solvers.html#free-response",
    "href": "solvers/direct_time_solvers.html#free-response",
    "title": "Direct-time integration solvers",
    "section": "2 Free response",
    "text": "2 Free response\nThe free response of a 2-dofs system is obtained by setting the external forces to zero. In this condition, the motion of the system is initiated by non-zero initial conditions. In the following example, the response provided by the direct time solvers is compared with the solution obtained by the modal solver described in Modal time solvers - Section 1 for the purpose of cross-validation.\n\n# System parameters\nM = Diagonal([2., 1.])\nK = [6. -2.; -2. 4.]\nξ = 0.05\n\nω, Φ = eigenmode(K, M)\nC = modal_damping_matrix(M, ω, ξ, Φ)\n\n# Time vector\nt = 0.:1e-2:30.\n\n# Initial conditions\nx0 = [0.2, 0.1]\nv0 = zeros(2)\nu0 = (x0, v0)\n\n# External forces\nF_free = zeros(2, length(t))\n\n# Direct time problem\nprob_free = DirectTimeProblem(K, M, C, F_free, u0, t)\nx_free_gα = solve(prob_free).u\nx_free_cd = solve(prob_free, CentralDiff()).u\nx_free_rk = solve(prob_free, RK4()).u\n\n# Modal time problem\nprob_free_modal =  FreeModalTimeProblem(K, M, ξ, u0, t)\nx_free_modal = solve(prob_free_modal).u",
    "crumbs": [
      "Solvers",
      "Direct-time integration solvers"
    ]
  },
  {
    "objectID": "solvers/direct_time_solvers.html#forced-response",
    "href": "solvers/direct_time_solvers.html#forced-response",
    "title": "Direct-time integration solvers",
    "section": "3 Forced response",
    "text": "3 Forced response\nThe forced response of a 2-dofs system is obtained by applying a haversine excitation to the first dof of the system. As in the previous section, the response provided by the direct time solvers is compared with the solution obtained by the modal solver described in Modal time solvers - Section 2 for the purpose of cross-validation.\n\n# System parameters\nM = Diagonal([2., 1.])\nK = [6. -2.; -2. 4.]\nξ = 0.05\n\nω, Φ = eigenmode(K, M)\nC = modal_damping_matrix(M, ω, ξ, Φ)\n\n# Time vector\nt = 0.:1e-2:30.\n\n# Initial conditions\nx0 = zeros(2)\nv0 = zeros(2)\nu0 = (x0, v0)\n\n# External forces\nF0 = 10.\ntstart = 2.\nduration = 5.\nhaversine = HaverSine(F0, tstart, duration)\nF0 = excitation(haversine, t)\nF = zeros(2, length(t))\nF[1, :] .= F0\n\n# Direct time problem\nprob_forced = DirectTimeProblem(K, M, C, F, u0, t)\nx_forced_gα = solve(prob_forced).u\nx_forced_cd = solve(prob_forced, CentralDiff()).u\nx_forced_rk = solve(prob_forced, RK4()).u\n\n# Modal time problem\nprob_forced_modal = ForcedModalTimeProblem(K, M, ξ, F, u0, t)\nx_forced_modal = solve(prob_forced_modal).u",
    "crumbs": [
      "Solvers",
      "Direct-time integration solvers"
    ]
  },
  {
    "objectID": "solvers/direct_time_solvers.html#differentialequations.jl-solvers",
    "href": "solvers/direct_time_solvers.html#differentialequations.jl-solvers",
    "title": "Direct-time integration solvers",
    "section": "4 DifferentialEquations.jl solvers",
    "text": "4 DifferentialEquations.jl solvers\nThis section illustrates how to use the DifferentialEquations.jl solvers to solve problems discretized with the finite element method. The implementation is done using the ODEProblem from the DifferentialEquations.jl package.\n\n4.1 Data preparation\n\nL = 1.\nb = 0.03\nh = 0.01\nS = b*h\nI = b*h^3/12\nE = 2.1e11\nρ = 7850.\n\n# Initialization of the data types\nbeam = Beam(L, S, I, E, ρ)\n\n# Mesh definition\noned_mesh = OneDMesh(beam, 0., 20, :SS)\n\n# Construction of K and M\nKfe, Mfe = assembly(beam, oned_mesh)\n\n# Application of the BCs\nKbc = apply_bc(Kfe, oned_mesh)\nMbc = apply_bc(Mfe, oned_mesh)\nnddl = size(Kbc, 1)\n\n# Calculation of the damping matrix\nCbc = rayleigh_damping_matrix(Kbc, Mbc, 1e-4, 5e-4)\n\n\n\n4.2 Problem solution\n\n# Time vector\nt = 0.:1e-5:1.\nnt = length(t)\n\n# Initial conditions\nx0 = 1e-3ones(nddl)\nv0 = zeros(nddl)\nu0 = (x0, v0)\n\n# Direct time problem - Generalized-alpha method\nprob = DirectTimeProblem(Kbc, Mbc, Cbc, u0, t)\nu_gα = solve(prob).u\n\n\n# To avoid name conflicts\nimport OrdinaryDiffEqTsit5 as DET\nimport OrdinaryDiffEqRosenbrock as DER\n\n# First-order ODE function\nfunction ode_solve!(du, u, p, t)\n    A = p[1].Ac\n\n    du .= A*u\nend\n\nu0 = [x0; v0]\ncss = ss_model(Kbc, Mbc, Cbc)\nprob_ode = DET.ODEProblem(ode_solve!, u0, (t[1], t[end]), (css,))\nsol_ode = DET.solve(prob_ode, DET.AutoTsit5(DER.Rosenbrock23()))\nu_ode = sol_ode(t)[1:nddl, :]\n\n# Second-order ODE function\nfunction sde_solve!(ddu, du, u, p, t)\n    M = p[1]\n    K = p[2]\n    C = p[3]\n\n    ddu .= M\\(-C*du .- K*u)\nend\n\nprob_sde = DET.SecondOrderODEProblem(sde_solve!, v0, x0, (t[1], t[end]), (Mbc, Kbc, Cbc))\nsol_sde = DET.solve(prob_sde, DET.AutoTsit5(DER.Rosenbrock23()))\nu_sde = sol_sde(t)[nddl+1:2*nddl, :]",
    "crumbs": [
      "Solvers",
      "Direct-time integration solvers"
    ]
  },
  {
    "objectID": "solvers/direct_time_solvers.html#footnotes",
    "href": "solvers/direct_time_solvers.html#footnotes",
    "title": "Direct-time integration solvers",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nN. M. Newmark. “A method of computation for structural dynamics”. Journal of the Engineering Mechanics Division, 85(3), 67-94, 1959.↩︎\nH. M. Hilber, T. J. Hughes and R. L. Taylor. “Improved numerical dissipation for time integration algorithms in structural dynamics”. Earthquake Engineering & Structural Dynamics 5(3), 283–292. 1977.↩︎\nW. L. Wood, M. Bossak, O. Zienkiewicz. “An alpha modification of Newmark’s method”. International Journal for Numerical Methods in Engineering, 15(10), 1562-1566, 1980.↩︎\nL. Fox, E. T. Goodwin. “Some new methods for numerical integration of ordinary differential equations”. Mathematical Proceedings of the Cambridge Philosophical Society, 45(3), 373-388, 1949.↩︎\nM. Géradin and D. Rixen. “Mechanical Vibrations: Theory and Application to Structural Dynamics”. Third Edition. John Wiley & Sons, 2015.↩︎\nJ. Chung and G. M. Hulbert. “A time integration algorithm for structural dynamics with improved numerical dissipation: the generalized-alpha method”. Journal of Applied Mechanics, 60(2), 371-375, 1993.↩︎",
    "crumbs": [
      "Solvers",
      "Direct-time integration solvers"
    ]
  },
  {
    "objectID": "solvers/modal_time_solvers.html",
    "href": "solvers/modal_time_solvers.html",
    "title": "Modal time solvers",
    "section": "",
    "text": "The aim of this section is to describe the modal time solvers available for solving Multi-degrees of freedom (Mdof) systems. To explain, the theoretical foundations of the proposed solvers, let’s consider a Mdof system with \\(N\\) degrees of freedom. The equation of motion of the system is given by: \\[\n\\mathbf{M} \\ddot{\\mathbf{x}}(t) + \\mathbf{C} \\dot{\\mathbf{x}}(t) + \\mathbf{K} \\mathbf{x}(t) = \\mathbf{F}(t)\n\\] where \\(\\mathbf{M}\\) is the mass matrix, \\(\\mathbf{C}\\) is the damping matrix, \\(\\mathbf{K}\\) is the stiffness matrix, \\(\\mathbf{x}(t)\\) is the displacement vector, and \\(\\mathbf{F}(t)\\) is the vector of external forces.\nTo solve the previous in the modal space, the solution \\(\\mathbf{x}(t)\\) is expressed as: \\[\n\\mathbf{x}(t) = \\mathbf{\\Phi} \\mathbf{q}(t)\n\\] where \\(\\mathbf{\\Phi}\\) is the matrix of the mode shapes and \\(\\mathbf{q}(t)\\) is the vector of modal coordinates.\nSubstituting the previous expression in the equation of motion, premultiplying by \\(\\mathbf{\\Phi}^\\mathsf{T}\\), and using the orthogonality property of the mode shapes, one obtains a set of \\(N\\) independent modal equations of motion given by: \\[\n\\ddot{q}_n(t) + 2 \\xi_n \\omega_n \\dot{q}_n(t) + \\omega_n^2 q_n(t) = \\frac{f_n(t)}{m_n}\n\\] where for the n-th mode, \\(q_n(t)\\) is the generalized coordinate, \\(\\xi_n\\) is the damping ratio, \\(\\omega_n\\) is the natural angular frequency, \\(f_n(t)\\) is the modal force, and \\(m_n\\) is the modal mass.\nIt should be noticed that a modal equation of motion corresponds to the equation of motion of a Sdof system with mass \\(m_n\\), damping ratio \\(\\xi_n\\), natural angular frequency \\(\\omega_n\\).\nIt results that computing the response of an Mdof system in the modal space is equivalent to solving \\(N\\) independent Sdof systems.",
    "crumbs": [
      "Solvers",
      "Modal time solvers"
    ]
  },
  {
    "objectID": "solvers/modal_time_solvers.html#free-response",
    "href": "solvers/modal_time_solvers.html#free-response",
    "title": "Modal time solvers",
    "section": "1 Free response",
    "text": "1 Free response\nThe free response of an MDOF system is the response of the system when there are no external forces acting on it. In this case, the modal equations of motion of the system is given by: \\[\n\\ddot{q}_n(t) + 2 \\xi_n \\omega_n \\dot{q}_n(t) + \\omega_n^2 q_n(t) = 0\n\\]\nThe solution of the previous equation can be found in Sdof solvers - Section 1.1.\n\n1.1 API\nData type\n\nFreeModalTimeProblem\n\n\n\nFreeModalTimeProblem(K, M, ξn, n = size(K, 1); ismodal = false)\nStructure containing data for the modal time solver\nFields\n\nK::VecOrMat{Real}:\n\nIf ismodal = false then Matrix{Real}: Stiffness matrix\n\nIf ismodal = true then Vector{Real}: Natural angular frequencies\n\n\n\nM::AbtractMatrix:\n\nIf ismodal = false: Mass matrix\n\nIf ismodal = true: Mass-normalized mode shapes\n\n\n\nξn: Damping ratios\n\nu0::Tuple: Initial conditions\n\nu0[1]: Initial displacement (or modal displacement)\n\nu0[2]: Initial velocity (or modal velocity)\n\n\n\nt::AbstractRange: Time points at which to evaluate the response\n\nF::Matrix{Real}: External force matrix (or modal force matrix)\n\nn::Int: Number of modes to retain in the modal basis\n\nismodal::Bool: Flag to indicate if the problem contains modal data\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nTwo possibilities are offered to the user to enter the structural properties of the system.\n\nProvide the stiffness and mass matrices.\nProvide the squared natural frequencies and (mass-normalized) mode shapes. This allows to use the modal information computed analytically for continuous systems or numerically for discrete systems.\n\nIn the latter case, the initial conditions must be expressed in the modal space.\n\n\n\nRelated function\n\nsolve\n\n\n\nsolve(prob::FreeModalTimeProblem)\nCompute the free response of a multi-degrees of freedom (Mdof) system using the modal approach.\nInputs\n\nprob: Structure containing the parameters of the Mdof problem\n\n\nOutput\n\nsol: ModalTimeSolution structure containing the response of the system at the given time points\n\n\n\n\n\n\n\n\n\n\n1.2 Example\n\n# System parameters\nM = Diagonal([2., 1.])\nK = [6. -2.; -2. 4.]\nξ = 0.05\n\n# Time vector\nt = 0.:1e-2:30.\n\n# Initial conditions\nx0 = [0.2, 0.1]\nv0 = zeros(2)\n\n# Problem definition - case 1 - Provide the stiffness and mass matrices\nu0 = (x0, v0)\nprob = FreeModalTimeProblem(K, M, ξ, u0, t)\n\n# Problem definition - case 2 - Provide the squared natural frequencies and mode shapes\nωm, Φm = eigenmode(K, M)\nx0m = Φm'*M*x0\nv0m = Φm'*M*v0\nu0m = (x0m, v0m)\nprob_modal = FreeModalTimeProblem(ωm, Φm, ξ, u0m, t, ismodal = true)\n\n# Solution\nx_free = solve(prob).u\nx_free_modal = solve(prob_modal).u",
    "crumbs": [
      "Solvers",
      "Modal time solvers"
    ]
  },
  {
    "objectID": "solvers/modal_time_solvers.html#forced-response",
    "href": "solvers/modal_time_solvers.html#forced-response",
    "title": "Modal time solvers",
    "section": "2 Forced response",
    "text": "2 Forced response\nThe forced response of an Mdof system is the response of the system when external forces are acting on it. In this case, the modal equations of motion of the system is given by: \\[\n\\ddot{q}_n(t) + 2 \\xi_n \\omega_n \\dot{q}_n(t) + \\omega_n^2 q_n(t) = \\frac{f_n(t)}{m_n}\n\\]\nThe solution of the previous equation can be found in Sdof solvers - Section 1.2.\n\n2.1 Harmonic excitation\n\n2.1.1 API\nData type\n\nHarmonicModalTimeProblem\n\n\n\nHarmonicModalTimeProblem(K, M, ξn, u0, t, F, ω = 0., n = size(K, 1); ismodal = false)\nStructure containing data for the modal time solver for computing the forced response due to an harmonic excitation\nConstructor\n\nK::VecOrMat{Real}:\n\nIf ismodal = false then Matrix{Real}: Stiffness matrix\n\nIf ismodal = true then Vector{Real}: Natural angular frequencies\n\n\n\nM::AbtractMatrix:\n\nIf ismodal = false: Mass matrix\n\nIf ismodal = true: Mass-normalized mode shapes\n\n\n\nξn: Damping ratios\n\nu0::Tuple: Initial conditions\n\nu0[1]: Initial displacement (or modal displacement)\n\nu0[2]: Initial velocity (or modal velocity)\n\n\n\nt::AbstractRange: Time points at which to evaluate the response\n\nF::Real: External force matrix (or modal participation factors)\n\nfreq::Real: Excitation frequency\n\nn::Int: Number of modes to retain in the modal basis\n\nismodal::Bool: Flag to indicate if the problem contains modal data\n\n\nFields\n\nK: Stiffness matrix (or modal stiffness matrix)\n\nM: Mass matrix (or mass-normalized mode shapes)\n\nξn: Damping ratios\n\nu0: Initial conditions\n\nu0[1]: Initial displacement (or modal displacement)\n\nu0[2]: Initial velocity (or modal velocity)\n\n\n\nt: Time points at which to evaluate the response\n\nF: Amplitude vector (or modal participation vector)\n\nω: Excitation angular frequency\n\nn: Number of modes to retain in the modal basis\n\nismodal: Flag to indicate if the problem contains modal data\n\n\n\n\n\n\n\n\nRelated function\n\nsolve\n\n\n\nsolve(prob::HarmonicModalTimeProblem)\nCompute the forced response of a multi-degrees of freedom (Mdof) system due to an harmonic excitation using the modal approach.\nInputs\n\nprob: Structure containing the parameters of the Mdof problem\n\n\nOutput\n\nsol: Solution structure containing the response of the system at the given time points\n\nu: Displacement\n\ndu: Velocity\n\nddu: Acceleration\n\n\n\n\n\n\n\n\n\n\n\n\n2.1.2 Example\n\n# System parameters\nM = Diagonal([2., 1.])\nK = [6. -2.; -2. 4.]\nξ = 0.05\n\n# Time vector\nt = 0.:1e-2:30.\n\n# Initial conditions\nx0 = [0., 1e-4]\nv0 = zeros(2)\nu0 = (x0, v0)\n\n# Excitation parameters\nF = [1., 2.]\nfreq = 0.5\n\n# Problem definition - case 1 - Provide the stiffness and mass matrices\nprob_harmo = HarmonicModalTimeProblem(K, M, ξ, F, 2π*freq, u0, t)\n\n# Problem definition - case 2 - Provide the squared natural frequencies and mode shapes\nωm, Φm = eigenmode(K, M)\nx0m = Φm'*M*x0\nv0m = Φm'*M*v0\nu0m = (x0m, v0m)\nLm = Φm'*F\nprob_harmo_modal = HarmonicModalTimeProblem(ωm, Φm, ξ, Lm, 2π*freq, u0m, t, ismodal = true)\n\n# Solution\nx_harmo = solve(prob_harmo).u\nx_harmo_modal = solve(prob_harmo_modal).u\n\n\n\n\n\n\n\n\n\n2.2 Arbitrary excitation\n\n2.2.1 API\nData type\n\nForcedModalTimeProblem\n\n\n\nForcedModalTimeProblem(K, M, ξn, F, u0, t,  n = size(K, 1); ismodal = false)\nStructure containing data for modal time solver for computing the forced response due to an arbitrary excitation\nFields\n\nK::VecOrMat{Real}:\n\nIf ismodal = false then Matrix{Real}: Stiffness matrix\n\nIf ismodal = true then Vector{Real}: Natural angular frequencies\n\n\n\nM::AbtractMatrix:\n\nIf ismodal = false: Mass matrix\n\nIf ismodal = true: Mass-normalized mode shapes\n\n\n\nξn: Damping ratios\n\nF::Matrix{Real}: External force matrix (or modal participation factors)\n\nu0::Tuple: Initial conditions\n\nu0[1]: Initial displacement (or modal displacement)\n\nu0[2]: Initial velocity (or modal velocity)\n\n\n\nt::AbstractRange: Time points at which to evaluate the response\n\nn::Int: Number of modes to retain in the modal basis\n\nismodal::Bool: Flag to indicate if the problem contains modal data\n\n\n\n\n\n\n\n\nRelated function\n\nsolve\n\n\n\nsolve(prob::ForcedModalTimeProblem)\nCompute the forced response of a multi-degrees of freedom (Mdof) system due to an arbitrary excitation using the modal approach.\nInputs\n\nprob: Structure containing the parameters of the Mdof problem\n\nmethod: Method to compute the Duhamel's integral\n\n:filt: Filtering using the Z-transform of the impulse response (default)\n\n:interp: Interpolation + Gaussian quadrature\n\n:conv: Convolution\n\n\n\n\nOutput\n\nsol: ModalTimeSolution structure containing the response of the system at the given time points\n\n\n\n\n\n\n\n\n\n\n2.2.2 Example\n\n# System parameters\nM = Diagonal([2., 1.])\nK = [6. -2.; -2. 4.]\nξ = 0.05\n\n# Time vector\nt = 0.:1e-2:30.\n\n# Initial conditions\nu0 = (zeros(2), zeros(2))\n\n# Excitation parameters\nF0 = 10.\ntstart = 2.\nduration = 5.\nhaversine = HaverSine(F0, tstart, duration)\nF0 = excitation(haversine, t)\nF = zeros(2, length(t))\nF[1, :] .= F0\n\n# Problem definition - case 1 - Provide the stiffness and mass matrices\nprob_forced = ForcedModalTimeProblem(K, M, ξ, F, u0, t)\n\n# Problem definition - case 2 - Provide the squared natural frequencies and mode shapes\nωm, Φm = eigenmode(K, M)\nu0m = (zeros(2), zeros(2))\nLm = Φm'*F\nprob_forced_modal = ForcedModalTimeProblem(ωm, Φm, ξ, Lm, u0m, t, ismodal = true)\n\n# Solution\nx_forced = solve(prob_forced).u\nx_forced_modal = solve(prob_forced_modal).u",
    "crumbs": [
      "Solvers",
      "Modal time solvers"
    ]
  },
  {
    "objectID": "solvers/modal_time_solvers.html#additional-function---impulse-response-matrix",
    "href": "solvers/modal_time_solvers.html#additional-function---impulse-response-matrix",
    "title": "Modal time solvers",
    "section": "3 Additional function - Impulse response matrix",
    "text": "3 Additional function - Impulse response matrix\nThe impulse response matrix of an Mdof system is obtained from the modal impulse response matrix. The modal impulse response matrix is given by: \\[\n\\mathbf{h}(t) = \\Phi \\begin{bmatrix}\nh_1(t) & & & & \\\\\n& \\ddots & & & \\\\\n& & h_n(t) & & \\\\\n& & & \\ddots & \\\\\n& & & & h_N(t)\n\\end{bmatrix}\n\\Phi^\\mathsf{T},\n\\] where \\(h_n(t)\\) is the modal impulse response of the mode \\(n\\) computed as in Sdof solvers - Section 1.3.\n\nimpulse_response\n\n\n\nimpulse_response(K::Matrix{Float64}, M::Matrix{Float64}, ξn, t, n = size(K, 1); ismat = false)\nCompute the impulse response of a multi-degrees of freedom (Mdof) system using the modal approach\nInputs\n\nK:\n\nIf ismodal = false: Stiffness matrix\n\nIf ismodal = true: Squared natural angular frequencies\n\n\n\nM:\n\nIf ismodal = false: Mass matrix\n\nIf ismodal = true: Mass-normalized mode shapes\n\n\n\nξn: Damping ratios\n\nt: Time points at which to evaluate the response\n\nn: Number of modes to retain in the modal basis\n\nismodal::Bool: Flag to indicate if the problem contains modal data\n\n\nOutput\n\nsol: ModalImpulseSolution\n\nu: Impulse response matrix\n\n\n\n\n\n\n\n\n\n\n\n# System parameters\nM = Diagonal([2., 1.])\nK = [6. -2.; -2. 4.]\nξ = 0.05\n\n# Time vector\nt = 0.:1e-2:30.\n\n# Impulse response matrix\nh = impulse_response(K, M, ξ, t).u;",
    "crumbs": [
      "Solvers",
      "Modal time solvers"
    ]
  },
  {
    "objectID": "solvers/state_space_solvers.html",
    "href": "solvers/state_space_solvers.html",
    "title": "State-space solvers",
    "section": "",
    "text": "For solving time-domain problems, the StructuralVibration.jl package provides two different approach. The first one consist in solving the problem using the discrete-time state equation (see Mechanical solvers - Section 3.2 for details). In this case, four discretization methods are available: Zero-Order Hold (:zoh), First-Order Hold (:foh), Band-Limited Hold (:blh), and Fourth order Runge-Kutta scheme (:rk4).\nThe second approach is to solve the problem using the continuous-time state equation. In this case, the user can build a continuous state-space model and solve it using DifferentialEquations.jl to take advantage of one of its numerous solvers or use the Fourth order Runge-Kutta scheme implemented in the package.\n\n\nData type\n\nStateSpaceTimeProblem\n\n\n\nStateSpaceProblem(css::ContinuousStateSpace, u0::Vector{Float64}, h::Float64, F::Matrix{Float64})\nStructure containing data for the state-space model\nConstructor\n\ncss: Continuous-time state space model\n\nu0: Initial conditions\n\nF: External force matrix\n\nt: Time vector\n\n\nFields\n\ncss: ContinuousStateSpace\n\nF: External force matrix\n\nu0: Initial conditions\n\nh: Time step\n\n\n\n\n\n\n\n\nRelated function\n\nsolve\n\n\n\nsolve(prob::StateSpaceTimeProblem, method = :zoh; progress = true)\nSolves a discrete-time problem using the state-space model\nInputs\n\nprob: Discrete-time problem\n\nmethod: Discretization method\n\n:zoh: Zero-order Hold method\n\n:foh: First-order Hold method\n\n:blh: Band-limited Hold method\n\n:rk4: Runge-Kutta 4th order method\n\n\n\nprogress: Show progress bar (default = true)\n\n\nOutput\n\nStateSpaceSolution: Solution of the state-space model\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Structural parameters\nM = Diagonal([2., 1.])\nK = [6. -2.; -2. 4.]\nξ = 0.05\n\nω, Φ = eigenmode(K, M)\nC = modal_damping_matrix(M, ω, ξ, Φ)\n\n# Time vector\nt = 0.:1e-2:30.\n\n# State-space model\ncss = ss_model(K, M, C)\n\n# Force\nF_free = zeros(2, length(t))\n\n# Initial conditions\nx0 = [0.2, 0.1]\nv0 = zeros(2)\nu0 = [x0; v0]\n\n# Problem definition\nprob_free = StateSpaceTimeProblem(css, F_free, u0, t)\nx_free_zoh = solve(prob_free).u\nx_free_foh = solve(prob_free, :foh).u\nx_free_blh = solve(prob_free, :blh).u\nx_free_rk = solve(prob_free, RK4()).u\n# Other possibility\n# x_free_rk = solve(prob_free, :rk4).u\n\nprob_free_modal =  FreeModalTimeProblem(K, M, ξ, (x0, v0), t)\nx_free_modal = solve(prob_free_modal).u\n\n\n\n\n\n\n\n\n\n\n# Structural parameters\nM = Diagonal([2., 1.])\nK = [6. -2.; -2. 4.]\nξ = 0.05\n\nω, Φ = eigenmode(K, M)\nC = modal_damping_matrix(M, ω, ξ, Φ)\n\n# Time vector\nt = 0.:1e-2:30.\n\n# State-space model\ncss = ss_model(K, M, C)\n\nF0 = 10.\ntstart = 2.\nduration = 5.\nhaversine = HaverSine(F0, tstart, duration)\nF0 = excitation(haversine, t)\nF = zeros(2, length(t))\nF[1, :] .= F0\n\n# Initial conditions\nx0 = zeros(2)\nv0 = zeros(2)\nu0 = [x0; v0]\n\n# Problem definition\nprob_forced = StateSpaceTimeProblem(css, F, u0, t)\nx_forced_zoh = solve(prob_forced).u\nx_forced_foh = solve(prob_forced, :foh).u\nx_forced_blh = solve(prob_forced, :blh).u\nx_forced_rk = solve(prob_forced, :rk4).u\n\nprob_forced_modal = ForcedModalTimeProblem(K, M, ξ, F, (x0, v0), t)\nx_forced_modal = solve(prob_forced_modal).u",
    "crumbs": [
      "Solvers",
      "State-space solvers"
    ]
  },
  {
    "objectID": "solvers/state_space_solvers.html#time-domain-solvers",
    "href": "solvers/state_space_solvers.html#time-domain-solvers",
    "title": "State-space solvers",
    "section": "",
    "text": "For solving time-domain problems, the StructuralVibration.jl package provides two different approach. The first one consist in solving the problem using the discrete-time state equation (see Mechanical solvers - Section 3.2 for details). In this case, four discretization methods are available: Zero-Order Hold (:zoh), First-Order Hold (:foh), Band-Limited Hold (:blh), and Fourth order Runge-Kutta scheme (:rk4).\nThe second approach is to solve the problem using the continuous-time state equation. In this case, the user can build a continuous state-space model and solve it using DifferentialEquations.jl to take advantage of one of its numerous solvers or use the Fourth order Runge-Kutta scheme implemented in the package.\n\n\nData type\n\nStateSpaceTimeProblem\n\n\n\nStateSpaceProblem(css::ContinuousStateSpace, u0::Vector{Float64}, h::Float64, F::Matrix{Float64})\nStructure containing data for the state-space model\nConstructor\n\ncss: Continuous-time state space model\n\nu0: Initial conditions\n\nF: External force matrix\n\nt: Time vector\n\n\nFields\n\ncss: ContinuousStateSpace\n\nF: External force matrix\n\nu0: Initial conditions\n\nh: Time step\n\n\n\n\n\n\n\n\nRelated function\n\nsolve\n\n\n\nsolve(prob::StateSpaceTimeProblem, method = :zoh; progress = true)\nSolves a discrete-time problem using the state-space model\nInputs\n\nprob: Discrete-time problem\n\nmethod: Discretization method\n\n:zoh: Zero-order Hold method\n\n:foh: First-order Hold method\n\n:blh: Band-limited Hold method\n\n:rk4: Runge-Kutta 4th order method\n\n\n\nprogress: Show progress bar (default = true)\n\n\nOutput\n\nStateSpaceSolution: Solution of the state-space model\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Structural parameters\nM = Diagonal([2., 1.])\nK = [6. -2.; -2. 4.]\nξ = 0.05\n\nω, Φ = eigenmode(K, M)\nC = modal_damping_matrix(M, ω, ξ, Φ)\n\n# Time vector\nt = 0.:1e-2:30.\n\n# State-space model\ncss = ss_model(K, M, C)\n\n# Force\nF_free = zeros(2, length(t))\n\n# Initial conditions\nx0 = [0.2, 0.1]\nv0 = zeros(2)\nu0 = [x0; v0]\n\n# Problem definition\nprob_free = StateSpaceTimeProblem(css, F_free, u0, t)\nx_free_zoh = solve(prob_free).u\nx_free_foh = solve(prob_free, :foh).u\nx_free_blh = solve(prob_free, :blh).u\nx_free_rk = solve(prob_free, RK4()).u\n# Other possibility\n# x_free_rk = solve(prob_free, :rk4).u\n\nprob_free_modal =  FreeModalTimeProblem(K, M, ξ, (x0, v0), t)\nx_free_modal = solve(prob_free_modal).u\n\n\n\n\n\n\n\n\n\n\n# Structural parameters\nM = Diagonal([2., 1.])\nK = [6. -2.; -2. 4.]\nξ = 0.05\n\nω, Φ = eigenmode(K, M)\nC = modal_damping_matrix(M, ω, ξ, Φ)\n\n# Time vector\nt = 0.:1e-2:30.\n\n# State-space model\ncss = ss_model(K, M, C)\n\nF0 = 10.\ntstart = 2.\nduration = 5.\nhaversine = HaverSine(F0, tstart, duration)\nF0 = excitation(haversine, t)\nF = zeros(2, length(t))\nF[1, :] .= F0\n\n# Initial conditions\nx0 = zeros(2)\nv0 = zeros(2)\nu0 = [x0; v0]\n\n# Problem definition\nprob_forced = StateSpaceTimeProblem(css, F, u0, t)\nx_forced_zoh = solve(prob_forced).u\nx_forced_foh = solve(prob_forced, :foh).u\nx_forced_blh = solve(prob_forced, :blh).u\nx_forced_rk = solve(prob_forced, :rk4).u\n\nprob_forced_modal = ForcedModalTimeProblem(K, M, ξ, F, (x0, v0), t)\nx_forced_modal = solve(prob_forced_modal).u",
    "crumbs": [
      "Solvers",
      "State-space solvers"
    ]
  },
  {
    "objectID": "solvers/state_space_solvers.html#frequency-domain-solvers",
    "href": "solvers/state_space_solvers.html#frequency-domain-solvers",
    "title": "State-space solvers",
    "section": "2 Frequency-domain solvers",
    "text": "2 Frequency-domain solvers\nThe frequency-domain solvers are based on the state-space representation of the system, which includes both the state equation and the output equation. It is given that: \\[\n\\begin{cases}\n\\dot{\\mathbf{z}}(t) &= \\mathbf{A}_c \\mathbf{z}(t) + \\mathbf{B}_c \\mathbf{u}(t) \\\\\n\\mathbf{y}(t) &= \\mathbf{C}_c \\mathbf{z}(t) + \\mathbf{D}_c \\mathbf{u}(t)\n\\end{cases},\n\\] where:\n\n\\(\\mathbf{z}(t)\\): State vector\n\\(\\mathbf{u}(t)\\): Input vector\n\\(\\mathbf{y}(t)\\): Output vector\n\\(\\mathbf{A}_c\\): System matrix\n\\(\\mathbf{B}_c\\): Input matrix\n\\(\\mathbf{C}_c\\): Observation matrix\n\\(\\mathbf{D}_c\\): Direct feedthrough matrix\n\nIt is also possible to express the state-space system. To this end, the state-space representation is transformed into modal coordinates, i.e., \\(\\mathbf{z} = \\mathbf{\\Psi} \\mathbf{q}\\), where \\(\\mathbf{\\Psi}\\) is the matrix of eigenvectors of the system matrix \\(\\mathbf{A}_c\\). The modal state-space representation is given by: \\[\n\\begin{cases}\n\\dot{\\mathbf{q}}(t) &= \\mathbf{\\Lambda} \\mathbf{q}(t) + \\mathbf{B}_m \\mathbf{u}(t) \\\\\n\\mathbf{y}(t) &= \\mathbf{C}_m \\mathbf{q}(t) + \\mathbf{D}_m \\mathbf{u}(t)\n\\end{cases},\n\\] where:\n\n\\(\\mathbf{q}(t)\\): Modal state vector\n\\(\\Lambda = \\text{diag}(\\lambda_1, \\lambda_1^\\ast, \\dots, \\lambda_N, \\lambda_N^\\ast)\\): Eigenvalues matrix\n\\(\\mathbf{B}_m = \\mathbf{\\Psi}^{-1} \\mathbf{B}_c\\): Modal input matrix\n\\(\\mathbf{C}_m = \\mathbf{C}_c \\mathbf{\\Psi}\\): Modal observation matrix\n\\(\\mathbf{D}_m = \\mathbf{D}_c\\): Modal direct feedthrough matrix\n\nFinally\n\n2.1 Frequency Response Function\nThe Frequency Response Function (FRF) is a complex function that describes the steady-state response of a system to a sinusoidal input. The FRF is defined as the ratio of the output to the input in the frequency domain. From the state-space representation, the transfer function of the system at a given angular frequency \\(\\omega\\) can be obtained in a straightforward manner and is given by: \\[\n\\mathbf{H}(\\omega) = \\mathbf{C}_c (j\\omega \\mathbf{I} - \\mathbf{A}_c)^{-1} \\mathbf{B}_c + \\mathbf{D}_c,\n\\] or equivalently from the modes of the system: \\[\n\\mathbf{H}(\\omega) = \\mathbf{C}_m (j\\omega \\mathbf{I} - \\mathbf{\\Lambda} )^{-1} \\mathbf{B}_m + \\mathbf{D}_m.\n\\]\nFinally, it should be noted that the FRF can be computed for a given set of response dofs and a given set of excitation dofs by introducing the appropriate selection matrices \\(\\mathbf{S}_o\\) and \\(\\mathbf{S}_e\\). In this case, the FRF is given by: \\[\n\\mathbf{H}_{oe}(\\omega) = \\mathbf{S}_o\\mathbf{H}(\\omega)\\mathbf{S}_e.\n\\]\n\n\n\n\n\n\nNote\n\n\n\n\nFor the admittance : \\(\\mathbf{C}_c = [\\mathbf{I},\\quad \\mathbf{0}]\\) and \\(\\mathbf{D}_c = \\mathbf{0}\\).\nFor the mobility : \\(\\mathbf{C}_c = [\\mathbf{0}, \\quad \\mathbf{I}]\\) and \\(\\mathbf{D}_c = \\mathbf{0}\\).\nFor the accelerance, \\(\\mathbf{C}_c = \\mathbf{A}_c[m:\\text{end}, :]\\) and \\(\\mathbf{D}_c = \\mathbf{B}_c[m:\\text{end}, :]\\) with \\(m = N/2\\) (this corresponds to a rewrite of the equation of motion).\n\n\n\n\n2.1.1 API\nData types\n\nStateSpaceFRFProblem\n\n\n\nStateSpaceFRFProblem(css::ContinuousStateSpace, freq, type, So, Se)\nStructure containing the data feeding the direct solver for calculating an FRF\nFields\n\ncss: Continuous-time state space model\n\nfreq: Frequencies of interest\n\nSo: Selection matrix for observation points\n\nSe: Selection matrix for excitation points\n\n\nNote It is assumed that the output equation is of the form y = So*x\n\n\n\n\n\n\n\nStateSpaceModalFRFProblem\n\n\n\nStateSpacemodalFRFProblem(css::ContinuousStateSpace, freq, type, So, Se, n)\nStructure containing the data feeding the direct solver for calculating an FRF\nFields\n\ncss: Continuous-time state space model\n\nfreq: Frequencies of interest\n\nSo: Selection matrix for observation points\n\nSe: Selection matrix for excitation points\n\nn: Number of mode pairs to keep in the modal basis (default = size(css.Ac, 2) ÷ 2)\n\n\n\n\n\n\n\n\nRelated function\n\nsolve\n\n\n\nsolve(prob::StateSpaceFRFProblem; type = :dis, progress = true)\nsolve(prob::StateSpaceModalFRFProblem; type = :dis, progress = true)\nComputes the FRF matrix by direct or modal method\nInputs\n\nprob: Structure containing the problem data\n\ntype: Type of FRF to compute\n\n:dis: Admittance\n\n:vel: Mobility\n\n:acc: Accelerance\n\n\n\nprogress: Show progress bar (default = true)\n\n\nOutput\n\nsol: FRFSolution structure\n\nu: FRF matrix\n\n\n\n\n\n\n\n\n\n\n\n\n2.1.2 Example\n\n# Structural parameters\nM = Diagonal([2., 1.])\nK = [6. -2.; -2. 4.]\nξ = 0.05\n\nω, Φ = eigenmode(K, M)\nC = modal_damping_matrix(M, ω, ξ, Φ)\n\n# State-space model\ncss = ss_model(K, M, C)\n\n# Frequency vector\nfreq = 0.01:0.001:1.\n\n# Problem definition - Case 1 - Direct\nprob_frf = StateSpaceFRFProblem(css, freq)\nH_direct = solve(prob_frf).u\n\n# Problem definition - Case 2 - Modal\nprob_frf_modal = StateSpaceModalFRFProblem(css, freq)\nH_modal = solve(prob_frf_modal).u\n\n\n\n\n\n\n\n\n\n2.2 Response spectrum\nSimilarly to the FRF, the response spectrum is a complex function that describes the steady-state response of a system to a sinusoidal input. From the state-space representation, the response spectrum of the system at a given angular frequency \\(\\omega\\) is given by: \\[\n\\mathbf{y}(\\omega) = \\left[\\mathbf{C}_c (j\\omega \\mathbf{I} - \\mathbf{A}_c)^{-1} \\mathbf{B}_c + \\mathbf{D}_c\\right] \\mathbf{u}(\\omega),\n\\] or equivalently from the modes of the system: \\[\n\\mathbf{y}(\\omega) = \\left[\\mathbf{C}_m (j\\omega \\mathbf{I} - \\mathbf{\\Lambda} )^{-1} \\mathbf{B}_m + \\mathbf{D}_m\\right] \\mathbf{u}(\\omega).\n\\]\n\n2.2.1 API\n\nStateSpaceFreqProblem\n\n\n\nStateSpaceFreqProblem(css::ContinuousStateSpace, F, freq, So)\nStructure containing the data feeding the modal solver for calculating the frequency response\nFields\n\ncss: Continuous-time state space model\n\nF: External force matrix\n\nfreq: Frequencies of interest\n\nSo: Selection matrix for observation points\n\n\n\n\n\n\n\n\n\nStateSpaceModalFreqProblem\n\n\n\nStateSpaceModalFreqProblem(css::ContinuousStateSpace, F, freq, So, n)\nStructure containing the data feeding the modal solver for calculating the frequency response\nFields\n\ncss: Continuous-time state space model\n\nF: External force matrix\n\nfreq: Frequencies of interest\n\nSo: Selection matrix for observation points\n\nn: Number of mode pairs to keep in the modal basis (default = size(css.Ac, 2) ÷ 2)\n\n\n\n\n\n\n\n\nRelated function\n\nsolve\n\n\n\nsolve(prob::StateSpaceFreqProblem; type = :dis, progress = true)\nsolve(prob::StateSpaceFreqProblem; type = :dis, progress = true)\nComputes the frequency response by direct or modal method\nInputs\n\nprob: Structure containing the problem data\n\ntype::Symbol: Type of FRF to compute\n\n:dis: Displacement\n\n:vel: Velocity\n\n:acc: Acceleration\n\n\n\nprogress: Show progress bar\n\n\nOutput sol: Solution of the problem     * u: Response spectrum matrix\n\n\n\n\n\n\n\n\n2.2.2 Example\n\n# Structural parameters\nM = Diagonal([2., 1.])\nK = [6. -2.; -2. 4.]\nξ = 0.05\n\nω, Φ = eigenmode(K, M)\nC = modal_damping_matrix(M, ω, ξ, Φ)\n\n# State-space model\ncss = ss_model(K, M, C)\n\n# Frequency vector\nfreq = 0.01:0.001:1.\n\n# Force matrix\nF = zeros(2, length(freq))\nF[1, :] .= 10.\n\n# Problem definition - Case 1 - Direct\nprob_freq = StateSpaceFreqProblem(css, F, freq)\ny_freq = solve(prob_freq).u\n\n# Problem definition - Case 2 - Modal\nprob_freq_modal = StateSpaceModalFreqProblem(css, F, freq)\ny_freq_modal = solve(prob_freq_modal).u",
    "crumbs": [
      "Solvers",
      "State-space solvers"
    ]
  },
  {
    "objectID": "models/index.html",
    "href": "models/index.html",
    "title": "Mechanical models",
    "section": "",
    "text": "Longitudinal bars, torsional rods and strings are governed by the wave equation, which can be written under the following form: \\[\nm \\ddot y(x, t) - D \\frac{\\partial^2 y(x,t)}{\\partial x^2} = p(x, t),\n\\] where:\n\n\\(y(x, t)\\): Kinematic data at location \\(x\\) and time \\(t\\)\n\\(p(x, t)\\): External excitation term\n\\(m\\): Linear inertia of the type\n\\(D\\): Stiffness of the type\n\nFor a longitudinal bar:\n\n\\(y(x, t) = u(x, t)\\)\n\n\\(u(x, t)\\): Longitudinal displacement [m]\n\n\\(p(x, t)\\): Distributed longitudinal force [N/m]\n\\(m = \\rho S\\): Linear mass density [kg/m2]\n\n\\(\\rho\\): Mass density [kg/m3]\n\\(S\\): Cross-section area [m2]\n\n\\(D = E S\\): Longitudinal stiffness [N]\n\n\\(E\\): Young’s modulus [Pa]\n\n\nFor a torsional rod:\n\n\\(y(x, t) = \\theta(x, t)\\)\n\n\\(\\theta\\): Torsion angle [rad]\n\n\\(p(x, t)\\): Distributed moment [N.m/m]\n\\(m = \\rho I_G\\): Linear rotational inertia [kg.m4]\n\n\\(I_G\\): Polar moment of area [m4]\n\n\\(D = G J_T\\): Rotational stiffness [N.m2]\n\n\\(G\\): Shear modulus [Pa]\n\\(J_T\\): Torsion constant [m4]\n\n\nFor a string:\n\n\\(y(x, y)\\): Transverse displacement [m]\n\\(m\\): Linear mass density [kg/m]\n\\(D\\): Tension force [N]\n\n\n\n\nEuler-Bernoulli beams are governed by the following equation of motion: \\[\nm\\ddot v(x, t) + D\\frac{\\partial^4 v(x, t)}{\\partial x^4} = p(x, t),\n\\] where:\n\n\\(v(x, t)\\): Transverse displacement [m]\n\\(p(x, t)\\): External excitation term [N/m]\n\\(m = \\rho S\\): Linear mass density [kg/m]\n\\(D = E I_z\\): Bending stiffness [N.m2]\n\n\\(I_z\\): Second moment of area [m4]\n\n\n\n\n\nData types\nAll the following data types are a subtype of the super type OneDtype.\n\nBar\n\n\n\nBar(L, S, E, ρ)\nStructure containing the data of a homogeneous and isotropic longitudinal bar\nConstructor parameters\n\nL: Length [m]\n\nS: Cross-section area [m²]\n\nE: Young's modulus [Pa]\n\nρ: Mass density [kg/m³]\n\n\nFields\n\nL: Length [m]\n\nm: Line mass [kg/m]\n\nD: Stiffness coefficient [Pa]\n\n\n\n\n\n\n\n\n\nRod\n\n\n\nRod(L, I, J, G, ρ)\nStructure containing the data of a homogeneous and isotropic torsional bar\nConstructor parameters\n\nL: Length [m]\n\nI: Second-moment of area [m⁴]\n\nJ: Torsion constant [m⁴]\n\nG: Shear modulus [Pa]\n\nρ: Mass density [kg/m³]\n\n\nFields\n\nL: Length [m]\n\nm: Line mass [kg/m]\n\nD: Stiffness coefficient [Pa]\n\n\n\n\n\n\n\n\n\nStrings\n\n\n\nStrings(L, S, D, ρ)\nStructure containing the data of a homogeneous and isotropic string\nConstructor parameters\n\nL: Length [m]\n\nS: Cross-section area [m²]\n\nD: Tension [N]\n\nρ: Mass density [kg/m³]\n\n\nFields\n\nL: Length [m]\n\nm: Linear mass density [kg/m]\n\nD: Tension [N]\n\n\n\n\n\n\n\n\n\nBeam\n\n\n\nBeam(L, S, I, E, ρ)\nStructure containing the data of a homogeneous and isotropic bending beam\nConstructor parameters\n\nL: Length [m]\n\nS: Cross-section area [m²]\n\nI: Second moment of area [m⁴]\n\nE: Young's modulus [Pa]\n\nρ: Density [kg/m³]\n\n\nFields\n\nL: Length [m]\n\nM: Linear mass density [kg/m]\n\nD: Bending stiffness [N.m²]\n\n\n\n\n\n\n\n\nRelated functions\n\nmodefreq\n\n\n\nmodefreq(model::Bar, fmax, bc = :CC)\nmodefreq(model::Rod, fmax, bc = :CC)\nmodefreq(model::Strings, fmax, bc = :CC)\nmodefreq(model::Beam, fmax, bc = :SS)\nComputes the natural frequencies of a longitudinal or torsional bar up to fmax\nInputs\n\nmodel: Structure containing the bar data\n\nfmax: Maximum frequency for calculating the mode shapes [Hz]\n\nbc: Boundary conditions\n\nFor all OneDStructure\n\n:CC: Clamped - Clamped\n\n:CF: Clamped - Free\n\n:FF: Free - Free\n\n\n\nFor beams\n\n:SS: Simply Supported - Simply Supported\n\n:SC: Simply Supported - Clamped\n\n:SF: Simply Supported - Free\n\n\n\n\n\n\nOutputs\n\nωn: Natural frequencies calculated up to ωmax = 2π*fmax [Hz]\n\nkn: Vector of modal wavenumbers\n\n\n\n\n\n\n\n\n\nmodeshape\n\n\n\nmodeshape(model::Bar, kn, x, bc = :CC)\nmodeshape(model::Rod, kn, x, bc = :CC)\nmodeshape(model::Strings, kn, x, bc = :CC)\nmodeshape(model::Beam, kn, x, bc = :SS)\nComputes the mass-normalized mode shapes of a longitudinal or torsional bar\nInputs\n\nmodel: Structure containing the bar data\n\nkn: Array of modal wavenumbers\n\nx: Coordinates of calculation points of the mode shapes\n\nbc: Boundary conditions\n\nFor all OneDStructure\n\n:CC: Clamped - Clamped\n\n:CF: Clamped - Free\n\n:FF: Free - Free\n\n\n\nFor beams\n\n:SS: Simply Supported - Simply Supported\n\n:SC: Simply Supported - Clamped\n\n:SF: Simply Supported - Free\n\n\n\n\n\n\nOutput\n\nϕ: Mass-normalized mode shapes\n\n\n\n\n\n\n\n\n\n\n\n# Dimensions\nL = 1.\nd = 3e-2\n\n# Section features\nS = π*d^2/4\nIz = π*d^4/64\nIG = 2Iz\nJ = IG\n\n# Tension for string\nT = 5000.\n\n# Material\nE = 2.1e11\nν = 0.33\nG = E/(1 - 2*ν)\nρ = 7800.\n\n# Computation parameters\nx = [0.1, 0.9]\n\n# Initialization of the data types\nbar = Bar(L, S, E, ρ)\nrod = Rod(L, IG, J, G, ρ)\nstrings = Strings(L, S, T, ρ)\nbeam = Beam(L, S, Iz, E, ρ)\n\n# Computation of the natural frequencies\nω_bar, k_bar = modefreq(bar, 10_000.)\nω_rod, k_rod = modefreq(rod, 10_000.)\nω_strings, k_strings = modefreq(strings, 100.)\nω_beam, k_beam = modefreq(beam, 2000.)\n\n# Computation of the corresponding mode shapes\nϕ_bar = modeshape(bar, k_bar, x, :CC)\nϕ_rod = modeshape(rod, k_rod, x, :FF)\nϕ_strings = modeshape(strings, k_strings, x, :CC)\nϕ_beam = modeshape(beam, k_beam, x, :SS)\n\n\n\n\n\n\nRectangular membranes are governed by the following equation of motion: \\[\nm \\ddot w(x, y ,t) + D\\Delta w(x, y, t) = p(x, y, t),\n\\] where:\n\n\\(w(x, y, t)\\): Transverse displacement [m] at point \\((x, y)\\) and time \\(t\\)\n\\(m\\): Surface mass [kg/m]\n\\(D = \\tau\\): Linear tension [N/m]\n\\(\\Delta = \\frac{\\partial^2}{\\partial x^2} + \\frac{\\partial^2}{\\partial y^2}\\): Laplacian operator\n\n\n\n\nRectangular Kirchhoff-Love plates are governed by the following equation of motion: \\[\nm \\ddot w(x, y, t) + D \\Delta^2 w(x, y, t) = p(x, y, t),\n\\] where:\n\n\\(w(x, y, t)\\): Transverse displacement [m] at point \\((x, y)\\) and time \\(t\\)\n\\(m = \\rho h\\): Surface mass [kg/m2]\n\n\\(h\\): Thickness [m]\n\n\\(D = \\frac{Eh^3}{12(1 - \\nu^2)}\\): Bending stiffness [N.m]\n\n\\(\\nu\\): Poisson’s coefficient\n\n\\(\\Delta^2 = \\frac{\\partial^4}{\\partial x^4} + 2\\frac{\\partial^4}{\\partial x^2 \\partial y^2} + \\frac{\\partial^4}{\\partial y^4}\\): Bilaplacian operator\n\n\n\n\nData type\nAll the following data types are a subtype of the super type TwoDStructure.\n\nMembrane\n\n\n\nMembrane(L, b, m, D)\nStructure containing the data of a homogeneous and isotropic rectangular membrane\nFields\n\nL: Length [m]\n\nb: Width [m]\n\nm: Surface mass [kg/m²]\n\nD: Tension per unit length [N/m]\n\n\n\n\n\n\n\n\n\nPlate\n\n\n\nPlate(L, b, h, E, ρ, ν)\nStructure containing the data of a homogeneous and isotropic bending plate\nConstructor parameters\n\nL: Length [m]\n\nb: Width [m]\n\nE: Young's modulus [Pa]\n\nρ: Density [kg/m³]\n\nν: Poisson's ratio\n\n\nFields\n\nL: Length [m]\n\nb: Width [m]\n\nm: Surface mass [kg/m²]\n\nD: Bending stiffness [N.m]\n\n\n\n\n\n\n\n\nRelated functions\n\nmodefreq\n\n\n\nmodefreq(model::Plate, fmax)\nmodefreq(model::Membrane, fmax)\nComputes the natural frequencies of a simply supported rectangular plate or a clamped rectangular membrane up to fmax\nInputs\n\nmodel: Structure containing the data related to the plate\n\nfmax: Maximum frequency for calculating the modal shapes [Hz]\n\n\nOutputs\n\nωmn: Natural frequencies calculated up to ωmax = 2π*fmax [Hz]\n\nkmn: Matrix of modal wave numbers\n\nind: Matrix of modal indices (m, n)\n\n\n\n\n\n\n\n\n\nmodeshape\n\n\n\nmodeshape(model::Plate, kpq, x, y)\nmodeshape(model::Membrane, kpq, x, y)\nComputes the mass-normalized mode shapes of a simply supported rectangular plate or a clamped rectangular membrane\nInputs\n\nmodel: Structure containing the data related to the structure\n\nkmn: Matrix of modal wave numbers\n\n(x, y): Coordinates of the points where the mode shapes are calculated\n\n\nOutput\n\nϕ: Mass-normalized mode shapes\n\n\n\n\n\n\n\n\n\n\n\n# Dimensions\nLp = 0.6\nbp = 0.4\nhp = 1e-3\n\n# Material parameters\nE = 2.1e11\nρ = 7800.\nν = 0.33\n\n# Computation parameters\nfmax = 500.\nxp = [0.1, 0.5]\nyp = [0.1, 0.3]\n\n# Initialization of the data types\nplate = Plate(Lp, bp, hp, E, ρ, ν)\nmembrane = Membrane(Lp, bp, ρ*hp, 100.)\n\n# Computation of the natural frequencies\nω_plate, k_plate = modefreq(plate, fmax)[1:2]\nω_membrane, k_membrane = modefreq(membrane, fmax)[1:2]\n\n# Computation of the corresponding mode shapes\nϕ_plate = modeshape(plate, k_plate, xp, yp)\nϕ_membrane = modeshape(membrane, k_membrane, xp, yp)",
    "crumbs": [
      "Models",
      "Mechanical models"
    ]
  },
  {
    "objectID": "models/index.html#continuous-models",
    "href": "models/index.html#continuous-models",
    "title": "Mechanical models",
    "section": "",
    "text": "Longitudinal bars, torsional rods and strings are governed by the wave equation, which can be written under the following form: \\[\nm \\ddot y(x, t) - D \\frac{\\partial^2 y(x,t)}{\\partial x^2} = p(x, t),\n\\] where:\n\n\\(y(x, t)\\): Kinematic data at location \\(x\\) and time \\(t\\)\n\\(p(x, t)\\): External excitation term\n\\(m\\): Linear inertia of the type\n\\(D\\): Stiffness of the type\n\nFor a longitudinal bar:\n\n\\(y(x, t) = u(x, t)\\)\n\n\\(u(x, t)\\): Longitudinal displacement [m]\n\n\\(p(x, t)\\): Distributed longitudinal force [N/m]\n\\(m = \\rho S\\): Linear mass density [kg/m2]\n\n\\(\\rho\\): Mass density [kg/m3]\n\\(S\\): Cross-section area [m2]\n\n\\(D = E S\\): Longitudinal stiffness [N]\n\n\\(E\\): Young’s modulus [Pa]\n\n\nFor a torsional rod:\n\n\\(y(x, t) = \\theta(x, t)\\)\n\n\\(\\theta\\): Torsion angle [rad]\n\n\\(p(x, t)\\): Distributed moment [N.m/m]\n\\(m = \\rho I_G\\): Linear rotational inertia [kg.m4]\n\n\\(I_G\\): Polar moment of area [m4]\n\n\\(D = G J_T\\): Rotational stiffness [N.m2]\n\n\\(G\\): Shear modulus [Pa]\n\\(J_T\\): Torsion constant [m4]\n\n\nFor a string:\n\n\\(y(x, y)\\): Transverse displacement [m]\n\\(m\\): Linear mass density [kg/m]\n\\(D\\): Tension force [N]\n\n\n\n\nEuler-Bernoulli beams are governed by the following equation of motion: \\[\nm\\ddot v(x, t) + D\\frac{\\partial^4 v(x, t)}{\\partial x^4} = p(x, t),\n\\] where:\n\n\\(v(x, t)\\): Transverse displacement [m]\n\\(p(x, t)\\): External excitation term [N/m]\n\\(m = \\rho S\\): Linear mass density [kg/m]\n\\(D = E I_z\\): Bending stiffness [N.m2]\n\n\\(I_z\\): Second moment of area [m4]\n\n\n\n\n\nData types\nAll the following data types are a subtype of the super type OneDtype.\n\nBar\n\n\n\nBar(L, S, E, ρ)\nStructure containing the data of a homogeneous and isotropic longitudinal bar\nConstructor parameters\n\nL: Length [m]\n\nS: Cross-section area [m²]\n\nE: Young's modulus [Pa]\n\nρ: Mass density [kg/m³]\n\n\nFields\n\nL: Length [m]\n\nm: Line mass [kg/m]\n\nD: Stiffness coefficient [Pa]\n\n\n\n\n\n\n\n\n\nRod\n\n\n\nRod(L, I, J, G, ρ)\nStructure containing the data of a homogeneous and isotropic torsional bar\nConstructor parameters\n\nL: Length [m]\n\nI: Second-moment of area [m⁴]\n\nJ: Torsion constant [m⁴]\n\nG: Shear modulus [Pa]\n\nρ: Mass density [kg/m³]\n\n\nFields\n\nL: Length [m]\n\nm: Line mass [kg/m]\n\nD: Stiffness coefficient [Pa]\n\n\n\n\n\n\n\n\n\nStrings\n\n\n\nStrings(L, S, D, ρ)\nStructure containing the data of a homogeneous and isotropic string\nConstructor parameters\n\nL: Length [m]\n\nS: Cross-section area [m²]\n\nD: Tension [N]\n\nρ: Mass density [kg/m³]\n\n\nFields\n\nL: Length [m]\n\nm: Linear mass density [kg/m]\n\nD: Tension [N]\n\n\n\n\n\n\n\n\n\nBeam\n\n\n\nBeam(L, S, I, E, ρ)\nStructure containing the data of a homogeneous and isotropic bending beam\nConstructor parameters\n\nL: Length [m]\n\nS: Cross-section area [m²]\n\nI: Second moment of area [m⁴]\n\nE: Young's modulus [Pa]\n\nρ: Density [kg/m³]\n\n\nFields\n\nL: Length [m]\n\nM: Linear mass density [kg/m]\n\nD: Bending stiffness [N.m²]\n\n\n\n\n\n\n\n\nRelated functions\n\nmodefreq\n\n\n\nmodefreq(model::Bar, fmax, bc = :CC)\nmodefreq(model::Rod, fmax, bc = :CC)\nmodefreq(model::Strings, fmax, bc = :CC)\nmodefreq(model::Beam, fmax, bc = :SS)\nComputes the natural frequencies of a longitudinal or torsional bar up to fmax\nInputs\n\nmodel: Structure containing the bar data\n\nfmax: Maximum frequency for calculating the mode shapes [Hz]\n\nbc: Boundary conditions\n\nFor all OneDStructure\n\n:CC: Clamped - Clamped\n\n:CF: Clamped - Free\n\n:FF: Free - Free\n\n\n\nFor beams\n\n:SS: Simply Supported - Simply Supported\n\n:SC: Simply Supported - Clamped\n\n:SF: Simply Supported - Free\n\n\n\n\n\n\nOutputs\n\nωn: Natural frequencies calculated up to ωmax = 2π*fmax [Hz]\n\nkn: Vector of modal wavenumbers\n\n\n\n\n\n\n\n\n\nmodeshape\n\n\n\nmodeshape(model::Bar, kn, x, bc = :CC)\nmodeshape(model::Rod, kn, x, bc = :CC)\nmodeshape(model::Strings, kn, x, bc = :CC)\nmodeshape(model::Beam, kn, x, bc = :SS)\nComputes the mass-normalized mode shapes of a longitudinal or torsional bar\nInputs\n\nmodel: Structure containing the bar data\n\nkn: Array of modal wavenumbers\n\nx: Coordinates of calculation points of the mode shapes\n\nbc: Boundary conditions\n\nFor all OneDStructure\n\n:CC: Clamped - Clamped\n\n:CF: Clamped - Free\n\n:FF: Free - Free\n\n\n\nFor beams\n\n:SS: Simply Supported - Simply Supported\n\n:SC: Simply Supported - Clamped\n\n:SF: Simply Supported - Free\n\n\n\n\n\n\nOutput\n\nϕ: Mass-normalized mode shapes\n\n\n\n\n\n\n\n\n\n\n\n# Dimensions\nL = 1.\nd = 3e-2\n\n# Section features\nS = π*d^2/4\nIz = π*d^4/64\nIG = 2Iz\nJ = IG\n\n# Tension for string\nT = 5000.\n\n# Material\nE = 2.1e11\nν = 0.33\nG = E/(1 - 2*ν)\nρ = 7800.\n\n# Computation parameters\nx = [0.1, 0.9]\n\n# Initialization of the data types\nbar = Bar(L, S, E, ρ)\nrod = Rod(L, IG, J, G, ρ)\nstrings = Strings(L, S, T, ρ)\nbeam = Beam(L, S, Iz, E, ρ)\n\n# Computation of the natural frequencies\nω_bar, k_bar = modefreq(bar, 10_000.)\nω_rod, k_rod = modefreq(rod, 10_000.)\nω_strings, k_strings = modefreq(strings, 100.)\nω_beam, k_beam = modefreq(beam, 2000.)\n\n# Computation of the corresponding mode shapes\nϕ_bar = modeshape(bar, k_bar, x, :CC)\nϕ_rod = modeshape(rod, k_rod, x, :FF)\nϕ_strings = modeshape(strings, k_strings, x, :CC)\nϕ_beam = modeshape(beam, k_beam, x, :SS)\n\n\n\n\n\n\nRectangular membranes are governed by the following equation of motion: \\[\nm \\ddot w(x, y ,t) + D\\Delta w(x, y, t) = p(x, y, t),\n\\] where:\n\n\\(w(x, y, t)\\): Transverse displacement [m] at point \\((x, y)\\) and time \\(t\\)\n\\(m\\): Surface mass [kg/m]\n\\(D = \\tau\\): Linear tension [N/m]\n\\(\\Delta = \\frac{\\partial^2}{\\partial x^2} + \\frac{\\partial^2}{\\partial y^2}\\): Laplacian operator\n\n\n\n\nRectangular Kirchhoff-Love plates are governed by the following equation of motion: \\[\nm \\ddot w(x, y, t) + D \\Delta^2 w(x, y, t) = p(x, y, t),\n\\] where:\n\n\\(w(x, y, t)\\): Transverse displacement [m] at point \\((x, y)\\) and time \\(t\\)\n\\(m = \\rho h\\): Surface mass [kg/m2]\n\n\\(h\\): Thickness [m]\n\n\\(D = \\frac{Eh^3}{12(1 - \\nu^2)}\\): Bending stiffness [N.m]\n\n\\(\\nu\\): Poisson’s coefficient\n\n\\(\\Delta^2 = \\frac{\\partial^4}{\\partial x^4} + 2\\frac{\\partial^4}{\\partial x^2 \\partial y^2} + \\frac{\\partial^4}{\\partial y^4}\\): Bilaplacian operator\n\n\n\n\nData type\nAll the following data types are a subtype of the super type TwoDStructure.\n\nMembrane\n\n\n\nMembrane(L, b, m, D)\nStructure containing the data of a homogeneous and isotropic rectangular membrane\nFields\n\nL: Length [m]\n\nb: Width [m]\n\nm: Surface mass [kg/m²]\n\nD: Tension per unit length [N/m]\n\n\n\n\n\n\n\n\n\nPlate\n\n\n\nPlate(L, b, h, E, ρ, ν)\nStructure containing the data of a homogeneous and isotropic bending plate\nConstructor parameters\n\nL: Length [m]\n\nb: Width [m]\n\nE: Young's modulus [Pa]\n\nρ: Density [kg/m³]\n\nν: Poisson's ratio\n\n\nFields\n\nL: Length [m]\n\nb: Width [m]\n\nm: Surface mass [kg/m²]\n\nD: Bending stiffness [N.m]\n\n\n\n\n\n\n\n\nRelated functions\n\nmodefreq\n\n\n\nmodefreq(model::Plate, fmax)\nmodefreq(model::Membrane, fmax)\nComputes the natural frequencies of a simply supported rectangular plate or a clamped rectangular membrane up to fmax\nInputs\n\nmodel: Structure containing the data related to the plate\n\nfmax: Maximum frequency for calculating the modal shapes [Hz]\n\n\nOutputs\n\nωmn: Natural frequencies calculated up to ωmax = 2π*fmax [Hz]\n\nkmn: Matrix of modal wave numbers\n\nind: Matrix of modal indices (m, n)\n\n\n\n\n\n\n\n\n\nmodeshape\n\n\n\nmodeshape(model::Plate, kpq, x, y)\nmodeshape(model::Membrane, kpq, x, y)\nComputes the mass-normalized mode shapes of a simply supported rectangular plate or a clamped rectangular membrane\nInputs\n\nmodel: Structure containing the data related to the structure\n\nkmn: Matrix of modal wave numbers\n\n(x, y): Coordinates of the points where the mode shapes are calculated\n\n\nOutput\n\nϕ: Mass-normalized mode shapes\n\n\n\n\n\n\n\n\n\n\n\n# Dimensions\nLp = 0.6\nbp = 0.4\nhp = 1e-3\n\n# Material parameters\nE = 2.1e11\nρ = 7800.\nν = 0.33\n\n# Computation parameters\nfmax = 500.\nxp = [0.1, 0.5]\nyp = [0.1, 0.3]\n\n# Initialization of the data types\nplate = Plate(Lp, bp, hp, E, ρ, ν)\nmembrane = Membrane(Lp, bp, ρ*hp, 100.)\n\n# Computation of the natural frequencies\nω_plate, k_plate = modefreq(plate, fmax)[1:2]\nω_membrane, k_membrane = modefreq(membrane, fmax)[1:2]\n\n# Computation of the corresponding mode shapes\nϕ_plate = modeshape(plate, k_plate, xp, yp)\nϕ_membrane = modeshape(membrane, k_membrane, xp, yp)",
    "crumbs": [
      "Models",
      "Mechanical models"
    ]
  },
  {
    "objectID": "models/index.html#discrete-models",
    "href": "models/index.html#discrete-models",
    "title": "Mechanical models",
    "section": "2 Discrete models",
    "text": "2 Discrete models\n\n2.1 Sdof systems\nSingle degree of freedom (Sdof) systems are classically composed of a mass \\(m\\), a stiffness \\(k\\) and a viscous damper \\(c\\) (see Figure 1).\n\n\n\n\n\n\nFigure 1: Classical representation of an Sdof system\n\n\n\nMathematically, their dynamic behavior is governed by the following normalized equation of motion : \\[\n\\ddot x(t) + 2\\xi\\,\\omega_0\\, \\dot x(t) + \\omega_0^2 x(t) = \\frac{F(t)}{m}.\n\\] where \\(F(t)\\) can be either a base or an external excitation applied to the system.\nThe Sdof system can thus be defined by:\n\nits mass \\(m\\)\nits natural angular frequency \\(\\omega_0\\) (or its natural frequency \\(f_0\\))\nits damping ratio \\(\\xi\\)\n\n\n2.1.1 API\n\nSdof\n\n\n\nSdof(m, ω0, ξ)\nStructure containing the data of a sdof system\nConstructor\n\nm: Mass [kg]\n\nf0: Natural frequency [Hz]\n\nξ: Damping ratio\n\n\nFields\n\nm: Mass [kg]\n\nω0: Natural frequency [rad/s]\n\nξ: Damping ratio\n\n\n\n\n\n\n\n\n\n\n2.1.2 Example\n# Definition of the structural parameters\nm = 1.\nf₀ = 10.\nξ = 0.01\n\n# Initialization of Sdof\nsdof = Sdof(m, f₀, ξ)\n\n\n\n2.2 Mdof systems\nStructuralVibration.jl considers Multi-degrees of freedom (Mdof) systems, which topology is presented in Figure 2. This choice has been made, because it allows modeling a large variety of possible configurations.\n\n\n\n\n\n\nFigure 2: General topology of an Mdof system\n\n\n\nThe dynamic behavior of such a system is governed by the following matrix system: \\[\n\\mathbf{M} \\ddot{\\mathbf{x}}(t) + \\mathbf{K}\\mathbf{x}(t) = \\mathbf{f}(t),\n\\] where:\n\n\\(\\mathbf{M} = \\text{diag}(m_1, \\dots, m_j, \\dots, m_N)\\) is the mass matrix.\n\\(\\mathbf{K}\\) is the stiffness matrix such that: \\[\n\\mathbf{K} = \\begin{bmatrix}\nk_1 & -k_1 & 0 & \\ldots & 0 & 0 \\\\\n-k_1 & k_1 + k_2 & -k_2 & \\ddots & \\vdots & \\vdots \\\\\n0 & -k_2 & \\ddots & \\ddots & 0 & \\vdots \\\\\n\\vdots & 0 & \\ddots & \\ddots & -k_{N-1} & 0 \\\\\n\\vdots & \\vdots & \\ddots & -k_{N-1} & k_{N-1} + k_N & -k_N \\\\\n0 & 0 & \\ldots & 0 & -k_N & k_N\n\\end{bmatrix}.\n\\]\n\\(\\mathbf{x}(t) = \\left[x_1(t), \\dots, x_j(t), \\dots, x_N(t)\\right]^\\mathsf{T}\\) is the displacement vector.\n\\(\\mathbf{f}(t) = \\left[F_1(t), \\dots, F_j(t), \\dots, F_N(t)\\right]^\\mathsf{T}\\) is the external force vector.\n\n\n2.2.1 API\nData types\n\nMdof\n\n\n\nMdof(k, m, c = Float64[])\nStructure containing the data for building a mdof system\nFields\n\nk: Stiffness coefficients of the spring elements\n\nm: Masses of the mdof system\n\nc: Damping coefficients of the viscous dampers\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteAbout the damping matrix C\n\n\n\n\n\nIf viscous dampers are defined, the damping matrix \\(\\mathbf{C}\\) is consistent with the stiffness matrix \\(\\mathbf{K}\\), meaning that: \\[\n\\mathbf{C} = \\begin{bmatrix}\nc_1 & -c_1 & 0 & \\ldots & 0 & 0 \\\\\n-c_1 & c_1 + c_2 & -c_2 & \\ddots & \\vdots & \\vdots \\\\\n0 & -k_2 & \\ddots & \\ddots & 0 & \\vdots \\\\\n\\vdots & 0 & \\ddots & \\ddots & -c_{N-1} & 0 \\\\\n\\vdots & \\vdots & \\ddots & -c_{N-1} & c_{N-1} + c_N & -c_N \\\\\n0 & 0 & \\ldots & 0 & -c_N & c_N\n\\end{bmatrix}.\n\\]\n\n\n\n\n\nMdofMesh\n\n\n\nMdofMesh(Elt, constrained_dofs, free_dofs)\nStructure containing the data for building a mdof mesh\nConstructor\n\nmodel: Mdof model\n\nbc: Boundary conditions\n\n:CC: Clamped - Clamped\n\n:CF: Clamped - Free\n\n:FF: Free - Free\n\n\n\n\nFields\n\nElt: Element connectivity matrix\n\nconstrained_dofs: Constrained degrees of freedom\n\nfree_dofs: Free degrees of freedom\n\n\n\n\n\n\n\n\nRelated functions\n\nassembly\n\n\n\nassembly(model::Mdof)\nAssembly of the mass, stiffness and damping matrices of a mdof system\nInput\n\nmodel: Mdof model\n\n\nOutputs\n\nK: Stiffness matrix\n\nM: Mass matrix\n\nC: Damping matrix (if viscous dampers are defined in model)\n\n\n\n\n\n\n\n\n\napply_bc\n\n\n\napply_bc(A, mesh)\nApply boundary conditions to a given matrix\nInputs\n\nA: Matrix to apply the boundary conditions\n\nmesh: Mesh of the system\n\n\nOutput\n\nA_bc: Matrix with boundary conditions applied\n\n\n\n\n\n\n\n\n\neigenmode\n\n\n\neigenmode(K, M, n = size(K, 1))\nComputes the eigenmodes of a system defined by its mass and stiffness matrices.\nInputs\n\nK: Stiffness matrix\n\nM: Mass matrix\n\nn: Number of modes to be keep in the modal basis\n\n\nOutputs\n\nω: Vector of natural frequencies\n\nΦ: Mass-normalized mode shapes\n\n\n\n\n\n\n\n\n\nmodal_matrices\n\n\n\nmodal_matrices(ωn, ξn)\nComputes the modal mass, stiffness, and damping matrices\nInputs\n\nωn: Vector of natural frequencies\n\nξn: Modal damping\n\n\nOutputs\n\nKn: Generalized stiffness matrix\n\nMn: Generalized mass matrix (identity matrix, due to mass normalization)\n\nCn: Generalized damping matrix\n\n\n\n\n\n\n\n\n\nmodal_effective_mass\n\n\n\nmodal_effective_mass(M, ϕn, r)\nComputes the effective mass of a mode\nInputs\n\nM: Mass matrix\n\nϕn: Mode shape\n\nr: Influence vector (rigid body mode)\n\n\nOutputs\n\nmeff: Modal effective mass\n\n\nNote: The modeshapes are supposed to be mass-normalized\n\n\n\n\n\n\n\n\n2.2.2 Example\n# Definition of the structural parameters\nk_mdof = [1., 1.]\nm_mdof = ones(3)\nc_mdof = [0.1, 0.1]\n\n# Initialization of Mdof\nmdof = Mdof(k_mdof, m_mdof, c_mdof)\n\n# Definition of a MdofMesh\nmdof_mesh = MdofMesh(mdof, :CF)\n\n# System assembly\nK_mdof, M_mdof, C_mdof = assembly(mdof)\n\n# Apply boundary conditions (if any)\nK_bc = apply_bc(K_mdof, mdof_mesh)\nM_bc = apply_bc(M_mdof, mdof_mesh)\nC_bc = apply_bc(C_mdof, mdof_mesh)\n\n# Compute the eigenmodes of the systems\nωn, Φn = eigenmode(K_bc, M_bc)\n\n# Computation of the modal matrices\nKmodal, Mmodal, Cmodal = modal_matrices(ωn, 0.01)\n\n# Computation of modal effective mass\nmeff = modal_effective_mass(M_bc, Φn, ones(2))\n\n\n\n2.3 FE model\nFinite element models are available for the 1D continuous systems defined in Section 1.1.\n\n2.3.1 API\nData type\n\nOneDMesh\n\n\n\nOneDMesh(model, xmin, Nelt, bc)\nConstruct a mesh for a beam with Nelt elements, length L and starting at xmin.\nConstructor parameters\n\nmodel: Structure containing the data related to the 1D system\n\nxmin: starting position of the beam\n\nNelt: number of elements\n\nbc: Boundary conditions type\n\n:CC: Clamped - Clamped\n\n:FF: Free - Free\n\n:CF: Clamped - Free\n\n:SS: Simply Supported - Simply Supported (specific to beam)\n\n:CS: Clamped - Simply Supported (specific to beam)\n\n:SF: Simply Supported - Free (specific to beam)\n\n\n\n\nFields\n\nxmin: Starting position of the beam\n\nL: Length of the beam\n\nNodes: Node coordinates\n\nElt: Elements of the mesh\n\nNdof_per_node`: Number of degrees of freedom per node\n\nelem_size: Size of the elements\n\nconstrained_dofs: Constrained degrees of freedom\n\nfree_dofs: Free degrees of freedom\n\n\n\n\n\n\n\n\nRelated functions\n\nassemby\n\n\n\nassembly(model::OneDStructure, mesh::OneDMesh)\nCompute the global stiffness and mass matrices for a 1D structure with a given mesh.\nInputs\n\nmodel: OneDStructure\n\nBeam: Beam model\n\nWaveEquation: Bar, Rod or String model\n\n\n\nmesh: OneDMesh\n\n\nOutputs\n\nK: global stiffness matrix\n\nM: global mass matrix\n\n\n\n\n\n\n\n\n\nrayleigh_damping_matrix\n\n\n\nrayleigh_damping_matrix(M, K, α, β)\nrayleigh_damping_matrix(M, K, ω1, ω2, ξ1, ξ2)\nCompute the Rayleigh damping matrix for a given stiffness and mass matrices\nInputs\n\nM: Mass matrix\n\nK: Stiffness matrix\n\nConstruction parameters\n\nMethod 1\n\nα: Mass proportional damping coefficient\n\nβ: Stiffness proportional damping coefficient\n\n\n\nMethod 2\n\nω1: First natural frequency\n\nω2: Second natural frequency\n\nξ1: Damping ratio for the first natural frequency\n\nξ2: Damping ratio for the second natural frequency\n\n\n\n\n\n\nOutput\n\nC: Rayleigh damping matrix\n\n\n\n\n\n\n\n\n\nmodal_damping_matrix\n\n\n\nmodal_damping_matrix(M, ωn, ξn, Φn)\nCompute the damping matrix C from modal parameters\nInputs\n\nM: Mass matrix\n\nωn: Natural angular frequencies\n\nξn: Damping ratios\n\nΦn: Mass-normalized mode shapes\n\n\nOutput\n\nC: Damping matrix\n\n\n\n\n\n\n\n\n\nSelection matrix\n\n\n\nselection_matrix(mesh, selected_dofs)\nCompute the selection matrix for the selected dofs.\nInputs\n\nmesh: OneDmesh\n\nselected_dofs: Selected dofs\n\n\nOutput\n\nS: Selection matrix\n\n\n\n\n\n\n\n\n\napply_bc - See Section 2.2.1.\n\n\neigenmode - See Section 2.2.1.\n\n\nmodal_matrices - See Section 2.2.1.\n\n\nmodal_effective_mass - See Section 2.2.1.\n\n\n\n2.3.2 Example\n# Dimensions\nL = 1.\nd = 3e-2\n\n# Section features\nS = π*d^2/4\nIz = π*d^4/64\n\n# Material\nE = 2.1e11\nρ = 7800.\n\n# Computation parameters\nfmax = 2000.\n\n# Initialization of the data types\nbeam = Beam(L, S, Iz, E, ρ)\n\n# Mesh definition\noned_mesh = OneDMesh(beam, 0., 20, :SS)\n\n# Construction of K and M\nKfe, Mfe = assembly(beam, oned_mesh)\n\n# Application of the BCs\nKbc = apply_bc(Kfe, oned_mesh)\nMbc = apply_bc(Mfe, oned_mesh)\n\n# Computation ofthe eigenmodes of the structure\nωfe, Φfe = eigenmode(Kbc, Mbc)\n\n# Calculation of the damping matrix\nCray = rayleigh_damping_matrix(Mbc, Kbc, 1., 1.)\nCmodal = modal_damping_matrix(Mbc, ωfe, 0.01, Φfe)",
    "crumbs": [
      "Models",
      "Mechanical models"
    ]
  },
  {
    "objectID": "models/index.html#state-space-representation",
    "href": "models/index.html#state-space-representation",
    "title": "Mechanical models",
    "section": "3 State space representation",
    "text": "3 State space representation\nThe state space representation of a mechanical system is expressed as: \\[\n\\dot{\\mathbf{z}}(t) = \\mathbf{A}_c \\mathbf{z}(t) + \\mathbf{B}_c \\mathbf{u}(t),\n\\] where:\n\n\\(\\mathbf{z}(t)\\): State vector\n\\(\\mathbf{u}(t)\\): Input vector\n\\(\\mathbf{A}_c\\): System matrix\n\\(\\mathbf{B}_c\\): Input matrix\n\n\n3.1 Continuous-time models\nFor a mechanical system, whose equation of motion is: \\[\n\\mathbf{M}\\ddot{\\mathbf{x}}(t) + \\mathbf{C}\\dot{\\mathbf{x}}(t) + \\mathbf{K x}(t) = \\mathbf{u}(t),\n\\] the corresponding continuous-time state equation is given by: \\[\n\\begin{bmatrix}\n\\dot{\\mathbf{x}}(t) \\\\\n\\ddot{\\mathbf{x}}(t)\n\\end{bmatrix} = \\begin{bmatrix}\n\\mathbf{0} & \\mathbf{I} \\\\\n-\\mathbf{M}^{-1}\\mathbf{K} & -\\mathbf{M}^{-1}\\mathbf{C}\n\\end{bmatrix}\\begin{bmatrix}\n\\mathbf{x}(t) \\\\\n\\dot{\\mathbf{x}}(t)\n\\end{bmatrix}+ \\begin{bmatrix}\n\\mathbf{0} \\\\\n\\mathbf{M}^{-1}\n\\end{bmatrix}\\mathbf{u}(t).\n\\]\nWhen using a modal expansion such that \\[\n\\mathbf{x}(t) = \\mathbf{\\Phi}\\mathbf{q}(t),\n\\] where \\(\\mathbf{\\Phi}\\) is the mode shapes matrix and \\(\\mathbf{q}(t)\\) is the modal coordinate vector, a modal state space equation can be obtained. The latter is written: \\[\n\\begin{bmatrix}\n\\dot{\\mathbf{q}}(t) \\\\\n\\ddot{\\mathbf{q}}(t)\n\\end{bmatrix} = \\begin{bmatrix}\n\\mathbf{0} & \\mathbf{I} \\\\\n-\\mathbf{\\Omega}^2 & -\\mathbf{\\Xi}\n\\end{bmatrix}\\begin{bmatrix}\n\\mathbf{q}(t) \\\\\n\\dot{\\mathbf{q}}(t)\n\\end{bmatrix}+ \\begin{bmatrix}\n\\mathbf{0} \\\\\n\\mathbf{\\Phi}^\\mathsf{T}\n\\end{bmatrix}\\mathbf{u}(t),\n\\] where \\(\\mathbf{\\Omega}^2 = \\text{diag}(\\omega_1^2, \\dots, \\omega_N^2)\\) and \\(\\mathbf{\\Xi} = \\text{diag}(2\\xi_1\\omega_1, \\dots, 2\\xi_N\\omega_N)\\).\n\n3.1.1 API\nData type\n\nContinuousStateSpace\n\n\n\nContinuousStateSpace(Ac, Bc)\nContinuous-time state-space model\nFields\n\nAc: Continuous-time state matrix A\n\nBc: Continuous-time input matrix B\n\n\n\n\n\n\n\n\nRelated functions\n\nss_model\n\n\n\nss_model(K, M, C)\nGenerates a continuous-time state-space model from the mass, damping, and stiffness matrices\nInputs\n\nK: Stiffness matrix\n\nM: Mass matrix\n\nC: Damping matrix\n\n\nOutput\n\ncss: ContinuousStateSpace\n\n\n\n\n\n\n\n\n\nss_modal_model\n\n\n\nss_modal_model(ωn, ξn, ϕn)\nGenerates a continuous-time state-space model from the mass, damping, and stiffness matrices\nInputs\n\nωn: Natural angular frequencies\n\nξn: Damping ratios\n\nϕn: Mass-normalized mode shapes\n\n\nOutput\n\ncss: ContinuousStateSpace\n\n\n\n\n\n\n\n\n\neigenmode\n\n\n\neigenmode(K, M, n = size(K, 1))\nComputes the eigenmodes of a system defined by its mass and stiffness matrices.\nInputs\n\nK: Stiffness matrix\n\nM: Mass matrix\n\nn: Number of modes to be keep in the modal basis\n\n\nOutputs\n\nω: Vector of natural frequencies\n\nΦ: Mass-normalized mode shapes\n\n\n\n\n\n\n\n\n\nmodal_parameters\n\n\n\nmodal_parameters(λ)\nComputes the natural angular frequencies and damping ratios from the complex eigenvalues\nInput\n\nλ: Complex eigenvalues\n\n\nOutputs\n\nωn: Natural angular frequencies\n\nξn: Damping ratios\n\n\n\n\n\n\n\n\n\n\n3.1.2 Example\n# System matrices\nm_ss = Diagonal([2., 1.])\nk_ss = [6. -2.; -2. 4.]\nc_ss = [0.67 -0.11; -0.11 0.39]\n\n# Continuous-time state space from system matrices\ncss = ss_model(k_ss, m_ss, c_ss)\nλ, Ψ = eigenmode(css.Ac)\nω, ξ = modal_parameters(λ)\n\n# Continuous-time state space from modal information\nωn, ϕn = eigenmode(k_ss, m_ss)\ncss_modal = ss_modal_model(ωn, 0.01, ϕn)\n\n\n\n3.2 Discrete-time models\nDiscrete-time models can be either be obtained using sampled strategies from direct-time integration methods (e.g. Newmark’s scheme). However, both approaches lead to a discrete-time state equation of the form: \\[\n    \\mathbf{z}_{k+1} = \\mathbf{A}\\, \\mathbf{z}_k + \\mathbf{B}_f\\, \\mathbf{u}_k + \\mathbf{B}_g\\, \\mathbf{u}_{k+1},\n\\]\nThe previous formulation is rather non-standard, since the state vector at frequency step \\(k + 1\\) requires the knowledge of the input vector at time steps \\(k\\) and \\(k + 1\\). To reduce the state-space representation to its standard form, a reduced state \\(\\mathbf{\\overline{z}}_{k+1}\\) is introduced: \\[\n    \\mathbf{z}_{k+1} = \\mathbf{A}\\, \\mathbf{x}_k + \\mathbf{B}_f\\, \\mathbf{u}_k,\n\\]\nIn doing so, the discretized state equation becomes: \\[\n    \\mathbf{\\overline{z}}_{k+1} = \\mathbf{A}\\, \\mathbf{\\overline{z}}_k + \\mathbf{B}\\, \\mathbf{u}_k\n\\] where \\(\\mathbf{B} = \\mathbf{B}_f + \\mathbf{A\\, B}_g\\).\n\n3.2.1 Sampling methods\nSampling methods are based on the discretization of the solution of the continuous-time state equation. Once discretized, the state equation can be written as: \\[\n\\mathbf{z}_{k+1} = \\mathbf{A} \\, \\mathbf{z}_k + \\mathbf{A}\\, \\int_{0}^{h} e^{-\\mathbf{A_c}\\tau}\\, \\mathbf{B_c}\\,\\mathbf{u}(\\tau + kh)\\, d\\tau,\n\\] where \\(\\mathbf{A} = e^{\\mathbf{A_c} h}\\) is the the discretized system matrix and \\(h\\) is the discretization timestep.\nTo cover a wide range of situations, the input vector is assumed to be parameterized as follows: \\[\n\\mathbf{u}(\\tau + kh) = f(\\tau)\\, \\mathbf{u}_k + g(\\tau)\\, \\mathbf{u}_{k+1},\n\\] where the basis function \\(f(\\tau)\\) and \\(g(\\tau)\\) control the evolution of the input vector between two time steps.\nIntroducing the parameterization of the input vector into the convolution integral, one obtains the following state equation: \\[\n    \\mathbf{z}_{k+1} = \\mathbf{A}\\, \\mathbf{z}_k + \\mathbf{B}_f\\, \\mathbf{u}_k + \\mathbf{B}_g\\, \\mathbf{u}_{k+1},\n\\] where \\(\\mathbf{B}_f\\) and \\(\\mathbf{B}_g\\) are the discretized input matrices defined such that: \\[\n    \\mathbf{B}_f = \\mathbf{A}\\, \\int_{0}^{h} e^{-\\mathbf{A_c}\\tau}\\, \\mathbf{B_c}\\,f(\\tau)\\, d\\tau \\; \\text{ and } \\; \\mathbf{B}_g = \\mathbf{A}\\, \\int_{0}^{h} e^{-\\mathbf{A_c}\\tau}\\, \\mathbf{B_c}\\,g(\\tau)\\, d\\tau.\n\\]\nIn the literature, the most commonly used sampling methods are the following1:\n\nThe Zero-Order Hold (ZOH) strategy, which assumes that the input vector is constant between two samples. This assumption is satisfied for \\(f(\\tau) = 1\\) and \\(g(\\tau) = 0\\) and leads to: \\[\n     \\mathbf{B} = \\mathbf{B}_f = (\\mathbf{A} - \\mathbf{I})\\, \\mathbf{A}_\\mathbf{c}^{-1}\\, \\mathbf{B_c}.\n\\]\nThe First-Order Hold (FOH) sampling method, which assumes that the input vector varies linearly between two samples. This assumption is satisfied for \\(f(\\tau) = 1 - \\tau/h\\) and \\(g(\\tau) = \\tau/h\\) and leads to: \\[\n      \\begin{split}\n          &\\mathbf{B}_f + \\mathbf{B}_g = (\\mathbf{A} - \\mathbf{I})\\, \\mathbf{A}_\\mathbf{c}^{-1}\\, \\mathbf{B_c}, \\\\\n          &\\mathbf{B}_g = (\\mathbf{A} - \\mathbf{A_c}h - \\mathbf{I})\\mathbf{A}_\\mathbf{c}^{-2}\\, \\mathbf{B_c}/h.\n      \\end{split}\n\\]\nThe Band-Limited Hold (BLH) sampling method, which assumes that the input signal can be approximated as a band-limited signal (i.e. the energy of the signal is concentrated in a defined frequency range). This assumption is satisfied for \\(f(\\tau) = h\\, \\delta(\\tau)\\) and \\(g(\\tau) = 0\\), where \\(\\delta(\\tau)\\) is the Dirac delta function and leads to: \\[\n      \\mathbf{B} = \\mathbf{B}_f = \\mathbf{A}\\, \\mathbf{B_c}\\, h.\n\\]\n\n\n\n3.2.2 Direct-time integration based methods\nDespite several methods can be found in the literature, such as the Newmark’s family schemes, this package only provides the Runge-Kutta approach, because it is an explicit method (i.e. does not require any matrix inversion). After some calculation not detailed here2, the discrete system and input matrices are expressed as: \\[\n    \\begin{split}\n    &\\mathbf{A} = \\frac{1}{24}\\left[24\\,(\\mathbf{I} + \\mathbf{A_c}\\, h) + 12\\, \\mathbf{A}_\\mathbf{c}^2\\, h^2 + 4\\, \\mathbf{A}_\\mathbf{c}^3\\, h^3 + \\mathbf{A}_\\mathbf{c}^4\\, h^4\\right], \\\\\n    &\\mathbf{B}_f = \\frac{h}{24}\\left[12\\, \\mathbf{I} + 8\\, \\mathbf{A_c}\\, h + 3 \\mathbf{A}_\\mathbf{c}^2\\, h^2 + \\mathbf{A}_\\mathbf{c}^3\\, h^3\\right]\\mathbf{B_c}, \\\\\n    &\\mathbf{B}_g = \\frac{h}{24}\\left[12\\, \\mathbf{I} + 4\\, \\mathbf{A_c}\\, h + \\mathbf{A}_\\mathbf{c}^2\\, h^2\\right]\\mathbf{B_c}.\n    \\end{split}\n\\]\n\n\n3.2.3 API\nData type\n\nDiscreteStateSpace\n\n\n\nDiscreteStateSpace(Ad, Bd, Bdp)\nDiscrete-time state-space model\nFields\n\nAd: Discrete-time state matrix A\n\nBd: Discrete-time input matrix B\n\nBdp: Discrete-time input matrix Bp (only for :foh method)\n\n\n\n\n\n\n\n\nRelated function\n\nc2d\n\n\n\nc2d(css::ContinuouStateSpace, h::Float64, method::Symbol)\nConverts a continuous-time state-space model to a discrete-time state-space model.\nInputs\n\ncss: Continuous-time state-space model\n\nh: Sampling time.\n\nmethod: Discretization method\n\n:zoh: Zero-order Hold method\n\n:foh: First-order Hold method\n\n:blh: Band-limited Hold method\n\n:rk4: 4th order Runge-Kutta method\n\n\n\n\nOutput\n\nDiscreteStateSpace: Discrete-time state-space model\n\nAd: Discrete-time state-space matrix A\n\nBd: Discrete-time state-space matrix B\n\nBdp: Discrete-time state-space matrix Bp (only for :foh and :rk4 methods)\n\n\n\n\n\n\n\n\n\n\n\n\n3.2.4 Example\ndss = c2d(css, 0.01, :zoh)",
    "crumbs": [
      "Models",
      "Mechanical models"
    ]
  },
  {
    "objectID": "models/index.html#footnotes",
    "href": "models/index.html#footnotes",
    "title": "Mechanical models",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nD. Bernal. “Optimal discrete to continuous transfer for band limited inputs”, Journal of Engineering Mechanics, vol. 133 (12), pp. 1370-1377, 2007.↩︎\nFor further details, see: J. Ghibaudo. “Inverse estimation of sparse mechanical excitation sources by Bayesian filtering”, PhD thesis, Conservatoire national des arts et métiers, 2024.↩︎",
    "crumbs": [
      "Models",
      "Mechanical models"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "StructuralVibration.jl",
    "section": "",
    "text": "StructuralVibration.jl is a Julia package designed to generate vibration data for mechanical systems. This package can be used for educational and research purposes. As a teacher, you can use it to illustrate vibration theory and its practical implementation. As a researcher, you can use it to test new methods on synthetic data.",
    "crumbs": [
      "Overview",
      "StructuralVibration.jl"
    ]
  },
  {
    "objectID": "index.html#features",
    "href": "index.html#features",
    "title": "StructuralVibration.jl",
    "section": "Features",
    "text": "Features\nThe package provides the following features:\n\nMechanical models\n\nDiscrete models\n\nSpring-mass-damper SDOF system\nSpring-mass-damper MDOF system\nFE models of bar, rod, strings and beams\n\nContinuous models\n\nLongitudinal bars\nTorsional bars\nStrings\nBeams\nRectangular plates\nRectangular membranes\n\nState space model\n\nContinuous state-space representation\nDiscrete state-space representation\n\nZero-order hold (ZOH)\nFirst-order hold (FOH)\nBand-limited hold (BLH)\nRK4\n\n\n\n\n\nVibration data generation\n\nExcitation signals\n\nRectangular wave\nTriangular wave\nHammer impact\nSmoothed rectangular wave\nSine wave\nHalf-sine pulse\nHarversine pulse\nSwept sine wave\nGaussian pulse\nColored noise\n\nSolution for SDOF systems\n\nFree response\nForced response due to a harmonic force or a base motion\nForced response due to any external force or base motion (Duhamel’s integral)\n\nTime-domain integration schemes for linear second order systems\n\nCentral difference scheme\nRK4\nNewmark-beta method\nLinear acceleration method\nFox-Goodwin method\nHHT\nWBZ\nGeneralized-alpha\nMid-Point rule\n\nFrequency-domain calculations for linear systems\n\nFrequency spectrum\n\nModal summation\nDirect method\n\nFrequency response function (FRF)\n\nModal summation\nDirect method\n\n\nState-space solvers\n\nTime domain\n\nRK4 for continuous systems\nZOH, FOH, BLH, RK4 for discrete models\n\nFrequency spectrum\n\nModal summation\nDirect method\n\nFrequency response function (FRF)\n\nModal summation\nDirect method\n\n\nMeasurement noise\n\nAdditive Gaussian white noise (agwn) with a prescribed SNR\nAdditive Colored noise (acn)\nMultiplicative noise\nMixed - agwn + multiplicative noise\n\n\n\n\nSignal processing\n\nMeasurement noise variance estimation algorithms from noisy data\n\nRegularization-based estimation\nD’Errico’s method - Link to the Matlab version\nSNR estimation from estimated measurement noise variance\n\nDenoising algorithms\n\nRegularization\nKalman filtering\n\nSignal preprocessing\n\nDetrending data using polynomial fit\nGradient calculation using interpolation\n\nSignal estimation\n\nTransfer functions estimation (H1, H2, H3, Hv)\nWelch method (PSD, ESD, Autopower, Autopower linear)\nSignal spectrum estimation\n\n\n\n\nModal analysis\n\nExperimental Modal Analysis - SDOF methods\n\nPeak picking method\nCircle fit method\nLeast-squares fit method\n\nExperimental Modal Analysis - MDOF methods\n\nLeast-squares complex exponential (LSCE)\nLeast-squares complex frequency (LSCF)\nPolyreference least-squares complex frequency (PLSCF)\nStabilization diagram\n\nOperational Modal Analysis - EMA-based methods\n\nEMA-based approaches (LSCE, LSCF, PLSCF)\nFrequency-spatial Domain Decomposition (FSDD)\nStochastic Subspace Identification (SSI)\n\nCovariance-driven SSI (CovSSI)\nData-driven SSI (DataSSI)\n\n\nOperational Modal Analysis - ODS-based methods\n\nExtraction of Operational Deflection Shapes (ODS) from response spectra\nExtraction of Operational Deflection Shapes (ODS) from cross-spectral density matrices\n\nAnalysis indicators\n\nModal Overlap Factor (MOF)\nMode overcomplexity value (MOV)\nMode Phase Collinearity (MPC)\nMode Complexity Factor (MCF)\nMean Phase Deviation (MPD)\nModal Assurance Criterion (MAC)\nCoordinate Modal Assurance Criterion (COMAC)\nEnhanced Coordinate Modal Assurance Criterion (ECOMAC)\nFrequency Response Assurance Criterion (FRAC)\nComplex Mode Indicator Function (CMIF)\nPower Spectrum indicator function (PSIF)\n\nModal synthesis\n\nEstimation of the FRF/Half-spectrum residuals\nReconstruct FRF/Half-spectrum from modal parameters\n\n\n\n\nVisualization\n\nBode plot\n2D and 3D Nyquist plot\nWaterfall plot\nGeneral 2D plot",
    "crumbs": [
      "Overview",
      "StructuralVibration.jl"
    ]
  },
  {
    "objectID": "index.html#reproducibility",
    "href": "index.html#reproducibility",
    "title": "StructuralVibration.jl",
    "section": "Reproducibility",
    "text": "Reproducibility\n\n\n\n\n\n\nNoteProject direct dependencies\n\n\n\n\n\nProject StructuralVibration v1.1.2\nStatus\n  [717857b8] DSP v0.8.4\n  [7a1cc6ca] FFTW v1.10.0\n  [442a2c76] FastGaussQuadrature v1.1.0\n  [a98d9a8b] Interpolations v0.15.1\n  [429524aa] Optim v1.13.2\n  [18e31ff7] Peaks v0.5.3\n  [f27b6e38] Polynomials v4.1.0\n  [92933f4c] ProgressMeter v1.11.0\n  [aed68c70] SkipNan v0.2.0\n  [276daf66] SpecialFunctions v2.6.1\n  [10745b16] Statistics v1.11.1\n  [c751599d] ToeplitzMatrices v0.8.5\n  [37e2e46d] LinearAlgebra v1.12.0\n  [9a3f8284] Random v1.11.0\n\n\n\n\n\n\n\n\n\nNoteJulia version and machine information\n\n\n\n\n\nJulia Version 1.12.1\nCommit ba1e628ee49 (2025-10-17 13:02 UTC)\nBuild Info:\n  Official https://julialang.org release\nPlatform Info:\n  OS: macOS (arm64-apple-darwin24.0.0)\n  CPU: 16 × Apple M4 Max\n  WORD_SIZE: 64\n  LLVM: libLLVM-18.1.7 (ORCJIT, apple-m4)\n  GC: Built with stock GC\nThreads: 1 default, 1 interactive, 1 GC (on 12 virtual cores)\nEnvironment:\n  JULIA_PKG_SERVER = https://juliahub.com\n  JULIA_EDITOR = code\n  JULIA_VSCODE_REPL = 1",
    "crumbs": [
      "Overview",
      "StructuralVibration.jl"
    ]
  },
  {
    "objectID": "index.html#license",
    "href": "index.html#license",
    "title": "StructuralVibration.jl",
    "section": "License",
    "text": "License\nThis package is under MIT License.",
    "crumbs": [
      "Overview",
      "StructuralVibration.jl"
    ]
  },
  {
    "objectID": "overview/installation.html",
    "href": "overview/installation.html",
    "title": "Installation",
    "section": "",
    "text": "Note\n\n\n\nIf you are already a Julia user, you can skip this section.\nThis section explains how to install Julia and StructuralVibration.jl.",
    "crumbs": [
      "Overview",
      "Installation"
    ]
  },
  {
    "objectID": "overview/installation.html#install-julia",
    "href": "overview/installation.html#install-julia",
    "title": "Installation",
    "section": "Install Julia ",
    "text": "Install Julia \nThere exists several ways of installing Julia and managing versions. The recommended way consists in installing juliaup, which is a Julia version manager.\n\nWindows\nOn Windows, juliaup can be installed directly from the Windows store or from a terminal by typing the following command:\nwinget install julia -s msstore\nMacOS and Linux\nOn MacOS and Linux, juliaup can be installed from a terminal by typing:\ncurl -fsSL https://install.julialang.org | sh\nor by using software repositories:\n# MacOS\nbrew install juliaup\n\n# Arch-based distributions\nyay -S juliaup\n\nOnce juliaup is installed, the latest version of Julia can be installed from a terminal as follows:\njuliaup add release",
    "crumbs": [
      "Overview",
      "Installation"
    ]
  },
  {
    "objectID": "overview/installation.html#install-structuralvibration.jl",
    "href": "overview/installation.html#install-structuralvibration.jl",
    "title": "Installation",
    "section": "Install StructuralVibration.jl ",
    "text": "Install StructuralVibration.jl \nThe package is registered in the Julia General Registry. So, to install the package, you can use the following command:\n(Yourenv) pkg&gt; add StructuralVibration",
    "crumbs": [
      "Overview",
      "Installation"
    ]
  },
  {
    "objectID": "signal_processing/other.html",
    "href": "signal_processing/other.html",
    "title": "Other processing",
    "section": "",
    "text": "Other signal processing methods are available in StructuralVibration.jl.",
    "crumbs": [
      "Signal processing",
      "Other processing"
    ]
  },
  {
    "objectID": "signal_processing/other.html#detrending",
    "href": "signal_processing/other.html#detrending",
    "title": "Other processing",
    "section": "1 Detrending",
    "text": "1 Detrending\nDetrending is the process of removing trends from a signal. This is useful when you want to analyze the fluctuations around a trend. The detrend function can be used to remove linear or polynomial trends from a signal.\n\n1.1 API\n\ndetrend\n\n\n\ndetrend(t, y, order = 1, bp = [])\nDetrend a signal y with respect to time t using a polynomial of order order.\nInputs\n\nt: Time vector\n\ny: Signal to be detrended\n\norder: Order of the polynomial (default is 1)\n\nbp: Breakpoints for the polynomial (default is empty)\n\n\nOutput\n\ny_detrended: Detrended signal\n\n\nNotes\norder can be a vector if the trend is different over the segments defined by the breakpoints bp.\nThe breakpoints bp are the points where the polynomial order changes. If bp is empty, a single polynomial is fitted to the entire signal.\n\n\n\n\n\n\n\n\n1.2 Example\n\n# Signal 1\nx1 = -0.5:0.01:0.5\ny1 = @. sin(π*x1) + 0.25\ny1_const = detrend(x1, y1, 0)\ny1_lin = detrend(x1, y1, 1)\n\n# Signal 2\nx2 = 0:0.1:20\ny2 = @. 3sin(x2) + x2\ny2_const = detrend(x2, y2, 0)\ny2_lin = detrend(x2, y2, 1)",
    "crumbs": [
      "Signal processing",
      "Other processing"
    ]
  },
  {
    "objectID": "signal_processing/other.html#gradient",
    "href": "signal_processing/other.html#gradient",
    "title": "Other processing",
    "section": "2 Gradient",
    "text": "2 Gradient\nThe gradient of a signal is the rate of change of the signal with respect to time. Julia [] has a lot of packages for computing the gradient of a signal. The gradient function in StructuralVibration.jl is a simple helper function built around the gradient function in Interpolations.jl.\n\n2.1 API\n\ngradient\n\n\n\ngradient(f::Vector{Real}, t; method = :cubic)\ngradient(f::Matrix{Real}, t; method = :cubic, dims = 1)\nCompute the gradient of a function f at points t.\nInputs\n\nf: Function values\n\nt: Points at which to evaluate the gradient\n\nmethod: Interpolation method\n\n:linear: Linear interpolation\n\n:cubic: Cubic spline interpolation (default)\n\n\n\ndims: Dimension along which to compute the gradient\n\n1: Rows (default)\n\n2: Columns\n\n\n\n\nOutput\n\ndf: Gradient of the vector f at points t\n\n\nNote\nIf method is :cubic, t must be an AbstractRange.\n\n\n\n\n\n\n\n\n2.2 Example\n\n# Signal\nx = LinRange(0., 3π, 100)\ny = sin.(x)\n\n# True gradient\ndy = cos.(x)\n\n# Estimated gradient\ndy_approx = gradient(y, x)\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nBeing based on interpolation, gradient is not robust against noise. For robust gradient estimation, you can compute the gradient of the signal denoised by the denoising function by using one of the numerous Julia differentiation packages if the signal is smooth enough (at least class \\(C^\\2\\)). If the latter condition is not satisfied, you can for instance use NoiseRobustDifferentiation.jl, which implements the Total variation regularized numerical differentiation method1 .",
    "crumbs": [
      "Signal processing",
      "Other processing"
    ]
  },
  {
    "objectID": "signal_processing/other.html#footnotes",
    "href": "signal_processing/other.html#footnotes",
    "title": "Other processing",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nR. Chartrand. “Numerical differentiation of noisy, nonsmooth data”. ISRN Applied Mathematics, vol. 2011, 164564, 2011.↩︎",
    "crumbs": [
      "Signal processing",
      "Other processing"
    ]
  },
  {
    "objectID": "modal_extraction/oma.html",
    "href": "modal_extraction/oma.html",
    "title": "Operational Modal Analysis",
    "section": "",
    "text": "Operational Modal Analysis (OMA) is a technique used to extract modal parameters of a structure based solely on its response measurements, without requiring knowledge of the input excitation forces. This is particularly useful in scenarios where it is difficult or impossible to measure the input forces, such as in ambient vibration testing of large structures.\nFrom an algorithmic perspective, OMA can be performed using various methods, including EMA-based algorithms or specific OMA techniques such as Stochastic Subspace Identification techniques. In StructuralVibration.jl, the following methods are implemented for OMA:",
    "crumbs": [
      "Modal extraction",
      "Operational Modal Analysis"
    ]
  },
  {
    "objectID": "modal_extraction/oma.html#sdof-method",
    "href": "modal_extraction/oma.html#sdof-method",
    "title": "Operational Modal Analysis",
    "section": "1 Sdof method",
    "text": "1 Sdof method\nThe Frequency-Spatial Domain Decomposition (FSDD) method is a single-degree-of-freedom (Sdof) technique used in Operational Modal Analysis (OMA) to extract modal parameters from output-only data1. The FSDD method relies on the fact that in the vicinity of a resonance frequency \\(\\omega_k\\), the cross-spectral density (CSD) matrix of the output responses can be approximated by a rank-1 matrix, which corresponds to the dominant mode shape of the structure at that frequency. In particular, this means that the CSD matrix \\(\\mathbf{G}_{yy}(\\omega_k)\\) can be expressed as: \\[\n\\mathbf{G}_{yy}(\\omega_k) \\approx \\mathbf{u}_1(\\omega_k)\\, s_1(\\omega_k) \\mathbf{u}_1(\\omega_k)^H,\n\\] where \\(\\mathbf{u}_1(\\omega_k)\\) is the first singular vector of the CSD matrix, and \\(s_1(\\omega_k)\\) is the corresponding singular value.\nBy noting that the CSD matrix near the resonance frequency can also be expressed in terms of the mode shape \\(\\boldsymbol{\\Phi}\\) and the power spectral density of the modal coordinate \\({G}_{qq}(\\omega)\\) as: \\[\n\\mathbf{G}_{yy}(\\omega_k) \\approx \\boldsymbol{\\Phi}\\boldsymbol{G}_{qq}(\\omega_k) \\boldsymbol{\\Phi}^H,\n\\] where \\(\\boldsymbol{G}_{qq}(\\omega)\\) is dominated by the contribution of the \\(k\\)-th mode, we can establish a relationship between the singular vectors and the mode shapes. More specifically, the mode shape \\(\\boldsymbol{\\Phi}_k\\) at frequency \\(\\omega_k\\) is given by the first singular vector: \\[\n\\boldsymbol{\\Phi}_k \\approx \\mathbf{u}_1(\\omega_k).\n\\]\nOnce the mode shapes are extracted, the FSDD utilizes the unitary property of the singular vectors to derive an enhanced output PSD \\(\\hat{G}_{yy}(\\omega)\\), which is a real quantity, in the vicinity of the resonance frequency, such that: \\[\n\\hat{G}_{yy}(\\omega) = \\mathbf{u}_1(\\omega_k)^H\\, \\mathbf{G}_{yy}(\\omega)\\, \\mathbf{u}_1(\\omega_k) \\approx \\frac{d_k}{\\sigma_k^2 + (\\omega - \\Omega_k)^2},\n\\] where \\(d_k\\) is a constant related to the mode shape normalization, \\(\\sigma_k = -\\xi_k\\omega_k\\) , and \\(\\Omega_k\\) is the damped natural angular frequency of the \\(k\\)-th mode. By fitting a Sdof model to the enhanced PSD \\(\\hat{G}_{yy}(\\omega)\\) around the resonance frequency \\(\\omega_k\\) using a least-squares approach, the modal parameters (natural frequency and damping ratio) can be estimated.\n\n\n\n\n\n\nNote\n\n\n\nThe FSDD method is particularly effective for structures with well-separated modes and low damping, as it relies on the dominance of a single mode in the CSD matrix near resonance frequencies. However, it may face challenges when dealing with closely spaced modes or high damping scenarios, where the rank-1 approximation may not hold true.\n\n\nTo perform a robust FSDD, StructuralVibration.jl implements two additional steps during the estimation process:\n\nBecause the signals are often contaminated with noise, the singular vector \\(\\mathbf{u}_1(\\omega_k)\\) is estimated by averaging the first left-singlular vectors within a frequency band around each resonance frequency. This aims to reduce the effects of noise on the mode shape estimates. During this process, a MAC threshold is used to select only the singular vectors that are sufficiently similar to the reference singular vector at the peak frequency. Said differently, only the singular vectors, for which the first singular value is approximately constant within the frequency band, are considered for the averaging.\nIn doing so, we define the so-called Sdof-bell corresponding to the frequencies around each peak where the singular vectors are considered for averaging. It results that the left-singular vector \\(\\mathbf{u}_1(\\omega_k)\\) is estimated as: \\[\n\\hat{\\mathbf{u}}_1(\\omega_k) = \\frac{\\sum_{i=1}^{N_k} w_i\\, \\mathbf{u}_1(\\omega_i)}{\\sum_{i=1}^{N_k} w_i},\n\\]\nwhere \\(N_k\\) is the number of selected candidates within the bell and \\(w_i\\) are the weights assigned to each candidate. StructuralVibration.jl proposes two types of weights:\n\nUniform weights: \\(w_i = 1\\) corresponding to a linear average of the selected candidates.\nSingular value-based weights: \\(w_i = s_1(\\omega_i)\\). This weighting scheme gives more importance to candidates that are more likely to represent the true mode shape and less importance to those that may be influenced by noise or other factors.\n\nKnowing the Sdof-bell also allows to define the frequency range around each resonance frequency where the Sdof model is fitted to the enhanced PSD. To do so, the fitting equation is expressed as: \\[\n\\begin{bmatrix}\n\\hat{G}_{yy}(\\omega) & -2\\omega \\hat{G}_{yy}(\\omega) & -1 \\\\\n\\end{bmatrix} \\begin{bmatrix}\n\\omega_k^2 \\\\\n\\Omega_k \\\\\nd_k\n\\end{bmatrix} = -\\omega^2 \\hat{G}_{yy}(\\omega)\n\\]\nBy applying this equation over all frequencies \\(\\omega\\) within the Sdof-bell, a least-squares solution can be obtained for the unknowns \\(\\omega_k\\), \\(\\Omega_k\\), and \\(d_k\\). From these estimates, the poles \\(p_k\\) can be computed as: \\[\np_k = -\\sqrt{\\omega_k^2 - \\Omega_k^2} + j \\Omega_k,\n\\]\nFor lightly damped structures, the least-squares fitting may failed to provide a physical solution due to numerical inaccuracies. In this case, one typically observes that \\(\\Omega_k &gt; \\omega_k\\), leading to imaginary values for the damping ratio. To overcome this issue, StructuralVibration.jl uses the estimation inspired by the Enhanced Frequency Domain Decomposition (EFDD) method2.\nThe estimation consists in taking the inverse Fourier transform of the enhanced PSD \\(\\hat{G}_{yy}(\\omega)\\) to obtain the corresponding Autocorrelation function \\(R(\\tau)\\) of the Sdof system: \\[\nR(\\tau) \\approx C\\, e^{-\\sigma_k \\tau} \\cos(\\Omega_k \\tau).\n\\]\nThen, we compute the envelope \\(E(\\tau)\\) of the signal using the Hilbert transform, which gives: \\[\nE(\\tau) = C\\, e^{-\\sigma_k \\tau}.\n\\] By fitting a linear model to the logarithm of the envelope, we can estimate \\(\\sigma_k\\) from a least-squares regression.\nAssuming that the damped natural frequency \\(\\Omega_k\\) was properly estimated in the initial estimation, the pole \\(p_k\\) can then be estimated as: \\[\np_k = -\\sigma_k + j \\Omega_k.\n\\]",
    "crumbs": [
      "Modal extraction",
      "Operational Modal Analysis"
    ]
  },
  {
    "objectID": "modal_extraction/oma.html#mdof-methods",
    "href": "modal_extraction/oma.html#mdof-methods",
    "title": "Operational Modal Analysis",
    "section": "2 Mdof methods",
    "text": "2 Mdof methods\n\n2.1 EMA-based methods for OMA\n\n2.1.1 General principle\nThe EMA-based methods for OMA in StructuralVibration.jl leverage the existing Mdof EMA algorithms to extract modal parameters from response-only data. For applying these methods, one has to replace the Frequency Response Function by the so-called positive half-spectrum of the response signals.\nTo obtain the half-spectrum, we start from the full cross-spectral density (CSD) matrix between the output responses \\(\\mathbf{y}\\), which is given by: \\[\n\\mathbf{G}_{yy}(\\omega) = \\mathbf{H}(\\omega) \\mathbf{G}_{ff}(\\omega) \\mathbf{H}^H(\\omega),\n\\] where \\(\\mathbf{H}(\\omega)\\) is the Frequency Response Function matrix of the system, \\(\\mathbf{G}_{ff}(\\omega)\\) is the cross-spectral density matrix of the input forces, and \\(^H\\) denotes the Hermitian transpose.\nGenerally, OMA relies on the assumption that the input excitation are random white noise processes, implying that \\(\\mathbf{G}_{ff}(\\omega) = \\mathbf{I}\\). Under this assumption, a component of the cross-spectral density matrix \\(G_{pq}(\\omega)\\) can be expressed under the poles-residues form as34: \\[\nG_{pq}(\\omega) = \\sum_{i=1}^{n} \\left( \\frac{{}_iR_{pq}}{j\\omega - \\lambda_i} + \\frac{{}_iR_{pq}^\\ast}{j\\omega - \\lambda_i^\\ast} + \\frac{{}_iS_{pq}}{-j\\omega - \\lambda_i} + \\frac{{}_iS_{pq}^\\ast}{-j\\omega - \\lambda_i^\\ast} \\right),\n\\] where \\(\\lambda_i\\) and (\\({}_iR_{pq}\\), \\({}_iS_{pq}\\)) are the system poles and residues, respectively.\nFrom this definition, the half-spectrum \\(G_{pq}^+(\\omega)\\) is defined as the sum of the first two terms in the above expression5: \\[\nG_{pq}^+(\\omega) = \\sum_{i=1}^{n} \\left( \\frac{{}_iR_{pq}}{j\\omega - \\lambda_i} + \\frac{{}_iR_{pq}^\\ast}{j\\omega - \\lambda_i^\\ast} \\right).\n\\]\nIn StructuralVibration.jl, the half-spectrum can be computed using the half_csd function, which can proceed in two different ways. These approaches can be summarized as follows:\n\nFirst approach - Post-processing of the full CSD matrix:\n\nCompute the correlation matrix \\(\\mathbf{R}_{yy}(\\tau)\\) of the response signals by applying an inverse Fourier transform to the CSD matrix \\(\\mathbf{G}_{yy}(\\omega)\\).\nKeep only the positive time lags of the correlation matrix \\(\\mathbf{R}_{yy}^+(\\tau)\\).\nMultiply \\(\\mathbf{R}_{yy}^+(\\tau)\\) by a flat triangular window and zero-pad the negative time lags of the correlation matrix to obtain a full matrix of the same size as the original correlation matrix (See Ref. [3]). The resulting signal is noted \\(\\tilde{\\mathbf{R}}_{yy}^+(\\tau)\\).\nCompute the half-spectrum \\(\\mathbf{G}_{yy}^+(\\omega)\\) by applying a Fourier transform to \\(\\tilde{\\mathbf{R}}_{yy}^+(\\tau)\\).\n\nSecond approach - Direct computation from time-domain signals:\n\nCompute the discrete directe correlation matrix \\(\\mathbf{R}^+_k\\) of the response signals directly from the time-domain data, considering only the positive time lags, using the following formula: \\[\n\\mathbf{R}^+_k = \\frac{1}{N - k} \\sum_{n=1}^{N-k} \\mathbf{y}_n \\mathbf{y}_{n+k}^T\n\\] where \\(N\\) is the total number of samples.\nMultiply \\(\\mathbf{R}_k^+\\) by a flat triangular window and zero-pad the signal to obtain \\(\\tilde{\\mathbf{R}}_k^+\\).\nCompute the half-spectrum \\(\\mathbf{G}_{yy}^+(\\omega)\\) by applying a Fourier transform to \\(\\tilde{\\mathbf{R}}_k^+\\).\n\n\n\n\n\n\n\n\nNote\n\n\n\nIf the length of the time signals are longer than the block size used for the FFT computation, the half-spectrum is computed for each block and then averaged over all blocks.\n\n\n\n\n2.1.2 Modal parameters extraction\nOnce the half-spectrum is computed, the existing Mdof EMA methods in StructuralVibration.jl can be directly applied to extract the poles from the half-spectrum data. More details on the usage of these methods can be found in the Mdof EMA documentation. Regarding the extraction of mode shapes in OMA using EMA-based methods, a procedure similar to the one used in EMA can’t be followed since the input forces are unknown. In this case, it is generally assumed that the rank of the residues is equal to 1, allowing to extract the mode shapes from the residues using a Singular Value Decomposition (SVD). Specifically, for a given mode \\(i\\), the residue matrix \\({}_i\\mathbf{R}\\) can be decomposed as: \\[\n{}_i\\mathbf{R} = \\mathbf{U}_i\\, \\mathbf{S}_i\\, \\mathbf{V}_i^H,\n\\]\nwhere \\(\\mathbf{U}_i\\) and \\(\\mathbf{V}_i\\) are the matrices containing the left and right singular vectors, respectively, and \\(\\mathbf{S}_i\\) is the diagonal matrix of singular values. The mode shape \\(\\boldsymbol{\\phi}_i\\) is then approximated by the first left singular vector corresponding to the highest singular value: \\[\n\\boldsymbol{\\phi}_i \\approx \\mathbf{U}_{i,1}\n\\]\nwhere \\(\\mathbf{U}_{i,1}\\) is the first column of \\(\\mathbf{U}_i\\). However, this assumption may not always hold true, especially in cases where the input excitation is not perfectly white noise or when multiple modes are closely spaced. In this case, more than one singular singular value may be significant, and the mode shape extraction may require additional considerations. In StructuralVibration.jl, the following procedure is adopted to extract the mode shapes from the residues:\n\nFor each mode \\(i\\), compute the SVD of the residue matrix \\({}_i\\mathbf{R}\\) to obtain \\(\\mathbf{U}_i\\), \\(\\mathbf{S}_i\\).\nFilter the singular values in \\(\\mathbf{S}_i\\) based on a predefined threshold to determine the number \\(j\\) of significant singular values. Here, the threshold is set to 1% of the largest singular value.\nFor the first mode, select \\(\\boldsymbol{\\phi}_i = \\mathbf{U}_{i,j}\\) as the mode shape, based on energy considerations. The selected singular vector corresponds to the highest energy spread. Generally, this will be the first singular vector.\nFor subsequent modes, select the singular vector \\(\\mathbf{U}_{i,j}\\) that minimizes the Modal Assurance Criterion (MAC) with respect to the previously extracted mode shapes, ensuring orthogonality and consistency among the extracted modes.\n\n\n\n2.1.3 Half-spectrum reconstruction\nFrom the identified modal parameters (poles and residues), it is possible to reconstruct the half_spectrum of the system under study using the half_csd_reconstruction function. This function implements the following relation for a number \\(M\\) of identified modes:\n\\[\nG_{pq}^+(\\omega) = \\sum_{i = 1}^{M} \\left[\\frac{{}_i R_{pq}}{(j\\omega - \\lambda_i)} + \\frac{{}_i R_{pq}^\\ast}{(j\\omega - \\lambda_i^\\ast)}\\right],\n\\]\nHowever, as for the FRF reconstruction in EMA, the reconstructed half-spectrum may not perfectly match the original half-spectrum due to modeling errors and noise in the data. To To account for this, it is common to include lower and upper residuals in the FRF reconstruction. This means that the admittance matrix can be expressed as: \\[\nG_{pq}^+(\\omega) = \\sum_{i = 1}^{M} \\left[\\frac{{}_i R_{pq}}{(j\\omega - \\lambda_i)} + \\frac{{}_i R_{pq}^\\ast}{(j\\omega - \\lambda_i^\\ast)}\\right] + \\frac{L_{pq}}{j\\omega} + j\\omega\\, U_{pq},\n\\]\nwhere \\(L_{pq}\\) and \\(U_{pq}\\) are the lower and upper residuals, respectively. These residuals can be computed using the compute_residuals function.\n\n\n\n\n\n\nNote\n\n\n\nAs indicated by Peeters and Van der Auweraer in Ref. [2], the lower and upper residuals are independent of the output quantity. More precisely, this means that the residuals terms are always of the form: \\[\n\\text{Res}_{pq} = \\frac{L_{pq}}{j\\omega} + j\\omega\\, U_{pq}.\n\\]\n\n\n\n\n\n2.2 Stochastic Subspace Identification methods\nStochastic Subspace Identification (SSI) methods are a class of techniques used in Operational Modal Analysis (OMA) to extract modal parameters from output-only data. These methods are based on the concept of subspace identification, which involves constructing a state-space model of the system from the measured response data. From a mathematical standpoint, the goal is to identify the system matrices \\((\\mathbf{A}, \\mathbf{C})\\) of the state-space representation: \\[\n\\begin{aligned}\n\\dot{\\mathbf{x}}_{k+1} &= \\mathbf{A}\\, \\mathbf{x}_k + \\mathbf{w}_k \\\\\n\\mathbf{y}_k &= \\mathbf{C}\\, \\mathbf{x}_k + \\mathbf{v}_k\n\\end{aligned}\n\\] where \\(\\mathbf{x}_k\\) is the state vector, \\(\\mathbf{y}_k\\) is the output vector, and \\(\\mathbf{w}_k\\) and \\(\\mathbf{v}_k\\) are process and measurement noise, respectively. Here, the system matrix \\(\\mathbf{A}\\) is the discrete-time state transition matrix that contains information about the system dynamics. If a ZOH discretization is considered, the relationship between the continuous-time system matrix \\(\\mathbf{A}_c\\) and the discrete-time system matrix \\(\\mathbf{A}\\) is given by: \\[\n\\mathbf{A} = e^{\\mathbf{A}_c T_s}\n\\] where \\(T_s\\) is the sampling period. The eigenvalues of \\(\\mathbf{A}\\) can be used to extract the continuous-time poles \\(\\lambda_i\\) of the system using the following relation: \\[\n\\lambda_i = \\frac{\\ln(\\mu_i)}{T_s}\n\\] where \\(\\mu_i\\) are the eigenvalues of \\(\\mathbf{A}\\).\nThe mode shapes \\(\\boldsymbol{\\phi}_i\\) can be obtained from the output matrix \\(\\mathbf{C}\\) and the eigenvectors of \\(\\mathbf{A}\\) using the following relation: \\[\n\\boldsymbol{\\phi}_i = \\mathbf{C}\\, \\boldsymbol{\\psi}_i\n\\] where \\(\\boldsymbol{\\psi}_i\\) are the eigenvectors of \\(\\mathbf{A}\\).\n\n2.2.1 Covariance-driven Stochastic Subspace Identification\nCovariance-driven Stochastic Subspace Identification (Cov-SSI) is a method that utilizes the covariance of the output data to identify the system matrices. The key steps involved in Cov-SSI are as follows:\n\nCompute the covariance matrices \\(\\mathbf{R}_i\\) of the output data at different time lags \\(i\\): \\[\n  \\mathbf{R}_i = \\frac{1}{N - i} \\sum_{n = 0}^{N-i} \\mathbf{y}_n\\, \\mathbf{y}_{n+i}^T\n  \\]\n\n\n\n\n\n\n\nNote\n\n\n\nIf a set of reference signals \\(\\mathbf{y}_{ref}\\) is provided, the cross-covariance matrices between the output signals and the reference signals are computed instead: \\[\n\\mathbf{R}_i = \\frac{1}{N - i} \\sum_{n=0}^{N-i} \\mathbf{y}_n\\, {\\mathbf{y}_{n+i}^\\text{ref}}^T\n\\]\n\n\n\nConstruct a block Toeplitz matrix from the covariance matrices:\n\n\\[\n  \\mathbf{T} = \\begin{bmatrix}\n  \\mathbf{R}_i & \\mathbf{R}_{i-1} & \\cdots & \\mathbf{R}_1 \\\\\n  \\mathbf{R}_{i+1} & \\mathbf{R}_i & \\ddots & \\mathbf{R}_2 \\\\\n  \\vdots & \\vdots & \\ddots & \\vdots \\\\\n  \\mathbf{R}_{2i-1} & \\mathbf{R}_{2i-2} & \\cdots & \\mathbf{R}_i\n  \\end{bmatrix}\n  \\]\n\nCompute the observability matrix \\(\\mathbf{O}\\) from the SVD of \\(\\mathbf{T}\\): \\[\n  \\mathbf{O} = \\begin{bmatrix}\n  \\mathbf{C} \\\\\n  \\mathbf{C} \\mathbf{A} \\\\\n  \\mathbf{C} \\mathbf{A}^2 \\\\\n  \\vdots \\\\\n  \\mathbf{C} \\mathbf{A}^{i-1}\n  \\end{bmatrix}\n  = \\mathbf{U}_n\\, \\mathbf{S}_n^{1/2},\n  \\] where \\(\\mathbf{U}_n\\) and \\(\\mathbf{S}_n\\) are the matrices containing the first \\(n\\) left singular vectors and singular values, respectively.\nExtract the system matrices \\(\\mathbf{A}\\) and \\(\\mathbf{C}\\) from the Observability matrix\n\nThe output matrix \\(\\mathbf{C}\\) is obtained from the first block row of \\(\\mathbf{O}\\).\nThe system matrix \\(\\mathbf{A}\\) is obtained by solving the following equation: \\[\n\\mathbf{O}_\\text{up}\\, \\mathbf{A} = \\mathbf{O}_\\text{down}\n\\] where \\(\\mathbf{O}_\\text{up}\\) and \\(\\mathbf{O}_\\text{down}\\) are derived from the observability matrix removing the last and first block rows, respectively.\n\n\n\n\n2.2.2 Data-driven Stochastic Subspace Identification\nData-driven Stochastic Subspace Identification (Data-SSI) is a method that directly utilizes the output data to identify the system matrices without explicitly computing the covariance matrices. The key steps involved in Data-SSI are as follows:\n\nConstruct a block Hankel matrix from the output data: \\[\n  \\mathbf{H} = \\frac{1}{\\sqrt{j}}\\begin{bmatrix}\n  \\mathbf{y}_0 & \\mathbf{y}_1 & \\cdots & \\mathbf{y}_{j-1} \\\\\n  \\mathbf{y}_1 & \\mathbf{y}_2 & \\cdots & \\mathbf{y}_j \\\\\n  \\cdots & \\cdots & \\cdots & \\cdots \\\\\n  \\mathbf{y}_{i - 1} & \\mathbf{y}_i & \\cdots & \\mathbf{y}_{i+j-2} \\\\\n  \\hline\n  \\mathbf{y}_i & \\mathbf{y}_{i+1} & \\cdots & \\mathbf{y}_{i+j-1} \\\\\n  \\mathbf{y}_{i+1} & \\mathbf{y}_{i+2} & \\cdots & \\mathbf{y}_{i+j} \\\\\n  \\cdots & \\cdots & \\cdots & \\cdots \\\\\n  \\mathbf{y}_{2i - 1} & \\mathbf{y}_{2i} & \\cdots & \\mathbf{y}_{2i+j-2}\n  \\end{bmatrix} = \\begin{bmatrix}\n  \\mathbf{Y}_p \\\\\n  \\hline\n  \\mathbf{Y}_f\n  \\end{bmatrix}\n  \\]\nwhere \\(i\\) is the number of block rows and \\(j\\) is the number of columns of the Hankel matrix and \\(\\mathbf{Y}_p\\) and \\(\\mathbf{Y}_f\\) are the past and future output data matrices. respectively.\n\n\n\n\n\n\n\nNote\n\n\n\nIf a set of reference signals \\(\\mathbf{y}_{ref}\\) is provided, the past data matrix \\(\\mathbf{Y}_p\\) is constructed using the reference signals instead of the output signals.\n\n\n\nConstruct the projection of the future output data onto the past output data: \\[\n  \\mathbf{P} = \\mathbf{Y}_f\\, \\mathbf{Y}_p^T\\, (\\mathbf{Y}_p\\, \\mathbf{Y}_p^T)^+\\, \\mathbf{Y}_p\n  \\]\nCompute the observability matrix \\(\\mathbf{O}\\) from the SVD of \\(\\mathbf{P}\\).\nExtract the system matrices \\(\\mathbf{A}\\) and \\(\\mathbf{C}\\) from the observability matrix as described in the Cov-SSI method.",
    "crumbs": [
      "Modal extraction",
      "Operational Modal Analysis"
    ]
  },
  {
    "objectID": "modal_extraction/oma.html#api",
    "href": "modal_extraction/oma.html#api",
    "title": "Operational Modal Analysis",
    "section": "3 API",
    "text": "3 API\nData types\n\n\n\nOMAProblem(Gyy, freq; frange, type_data)\nOMAProblem(y, yref, t, fs, bs; frange, type_data, win, overlap)\nOMAProblem(y, t, fs, bs; frange, type_data, win, overlap)\nData structure defining the inputs for Operational Modal Analysis (OMA) methods.\nConstructor parameters\n\nGyy::Array{Complex, 3}: Cross-spectral density matrix of size (no, nref, nf),\n\nfreq::AbstractArray{Real}: Frequency vector corresponding to the CSD matrix\n\nfrange::AbstractVector{Real}: Frequency range to consider for analysis (default: full range)\n\n\nAlternative constructor parameters\n\ny::AbstractMatrix{Real}: Matrix of measured outputs (no x nt)\n\nyref::AbstractMatrix{Real}: Matrix of reference outputs (nref x nt)\n\nt::AbstractArray{Real}: Time vector corresponding to the measurements\n\nfs::Real: Sampling frequency (Hz)\n\nbs::Int: Block size for CSD estimation\n\nfrange::AbstractVector{Real}: Frequency range to consider for analysis (default: [0., fs/2.56])\n\nwin::Function: Window function for CSD estimation (default: hanning)\n\noverlap::Real: Overlap ratio for CSD estimation (default: 0.5)\n\n\nFields\n\ny::AbstractMatrix{Real}: Matrix of measured outputs (no x nt)\n\nyref::AbstractMatrix{Real}: Matrix of reference outputs (nref x nt)\n\nt::AbstractArray{Real}: Time vector corresponding to the measurements\n\nfullspec::Array{Complex, 3}: Full cross-spectral density matrix\n\nhalfspec::Array{Complex, 3}: Half spectral density matrix\n\nfreq::AbstractArray{Real}: Frequency vector corresponding to the half-spectrum\n\n\nNote\n\nOMAProblem(y, t, ...) = OMAProblem(y, y, t, ...)\n\n\n\n\n\n\n\n\n\n\n\nFSDD\nFrequency-Spatial Domain Decomposition method for OMA modal extraction\nFields\n\nnothing\n\n\nReference\n[1] L. Zhang, T. Wang and Y. Tamura. \"A frequency–spatial domain decomposition (FSDD) method for operational modal analysis\". Mechanical Systems and Signal Processing, 24: 1227-1239, 2010.\n\n\n\n\n\n\n\n\n\nCovSSI\nCovariance-driven Stochastic Subspace Identification method for OMA modal extraction\nFields\n\nnothing\n\n\nReference\n[1] C. Rainieri and G. Fabbrocino. \"Operational Modal Analysis of Civil Engineering Structures: An Introduction and Guide for Applications\". Springer, 2014.\n[2] P. Peeters and G. De Roeck. \"Reference-based stochastic subspace identification for output-only modal analysis\". Mechanical Systems and Signal Processing, 13(6):855-878, 1999.\n[3] L. Hermans and H. Van der Auweraer. \"Modal testing and analysis of structures under operational conditions: Industrial applications\". Mechanical Systems and Signal Processing, 13(2):193-216, 1999.\n\n\n\n\n\n\n\n\n\nDataSSI\nData-driven Stochastic Subspace Identification method for OMA modal extraction\nFields\n\nnothing\n\n\nReference\n[1] C. Rainieri and G. Fabbrocino. \"Operational Modal Analysis of Civil Engineering Structures: An Introduction and Guide for Applications\". Springer, 2014.\n[2] P. Peeters and G. De Roeck. \"Reference-based stochastic subspace identification for output-only modal analysis\". Mechanical Systems and Signal Processing, 13(6):855-878, 1999.\n[3] L. Hermans and H. Van der Auweraer. \"Modal testing and analysis of structures under operational conditions: Industrial applications\". Mechanical Systems and Signal Processing, 13(2):193-216, 1999.\n\n\n\n\n\n\nRelated functions\n\nxcorr\n\n\n\nxcorr(y, yref, N)\nxcorr(y, N)\nCompute the cross-correlation matrix R of a signal y up to lag N-1.\nInputs\n\ny::VecOrMat{Real}: Input signal\n\nyref::VecOrMat{Real}: Reference input signal\n\nN: Number of lags\n\n\nOutput\n\nR: Cross-correlation matrix of size (ny, nyref, N), where ny        is the number of signals (ny = 1 if y is a vector)\n\n\nNote\n\nxcorr(y, N) = xcorr(y, y, N)\n\n\n\n\n\n\n\n\n\nhalf_csd\n\n\n\nhalf_psd(Gyy, freq)\nhalf_psd(y, yref, freq, fs, bs)\nhalf_psd(y, freq, fs, bs)\n\nCompute the half power spectral density matrix Gyy_half given the\nspectral density matrix Gyy.\nInputs\n\nGyy: Power spectral density matrix of size (ni, no, nf),      where ni is the number of inputs, no is the number of outputs,      and nf is the number of frequency points.\n\nfreq::AbstractVector: Frequency vector (Hz)\n\n\nAlternative inputs\n\ny::VecOrMat{Real}: Output signal\n\nyref::VecOrMat{Real}: Reference output signal\n\nfreq::AbstractVector: Frequency vector (Hz)\n\nfs: Sampling frequency (Hz)\n\nbs: Block size used to compute the cross-correlation matrix\n\n\nOutput\n\nGyy_half::Array{Complex, 3}: Half-spectrum matrix\n\n\nReferences\n[1] S. Chauhan. \"Parameter estimation algorithms in operational modal analysis\". In Proceedings of the 6th International Operational Modal Analysis Conference (IOMAC), Gijon, Spain, 2015.\n[2] B. Peeters and H. Van der Auweraer, \"PolyMax: A revolution in operational modal analysis\". In Proceedings of the 1st International Operational Modal Analysis Conference (IOMAC), Copenhagen, Denmark, 2005.\n[3] R. Brincker and C. E. Ventura. \"Introduction to operational modal analysis\". Wiley, 2015.\n\n\n\n\n\n\n\ncsd_from_tf\n\n\n\ncsd_from_tf(H, Gxx; id_input, id_output)\nCompute the output cross-spectral density matrix Gyy given the frequency response function matrix H and the input cross-spectral density matrix Gxx.\nInputs\n\nH::Array{Complex, 3}: Frequency response function matrix of size (no, ni, nf),\n\nGxx: Input power spectral density matrix of size (ni, ni, nf)\n\nid_input::AbstractVector: Indices of input channels to consider (default: all inputs)\n\nid_output::AbstractVector: Indices of output channels to consider (default: id_input)\n\n\nOutput\n\nGyy::Array{Complex, 3}: Output cross-spectral density matrix of size (ni, no, nf)\n\n\nReferences\n[1] B. Peeters and H. Van der Auweraer, \"PolyMax: A revolution in operational modal analysis\". In Proceedings of the 1st International Operational Modal Analysis Conference (IOMAC), Copenhagen, Denmark, 2005.\n\n\n\n\n\n\n\nconvert_csd\n\n\n\nconvert_csd(Gyy, freq; type = :dis)\nConvert a cross-spectral density matrix to displacement type\nInputs\n\nGyy: Cross-spectral density matrix of size (ni, no, nf),        where ni is the number of inputs, no is the number of outputs,        and nf is the number of frequency points.\n\nfreq::AbstractVector: Frequency vector (Hz)\n\ntype::Symbol: Type of Gyy\n\n:dis: displacement (default) - no conversion\n\n:vel: velocity\n\n:acc: acceleration\n\n\n\n\nOutput\n\nGyy_conv: Converted cross-spectral density matrix\n\n\n\n\n\n\n\n\n\npoles_extraction\n\n\n\npoles_extraction(prob, order, method; stabdiag)\nExtract poles using Stochastic System Identification methods.\nInputs\n\nprob::OMAProblem: Structure containing half-spectrum data and frequency vector\n\norder::Int: Order of the system to identify\n\nmethod::MdofOMA: OMA method to use for pole extraction\n\nCovSSI: Covariance-based SSI (default)\n\nDataSSI: Data-based SSI\n\n\n\nstabdiag::Bool: Whether to compute stabilization diagram (default: false)\n\n\nOutput\n\npoles::Vector{Complex}: Extracted poles\n\n\nReferences [1] C. Rainieri and G. Fabbrocino. \"Operational Modal Analysis of Civil Engineering Structures: An Introduction and Guide for Applications\". Springer, 2014.\n[2] P. Peeters and G. De Roeck. \"Reference-based stochastic subspace identification for output-only modal analysis\". Mechanical Systems and Signal Processing, 13(6):855-878, 1999.\n[3] L. Hermans and H. Van der Auweraer. \"Modal testing and analysis of structures under operational conditions: Industrial applications\". Mechanical Systems and Signal Processing, 13(2):193-216, 1999.\n\n\n\n\n\n\n\nmodes_extraction\n\n\n\nmodes_extraction(prob, alg::FSDD; width, min_prom, max_prom , pks_indices, min_mac, avg_alg)\nExtract modes from an Operational Modal Analysis problem using the Full Spectrum Decomposition and Decay (FSDD) method\nInputs\n\nprob::OMAProblem: OMA problem containing the CSD matrix and frequency lines.\n\nalg::SdofOMA: OMA method to use for pole extraction\n\nFSDD: Frequency-spatial Domain Decomposition)\n\n\n\nwidth::Int = 1: Width parameter for peak detection in the singular value spectrum\n\nmin_prom::Float64 = 0.: Minimum peak prominence for peak detection\n\nmax_prom::Float64 = Inf: Maximum peak prominence for peak detection\n\npks_indices::Vector{Int} = Int[]: Predefined indices of peaks\n\nmin_mac::Float64 = 0.9: Minimum MAC value to consider neighboring frequencies for mode shape estimation\n\navg_alg::Symbol = :sv: Averaging algorithm to use for mode shape estimation\n\n:sv: Weighted averaging using singular values\n\n:lin: Linear averaging\n\n\n\n\nOutputs\n\npoles::Vector{ComplexF64}: Extracted poles\n\nms::Array{ComplexF64, 2}: Extracted mode shapes\n\n\n\n\nmodes_extraction(prob, order, method; stabdiag)\nExtract modes using Stochastic System Identification methods.\nInputs\n\nprob::OMAProblem: Structure containing half-spectrum data and frequency vector\n\norder::Int: Order of the system to identify\n\nmethod: OMA method to use for pole extraction\n\nCovSSI: Covariance-based SSI (default)\n\nDataSSI: Data-based SSI\n\n\n\nstabdiag::Bool: Whether to compute stabilization diagram (default: false)\n\n\nOutput\n\npoles::Vector{Complex}: Extracted poles\n\nms::Matrix{Complex}: Extracted modal parameters\n\n\nReferences [1] C. Rainieri and G. Fabbrocino. \"Operational Modal Analysis of Civil Engineering Structures: An Introduction and Guide for Applications\". Springer, 2014.\n[2] P. Peeters and G. De Roeck. \"Reference-based stochastic subspace identification for output-only modal analysis\". Mechanical Systems and Signal Processing, 13(6):855-878, 1999.\n[3] L. Hermans and H. Van der Auweraer. \"Modal testing and analysis of structures under operational conditions: Industrial applications\". Mechanical Systems and Signal Processing, 13(2):193-216, 1999.\n\n\n\n\n\n\n\nhalf_csd_reconstruction\n\n\n\nhalf_csd_reconstruction(res, poles, freq; lr, ur, type)\nReconstruct a half-spectrum from its residues and poles.\nInputs\n\nres::Array{Complex, 3}: Residues corresponding to each pole\n\npoles::Vector{Complex}: Poles extracted from the half-spectrum\n\nfreq::Vector{Float64}: Frequency vector\n\nlr::Matrix{Complex, 2}: Lower residuals (default: zeros)\n\nur::Matrix{Complex, 2}: Upper residuals (default: zeros)\n\n\nOutput\n\nH_rec::Array{Complex, 3}: Reconstructed FRF\n\n\n\n\n\n\n\n\n\ncompute_residuals\n\n\n\ncompute_residuals(prob, res, poles)\nCompute lower and upper residuals of a frequency response function (FRF) given its residues and poles.\nInputs\n\nprob::EMAProblem: Structure containing FRF data and frequency vector\n\nres::Array{Complex, 3}: Residues corresponding to each pole\n\npoles::Vector{Complex}: Poles extracted from the FRF\n\n\nOutputs\n\nlr::Matrix{Complex, 2}: Lower residuals\n\nur::Matrix{Complex, 2}: Upper residuals\n\n\n\n\ncompute_residuals(prob, res, poles)\nCompute lower and upper residuals of a half-spectrum given its residues and poles.\nInputs\n\nprob::OMAProblem: Structure containing half-spectrum data and frequency vector\n\nres::Array{Complex, 3}: Residues corresponding to each pole\n\npoles::Vector{T}: Poles extracted from the half-spectrum\n\n\nOutputs\n\nlr::Matrix{Complex, 2}: Lower residuals\n\nur::Matrix{Complex, 2}: Upper residuals",
    "crumbs": [
      "Modal extraction",
      "Operational Modal Analysis"
    ]
  },
  {
    "objectID": "modal_extraction/oma.html#example",
    "href": "modal_extraction/oma.html#example",
    "title": "Operational Modal Analysis",
    "section": "4 Example",
    "text": "4 Example\n\n4.1 Data preparation\n\n# Structure parameters of the beam\nL = 1.        # Length\nb = 0.03      # Width\nh = 0.01      # Thickness\nS = b*h       # Cross-section area\nIz = b*h^3/12 # Moment of inertia\n\n# Material parameters\nE = 2.1e11  # Young's modulus\nρ = 7850.   # Density\nξ = 0.01    # Damping ratio\n\n# Mesh\nx = 0:0.05:L\n\n# Acquisition parameters\nsample_rate = 4096\nblock_size = 4096\nfft_params = FFTParameters(sample_rate, block_size)\n\nfreq = fft_params.freq\nt = fft_params.t\ndt = fft_params.dt\n\n# Mode calculation - Simply supported boundary conditions\nbeam = Beam(L, S, Iz, E, ρ)\nωn, kn = modefreq(beam, 2freq[end])\nms_ref = modeshape(beam, kn, x)\n\n# Chirp excitation\nF0 = 10.\nchirp = SweptSine(F0, t[1], 0.8t[end], freq[1], freq[end], zero_end = true)\nforce = zeros(length(x), length(t))\nforce[2, :] .= excitation(chirp, t)\n\n# Response calculation\nprob = ForcedModalTimeProblem(ωn, ms_ref, ξ*ones(length(kn)), ms_ref'force, (zeros(length(x)), zeros(length(x))), t)\ny = solve(prob).u\n\n# OMA problem definition\ntukeywin(x) = tukey(x, 0.5)\nprob_oma = OMAProblem(y, t, sample_rate, block_size, win = tukeywin, frange = [1., 1000.])\n\n\n\n4.2 Frequency-spatial Domain Decomposition\n\npks_indices = [23, 94, 211, 375, 586, 845]\np_fsdd, ms_fsdd = modes_extraction(prob_oma, FSDD(), pks_indices = pks_indices)\nms_fsdd_real = real_normalization(ms_fsdd)\n\n# Mode shape scaling for comparison using the modal scale factor\nscaling = msf(ms_fsdd_real, ms_ref[:, 1:size(ms_fsdd_real, 2)])\nms_fsdd_scaled = ms_fsdd_real .* scaling'\n\n\n\n\n\n\n\n\n\n\n\n\n\n4.3 EMA-based OMA\n\n4.3.1 Poles extraction using LSCF\n\n# EMA-MDOF pole stability analysis\nsol_stab = stabilization(prob_oma, 30, LSCF())\n\n# Extraction of stable poles\nstab_poles = sol_stab.poles[end][.!isnan.(sol_stab.poles[end])]\n\n# Plot stabilization diagram\nstabilization_plot(sol_stab)\n\n\n\n\n\n\n\n\n4.3.2 Mode shapes extraction\n\n# Computation of the mode residues\nres = mode_residues(prob_oma, stab_poles)\n\n# Extraction of the mode shapes\nms_ema = modeshape_extraction(res, stab_poles, LSCF(), modetype = :oma)[1]\n\n# Convert to real mode shapes\nms_ema_real = real_normalization(ms_ema)\n\n# Mode shape scaling for comparison using the modal scale factor\nscaling = msf(ms_ema_real, ms_ref[:, 1:size(ms_ema_real, 2)])\nms_ema_scaled = ms_ema_real .* scaling'\n\n\n\n\n\n\n\n\n4.3.3 Half-spectrum reconstruction\n\n# Half-spectrum reconstruction - without residuals\nSyy = half_csd_reconstruction(res, stab_poles, prob_oma.freq)\n\n# Half-spectrum reconstruction - with residuals\nlr, ur = compute_residuals(prob_oma, res, stab_poles)\nSyy2 = half_csd_reconstruction(res, stab_poles, prob_oma.freq, lr = lr, ur = ur)\n\n\n\n\n\n\n\n\n\n4.4 Covariance-driven Stochastic Subspace Identification\n\n# Stabilization analysis\nsol_stab_cssi = stabilization(prob_oma, 30, CovSSI())\n\n# Plot stabilization diagram\nstabilization_plot(sol_stab_cssi)\n\n\n\n\n\n# Extraction of stable modes\np_cssi, ms_cssi = modes_extraction(prob_oma, 30, CovSSI())\nms_cssi_real = real_normalization(ms_cssi)\n\n# Mode shape scaling for comparison using the modal scale factor\nscaling = msf(ms_cssi_real, ms_ref[:, 1:size(ms_cssi_real, 2)])\nms_cssi_scaled = ms_cssi_real .* scaling'\n\n\n\n\n\n\n\n\n\n\n\n\n\n4.5 Data-driven Stochastic Subspace Identification\n\n# Stabilization analysis\nsol_stab_dssi = stabilization(prob_oma, 30, DataSSI())\n\n# Plot stabilization diagram\nstabilization_plot(sol_stab_dssi)\n\n\n\n\n\n# Extraction of stable modes\np_dssi, ms_dssi = modes_extraction(prob_oma, 30, DataSSI())\nms_dssi_real = real_normalization(ms_dssi)\n\n# Mode shape scaling for comparison using the modal scale factor\nscaling = msf(ms_dssi_real, ms_ref[:, 1:size(ms_dssi_real, 2)])\nms_dssi_scaled = ms_dssi_real .* scaling'",
    "crumbs": [
      "Modal extraction",
      "Operational Modal Analysis"
    ]
  },
  {
    "objectID": "modal_extraction/oma.html#footnotes",
    "href": "modal_extraction/oma.html#footnotes",
    "title": "Operational Modal Analysis",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nW. Tong, Z. Lingmi and T. Yukio. “An operational modal analysis method in frequency and spatial domain”. Earthquake engineering and engineering vibration, 4(2): 295-300, 2005.↩︎\nR. Brincker, C. E. Ventura and P. Andersen. “Damping estimation by Frequency Domain Decomposition”. In Proceedings of IMAC XIX, Orlando, Florida, USA. 2001.↩︎\nR. Brincker and L. Zhang. “Frequency domain decomposition revisited”. In PProceedings of the 3rd International Operational Modal Analysis conference (IOMAC), Portonovo, Italy, 2009.↩︎\nB. Peeters and H. Van der Auweraer. “Polymax: A revolution in operational modal analysis”. In Proceedings of the 1st International Operational Modal Analysis conference (IOMAC), Copenhagen, Denmark, 2005.↩︎\nR. Brincker and C. Ventura. “Introduction to Operational Modal Analysis”. Wiley, 2015.↩︎",
    "crumbs": [
      "Modal extraction",
      "Operational Modal Analysis"
    ]
  },
  {
    "objectID": "modal_extraction/ods.html",
    "href": "modal_extraction/ods.html",
    "title": "Operational Deflection Shapes",
    "section": "",
    "text": "An Operational Deflection Shape (ODS) represents the deformation pattern of a structure at a specific frequency when it is subjected to operational forces. Unlike traditional mode shapes, which are derived from theoretical models or controlled experiments, ODS are obtained from measurements taken while the structure is in operation. This makes them particularly useful for understanding how a structure behaves under real-world conditions. If the structure under consideration is lightly damped, ODS can approximate mode shapes, providing insights into the dynamic characteristics of the structure.",
    "crumbs": [
      "Modal extraction",
      "Operational Deflection Shapes"
    ]
  },
  {
    "objectID": "modal_extraction/ods.html#extracting-ods-from-measured-data",
    "href": "modal_extraction/ods.html#extracting-ods-from-measured-data",
    "title": "Operational Deflection Shapes",
    "section": "1 Extracting ODS from measured data",
    "text": "1 Extracting ODS from measured data\nThe extraction of ODS from the measured data typically depends on the measured quantities. In StructuralVibration.jl, we provide methods to extract ODS from response spectra and cross-spectral density matrices.\n\n1.1 Extraction from response spectra\nWhen response spectra are available, ODS can be extracted by identifying the peaks in the spectra corresponding to the frequencies of interest. The ODS \\(\\boldsymbol{\\Psi}_k\\) at a specific frequency peak \\(f_k\\) is simply given by:\n\\[\n\\boldsymbol{\\Psi}_k = \\mathbf{y}(f_k),\n\\] where \\(\\mathbf{y}(f_k)\\) is the response spectrum vector at frequency \\(f_k\\).\n\n\n1.2 Extraction from CSD matrices\nWhen cross-spectral density (CSD) matrices are available, ODSs can be extracted using singular value decomposition (SVD). The CSD matrix \\(\\mathbf{G}_{yy}(f)\\) at some frequency \\(f\\) can be decomposed as 1: \\[\n\\mathbf{G}_{yy}(f) = \\boldsymbol{\\Phi}\\boldsymbol{G}_{qq}(f) \\boldsymbol{\\Phi}^H,\n\\] where \\(\\boldsymbol{\\Phi}\\) is the mode shapes matrix, and \\(\\boldsymbol{G}_{qq}(f)\\) is the power spectral density matrix of the modal coordinates. On the other hand, performing SVD on the CSD matrix yields:\n\\[\n\\mathbf{G}_{yy}(f) = \\mathbf{U}(f) \\boldsymbol{\\Sigma}(f) \\mathbf{U}(f)^H,\n\\] where \\(\\mathbf{U}\\) consists of the left singular vectors, and \\(\\boldsymbol{\\Sigma}\\) is a diagonal matrix containing the singular values. This comparison reveals a connection between the singular vectors and the mode shapes. In fact, near a resonance frequency \\(f_k\\), the largest singular value is associated with the dominant mode at that frequency.\nConsequently, the ODS \\(\\boldsymbol{\\Psi}_k\\) at frequency \\(f_k\\) is given by the first singular vector: \\[\n\\boldsymbol{\\Psi}_k = \\mathbf{u}_1(f_k).\n\\]\n\n\n1.3 Real-normalization of ODS\nIn practice, ODS are often real-normalized for better interpretability. It consists in converting the complex-valued ODS \\(\\boldsymbol{\\Psi}_k\\) into a real-valued vector \\(\\bar{\\boldsymbol{\\Psi}}_k\\). This can be achieved using the real_normalization function (see Mode shapes real-normalization).\n\n\n1.4 Improve ODS extraction robustness\nIn an attempt to improve the robustness of the ODS extraction, especially in the presence of noise, an averaging technique can be employed. This involves averaging multiple ODS candidates within a frequency band around each identified peak frequency. The candidates are selected based on a Modal Assurance Criterion (MAC) threshold to ensure they are sufficiently similar to the reference ODS at the peak frequency. This approach allows defining what is called the Sdof-bell corresponding to the frequencies around each peak where the ODS candidates are considered for averaging.\nTo estimate the ODS from the average of all selected candidates, a weighted averaging process is implemented using the following formula: \\[\n\\boldsymbol{\\Psi}_k = \\frac{\\sum_{i=1}^{N_k} w_i\\, \\mathbf{u}_1(\\omega_i)}{\\sum_{i=1}^{N_k} w_i},\n\\] where \\(N_k\\) is the number of selected candidates within the bell and \\(w_i\\) are the weights assigned to each candidate.\nIn StructuralVibration.jl, the weights are either uniform (i.e. \\(w_i = 1\\)) or based on the value of the largest singular value of the CSD matrix at the peak frequency (i.e. \\(w_i = s_1(\\omega_i)\\)). From a theoretical standpoint, using the singular value as a weight give more importance to candidates that are more likely to represent the true mode shape and less importance to those that may be influenced by noise or other factors.",
    "crumbs": [
      "Modal extraction",
      "Operational Deflection Shapes"
    ]
  },
  {
    "objectID": "modal_extraction/ods.html#api",
    "href": "modal_extraction/ods.html#api",
    "title": "Operational Deflection Shapes",
    "section": "2 API",
    "text": "2 API\n\nods\n\n\n\nods(y, freq, pks_indices)\nods(y, freq, pks_indices, min_mac)\nods(Gyy, freq, pks_indices)\nods(Gyy, freq, pks_indices, min_mac; avg_alg)\nCompute the operational deflection shapes (ODS) from response spectrum.\nInputs\n\ny::Matrix{Complex}: Response spectrum matrix (noutput x nfrequency)\n\nGyy::Array{Complex, 3}: Cross-spectral density matrix (nouput x ninput x n_frequency)\n\nfreq: Frequency vector (Hz)\n\npks_indices: Indices of the peaks in the frequency vector\n\nmin_mac: Minimum MAC value to consider a candidate ODS for averaging\n\navg_alg: Algorithm used for averaging\n\n:lin: Linear averaging\n\n:sv: Weighted average using singular value (default)\n\n\n\n\nOutputs\n\nods_mode: Operational deflection shape\n\nfreq_pks: Frequencies at the peaks (Hz)\n\n\nNote\n\nThe ODS are normalized such that the maximum absolute value of each mode shape is 1.",
    "crumbs": [
      "Modal extraction",
      "Operational Deflection Shapes"
    ]
  },
  {
    "objectID": "modal_extraction/ods.html#example",
    "href": "modal_extraction/ods.html#example",
    "title": "Operational Deflection Shapes",
    "section": "3 Example",
    "text": "3 Example\n\n3.1 Extracting ODS from response spectra\n\n# Structure parameters of the beam\nL = 1.        # Length\nb = 0.03      # Width\nh = 0.01      # Thickness\nS = b*h       # Cross-section area\nIz = b*h^3/12 # Moment of inertia\n\n# Material parameters\nE = 2.1e11  # Young's modulus\nρ = 7850.   # Density\nξ = 0.01    # Damping ratio\n\n# Mesh\nx = 0:0.05:L\nxexc = x[2]\n\n# Mode calculation - Simply supported boundary conditions\nbeam = Beam(L, S, Iz, E, ρ)\nfmax = 500.\n\nωn, kn = modefreq(beam, 2fmax)\nms_exc = modeshape(beam, kn, xexc)\nms_m = modeshape(beam, kn, x)\n\n# Response spectrum calculation\nfreq = 1.:0.1:fmax\nFn = repeat(ms_exc', 1, length(freq)) # Frequency-independent force vector\nprob = ModalFreqProblem(ωn, ξ, Fn, freq, ms_m)\ny = solve(prob).u\n\npks_indices = [225, 929, 2101, 3743]\nods_complex, freq_peaks = ods(y, freq, pks_indices)\nods_real = real_normalization(ods_complex)\n\nscaling = msf(ods_real, ms_m[:, 1:size(ods_real, 2)])\nods_scaled = ods_real .* scaling'\n\n\n\n\n\n\n\n\n3.2 Extracting ODS from CSD matrices\n\n# Acquisition parameters\nsample_rate = 4096\nblock_size = 4096\nfft_params = FFTParameters(sample_rate, block_size)\n\nfreq = fft_params.freq\nt = fft_params.t\ndt = fft_params.dt\n\n# Mode calculation - Simply supported boundary conditions\nωn, kn = modefreq(beam, 2freq[end])\nms_ref = modeshape(beam, kn, x)\n\n# Chirp excitation\nF0 = 10.\nchirp = SweptSine(F0, t[1], 0.8t[end], freq[1], freq[end], zero_end = true)\nforce = zeros(length(x), length(t))\nforce[2, :] .= excitation(chirp, t)\n\n# Response calculation\nprob = ForcedModalTimeProblem(ωn, ms_ref, ξ*ones(length(kn)), ms_ref'force, (zeros(length(x)), zeros(length(x))), t)\ny = solve(prob).u\n\ntukeywin(x) = tukey(x, 0.5)\nGyy, freq = csd(y, y, block_size, tukeywin, fs = sample_rate)\n\nfrange = [0., 500.]\nfreq_idx = freq .&gt;= frange[1] .&& freq .&lt;= frange[2]\nfreq = freq[freq_idx]\nGyy = Gyy[:, :, freq_idx]\n\npks_indices = [23, 94, 211, 375]\nods_complex, freq_peaks = ods(Gyy, freq, pks_indices)\nods_real = real_normalization(ods_complex)\n\nscaling = msf(ods_real, ms_m[:, 1:size(ods_real, 2)])\nods_scaled = ods_real .* scaling'",
    "crumbs": [
      "Modal extraction",
      "Operational Deflection Shapes"
    ]
  },
  {
    "objectID": "modal_extraction/ods.html#footnotes",
    "href": "modal_extraction/ods.html#footnotes",
    "title": "Operational Deflection Shapes",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nC. Rainieri and F. Fabbrocino, “Operational modal analysis of civil engineering structures: An introduction and guide for applications” Springer, 2014.↩︎",
    "crumbs": [
      "Modal extraction",
      "Operational Deflection Shapes"
    ]
  }
]