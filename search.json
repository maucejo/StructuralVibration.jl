[
  {
    "objectID": "modal_extraction/indicators.html",
    "href": "modal_extraction/indicators.html",
    "title": "Quality and analysis indicators",
    "section": "",
    "text": "The following indicators can be used to assess the complexity of the identified modes.\n\n\nThe Mode Overcomplexity Value (MOV) of a mode \\(i\\) is defined as: \\[\nMOV_i = \\frac{\\sum_{n = 1}^N s_{ni} \\vert\\phi_{ni}\\vert^2}{\\sum_{n = 1}^N \\vert\\phi_{ni}\\vert^2},\n\\] where \\(\\phi_{ni}\\) is the mode shape value at degree of freedom \\(n\\) for mode \\(i\\), and \\(s_{ni}\\) is a weighted factor. The latter is given by: \\[\ns_{ni} = \\begin{cases}\n0 & \\text{if } \\text{Im}(-\\lambda_i^2\\phi_{ni}^2 c_i) &gt; 0 \\\\\n1 & \\text{if } \\text{Im}(-\\lambda_i^2\\phi_{ni}^2 c_i) \\leq 0\n\\end{cases},\n\\] where \\(\\lambda_i\\) is the complex eigenvalue for mode \\(i\\), and \\(c_i\\) is the corresponding scaling factor.\nA value close to 1 indicates physical modes, while a value close to 0 indicates spurious modes (or computational modes).\n\nmov\n\n\n\nmov(poles, ms, ci)\nCompute the mode overcomplexity value\nThis indicator is a weighted percentage of the degrees of freedom of the response for which adding mass leads to a negative frequency shift. A value close to 1 indicates physical modes, while a low value indicates non-physical modes (numerical or noise-related)\nInputs\n\npoles: Poles of the system\n\nms: Mode shapes (each column corresponds to a mode)\n\nci: Scaling factors associated to the mode shapes\n\n\nOutput\n\nmov: Mode overcomplexity values\n\n\nReference\n[1] M+P Analyzer manual. Rev. 5.1. 2017\n\n\n\n\n\n\n\n\n\nThe Mode Phase Collinearity (MPC) aims at determining whether a mode is real or complex. It is an indicator defined in \\([0, 1]\\). For a mode \\(i\\), it is given by: \\[\n  MPC_i = \\left(\\frac{\\lambda_1 - \\lambda_2}{\\lambda_1 + \\lambda_2}\\right)^2,\n\\] where \\(\\lambda_1 = \\frac{S_{xx} + S_{yy}}{2} + \\sqrt{\\left(\\frac{S_{xx} - S_{yy}}{2}\\right)^2 + S_{xy}^2}\\) and \\(\\lambda_2 = \\frac{S_{xx} + S_{yy}}{2} - \\sqrt{\\left(\\frac{S_{xx} - S_{yy}}{2}\\right)^2 + S_{xy}^2}\\) are the eigenvalues of the covariance matrix \\(\\mathbf{S}\\): \\[\n\\mathbf{S} = \\begin{bmatrix}\nS_{xx} & S_{xy} \\\\\nS_{xy} & S_{yy}\n\\end{bmatrix} \\text{ with } \\begin{cases}\nS_{xx} = \\text{Re}(\\tilde{\\phi}_i)^T\\text{Re}(\\tilde{\\phi}_i) \\\\\nS_{yy} = \\text{Im}(\\tilde{\\phi}_i)^T\\text{Im}(\\tilde{\\phi}_i) \\\\\nS_{xy} = \\text{Re}(\\tilde{\\phi}_i)^T\\text{Im}(\\tilde{\\phi}_i)\n\\end{cases}\n\\] Here, \\(\\tilde{\\phi}_i\\) is the corrected mode shape vector for the mode \\(i\\) such that: \\[\n\\tilde{\\phi}_{ni} = \\phi_{ni} - \\frac{\\sum_{m = 1}^N \\phi_{mi}}{N}.\n\\]\nA value close to 1 indicates a real mode, while a value close to 0 indicates a complex mode.\n\nmpc\n\n\n\nmpc(ms)\nCompute the mode phase collinearity.\nThis indicator aims to measure the complexity of a mode. Its value ranges from 0 (no collinearity) to 1 (perfect collinearity). For real modes, mpc tends towards 1.\nInput\n\nms: Mode shapes (each column corresponds to a mode)\n\n\nOutput\n\nmpc: Mode phase collinearity values\n\n\nReferences\n[1] J.-N. Juang and R. Pappa: \"An eigensystem realization algorithm for modal parameter identification and model reduction\", Journal of Guidance, Control, and Dynamics, Vol. 8, No. 5, Sept.-Oct. 1985, pp. 620-627.\n[2] M+P Analyzer manual. Rev. 5.1. 2017\n\n\n\n\n\n\n\n\n\nThe Mode Complexity Factor (MCF) for a mode \\(i\\) is defined as: \\[\nMCF_i = 1 - \\frac{(S_{xx} - S_{yy})^2 + 4S_{xy}^2}{(S_{xx} + S_{yy})^2}\n\\]\nA value close to 0 indicates a real mode, while a value close to 1 indicates a complex mode.\n\n\n\nThe Mean Phase Deviation (MPD) indicator aims to measure the complexity of a mode. Its value is close to 0 for real modes, and increases as the mode becomes more complex. It is defined as: \\[\nMPD_i = \\frac{\\sum_{n = 1}^N\\vert\\phi_{ni}\\vert\\; \\text{acos}\\left\\vert\\frac{\\text{Re}(\\phi_{ni})V_{22} - \\text{Im}(\\phi_{ni})V_{12}}{\\sqrt{V_{12}^2 + V_{22}^2}\\;\\vert\\phi_{ni}\\vert}\\right\\vert}{\\sum_{n = 1}^N \\vert\\phi_{ni}\\vert},\n\\] where \\(V_{12}\\) and \\(V_{22}\\) are the components of the right singular vector associated to the singular value decomposition of the 2 \\(\\times\\) 2 matrix \\(\\mathbf{P}\\) expressed as: \\[\n\\mathbf{P} = \\begin{bmatrix}\n\\text{Re}(\\tilde{\\phi}_i) &\n\\text{Im}(\\tilde{\\phi}_i)\n\\end{bmatrix}.\n\\]\nFor real modes, the indicator is close to 0, while it increases for complex modes.\n\nmpd\n\n\n\nmpd(ms)\nCompute the mode phase deviation.\nThis indicator aims to measure the complexity of a mode. Its value is close to 0 for real modes, and increases as the mode becomes more complex.\nInput\n\nms: Mode shapes (each column corresponds to a mode)\n\n\nOutput\n\nmpd: Mode phase deviation values\n\n\nReference\n[1] E. Reynders, J. Houbrechts and G. De Roeck. Fully automated (operational) modal analysis. Mechanical Systems and Signal Processing. 29: 228-250. 2012\n[2] A. C. Dederichs and O. Oiseth. Experimental comparison of automatic operational modal analysis algorithms for application to long-span road bridges. Mechanical Systems and Signal Processing. 199: 110485. 2023",
    "crumbs": [
      "Modal extraction",
      "Quality and analysis indicators"
    ]
  },
  {
    "objectID": "modal_extraction/indicators.html#mode-complexity-indicators",
    "href": "modal_extraction/indicators.html#mode-complexity-indicators",
    "title": "Quality and analysis indicators",
    "section": "",
    "text": "The following indicators can be used to assess the complexity of the identified modes.\n\n\nThe Mode Overcomplexity Value (MOV) of a mode \\(i\\) is defined as: \\[\nMOV_i = \\frac{\\sum_{n = 1}^N s_{ni} \\vert\\phi_{ni}\\vert^2}{\\sum_{n = 1}^N \\vert\\phi_{ni}\\vert^2},\n\\] where \\(\\phi_{ni}\\) is the mode shape value at degree of freedom \\(n\\) for mode \\(i\\), and \\(s_{ni}\\) is a weighted factor. The latter is given by: \\[\ns_{ni} = \\begin{cases}\n0 & \\text{if } \\text{Im}(-\\lambda_i^2\\phi_{ni}^2 c_i) &gt; 0 \\\\\n1 & \\text{if } \\text{Im}(-\\lambda_i^2\\phi_{ni}^2 c_i) \\leq 0\n\\end{cases},\n\\] where \\(\\lambda_i\\) is the complex eigenvalue for mode \\(i\\), and \\(c_i\\) is the corresponding scaling factor.\nA value close to 1 indicates physical modes, while a value close to 0 indicates spurious modes (or computational modes).\n\nmov\n\n\n\nmov(poles, ms, ci)\nCompute the mode overcomplexity value\nThis indicator is a weighted percentage of the degrees of freedom of the response for which adding mass leads to a negative frequency shift. A value close to 1 indicates physical modes, while a low value indicates non-physical modes (numerical or noise-related)\nInputs\n\npoles: Poles of the system\n\nms: Mode shapes (each column corresponds to a mode)\n\nci: Scaling factors associated to the mode shapes\n\n\nOutput\n\nmov: Mode overcomplexity values\n\n\nReference\n[1] M+P Analyzer manual. Rev. 5.1. 2017\n\n\n\n\n\n\n\n\n\nThe Mode Phase Collinearity (MPC) aims at determining whether a mode is real or complex. It is an indicator defined in \\([0, 1]\\). For a mode \\(i\\), it is given by: \\[\n  MPC_i = \\left(\\frac{\\lambda_1 - \\lambda_2}{\\lambda_1 + \\lambda_2}\\right)^2,\n\\] where \\(\\lambda_1 = \\frac{S_{xx} + S_{yy}}{2} + \\sqrt{\\left(\\frac{S_{xx} - S_{yy}}{2}\\right)^2 + S_{xy}^2}\\) and \\(\\lambda_2 = \\frac{S_{xx} + S_{yy}}{2} - \\sqrt{\\left(\\frac{S_{xx} - S_{yy}}{2}\\right)^2 + S_{xy}^2}\\) are the eigenvalues of the covariance matrix \\(\\mathbf{S}\\): \\[\n\\mathbf{S} = \\begin{bmatrix}\nS_{xx} & S_{xy} \\\\\nS_{xy} & S_{yy}\n\\end{bmatrix} \\text{ with } \\begin{cases}\nS_{xx} = \\text{Re}(\\tilde{\\phi}_i)^T\\text{Re}(\\tilde{\\phi}_i) \\\\\nS_{yy} = \\text{Im}(\\tilde{\\phi}_i)^T\\text{Im}(\\tilde{\\phi}_i) \\\\\nS_{xy} = \\text{Re}(\\tilde{\\phi}_i)^T\\text{Im}(\\tilde{\\phi}_i)\n\\end{cases}\n\\] Here, \\(\\tilde{\\phi}_i\\) is the corrected mode shape vector for the mode \\(i\\) such that: \\[\n\\tilde{\\phi}_{ni} = \\phi_{ni} - \\frac{\\sum_{m = 1}^N \\phi_{mi}}{N}.\n\\]\nA value close to 1 indicates a real mode, while a value close to 0 indicates a complex mode.\n\nmpc\n\n\n\nmpc(ms)\nCompute the mode phase collinearity.\nThis indicator aims to measure the complexity of a mode. Its value ranges from 0 (no collinearity) to 1 (perfect collinearity). For real modes, mpc tends towards 1.\nInput\n\nms: Mode shapes (each column corresponds to a mode)\n\n\nOutput\n\nmpc: Mode phase collinearity values\n\n\nReferences\n[1] J.-N. Juang and R. Pappa: \"An eigensystem realization algorithm for modal parameter identification and model reduction\", Journal of Guidance, Control, and Dynamics, Vol. 8, No. 5, Sept.-Oct. 1985, pp. 620-627.\n[2] M+P Analyzer manual. Rev. 5.1. 2017\n\n\n\n\n\n\n\n\n\nThe Mode Complexity Factor (MCF) for a mode \\(i\\) is defined as: \\[\nMCF_i = 1 - \\frac{(S_{xx} - S_{yy})^2 + 4S_{xy}^2}{(S_{xx} + S_{yy})^2}\n\\]\nA value close to 0 indicates a real mode, while a value close to 1 indicates a complex mode.\n\n\n\nThe Mean Phase Deviation (MPD) indicator aims to measure the complexity of a mode. Its value is close to 0 for real modes, and increases as the mode becomes more complex. It is defined as: \\[\nMPD_i = \\frac{\\sum_{n = 1}^N\\vert\\phi_{ni}\\vert\\; \\text{acos}\\left\\vert\\frac{\\text{Re}(\\phi_{ni})V_{22} - \\text{Im}(\\phi_{ni})V_{12}}{\\sqrt{V_{12}^2 + V_{22}^2}\\;\\vert\\phi_{ni}\\vert}\\right\\vert}{\\sum_{n = 1}^N \\vert\\phi_{ni}\\vert},\n\\] where \\(V_{12}\\) and \\(V_{22}\\) are the components of the right singular vector associated to the singular value decomposition of the 2 \\(\\times\\) 2 matrix \\(\\mathbf{P}\\) expressed as: \\[\n\\mathbf{P} = \\begin{bmatrix}\n\\text{Re}(\\tilde{\\phi}_i) &\n\\text{Im}(\\tilde{\\phi}_i)\n\\end{bmatrix}.\n\\]\nFor real modes, the indicator is close to 0, while it increases for complex modes.\n\nmpd\n\n\n\nmpd(ms)\nCompute the mode phase deviation.\nThis indicator aims to measure the complexity of a mode. Its value is close to 0 for real modes, and increases as the mode becomes more complex.\nInput\n\nms: Mode shapes (each column corresponds to a mode)\n\n\nOutput\n\nmpd: Mode phase deviation values\n\n\nReference\n[1] E. Reynders, J. Houbrechts and G. De Roeck. Fully automated (operational) modal analysis. Mechanical Systems and Signal Processing. 29: 228-250. 2012\n[2] A. C. Dederichs and O. Oiseth. Experimental comparison of automatic operational modal analysis algorithms for application to long-span road bridges. Mechanical Systems and Signal Processing. 199: 110485. 2023",
    "crumbs": [
      "Modal extraction",
      "Quality and analysis indicators"
    ]
  },
  {
    "objectID": "modal_extraction/indicators.html#correlation-indicators",
    "href": "modal_extraction/indicators.html#correlation-indicators",
    "title": "Quality and analysis indicators",
    "section": "2 Correlation indicators",
    "text": "2 Correlation indicators\nThe following indicators can be used to assess the correlation between measured and reconstructed quantities.\n\n2.1 Modal Assurance Criterion\nThe Modal Assurance Criterion (MAC) is a widely used indicator to quantify the correlation between two sets mode shapes. For two mode shapes \\(\\phi_i\\) and \\(\\psi_j\\) (column vectors), it is defined as: \\[\nMAC_{ij} = \\frac{\\vert\\psi_j^H\\phi_i\\vert^2}{(\\phi_i^H\\phi_i) (\\psi_j^H\\psi_j)},\n\\] where the superscript \\(H\\) denotes the Hermitian transpose.\nA value close to 1 indicates a strong correlation between the two mode shapes, while a value close to 0 indicates no correlation.\n\n\n\n\n\n\nNote\n\n\n\nIn StructuralVibration.jl, it is assumed that \\(\\phi_i\\) is the theoretical (or reference) mode shape, while \\(\\psi_j\\) is the experimental (or identified) mode shape.\n\n\n\nmac\n\n\n\nmac(ms_exp, ms_th)\nCompute the modal assurance criterion (MAC) between experimental and theoretical mode shapes.\nInputs\n\nms_exp: Experimental mode shapes (nmes x nmodes array)\n\nms_th: Theoretical mode shapes (nmes x nmodes array)\n\n\nOutput\n\nmac: Modal assurance criterion values (nmodes x nmodes array)\n\n\nReference\n[1] R. J. Allemang. The modal assurance criterion twenty years of use and abuse. Sound & Vibration. 37 (8): 14-23. 2003\n\n\n\n\n\n\n\n\n2.2 Coordinate Modal Assurance Criterion\nThe Coordinate Modal Assurance Criterion (COMAC) is a variant of the MAC that considers the correlation between the coordinates of two mode shapes. For a coordinate \\(p\\) of two mode shapes \\(\\phi_p\\) and \\(\\psi_p\\) (row vectors), it is defined as: \\[\nCOMAC_p = \\frac{\\vert\\phi_{pi}\\psi_{pi}^H\\vert^2}{(\\phi_{pi}\\phi_{pi}^H) (\\psi_{pi}\n\\psi_{pi}^H)},\n\\] where the superscript \\(H\\) denotes the Hermitian transpose.\n\n\n\n\n\n\nNote\n\n\n\nThe computation of the COMAC indicator requires that the two mode shapes have the same number of coordinates and similar scaling. For the the latter, one of the mode shapes is multiplied by the modal scaling factor: \\[\nMSF_i = \\frac{\\phi_i^H\\psi_i}{\\phi_i^H\\phi_i}.\n\\] The previous equation assumes that \\(\\phi_i\\) is the reference mode shape to which \\(\\psi_i\\) is scaled.\n\n\nA value close to 1 indicates a strong correlation between the two mode shapes, while a value close to 0 indicates no correlation.\n\ncomac\n\n\n\ncomac(ms_exp, ms_th)\nCompute the coordinate modal assurance criterion (COMAC) between experimental and theoretical mode shapes.\nInputs\n\nms_exp: Experimental mode shapes (nmes x nmodes array)\n\nms_th: Theoretical mode shapes (nmes x nmodes array)\n\n\nOutput\n\ncomac: Coordinate modal assurance criterion values (nmes array)\n\n\nReference\n[1] R. J. Allemang. The modal assurance criterion twenty years of use and abuse. Sound & Vibration. 37 (8): 14-23. 2003\n\n\n\n\n\n\n\n\n2.3 Enhanced Coordinate Modal Assurance Criterion\nThe Enhanced Coordinate Modal Assurance Criterion (ECOMAC) extends the COMAC to take into account potential calibration scaling errors and/or sensor orientation errors by compouting the mean deviations of mode amplitudes of each coordinate. It is defined as: \\[\nECOMAC_p = \\frac{\\sum_{i=1}^N \\vert \\phi_{pi} - \\psi_{pi} \\vert}{2 N},\n\\] where \\(N\\) is the number of modes.\n\n\n\n\n\n\nNote\n\n\n\nAs for the COMAC indicator, the computation of the ECOMAC indicator requires that the two mode shapes have the same number of coordinates and similar scaling.\n\n\nLow values of the indicator indicates a strong correlation between the two mode shapes, while high values indicate very little correlation.\n\necomac\n\n\n\necomac(ms_exp, ms_th)\nCompute the enhanced coordinate modal assurance criterion (eCOMAC) between experimental and theoretical mode shapes.\nInputs\n\nms_exp: Experimental mode shapes (nmes x nmodes array)\n\nms_th: Theoretical mode shapes (nmes x nmodes array)\n\n\nOutput\n\necomac: Enhanced coordinate modal assurance criterion values (nmes array)\n\n\nReference [1] D. L. Hunt. Application of an Enhanced Coordinate Modal Assurance Criterion (ECOMAC). Proceedings of International Modal Analysis Conference, pp. 66-71, 1992.\n[2] G. Martin, E. Balmes and T. Chancelier. Improved Modal Assurance Criterion using a quantification of identification errors per mode/sensor. Proceedings of ISMA 2014, pp. 2509-2519. 2014.\n\n\n\n\n\n\n\n\n2.4 Frequency response assurance criterion\nThe Frequency Response Assurance Criterion (FRAC) is an indicator that quantifies the correlation between two frequency response functions (FRFs) over a given frequency range for a given measurement point \\(p\\) and a given excitation point \\(q\\). For two FRFs \\(H_{pq}(\\omega)\\) and \\(G_{pq}(\\omega)\\), it is defined as: \\[\nFRAC_{pq} = \\frac{\\vert \\sum_{\\omega = \\omega_1}^{\\omega_2} H_{pq}(\\omega) G_{pq}^\\ast(\\omega) \\, \\vert^2}{\\left( \\sum_{\\omega = \\omega_1}^{\\omega_2} \\vert H_{pq}(\\omega) \\vert^2\\right) \\left( \\sum_{\\omega = \\omega_1}^{\\omega_2} \\vert G_{pq}(\\omega) \\vert^2 \\right)},\n\\] \\(G_{pq}^\\ast(\\omega)\\) is the complex conjugate of \\(G_{pq}(\\omega)\\), and \\(\\omega_1\\) and \\(\\omega_2\\) define the frequency range of interest.\n\nfrac\n\n\n\nfrac(frf_exp, frf_th)\nCompute the frequency response assurance criterion (FRAC) between experimental and theoretical frequency response functions.\nInputs\n\nfrf_exp: Experimental frequency response functions (nmes x nexc x nf array\n\nfrf_th: Theoretical frequency response functions (nmes x nexc x nf array)\n\n\nOutput\n\nfrac: Frequency response assurance criterion values (nmes x nexc array)\n\n\nReference\n[1] R. J. Allemang. The modal assurance criterion twenty years of use and abuse. Sound & Vibration. 37 (8): 14-23. 2003",
    "crumbs": [
      "Modal extraction",
      "Quality and analysis indicators"
    ]
  },
  {
    "objectID": "modal_extraction/indicators.html#indicator-functions",
    "href": "modal_extraction/indicators.html#indicator-functions",
    "title": "Quality and analysis indicators",
    "section": "3 Indicator functions",
    "text": "3 Indicator functions\nThe following indicator functions can be used to estimate the number of modes of a structure.\n\n3.1 Complex Mode Indicator Function\nThe Complex Mode Indicator Function (CMIF) is a global indicator that helps identify the number of modes in a system. It is defined as the singular values of the frequency response function (FRF) matrix \\(\\mathbf{H}(\\omega)\\) over a frequency range of interest. The FRF matrix is constructed by stacking the FRFs for all measurement points and excitation points.\nWhen admittance or accelerance are used, the CMIF is computed as the singular values of the imaginary part of the FRF matrix, while for mobility, the real part is used. From a general standpoint, the CMIF is given by: \\[\nCMIF(\\omega) = \\mathbf{\\Sigma}(\\omega),\n\\] where \\(\\mathbf{\\Sigma}(\\omega)\\) is the vector of singular values obtained from the singular value decomposition of the FRF matrix.\n\ncmif\n\n\n\ncmif(frf; type = :dis)\nCompute the complex mode indicator function (CMIF)\nInputs\n\nfrf: Frequency response functions (nmes x nexc x nf array)\n\ntype: Type of FRF (:dis for displacement, :vel for velocity, :acc for acceleration)\n\n\nOutput\n\ncmif: Complex mode indicator function (min(nmes, nexc) x nf array)\n\n\nReference\n[1] R. J. Allemang and D. L. Brown. A Complete Review of the Complex Mode  Indicator Function (CMIF) with Applications. ISMA 2006. 2006\n\n\n\n\n\n\n\n\n3.2 Power spectrum indicator function\nThe Power Spectrum Indicator Function (PSIF) is another global indicator that helps identify the number of modes in a system. It is defined as the sum of the squared magnitudes of the FRFs over all measurement points and excitation points. The PSIF is given by: \\[\nPSIF(\\omega) = \\sum_{p=1}^{N_p} \\sum_{q=1}^{N_q} \\vert H_{pq}(\\omega) \\vert^2,\n\\] where \\(N_p\\) is the number of measurement points, \\(N_q\\) is the number of excitation points, and \\(H_{pq}(\\omega)\\) is the FRF between measurement point \\(p\\) and excitation point \\(q\\).\n\npsif\n\n\n\npsif(frf)\nCompute the power spectrum indicator function (PSIF).\nInput\n\nfrf: Frequency response functions (nmes x nexc x nf array or nmes x nf array)\n\n\nOutput\n\npsif: Power spectrum indicator function (nf array)\n\n\nReference\n[1] M+P Analyzer manual. Rev. 5.1. 2017",
    "crumbs": [
      "Modal extraction",
      "Quality and analysis indicators"
    ]
  },
  {
    "objectID": "modal_extraction/frf_reconstruction.html",
    "href": "modal_extraction/frf_reconstruction.html",
    "title": "FRF reconstruction",
    "section": "",
    "text": "From the identified modal parameters (poles and residues), it is possible to reconstruct the frequency response functions (FRFs) of the system under study using the frf_reconstruction function. This function implements the following relation for a number \\(M\\) of identified modes:\n\\[\nH_{pq}(\\omega) = \\sum_{i = 1}^{M} \\left[\\frac{{}_i R_{pq}}{(j\\omega - \\lambda_i)} + \\frac{{}_i R_{pq}^\\ast}{(j\\omega - \\lambda_i^\\ast)}\\right],\n\\] where:\n\n\\(\\lambda_i = -\\xi_i + j\\,\\Omega_i\\) is the pole related to the mode \\(i\\), with:\n\n\\(\\Omega_i = \\omega_i\\sqrt{1 - \\xi_i^2}\\) is the damped natural frequency of the mode \\(i\\), with \\(\\omega_i = \\vert \\lambda_i\\vert\\).\n\\(\\xi_i = -\\frac{\\text{Re}(\\lambda_i)}{\\omega_i}\\) the modal damping factor of the mode \\(i\\) \n\n\\({}_i R_{pq} = c_i\\, \\phi_i(x_p)\\, \\phi_i(x_q)\\) is the residue of the mode \\(i\\), with:\n\n\\(\\phi_i(x_p)\\) the mode shape of the mode \\(i\\) at point \\(x_p\\)\n\\(c_i = \\frac{1}{2jM_i\\Omega_i}\\) the normalization constant of the mode shape of the mode \\(i\\)\n\n\nIn practice, however, the reconstructed FRF may not perfectly match the experimental FRF due to the unmodeled contribution of the modes outside the frequency range of interest. To account for this, it is common to include lower and upper residuals in the FRF reconstruction. This means that the admittance matrix can be expressed as: \\[\nH_{pq}(\\omega) = \\sum_{i = 1}^{M} \\left[\\frac{{}_i R_{pq}}{(j\\omega - \\lambda_i)} + \\frac{{}_i R_{pq}^\\ast}{(j\\omega - \\lambda_i^\\ast)}\\right] - \\frac{L_{pq}}{\\omega^2} + U_{pq},\n\\] where \\(L_{pq}\\) and \\(U_{pq}\\) are the lower and upper residuals, respectively. These residuals can be computed using the compute_residuals function.\n\n\n\n\n\n\nNote\n\n\n\nTheoretically, the residuals can be computed in conjunction with the estimation of the residues using a least-squares approach. However, we observed that this often leads to inaccurate estimates of the residuals. Therefore, in StructuralVibration.jl, the computation of the residuals is performed separately after estimating the residues and poles.\n\n\nFinally, when only real mode shapes are available, it is possible to compute the residues from the modal parameters using the mode2residues function. This function implements the following relation: \\[\n{}_i R_{pq} = c_i\\, \\phi_i(x_p)\\, \\phi_i(x_q),\n\\] where \\(\\phi_i(x_p)\\) is the mode shape of the mode \\(i\\) at point \\(x_p\\) and \\(c_i = \\frac{1}{2jM_i\\Omega_i}\\) is the normalization constant of the mode shape of the mode \\(i\\). Here, \\(M_i = 1\\), since the mode shapes are mass-normalized. during the extraction process.",
    "crumbs": [
      "Modal extraction",
      "FRF reconstruction"
    ]
  },
  {
    "objectID": "modal_extraction/frf_reconstruction.html#basic-principle",
    "href": "modal_extraction/frf_reconstruction.html#basic-principle",
    "title": "FRF reconstruction",
    "section": "",
    "text": "From the identified modal parameters (poles and residues), it is possible to reconstruct the frequency response functions (FRFs) of the system under study using the frf_reconstruction function. This function implements the following relation for a number \\(M\\) of identified modes:\n\\[\nH_{pq}(\\omega) = \\sum_{i = 1}^{M} \\left[\\frac{{}_i R_{pq}}{(j\\omega - \\lambda_i)} + \\frac{{}_i R_{pq}^\\ast}{(j\\omega - \\lambda_i^\\ast)}\\right],\n\\] where:\n\n\\(\\lambda_i = -\\xi_i + j\\,\\Omega_i\\) is the pole related to the mode \\(i\\), with:\n\n\\(\\Omega_i = \\omega_i\\sqrt{1 - \\xi_i^2}\\) is the damped natural frequency of the mode \\(i\\), with \\(\\omega_i = \\vert \\lambda_i\\vert\\).\n\\(\\xi_i = -\\frac{\\text{Re}(\\lambda_i)}{\\omega_i}\\) the modal damping factor of the mode \\(i\\) \n\n\\({}_i R_{pq} = c_i\\, \\phi_i(x_p)\\, \\phi_i(x_q)\\) is the residue of the mode \\(i\\), with:\n\n\\(\\phi_i(x_p)\\) the mode shape of the mode \\(i\\) at point \\(x_p\\)\n\\(c_i = \\frac{1}{2jM_i\\Omega_i}\\) the normalization constant of the mode shape of the mode \\(i\\)\n\n\nIn practice, however, the reconstructed FRF may not perfectly match the experimental FRF due to the unmodeled contribution of the modes outside the frequency range of interest. To account for this, it is common to include lower and upper residuals in the FRF reconstruction. This means that the admittance matrix can be expressed as: \\[\nH_{pq}(\\omega) = \\sum_{i = 1}^{M} \\left[\\frac{{}_i R_{pq}}{(j\\omega - \\lambda_i)} + \\frac{{}_i R_{pq}^\\ast}{(j\\omega - \\lambda_i^\\ast)}\\right] - \\frac{L_{pq}}{\\omega^2} + U_{pq},\n\\] where \\(L_{pq}\\) and \\(U_{pq}\\) are the lower and upper residuals, respectively. These residuals can be computed using the compute_residuals function.\n\n\n\n\n\n\nNote\n\n\n\nTheoretically, the residuals can be computed in conjunction with the estimation of the residues using a least-squares approach. However, we observed that this often leads to inaccurate estimates of the residuals. Therefore, in StructuralVibration.jl, the computation of the residuals is performed separately after estimating the residues and poles.\n\n\nFinally, when only real mode shapes are available, it is possible to compute the residues from the modal parameters using the mode2residues function. This function implements the following relation: \\[\n{}_i R_{pq} = c_i\\, \\phi_i(x_p)\\, \\phi_i(x_q),\n\\] where \\(\\phi_i(x_p)\\) is the mode shape of the mode \\(i\\) at point \\(x_p\\) and \\(c_i = \\frac{1}{2jM_i\\Omega_i}\\) is the normalization constant of the mode shape of the mode \\(i\\). Here, \\(M_i = 1\\), since the mode shapes are mass-normalized. during the extraction process.",
    "crumbs": [
      "Modal extraction",
      "FRF reconstruction"
    ]
  },
  {
    "objectID": "modal_extraction/frf_reconstruction.html#api",
    "href": "modal_extraction/frf_reconstruction.html#api",
    "title": "FRF reconstruction",
    "section": "2 API",
    "text": "2 API\n\nfrf_reconstruction\n\n\n\nfrf_reconstruction(res, poles, freq; lr, ur, type)\nReconstruct a frequency response function (FRF) from its residues and poles.\nInputs\n\nres::Array{Complex, 3}: Residues corresponding to each pole\n\npoles::Vector{Complex}: Poles extracted from the FRF\n\nfreq::Vector{Float64}: Frequency vector\n\nlr::Matrix{Complex, 2}: Lower residuals (default: zeros)\n\nur::Matrix{Complex, 2}: Upper residuals (default: zeros)\n\ntype::Symbol: Type of FRF to reconstruct\n\n:dis: displacement (default)\n\n:vel: velocity\n\n:acc: acceleration\n\n\n\n\nOutput\n\nH_rec::Array{Complex, 3}: Reconstructed FRF\n\n\n\n\n\n\n\n\n\ncompute_residuals\n\n\n\ncompute_residuals(prob, res, poles)\nCompute lower and upper residuals of a frequency response function (FRF) given its residues and poles.\nInputs\n\nprob::Union{EMASdofProblem, EMAMdofProblem}: Structure containing FRF data and frequency vector\n\nres::Array{Complex, 3}: Residues corresponding to each pole\n\npoles::Vector{T}: Poles extracted from the FRF\n\n\nOutputs\n\nlr::Matrix{Complex, 2}: Lower residuals\n\nur::Matrix{Complex, 2}: Upper residuals\n\n\n\n\n\n\n\n\n\nmode2residues\n\n\n\nmode2residues(ms, poles, idx_m, idx_e)\nCompute the mode residues from mode shapes and poles.\nInputs\n\nms::Matrix{Complex, 2}: Mode shapes matrix\n\npoles::Vector{Complex}: Poles extracted from the FRF\n\nidx_m::Vector{Int}: Indices of measurement locations\n\nidx_e::Vector{Int}: Indices of excitation locations\n\n\nOutput\n\nres::Array{Complex, 3}: Residues corresponding to each pole\n\n\nNote The mode shapes are supposed to be real and mass-normalized.",
    "crumbs": [
      "Modal extraction",
      "FRF reconstruction"
    ]
  },
  {
    "objectID": "modal_extraction/frf_reconstruction.html#example",
    "href": "modal_extraction/frf_reconstruction.html#example",
    "title": "FRF reconstruction",
    "section": "3 Example",
    "text": "3 Example\n\n3.1 Data preparation and FRF calculation\n\n# Structure parameters of the beam\nL = 1.        # Length\nb = 0.03      # Width\nh = 0.01      # Thickness\nS = b*h       # Cross-section area\nIz = b*h^3/12 # Moment of inertia\n\n# Material parameters\nE = 2.1e11  # Young's modulus\nρ = 7850.   # Density\nξ = 0.01    # Damping ratio\n\n# Mesh\nxexc = 0:0.05:L\nxm = xexc[2]\n\n# Mode calculation - Simply supported boundary conditions\nbeam = Beam(L, S, Iz, E, ρ)\nfmax = 500.\n\nωn, kn = modefreq(beam, 2fmax)\nϕexc = modeshape(beam, kn, xexc)\nϕm = modeshape(beam, kn, xm)\n\n# FRF calculation\nfreq = 1.:0.1:fmax\nprob = ModalFRFProblem(ωn, ξ, freq, ϕm, ϕexc)\nH = solve(prob; ismat = true).u\n\n\n\n3.2 Sdof method\n\n# Problem definition\nprob_sdof = EMASdofProblem(H, freq)\n\n# Poles extraction using the Peak Picking method\npoles_pp = poles_extraction(prob_sdof, PeakPicking())\n\n# Mode shape extraction\ndpi = [1, 2]\nϕr = modeshape_extraction(prob_sdof, poles_pp, dpi)\n\n# Computation of the mode residues\nres_pp = mode2residues(ϕr, poles_pp, [2], 1:21)\n\n# FRF reconstruction - without residuals\nH_sdof = frf_reconstruction(res_pp, poles_pp, freq)\n\n# FRF reconstruction - with residuals\nlr, ur = compute_residuals(prob_sdof, res_pp, poles_pp)\nH_sdof2 = frf_reconstruction(res_pp, poles_pp, freq, lr = lr, ur = ur)\n\n\n\n\n\n\n\n\n3.3 Mdof method\n\n# Problem definition\nprob_mdof = EMAMdofProblem(H, freq)\n\n# Poles extraction using the Least-Squares Complex Frequency-domain method\npoles_lscf = poles_extraction(prob_mdof, 20, LSCF())\n\n# Residues extraction\nres_lscf = mode_residues(prob_mdof, poles_lscf)\n\n# FRF reconstruction - without residuals\nH_mdof = frf_reconstruction(res_lscf, poles_lscf, freq)\n\n# FRF reconstruction - with residuals\nlr, ur = compute_residuals(prob_mdof, res_lscf, poles_lscf)\nH_mdof2 = frf_reconstruction(res_lscf, poles_lscf, freq, lr = lr, ur = ur)",
    "crumbs": [
      "Modal extraction",
      "FRF reconstruction"
    ]
  },
  {
    "objectID": "modal_extraction/sdof_methods.html",
    "href": "modal_extraction/sdof_methods.html",
    "title": "Sdof methods",
    "section": "",
    "text": "The Sdof methods are based on the assumption that the system can be represented as a single degree of freedom system. This means that the system can be described by a single natural frequency, damping ratio, and mode shape. The Sdof methods are typically used for systems that are lightly damped and for which the modes are well separated.\nFor these methods, it is assumed that the FRF (admittance) is given by: \\[\nH_{pq}(\\omega) = \\sum_{i = 1}^N\\frac{_{i}R_{pq}}{\\omega_i^2 - \\omega^2 + j\\eta_i\\omega_i^2}\n\\] where, for a mode \\(i\\), \\(_{i}R_{pq} = \\phi_i(x_p)\\phi_i(x_q)\\) is the residue, \\(\\omega_i\\) is the natural frequency, \\(\\eta_i\\) is the modal damping factor, and \\(\\phi_i(x_p)\\) is the mass-normalized mode shape at the point \\(x_p\\).\nWhen the natural frequencies of the modes are sufficiently spaced and the damping is low, one can write at a frequency \\(\\omega\\) close to the natural frequency \\(\\omega_i\\): \\[\nH_{pq}(\\omega) \\approx \\frac{\\phi_i(x_p)\\phi_i(x_q)}{\\omega_i^2 - \\omega^2 + j\\eta_i\\omega_i^2}.\n\\]",
    "crumbs": [
      "Modal extraction",
      "Sdof methods"
    ]
  },
  {
    "objectID": "modal_extraction/sdof_methods.html#poles-extraction",
    "href": "modal_extraction/sdof_methods.html#poles-extraction",
    "title": "Sdof methods",
    "section": "1 Poles extraction",
    "text": "1 Poles extraction\nStructuralDynamics.jl provides three SDOF methods for extracting the poles of a system from its frequency response function (FRF):\n\nPeak picking method,\nCircle fit method,\nLeast squares fit method.\n\n\n1.1 Peak picking method\nThe peak picking method is a simple and effective way to extract the natural frequencies and damping ratios of a system. The method consists of the following steps:\n\nIdentification of natural frequencies\nThey are identified from the peaks of the amplitude of the FRF. The natural frequencies are identified as the frequencies at which the FRF has a local maximum. The local maxima are determined using Peaks.jl.\nEstimation of modal damping factors\nTo estimate the value of the damping factor for mode \\(i\\), the half power bandwidth method is used. This procedure, valid for low damping (\\(\\eta_i &lt; 0.1\\)), first determines the frequencies \\(\\omega_1\\) and \\(\\omega_2\\) such that: \\[\n\\vert H_{pq}(\\omega_1)\\vert = \\vert H_{pq}(\\omega_2)\\vert = \\frac{\\vert H_{pq}(\\omega_i)\\vert}{\\sqrt{2}},\n\\] with \\(\\omega_i \\in [\\omega_1, \\omega_2]\\).\nKnowing the values of \\(\\omega_i\\), \\(\\omega_1\\), and \\(\\omega_2\\), the damping ratio for mode \\(i\\) is determined using the formula: \\[\n\\eta_i = \\frac{\\omega_2^2 - \\omega_1^2}{2\\omega_i^2}.\n\\]\n\n\n\n\n\n\n\nNote\n\n\n\nIf we consider that the shape of a resonance peak is symmetric then \\(\\omega_i = \\frac{\\omega_1 + \\omega_2}{2}\\).\nIt comes that: \\[\n\\omega_2^2 - \\omega_1^2 \\approx 2\\omega_i(\\omega_2 - \\omega_1).\n\\]\nHence, the damping ratio can be approximated as: \\[\n\\eta_i \\approx \\frac{\\omega_2 - \\omega_1}{\\omega_i}.\n\\]\nThis formula is often given in textbooks when dealing with the half power bandwidth method.\n\n\nOnce the natural frequencies and damping ratios have been determined, the poles are recovered using the relation: \\[\n\\lambda_i = -\\xi_i \\omega_i + j\\omega_i\\sqrt{1 - \\xi_i^2}.\n\\]\n\n\n\n\n\n\nWarning\n\n\n\nThanks to its extreme simplicity, this method allows for quick analysis. However, this method generally does not provide satisfactory results, as it relies on measuring the resonance peak, which is very difficult to measure precisely. This is why this method is mainly applicable to lightly damped structures with well-separated modes, whose transfer functions have been measured with good frequency resolution.\n\n\n\n\n1.2 Circle fit method\nThe circle fit method is a more sophisticated method for extracting the natural frequencies and damping ratios of a system. It allows for more accurate results than the peak picking method. It is based on the fact that the admittance forms a circle (Nyquist circle) when plotted in the complex plane (see Figure 1). Indeed, assuming that the modes are mass-normalized, it can be shown that: \\[\nRe\\left[H_{pq}(\\omega)\\right]^2 + \\left(Im\\left[H_{pq}(\\omega)\\right] + \\frac{\\Phi_i(x_p)\\Phi_i(x_q)}{2\\eta_i\\omega_i^2}\\right)^2 = \\left(\\frac{\\Phi_i(x_p)\\Phi_i(x_q)}{2\\eta_i\\omega_i^2}\\right)^2,\n\\] which is the equation of a circle of radius \\(R = \\frac{\\vert\\Phi_i(x_p)\\Phi_i(x_q)\\vert}{2\\eta_i\\omega_i^2}\\) and center \\((x_c,y_c) = \\Bigl(0,-\\frac{\\Phi_i(x_p)\\Phi_i(x_q)}{2\\eta_i\\omega_i^2}\\Bigr)\\).\n\n\n\n\n\n\nFigure 1: Typical Nyquist circle of an admittance \\(H_{pq}(\\omega)\\)\n\n\n\nThe circle fit method consists of the following steps:\n\nIdentification of natural frequencies\nTo identify the natural frequency of a mode \\(i\\), we start by parameterizing the Nyquist circle by defining the angles \\(\\psi\\) and \\(\\theta\\) as shown in Figure 1. Mathematically, it can then be shown that: \\[\n\\omega_i^2 = \\frac{\\omega_1^2\\tan\\frac{\\theta_2}{2} - \\omega_2^2\\tan\\frac{\\theta_1}{2}}{\\tan\\frac{\\theta_2}{2} - \\tan\\frac{\\theta_1}{2}},\n\\] where \\(\\omega_1\\) and \\(\\omega_2\\) are the angular frequencies such that \\(\\omega_1 &lt; \\omega_i &lt; \\omega_2\\), while \\(\\theta_1\\) and \\(\\theta_2\\) are the corresponding angles of the Nyquist circle.\nEstimation of modal damping factors\nThe damping ratio is estimated using the following formula: \\[\n\\eta_i = \\frac{\\omega_2^2 - \\omega_1^2}{\\omega_i^2}\\frac{1}{\\tan\\frac{\\theta_1}{2} - \\tan\\frac{\\theta_2}{2}}.\n\\]\n\n\n\n\n\n\n\nNote\n\n\n\nGenerally, the angles \\(\\theta_1\\) and \\(\\theta_2\\) are chosen so that: \\[\n\\theta_1 = \\frac{\\pi}{2} \\text{ and } \\theta_2 = -\\frac{\\pi}{2}.\n\\]\nIn doing so, we have: \\[\n\\omega_i^2 = \\frac{\\omega_1^2 + \\omega_2^2}{2} \\text{ and } \\eta_i = \\frac{\\omega_2^2 - \\omega_1^2}{2\\omega_i^2}.\n\\]\n\n\n\n\n1.3 Least squares fit method\nThe least squares fit method is based on the idea of fitting the frequency response function (FRF) around the resonance peaks using a least squares approach1.\nWhen the natural frequencies of the modes are sufficiently spaced and the damping is low, one can write at a frequency \\(\\omega\\) close to the natural frequency \\(f_i\\): \\[\nH_{pq}(f) \\approx \\frac{_{i}A_{pq}}{f_i^2 - f^2 + 2j\\xi_i f_i f}.\n\\]\nThe least squares fit method consists of the following steps:\n\nDefinition of the system matrices\nTo construct the system matrices, we start by rewriting the previous equation as: \\[\nH_{pq}(f) \\left(f_i^2 - f^2 + 2j\\xi_i f_i f\\right) - _{i}A_{pq} = 0.\n\\]\nThis equation can be rewritten as: \\[\n\\begin{bmatrix}\nH_{pq}(f) & 2jfH_{pq}(f) & -1\n\\end{bmatrix} \\begin{bmatrix}\nf_i^2 \\\\\n\\xi_i f_i \\\\\n_{i}A_{pq}\n\\end{bmatrix} = f^2 H_{pq}(f).\n\\]\nIf we consider \\(M\\) frequency points around the resonance peak, we can construct the following system of equations: \\[\n\\begin{bmatrix}\nH_{pq}(f_1) & 2jf_1H_{pq}(f_1) & -1 \\\\\nH_{pq}(f_2) & 2jf_2H_{pq}(f_2) & -1 \\\\\n\\vdots & \\vdots & \\vdots \\\\\nH_{pq}(f_M) & 2jf_MH_{pq}(f_M) & -1\n\\end{bmatrix} \\begin{bmatrix}\nf_i^2 \\\\\n\\xi_i f_i \\\\\n_{i}A_{pq}\n\\end{bmatrix} = \\begin{bmatrix}\nf_1^2 H_{pq}(f_1) \\\\\nf_2^2 H_{pq}(f_2) \\\\\n\\vdots \\\\\nf_M^2 H_{pq}(f_M)\n\\end{bmatrix}.\n\\]\nLeast squares solution\nThe least squares solution of the previous system of equations is given by: \\[\n\\begin{bmatrix}\nf_i^2 \\\\\n\\xi_i f_i \\\\\n_{i}A_{pq}\n\\end{bmatrix} = \\left(\\mathbf{A}^H\\mathbf{A}\\right)^{-1}\\mathbf{A}^H\\mathbf{b},\n\\] where \\(\\mathbf{A}\\) is the matrix on the left-hand side of the system of equations, \\(\\mathbf{b}\\) is the vector on the right-hand side, and \\(\\mathbf{A}^H\\) is the conjugate transpose of \\(\\mathbf{A}\\).\n\n\n\n\n\n\n\nNote\n\n\n\nIn practice, the least squares solution is not directly computed using complex numbers, as this can lead to numerical issues. Instead, the real and imaginary parts are separated to solve a real system of double size.",
    "crumbs": [
      "Modal extraction",
      "Sdof methods"
    ]
  },
  {
    "objectID": "modal_extraction/sdof_methods.html#mode-shapes-extraction",
    "href": "modal_extraction/sdof_methods.html#mode-shapes-extraction",
    "title": "Sdof methods",
    "section": "2 Mode shapes extraction",
    "text": "2 Mode shapes extraction\nThe mode shapes are extracted from the admittance matrix at the resonance frequency \\(\\omega_i\\). In this situation, the admittance matrix is defined as: \\[\n\\mathbf{H} = \\frac{1}{j\\eta_i\\omega_i^2}\n  \\begin{bmatrix}\n    \\Phi_i(x_1)^2 & \\Phi_i(x_1)\\Phi_i(x_2) & \\ldots\\ & \\Phi_i(x_1)\\Phi_i(x_N) \\\\\n    \\Phi_i(x_2)\\Phi_i(x_1) & \\Phi_i(x_2)^2 &  & \\Phi_i(x_2)\\Phi_i(x_N) \\\\\n    \\vdots & & \\ddots & \\vdots \\\\\n    \\Phi_i(x_N)\\Phi_i(x_1) & \\ldots & \\ldots & \\Phi_i(x_N)^2\n  \\end{bmatrix},\n\\] where \\(\\omega_i\\) and \\(\\eta_i\\) have been determined using the peak picking method or the circle fit method.\nTo determine the mode shapes from the knowledge of a column \\(q\\) (or a row \\(p\\)), proceed as follows:\n\nFrom the measurement of an input admittance (diagonal term of the admittance matrix), the mode shape value at point \\(x_q\\) is obtained: \\[\n\\Phi_i(x_q)^2 = -\\eta_i\\omega_i^2 \\text{Im}(H_{qq}(\\omega_i)).\n\\]\nFrom the cross-admittances (off-diagonal terms of the admittance matrix), the mode shape value at a point \\(x_p\\) is calculated: \\[\n\\Phi_i(x_p)\\Phi_i(x_q) = -\\eta_i\\omega_i^2 \\text{Im}(H_{pq}(\\omega_i))\n\\]",
    "crumbs": [
      "Modal extraction",
      "Sdof methods"
    ]
  },
  {
    "objectID": "modal_extraction/sdof_methods.html#api",
    "href": "modal_extraction/sdof_methods.html#api",
    "title": "Sdof methods",
    "section": "3 API",
    "text": "3 API\nData types\n\nEMASdofProblem\n\n\n\nEMASdofProblem(frf, freq; frange, type_frf)\nData structure defining the inputs for EMA-MDOF modal extraction methods.\nConstructor parameters\n\nfrf::Array{Complex, 3}: 3D FRF matrix (array nm x ne x nf)\n\nfreq::AbstractArray{Real}: Vector of frequency values (Hz)\n\nfrange::Vector{Real}: Frequency range for analysis (default: [freq[1], freq[end]])\n\ntype_frf::Symbol: Type of FRF used in the analysis\n\n:dis: Admittance (default)\n\n:vel: Mobility\n\n:acc: Accelerance\n\n\n\n\nFields\n\nfrf::Array{Complex, 3}: 3D admittance matrix (array nm x ne x nf)\n\nfreq::AbstractArray{Real}: Vector of frequency values (Hz)\n\ntype_frf::Symbol: Type of FRF used in the analysis\n\n\nNote The FRF is internally converted to admittance if needed.\n\n\n\n\n\n\n\nAutoEMASdofProblem\n\n\n\nAutoEMASdofProblem(prob, dpi, method)\nStructure containing the input data for automatic experimental modal analysis using Sdof methods\nFields\n\nprob::EMASdofProblem: EMA-SDOF problem containing FRF data and frequency vector\n\ndpi::Vector{Int}: Driving point indices - default = [1, 1]\n\ndpi[1]: Driving point index on the measurement mesh\n\ndpi[2]: Driving point index on the excitation mesh\n\n\n\nmethod::SdofModalExtraction: Method to extract the poles\n\nPeakPicking: Peak picking method (default)\n\nCircleFit: Circle fitting method\n\nLSFit: Least squares fitting method\n\n\n\n\n\n\n\n\n\n\n\nEMASdofSolution\n\n\n\nEMASdofSolution(poles, ϕn)\nStructure containing the solution of the automatic experimental modal analysis using Sdof methods\nFields\n\npoles: Extracted poles\n\nms: Mode shapes\n\n\n\n\n\n\n\n\nRelated functions\n\npoles_extraction\n\n\n\npoles_extraction(prob, method)\nExtract poles from the Bode diagram fitting method\nInputs\n\nprob::EMASdofProblem: EMA-SDOF problem containing FRF data and frequency vector\n\nmethod::SdofModalExtraction: Method to extract the poles\n\nPeakPicking: Peak picking method (default)\n\nCircleFit: Circle fitting method\n\nLSFit: Least squares fitting method\n\n\n\n\nOutputs\n\npoles: Vector of extracted complex poles\n\n\nNote The natural frequencies and damping ratios are extracted from each FRF (each row of the matrix) and then averaged. The number of FRF used for averaging are those having the maximum (and same) number of peaks detected.\n\n\n\n\n\n\n\nmodeshape_extraction\n\n\n\nmodeshape_extraction(prob, poles, dpi)\nExtract mode shapes using Sdof approximation\nInputs\n\nprob::EMASdofProblem: EMA-SDOF problem containing FRF data and frequency vector\n\npoles: Vector of complex poles\n\ndpi: Driving point indices - default = [1, 1]\n\ndpi[1]: Driving point index on the measurement mesh\n\ndpi[2]: Driving point index on the excitation mesh\n\n\n\n\nOutput\n\nϕn: Mode shapes\n\n\nNote If the number of measurement points is less than the number of excitation points, the mode shapes are estimated at the excitation points (roving hammer test). Otherwise, the mode shapes are estimated at the measurement points (roving accelerometer test).\n\n\nmodeshape_extraction(residues, poles, dpi; type = :complex)\nExtract mode shapes using MDOF approximation\nInputs\n\nresidues: Residues matrix of size (np, nm, ne)\n\npoles: Vector of complex poles\n\ndpi: Driving point indices - default = [1, 1]\n\ndpi[1]: Driving point index on the measurement mesh\n\ndpi[2]: Driving point index on the excitation mesh\n\n\n\ntype: Type of mode shape\n\n:complex: Complex mode shapes (default)\n\n:real: Real mode shapes\n\n\n\n\nOutputs\n\nms: Mode shapes matrix\n\nci: Scaling factors vector\n\n\n\n\n\n\n\n\n\nsolve\n\n\n\nsolve(prob::AutoEMASdofProblem)\nSolve automatically experimental modal analysis problem using Sdof methods\nInputs\n\nprob_ema: Structure containing the input data for automatic experimental modal analysis using Sdof methods\n\n\nOutputs\n\nsol::EMASdofSolution: Structure containing the solution of the automatic experimental modal analysis using Sdof methods\n\n\n\n\n\n\n\n\n\nmodal2poles\n\n\n\nmodal2poles(fn, ξn)\nConvert natural frequencies and damping ratios to complex poles.\nInputs\n\nfn: Vector of natural frequencies (Hz)\n\nξn: Vector of damping ratios\n\n\nOutput\n\npoles: Vector of complex poles\n\n\n\n\n\n\n\n\n\npoles2modal\n\n\n\npoles2modal(poles)\nConvert complex poles to natural frequencies and damping ratios.\nInput\n\npoles: Vector of complex poles\n\n\nOutputs\n\nfn: Vector of natural frequencies (Hz)\n\nξn: Vector of damping ratios",
    "crumbs": [
      "Modal extraction",
      "Sdof methods"
    ]
  },
  {
    "objectID": "modal_extraction/sdof_methods.html#example",
    "href": "modal_extraction/sdof_methods.html#example",
    "title": "Sdof methods",
    "section": "4 Example",
    "text": "4 Example\n\n# Structure parameters of the beam\nL = 1.        # Length\nb = 0.03      # Width\nh = 0.01      # Thickness\nS = b*h       # Cross-section area\nIz = b*h^3/12 # Moment of inertia\n\n# Material parameters\nE = 2.1e11  # Young's modulus\nρ = 7850.   # Density\nξ = 0.01    # Damping ratio\n\n# Mesh\nxexc = 0:0.05:L\nxm = xexc[2]\n\n# Mode calculation - Simply supported boundary conditions\nbeam = Beam(L, S, Iz, E, ρ)\nfmax = 500.\n\nωn, kn = modefreq(beam, 2fmax)\nϕexc = modeshape(beam, kn, xexc)\nϕm = modeshape(beam, kn, xm)\n\n# FRF calculation\nfreq = 1.:0.1:fmax\nprob = ModalFRFProblem(ωn, ξ, freq, ϕm, ϕexc)\nH = solve(prob; ismat = true).u\n\n# Natural frequencies and damping ratios extraction\nprob_sdof = EMASdofProblem(H, freq)\nfn_pp, ξn_pp = poles2modal(poles_extraction(prob_sdof, PeakPicking()))\nfn_cf, ξn_cf = poles2modal(poles_extraction(prob_sdof, CircleFit()))\nfn_lsf, ξn_lsf = poles2modal(poles_extraction(prob_sdof, LSFit()))\n\n# Mode shape extraction\ndpi = [1, 2]\nϕid = modeshape_extraction(prob_sdof, modal2poles(fn_pp, ξn_pp), dpi)\n\n# Automatic EMA\nprob_ema = AutoEMASdofProblem(prob_sdof, dpi, LSFit())\nsol_ema = solve(prob_ema)\nfn_ema, ξn_ema = poles2modal(sol_ema.poles)\nϕn_ema = sol_ema.ms",
    "crumbs": [
      "Modal extraction",
      "Sdof methods"
    ]
  },
  {
    "objectID": "modal_extraction/sdof_methods.html#footnotes",
    "href": "modal_extraction/sdof_methods.html#footnotes",
    "title": "Sdof methods",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nA. Brandt. “Noise and Vibration Analysis: Signal Analysis and Experimental Procedures”, Wiley, 2011.↩︎",
    "crumbs": [
      "Modal extraction",
      "Sdof methods"
    ]
  },
  {
    "objectID": "signal_processing/other.html",
    "href": "signal_processing/other.html",
    "title": "Other processing",
    "section": "",
    "text": "Other signal processing methods are available in StructuralVibration.jl.",
    "crumbs": [
      "Signal processing",
      "Other processing"
    ]
  },
  {
    "objectID": "signal_processing/other.html#detrending",
    "href": "signal_processing/other.html#detrending",
    "title": "Other processing",
    "section": "1 Detrending",
    "text": "1 Detrending\nDetrending is the process of removing trends from a signal. This is useful when you want to analyze the fluctuations around a trend. The detrend function can be used to remove linear or polynomial trends from a signal.\n\n1.1 API\n\ndetrend\n\n\n\ndetrend(t, y, order = 1, bp = [])\nDetrend a signal y with respect to time t using a polynomial of order order.\nInputs\n\nt: Time vector\n\ny: Signal to be detrended\n\norder: Order of the polynomial (default is 1)\n\nbp: Breakpoints for the polynomial (default is empty)\n\n\nOutput\n\ny_detrended: Detrended signal\n\n\nNotes\norder can be a vector if the trend is different over the segments defined by the breakpoints bp.\nThe breakpoints bp are the points where the polynomial order changes. If bp is empty, a single polynomial is fitted to the entire signal.\n\n\n\n\n\n\n\n\n1.2 Example\n\n# Signal 1\nx1 = -0.5:0.01:0.5\ny1 = @. sin(π*x1) + 0.25\ny1_const = detrend(x1, y1, 0)\ny1_lin = detrend(x1, y1, 1)\n\n# Signal 2\nx2 = 0:0.1:20\ny2 = @. 3sin(x2) + x2\ny2_const = detrend(x2, y2, 0)\ny2_lin = detrend(x2, y2, 1)",
    "crumbs": [
      "Signal processing",
      "Other processing"
    ]
  },
  {
    "objectID": "signal_processing/other.html#gradient",
    "href": "signal_processing/other.html#gradient",
    "title": "Other processing",
    "section": "2 Gradient",
    "text": "2 Gradient\nThe gradient of a signal is the rate of change of the signal with respect to time. Julia [] has a lot of packages for computing the gradient of a signal. The gradient function in StructuralVibration.jl is a simple helper function built around the gradient function in Interpolations.jl.\n\n2.1 API\n\ngradient\n\n\n\ngradient(f::Vector{Real}, t; method = :cubic)\ngradient(f::Matrix{Real}, t; method = :cubic, dims = 1)\nCompute the gradient of a function f at points t.\nInputs\n\nf: Function values\n\nt: Points at which to evaluate the gradient\n\nmethod: Interpolation method\n\n:linear: Linear interpolation\n\n:cubic: Cubic spline interpolation (default)\n\n\n\ndims: Dimension along which to compute the gradient\n\n1: Rows (default)\n\n2: Columns\n\n\n\n\nOutput\n\ndf: Gradient of the vector f at points t\n\n\nNote\nIf method is :cubic, t must be an AbstractRange.\n\n\n\n\n\n\n\n\n2.2 Example\n\n# Signal\nx = LinRange(0., 3π, 100)\ny = sin.(x)\n\n# True gradient\ndy = cos.(x)\n\n# Estimated gradient\ndy_approx = gradient(y, x)\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nBeing based on interpolation, gradient is not robust against noise. For robust gradient estimation, you can compute the gradient of the signal denoised by the denoising function by using one of the numerous Julia differentiation packages if the signal is smooth enough (at least class \\(C^\\2\\)). If the latter condition is not satisfied, you can for instance use NoiseRobustDifferentiation.jl, which implements the Total variation regularized numerical differentiation method1 .",
    "crumbs": [
      "Signal processing",
      "Other processing"
    ]
  },
  {
    "objectID": "signal_processing/other.html#footnotes",
    "href": "signal_processing/other.html#footnotes",
    "title": "Other processing",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nR. Chartrand. “Numerical differentiation of noisy, nonsmooth data”. ISRN Applied Mathematics, vol. 2011, 164564, 2011.↩︎",
    "crumbs": [
      "Signal processing",
      "Other processing"
    ]
  },
  {
    "objectID": "overview/installation.html",
    "href": "overview/installation.html",
    "title": "Installation",
    "section": "",
    "text": "Note\n\n\n\nIf you are already a Julia user, you can skip this section.\nThis section explains how to install Julia and Vibration.jl.",
    "crumbs": [
      "Overview",
      "Installation"
    ]
  },
  {
    "objectID": "overview/installation.html#install-julia",
    "href": "overview/installation.html#install-julia",
    "title": "Installation",
    "section": "Install Julia ",
    "text": "Install Julia \nThere exists several ways of installing Julia and managing versions. The recommended way consists in installing juliaup, which is a Julia version manager.\n\nWindows\nOn Windows, juliaup can be installed directly from the Windows store or from a terminal by typing the following command:\nwinget install julia -s msstore\nMacOS and Linux\nOn MacOS and Linux, juliaup can be installed from a terminal by typing:\ncurl -fsSL https://install.julialang.org | sh\nor by using software repositories:\n# MacOS\nbrew install juliaup\n\n# Arch-based distributions\nyay -S juliaup\n\nOnce juliaup is installed, the latest version of Julia can be installed from a terminal as follows:\njuliaup add release",
    "crumbs": [
      "Overview",
      "Installation"
    ]
  },
  {
    "objectID": "overview/installation.html#install-vibrationdata.jl",
    "href": "overview/installation.html#install-vibrationdata.jl",
    "title": "Installation",
    "section": "Install VibrationData.jl ",
    "text": "Install VibrationData.jl \nThe package is registered in the Julia General Registry. So, to install the package, you can use the following command:\n(Yourenv) pkg&gt; add \"StructuralVibration\"",
    "crumbs": [
      "Overview",
      "Installation"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "StructuralVibration.jl",
    "section": "",
    "text": "StructuralVibration.jl is a Julia package designed to generate vibration data for mechanical systems. This package can be used for educational and research purposes. As a teacher, you can use it to illustrate vibration theory and its practical implementation. As a researcher, you can use it to test new methods on synthetic data.",
    "crumbs": [
      "Overview",
      "StructuralVibration.jl"
    ]
  },
  {
    "objectID": "index.html#features",
    "href": "index.html#features",
    "title": "StructuralVibration.jl",
    "section": "Features",
    "text": "Features\nThe package provides the following features:\n\nMechanical models\n\nDiscrete models\n\nSpring-mass-damper SDOF system\nSpring-mass-damper MDOF system\nFE models of bar, rod, strings and beams\n\nContinuous models\n\nLongitudinal bars\nTorsional bars\nStrings\nBeams\nRectangular plates\nRectangular membranes\n\nState space model\n\nContinuous state-space representation\nDiscrete state-space representation\n\nZero-order hold (ZOH)\nFirst-order hold (FOH)\nBand-limited hold (BLH)\nRK4\n\n\n\n\n\nVibration data generation\n\nExcitation signals\n\nRectangular wave\nTriangular wave\nHammer impact\nSmoothed rectangular wave\nSine wave\nHalf-sine pulse\nHarversine pulse\nSwept sine wave\nGaussian pulse\nColored noise\n\nSolution for SDOF systems\n\nFree response\nForced response due to a harmonic force or a base motion\nForced response due to any external force or base motion (Duhamel’s integral)\n\nTime-domain integration schemes for linear second order systems\n\nCentral difference scheme\nRK4\nNewmark-beta method\nLinear acceleration method\nFox-Goodwin method\nHHT\nWBZ\nGeneralized-alpha\nMid-Point rule\n\nFrequency-domain calculations for linear systems\n\nFrequency spectrum\n\nModal summation\nDirect method\n\nFrequency response function (FRF)\n\nModal summation\nDirect method\n\n\nState-space solvers\n\nTime domain\n\nRK4 for continuous systems\nZOH, FOH, BLH, RK4 for discrete models\n\nFrequency spectrum\n\nModal summation\nDirect method\n\nFrequency response function (FRF)\n\nModal summation\nDirect method\n\n\nMeasurement noise\n\nAdditive Gaussian white noise (agwn) with a prescribed SNR\nAdditive Colored noise (acn)\nMultiplicative noise\nMixed - agwn + multiplicative noise\n\n\n\n\nSignal processing\n\nMeasurement noise variance estimation algorithms from noisy data\n\nRegularization-based estimation\nD’Errico’s method - Link to the Matlab version\nSNR estimation from estimated measurement noise variance\n\nDenoising algorithms\n\nRegularization\nKalman filtering\n\nSignal preprocessing\n\nDetrending data using polynomial fit\nGradient calculation using interpolation\n\nSignal estimation\n\nTransfer functions estimation (H1, H2, H3, Hv)\nWelch method (PSD, ESD, Autopower, Autopower linear)\nSignal spectrum estimation\n\n\n\n\nModal analysis\n\nModal extraction - SDOF methods\n\nPeak picking method\nCircle fit method\nLeast-squares fit method\n\nModal extraction - MDOF methods\n\nLeast-squares complex exponential (LSCE)\nLeast-squares complex frequency (LSCF)\nPolyreference least-squares complex frequency (PLSCF)\nStabilization diagram\n\nAnalysis indicators\n\nModal Overlap Factor (MOF)\nMode overcomplexity value (MOV)\nMode Phase Collinearity (MPC)\nMode Complexity Factor (MCF)\nMean Phase Deviation (MPD)\nModal Assurance Criterion (MAC)\nCoordinate Modal Assurance Criterion (COMAC)\nEnhanced Coordinate Modal Assurance Criterion (ECOMAC)\nFrequency Response Assurance Criterion (FRAC)\nComplex Mode Indicator Function (CMIF)\nPower Spectrum indicator function (PSIF)\n\nModal synthesis\n\nEstimation of the FRF residuals\nReconstruct FRF from modal parameters\n\n\n\n\nVisualization\n\nBode plot\n2D and 3D Nyquist plot\nWaterfall plot\nGeneral 2D plot",
    "crumbs": [
      "Overview",
      "StructuralVibration.jl"
    ]
  },
  {
    "objectID": "index.html#reproducibility",
    "href": "index.html#reproducibility",
    "title": "StructuralVibration.jl",
    "section": "Reproducibility",
    "text": "Reproducibility\n\n\n\n\n\n\nProject direct dependencies\n\n\n\n\n\nProject StructuralVibration v1.0.0\nStatus\n  [717857b8] DSP v0.8.4\n  [7a1cc6ca] FFTW v1.10.0\n  [442a2c76] FastGaussQuadrature v1.0.2\n  [a98d9a8b] Interpolations v0.15.1\n  [37e2e46d] LinearAlgebra v1.12.0\n  [429524aa] Optim v1.13.2\n  [18e31ff7] Peaks v0.5.3\n  [f27b6e38] Polynomials v4.1.0\n  [aea7be01] PrecompileTools v1.3.3\n  [92933f4c] ProgressMeter v1.11.0\n  [9a3f8284] Random v1.11.0\n  [276daf66] SpecialFunctions v2.6.1\n  [10745b16] Statistics v1.11.1\n  [c751599d] ToeplitzMatrices v0.8.5\n\n\n\n\n\n\n\n\n\nJulia version and machine information\n\n\n\n\n\nJulia Version 1.12.0\nCommit b907bd0600f (2025-10-07 15:42 UTC)\nBuild Info:\n  Official https://julialang.org release\nPlatform Info:\n  OS: macOS (arm64-apple-darwin22.4.0)\n  CPU: 16 × Apple M4 Max\n  WORD_SIZE: 64\n  LLVM: libLLVM-18.1.7 (ORCJIT, apple-m4)\n  GC: Built with stock GC\nThreads: 1 default, 1 interactive, 1 GC (on 12 virtual cores)\nEnvironment:\n  JULIA_EDITOR = code\n  JULIA_VSCODE_REPL = 1\n  JULIA_PKG_SERVER = https://juliahub.com",
    "crumbs": [
      "Overview",
      "StructuralVibration.jl"
    ]
  },
  {
    "objectID": "index.html#license",
    "href": "index.html#license",
    "title": "StructuralVibration.jl",
    "section": "License",
    "text": "License\nThis package is under MIT License.",
    "crumbs": [
      "Overview",
      "StructuralVibration.jl"
    ]
  },
  {
    "objectID": "models/index.html",
    "href": "models/index.html",
    "title": "Mechanical models",
    "section": "",
    "text": "Longitudinal bars, torsional rods and strings are governed by the wave equation, which can be written under the following form: \\[\nm \\ddot y(x, t) - D \\frac{\\partial^2 y(x,t)}{\\partial x^2} = p(x, t),\n\\] where:\n\n\\(y(x, t)\\): Kinematic data at location \\(x\\) and time \\(t\\)\n\\(p(x, t)\\): External excitation term\n\\(m\\): Linear inertia of the type\n\\(D\\): Stiffness of the type\n\nFor a longitudinal bar:\n\n\\(y(x, t) = u(x, t)\\)\n\n\\(u(x, t)\\): Longitudinal displacement [m]\n\n\\(p(x, t)\\): Distributed longitudinal force [N/m]\n\\(m = \\rho S\\): Linear mass density [kg/m2]\n\n\\(\\rho\\): Mass density [kg/m3]\n\\(S\\): Cross-section area [m2]\n\n\\(D = E S\\): Longitudinal stiffness [N]\n\n\\(E\\): Young’s modulus [Pa]\n\n\nFor a torsional rod:\n\n\\(y(x, t) = \\theta(x, t)\\)\n\n\\(\\theta\\): Torsion angle [rad]\n\n\\(p(x, t)\\): Distributed moment [N.m/m]\n\\(m = \\rho I_G\\): Linear rotational inertia [kg.m4]\n\n\\(I_G\\): Polar moment of area [m4]\n\n\\(D = G J_T\\): Rotational stiffness [N.m2]\n\n\\(G\\): Shear modulus [Pa]\n\\(J_T\\): Torsion constant [m4]\n\n\nFor a string:\n\n\\(y(x, y)\\): Transverse displacement [m]\n\\(m\\): Linear mass density [kg/m]\n\\(D\\): Tension force [N]\n\n\n\n\nEuler-Bernoulli beams are governed by the following equation of motion: \\[\nm\\ddot v(x, t) + D\\frac{\\partial^4 v(x, t)}{\\partial x^4} = p(x, t),\n\\] where:\n\n\\(v(x, t)\\): Transverse displacement [m]\n\\(p(x, t)\\): External excitation term [N/m]\n\\(m = \\rho S\\): Linear mass density [kg/m]\n\\(D = E I_z\\): Bending stiffness [N.m2]\n\n\\(I_z\\): Second moment of area [m4]\n\n\n\n\n\nData types\nAll the following data types are a subtype of the super type OneDtype.\n\nBar\n\n\n\nBar(L, S, E, ρ)\nStructure containing the data of a homogeneous and isotropic longitudinal bar\nConstructor parameters\n\nL: Length [m]\n\nS: Cross-section area [m²]\n\nE: Young's modulus [Pa]\n\nρ: Mass density [kg/m³]\n\n\nFields\n\nL: Length [m]\n\nm: Line mass [kg/m]\n\nD: Stiffness coefficient [Pa]\n\n\n\n\n\n\n\n\n\nRod\n\n\n\nRod(L, I, J, G, ρ)\nStructure containing the data of a homogeneous and isotropic torsional bar\nConstructor parameters\n\nL: Length [m]\n\nI: Second-moment of area [m⁴]\n\nJ: Torsion constant [m⁴]\n\nG: Shear modulus [Pa]\n\nρ: Mass density [kg/m³]\n\n\nFields\n\nL: Length [m]\n\nm: Line mass [kg/m]\n\nD: Stiffness coefficient [Pa]\n\n\n\n\n\n\n\n\n\nStrings\n\n\n\nStrings(L, S, D, ρ)\nStructure containing the data of a homogeneous and isotropic string\nConstructor parameters\n\nL: Length [m]\n\nS: Cross-section area [m²]\n\nD: Tension [N]\n\nρ: Mass density [kg/m³]\n\n\nFields\n\nL: Length [m]\n\nm: Linear mass density [kg/m]\n\nD: Tension [N]\n\n\n\n\n\n\n\n\n\nBeam\n\n\n\nBeam(L, S, I, E, ρ)\nStructure containing the data of a homogeneous and isotropic bending beam\nConstructor parameters\n\nL: Length [m]\n\nS: Cross-section area [m²]\n\nI: Second moment of area [m⁴]\n\nE: Young's modulus [Pa]\n\nρ: Density [kg/m³]\n\n\nFields\n\nL: Length [m]\n\nM: Linear mass density [kg/m]\n\nD: Bending stiffness [N.m²]\n\n\n\n\n\n\n\n\nRelated functions\n\nmodefreq\n\n\n\nmodefreq(model::Bar, fmax, bc = :CC)\nmodefreq(model::Rod, fmax, bc = :CC)\nmodefreq(model::Strings, fmax, bc = :CC)\nmodefreq(model::Beam, fmax, bc = :SS)\nComputes the natural frequencies of a longitudinal or torsional bar up to fmax\nInputs\n\nmodel: Structure containing the bar data\n\nfmax: Maximum frequency for calculating the mode shapes [Hz]\n\nbc: Boundary conditions\n\nFor all OneDStructure\n\n:CC: Clamped - Clamped\n\n:CF: Clamped - Free\n\n:FF: Free - Free\n\n\n\nFor beams\n\n:SS: Simply Supported - Simply Supported\n\n:SC: Simply Supported - Clamped\n\n:SF: Simply Supported - Free\n\n\n\n\n\n\nOutputs\n\nωn: Natural frequencies calculated up to ωmax = 2π*fmax [Hz]\n\nkn: Vector of modal wavenumbers\n\n\n\n\n\n\n\n\n\nmodeshape\n\n\n\nmodeshape(model::Bar, kn, x, bc = :CC)\nmodeshape(model::Rod, kn, x, bc = :CC)\nmodeshape(model::Strings, kn, x, bc = :CC)\nmodeshape(model::Beam, kn, x, bc = :SS)\nComputes the mass-normalized mode shapes of a longitudinal or torsional bar\nInputs\n\nmodel: Structure containing the bar data\n\nkn: Array of modal wavenumbers\n\nx: Coordinates of calculation points of the mode shapes\n\nbc: Boundary conditions\n\nFor all OneDStructure\n\n:CC: Clamped - Clamped\n\n:CF: Clamped - Free\n\n:FF: Free - Free\n\n\n\nFor beams\n\n:SS: Simply Supported - Simply Supported\n\n:SC: Simply Supported - Clamped\n\n:SF: Simply Supported - Free\n\n\n\n\n\n\nOutput\n\nϕ: Mass-normalized mode shapes\n\n\n\n\n\n\n\n\n\n\n\n# Dimensions\nL = 1.\nd = 3e-2\n\n# Section features\nS = π*d^2/4\nIz = π*d^4/64\nIG = 2Iz\nJ = IG\n\n# Tension for string\nT = 100.\n\n# Material\nE = 2.1e11\nν = 0.33\nG = E/(1 - 2*ν)\nρ = 7800.\n\n# Computation parameters\nfmax = 2000.\nx = [0.1, 0.9]\n\n# Initialization of the data types\nbar = Bar(L, S, E, ρ)\nrod = Rod(L, IG, J, G, ρ)\nstrings = Strings(L, S, T, ρ)\nbeam = Beam(L, S, Iz, E, ρ)\n\n# Computation of the natural frequencies\nωn, kn = modefreq(bar, fmax)\n\n# Computation of the corresponding mode shapes\nϕn = modeshape(bar, kn, x, :CC)\n\n\n\n\n\n\nRectangular membranes are governed by the following equation of motion: \\[\nm \\ddot w(x, y ,t) + D\\Delta w(x, y, t) = p(x, y, t),\n\\] where:\n\n\\(w(x, y, t)\\): Transverse displacement [m] at point \\((x, y)\\) and time \\(t\\)\n\\(m\\): Surface mass [kg/m]\n\\(D = \\tau\\): Linear tension [N/m]\n\\(\\Delta = \\frac{\\partial^2}{\\partial x^2} + \\frac{\\partial^2}{\\partial y^2}\\): Laplacian operator\n\n\n\n\nRectangular Kirchhoff-Love plates are governed by the following equation of motion: \\[\nm \\ddot w(x, y, t) + D \\Delta^2 w(x, y, t) = p(x, y, t),\n\\] where:\n\n\\(w(x, y, t)\\): Transverse displacement [m] at point \\((x, y)\\) and time \\(t\\)\n\\(m = \\rho h\\): Surface mass [kg/m2]\n\n\\(h\\): Thickness [m]\n\n\\(D = \\frac{Eh^3}{12(1 - \\nu^2)}\\): Bending stiffness [N.m]\n\n\\(\\nu\\): Poisson’s coefficient\n\n\\(\\Delta^2 = \\frac{\\partial^4}{\\partial x^4} + 2\\frac{\\partial^4}{\\partial x^2 \\partial y^2} + \\frac{\\partial^4}{\\partial y^4}\\): Bilaplacian operator\n\n\n\n\nData type\nAll the following data types are a subtype of the super type TwoDStructure.\n\nMembrane\n\n\n\nMembrane(L, b, m, D)\nStructure containing the data of a homogeneous and isotropic rectangular membrane\nFields\n\nL: Length [m]\n\nb: Width [m]\n\nm: Surface mass [kg/m²]\n\nD: Tension per unit length [N/m]\n\n\n\n\n\n\n\n\n\nPlate\n\n\n\nPlate(L, b, h, E, ρ, ν)\nStructure containing the data of a homogeneous and isotropic bending plate\nConstructor parameters\n\nL: Length [m]\n\nb: Width [m]\n\nE: Young's modulus [Pa]\n\nρ: Density [kg/m³]\n\nν: Poisson's ratio\n\n\nFields\n\nL: Length [m]\n\nb: Width [m]\n\nm: Surface mass [kg/m²]\n\nD: Bending stiffness [N.m]\n\n\n\n\n\n\n\n\nRelated functions\n\nmodefreq\n\n\n\nmodefreq(model::Plate, fmax)\nmodefreq(model::Membrane, fmax)\nComputes the natural frequencies of a simply supported rectangular plate or a clamped rectangular membrane up to fmax\nInputs\n\nmodel: Structure containing the data related to the plate\n\nfmax: Maximum frequency for calculating the modal shapes [Hz]\n\n\nOutputs\n\nωmn: Natural frequencies calculated up to ωmax = 2π*fmax [Hz]\n\nkmn: Matrix of modal wave numbers\n\n\n\n\n\n\n\n\n\nmodeshape\n\n\n\nmodeshape(model::Plate, kpq, x, y)\nmodeshape(model::Membrane, kpq, x, y)\nComputes the mass-normalized mode shapes of a simply supported rectangular plate or a clamped rectangular membrane\nInputs\n\nmodel: Structure containing the data related to the structure\n\nkmn: Matrix of modal wave numbers\n\n(x, y): Coordinates of the points where the mode shapes are calculated\n\n\nOutput\n\nϕ: Mass-normalized mode shapes\n\n\n\n\n\n\n\n\n\n\n\n# Dimensions\nLp = 0.6\nbp = 0.4\nhp = 1e-3\n\n# Material parameters\nE = 2.1e11\nρ = 7800.\nν = 0.33\n\n# Computation parameters\nfmax = 1000.\nxp = [0.1, 0.5]\nyp = [0.1, 0.3]\n\n# Initialization of the data types\nplate = Plate(Lp, bp, hp, E, ρ, ν)\n\n# Computation of the natural frequencies\nωn, kn = modefreq(plate, fmax)\n\n# Computation of the corresponding mode shapes\nϕn = modeshape(plate, kn, xp, yp)",
    "crumbs": [
      "Models",
      "Mechanical models"
    ]
  },
  {
    "objectID": "models/index.html#continuous-models",
    "href": "models/index.html#continuous-models",
    "title": "Mechanical models",
    "section": "",
    "text": "Longitudinal bars, torsional rods and strings are governed by the wave equation, which can be written under the following form: \\[\nm \\ddot y(x, t) - D \\frac{\\partial^2 y(x,t)}{\\partial x^2} = p(x, t),\n\\] where:\n\n\\(y(x, t)\\): Kinematic data at location \\(x\\) and time \\(t\\)\n\\(p(x, t)\\): External excitation term\n\\(m\\): Linear inertia of the type\n\\(D\\): Stiffness of the type\n\nFor a longitudinal bar:\n\n\\(y(x, t) = u(x, t)\\)\n\n\\(u(x, t)\\): Longitudinal displacement [m]\n\n\\(p(x, t)\\): Distributed longitudinal force [N/m]\n\\(m = \\rho S\\): Linear mass density [kg/m2]\n\n\\(\\rho\\): Mass density [kg/m3]\n\\(S\\): Cross-section area [m2]\n\n\\(D = E S\\): Longitudinal stiffness [N]\n\n\\(E\\): Young’s modulus [Pa]\n\n\nFor a torsional rod:\n\n\\(y(x, t) = \\theta(x, t)\\)\n\n\\(\\theta\\): Torsion angle [rad]\n\n\\(p(x, t)\\): Distributed moment [N.m/m]\n\\(m = \\rho I_G\\): Linear rotational inertia [kg.m4]\n\n\\(I_G\\): Polar moment of area [m4]\n\n\\(D = G J_T\\): Rotational stiffness [N.m2]\n\n\\(G\\): Shear modulus [Pa]\n\\(J_T\\): Torsion constant [m4]\n\n\nFor a string:\n\n\\(y(x, y)\\): Transverse displacement [m]\n\\(m\\): Linear mass density [kg/m]\n\\(D\\): Tension force [N]\n\n\n\n\nEuler-Bernoulli beams are governed by the following equation of motion: \\[\nm\\ddot v(x, t) + D\\frac{\\partial^4 v(x, t)}{\\partial x^4} = p(x, t),\n\\] where:\n\n\\(v(x, t)\\): Transverse displacement [m]\n\\(p(x, t)\\): External excitation term [N/m]\n\\(m = \\rho S\\): Linear mass density [kg/m]\n\\(D = E I_z\\): Bending stiffness [N.m2]\n\n\\(I_z\\): Second moment of area [m4]\n\n\n\n\n\nData types\nAll the following data types are a subtype of the super type OneDtype.\n\nBar\n\n\n\nBar(L, S, E, ρ)\nStructure containing the data of a homogeneous and isotropic longitudinal bar\nConstructor parameters\n\nL: Length [m]\n\nS: Cross-section area [m²]\n\nE: Young's modulus [Pa]\n\nρ: Mass density [kg/m³]\n\n\nFields\n\nL: Length [m]\n\nm: Line mass [kg/m]\n\nD: Stiffness coefficient [Pa]\n\n\n\n\n\n\n\n\n\nRod\n\n\n\nRod(L, I, J, G, ρ)\nStructure containing the data of a homogeneous and isotropic torsional bar\nConstructor parameters\n\nL: Length [m]\n\nI: Second-moment of area [m⁴]\n\nJ: Torsion constant [m⁴]\n\nG: Shear modulus [Pa]\n\nρ: Mass density [kg/m³]\n\n\nFields\n\nL: Length [m]\n\nm: Line mass [kg/m]\n\nD: Stiffness coefficient [Pa]\n\n\n\n\n\n\n\n\n\nStrings\n\n\n\nStrings(L, S, D, ρ)\nStructure containing the data of a homogeneous and isotropic string\nConstructor parameters\n\nL: Length [m]\n\nS: Cross-section area [m²]\n\nD: Tension [N]\n\nρ: Mass density [kg/m³]\n\n\nFields\n\nL: Length [m]\n\nm: Linear mass density [kg/m]\n\nD: Tension [N]\n\n\n\n\n\n\n\n\n\nBeam\n\n\n\nBeam(L, S, I, E, ρ)\nStructure containing the data of a homogeneous and isotropic bending beam\nConstructor parameters\n\nL: Length [m]\n\nS: Cross-section area [m²]\n\nI: Second moment of area [m⁴]\n\nE: Young's modulus [Pa]\n\nρ: Density [kg/m³]\n\n\nFields\n\nL: Length [m]\n\nM: Linear mass density [kg/m]\n\nD: Bending stiffness [N.m²]\n\n\n\n\n\n\n\n\nRelated functions\n\nmodefreq\n\n\n\nmodefreq(model::Bar, fmax, bc = :CC)\nmodefreq(model::Rod, fmax, bc = :CC)\nmodefreq(model::Strings, fmax, bc = :CC)\nmodefreq(model::Beam, fmax, bc = :SS)\nComputes the natural frequencies of a longitudinal or torsional bar up to fmax\nInputs\n\nmodel: Structure containing the bar data\n\nfmax: Maximum frequency for calculating the mode shapes [Hz]\n\nbc: Boundary conditions\n\nFor all OneDStructure\n\n:CC: Clamped - Clamped\n\n:CF: Clamped - Free\n\n:FF: Free - Free\n\n\n\nFor beams\n\n:SS: Simply Supported - Simply Supported\n\n:SC: Simply Supported - Clamped\n\n:SF: Simply Supported - Free\n\n\n\n\n\n\nOutputs\n\nωn: Natural frequencies calculated up to ωmax = 2π*fmax [Hz]\n\nkn: Vector of modal wavenumbers\n\n\n\n\n\n\n\n\n\nmodeshape\n\n\n\nmodeshape(model::Bar, kn, x, bc = :CC)\nmodeshape(model::Rod, kn, x, bc = :CC)\nmodeshape(model::Strings, kn, x, bc = :CC)\nmodeshape(model::Beam, kn, x, bc = :SS)\nComputes the mass-normalized mode shapes of a longitudinal or torsional bar\nInputs\n\nmodel: Structure containing the bar data\n\nkn: Array of modal wavenumbers\n\nx: Coordinates of calculation points of the mode shapes\n\nbc: Boundary conditions\n\nFor all OneDStructure\n\n:CC: Clamped - Clamped\n\n:CF: Clamped - Free\n\n:FF: Free - Free\n\n\n\nFor beams\n\n:SS: Simply Supported - Simply Supported\n\n:SC: Simply Supported - Clamped\n\n:SF: Simply Supported - Free\n\n\n\n\n\n\nOutput\n\nϕ: Mass-normalized mode shapes\n\n\n\n\n\n\n\n\n\n\n\n# Dimensions\nL = 1.\nd = 3e-2\n\n# Section features\nS = π*d^2/4\nIz = π*d^4/64\nIG = 2Iz\nJ = IG\n\n# Tension for string\nT = 100.\n\n# Material\nE = 2.1e11\nν = 0.33\nG = E/(1 - 2*ν)\nρ = 7800.\n\n# Computation parameters\nfmax = 2000.\nx = [0.1, 0.9]\n\n# Initialization of the data types\nbar = Bar(L, S, E, ρ)\nrod = Rod(L, IG, J, G, ρ)\nstrings = Strings(L, S, T, ρ)\nbeam = Beam(L, S, Iz, E, ρ)\n\n# Computation of the natural frequencies\nωn, kn = modefreq(bar, fmax)\n\n# Computation of the corresponding mode shapes\nϕn = modeshape(bar, kn, x, :CC)\n\n\n\n\n\n\nRectangular membranes are governed by the following equation of motion: \\[\nm \\ddot w(x, y ,t) + D\\Delta w(x, y, t) = p(x, y, t),\n\\] where:\n\n\\(w(x, y, t)\\): Transverse displacement [m] at point \\((x, y)\\) and time \\(t\\)\n\\(m\\): Surface mass [kg/m]\n\\(D = \\tau\\): Linear tension [N/m]\n\\(\\Delta = \\frac{\\partial^2}{\\partial x^2} + \\frac{\\partial^2}{\\partial y^2}\\): Laplacian operator\n\n\n\n\nRectangular Kirchhoff-Love plates are governed by the following equation of motion: \\[\nm \\ddot w(x, y, t) + D \\Delta^2 w(x, y, t) = p(x, y, t),\n\\] where:\n\n\\(w(x, y, t)\\): Transverse displacement [m] at point \\((x, y)\\) and time \\(t\\)\n\\(m = \\rho h\\): Surface mass [kg/m2]\n\n\\(h\\): Thickness [m]\n\n\\(D = \\frac{Eh^3}{12(1 - \\nu^2)}\\): Bending stiffness [N.m]\n\n\\(\\nu\\): Poisson’s coefficient\n\n\\(\\Delta^2 = \\frac{\\partial^4}{\\partial x^4} + 2\\frac{\\partial^4}{\\partial x^2 \\partial y^2} + \\frac{\\partial^4}{\\partial y^4}\\): Bilaplacian operator\n\n\n\n\nData type\nAll the following data types are a subtype of the super type TwoDStructure.\n\nMembrane\n\n\n\nMembrane(L, b, m, D)\nStructure containing the data of a homogeneous and isotropic rectangular membrane\nFields\n\nL: Length [m]\n\nb: Width [m]\n\nm: Surface mass [kg/m²]\n\nD: Tension per unit length [N/m]\n\n\n\n\n\n\n\n\n\nPlate\n\n\n\nPlate(L, b, h, E, ρ, ν)\nStructure containing the data of a homogeneous and isotropic bending plate\nConstructor parameters\n\nL: Length [m]\n\nb: Width [m]\n\nE: Young's modulus [Pa]\n\nρ: Density [kg/m³]\n\nν: Poisson's ratio\n\n\nFields\n\nL: Length [m]\n\nb: Width [m]\n\nm: Surface mass [kg/m²]\n\nD: Bending stiffness [N.m]\n\n\n\n\n\n\n\n\nRelated functions\n\nmodefreq\n\n\n\nmodefreq(model::Plate, fmax)\nmodefreq(model::Membrane, fmax)\nComputes the natural frequencies of a simply supported rectangular plate or a clamped rectangular membrane up to fmax\nInputs\n\nmodel: Structure containing the data related to the plate\n\nfmax: Maximum frequency for calculating the modal shapes [Hz]\n\n\nOutputs\n\nωmn: Natural frequencies calculated up to ωmax = 2π*fmax [Hz]\n\nkmn: Matrix of modal wave numbers\n\n\n\n\n\n\n\n\n\nmodeshape\n\n\n\nmodeshape(model::Plate, kpq, x, y)\nmodeshape(model::Membrane, kpq, x, y)\nComputes the mass-normalized mode shapes of a simply supported rectangular plate or a clamped rectangular membrane\nInputs\n\nmodel: Structure containing the data related to the structure\n\nkmn: Matrix of modal wave numbers\n\n(x, y): Coordinates of the points where the mode shapes are calculated\n\n\nOutput\n\nϕ: Mass-normalized mode shapes\n\n\n\n\n\n\n\n\n\n\n\n# Dimensions\nLp = 0.6\nbp = 0.4\nhp = 1e-3\n\n# Material parameters\nE = 2.1e11\nρ = 7800.\nν = 0.33\n\n# Computation parameters\nfmax = 1000.\nxp = [0.1, 0.5]\nyp = [0.1, 0.3]\n\n# Initialization of the data types\nplate = Plate(Lp, bp, hp, E, ρ, ν)\n\n# Computation of the natural frequencies\nωn, kn = modefreq(plate, fmax)\n\n# Computation of the corresponding mode shapes\nϕn = modeshape(plate, kn, xp, yp)",
    "crumbs": [
      "Models",
      "Mechanical models"
    ]
  },
  {
    "objectID": "models/index.html#discrete-models",
    "href": "models/index.html#discrete-models",
    "title": "Mechanical models",
    "section": "2 Discrete models",
    "text": "2 Discrete models\n\n2.1 Sdof systems\nSingle degree of freedom (Sdof) systems are classically composed of a mass \\(m\\), a stiffness \\(k\\) and a viscous damper \\(c\\) (see Figure 1).\n\n\n\n\n\n\nFigure 1: Classical representation of an Sdof system\n\n\n\nMathematically, their dynamic behavior is governed by the following normalized equation of motion : \\[\n\\ddot x(t) + 2\\xi\\,\\omega_0\\, \\dot x(t) + \\omega_0^2 x(t) = \\frac{F(t)}{m}.\n\\] where \\(F(t)\\) can be either a base or an external excitation applied to the system.\nThe Sdof system can thus be defined by:\n\nits mass \\(m\\)\nits natural angular frequency \\(\\omega_0\\) (or its natural frequency \\(f_0\\))\nits damping ratio \\(\\xi\\)\n\n\n2.1.1 API\n\nSdof\n\n\n\nSdof(m, ω0, ξ)\nStructure containing the data of a sdof system\nConstructor\n\nm: Mass [kg]\n\nf0: Natural frequency [Hz]\n\nξ: Damping ratio\n\n\nFields\n\nm: Mass [kg]\n\nω0: Natural frequency [rad/s]\n\nξ: Damping ratio\n\n\n\n\n\n\n\n\n\n\n2.1.2 Example\n# Definition of the structural parameters\nm = 1.\nf₀ = 10.\nξ = 0.01\n\n# Initialization of Sdof\nsdof = Sdof(m, f₀, ξ)\n\n\n\n2.2 Mdof systems\nStructuralVibration.jl considers Multi-degrees of freedom (Mdof) systems, which topology is presented in Figure 2. This choice has been made, because it allows modeling a large variety of possible configurations.\n\n\n\n\n\n\nFigure 2: General topology of an Mdof system\n\n\n\nThe dynamic behavior of such a system is governed by the following matrix system: \\[\n\\mathbf{M} \\ddot{\\mathbf{x}}(t) + \\mathbf{K}\\mathbf{x}(t) = \\mathbf{f}(t),\n\\] where:\n\n\\(\\mathbf{M} = \\text{diag}(m_1, \\dots, m_j, \\dots, m_N)\\) is the mass matrix.\n\\(\\mathbf{K}\\) is the stiffness matrix such that: \\[\n\\mathbf{K} = \\begin{bmatrix}\nk_1 & -k_1 & 0 & \\ldots & 0 & 0 \\\\\n-k_1 & k_1 + k_2 & -k_2 & \\ddots & \\vdots & \\vdots \\\\\n0 & -k_2 & \\ddots & \\ddots & 0 & \\vdots \\\\\n\\vdots & 0 & \\ddots & \\ddots & -k_{N-1} & 0 \\\\\n\\vdots & \\vdots & \\ddots & -k_{N-1} & k_{N-1} + k_N & -k_N \\\\\n0 & 0 & \\ldots & 0 & -k_N & k_N\n\\end{bmatrix}.\n\\]\n\\(\\mathbf{x}(t) = \\left[x_1(t), \\dots, x_j(t), \\dots, x_N(t)\\right]^\\mathsf{T}\\) is the displacement vector.\n\\(\\mathbf{f}(t) = \\left[F_1(t), \\dots, F_j(t), \\dots, F_N(t)\\right]^\\mathsf{T}\\) is the external force vector.\n\n\n2.2.1 API\nData types\n\nMdof\n\n\n\nMdof(k, m, c = Float64[])\nStructure containing the data for building a mdof system\nFields\n\nk: Stiffness coefficients of the spring elements\n\nm: Masses of the mdof system\n\nc: Damping coefficients of the viscous dampers\n\n\n\n\n\n\n\n\n\n\n\n\n\nAbout the damping matrix C\n\n\n\n\n\nIf viscous dampers are defined, the damping matrix \\(\\mathbf{C}\\) is consistent with the stiffness matrix \\(\\mathbf{K}\\), meaning that: \\[\n\\mathbf{C} = \\begin{bmatrix}\nc_1 & -c_1 & 0 & \\ldots & 0 & 0 \\\\\n-c_1 & c_1 + c_2 & -c_2 & \\ddots & \\vdots & \\vdots \\\\\n0 & -k_2 & \\ddots & \\ddots & 0 & \\vdots \\\\\n\\vdots & 0 & \\ddots & \\ddots & -c_{N-1} & 0 \\\\\n\\vdots & \\vdots & \\ddots & -c_{N-1} & c_{N-1} + c_N & -c_N \\\\\n0 & 0 & \\ldots & 0 & -c_N & c_N\n\\end{bmatrix}.\n\\]\n\n\n\n\n\nMdofMesh\n\n\n\nMdofMesh(Elt, constrained_dofs, free_dofs)\nStructure containing the data for building a mdof mesh\nConstructor\n\nmodel: Mdof model\n\nbc: Boundary conditions\n\n:CC: Clamped - Clamped\n\n:CF: Clamped - Free\n\n:FF: Free - Free\n\n\n\n\nFields\n\nElt: Element connectivity matrix\n\nconstrained_dofs: Constrained degrees of freedom\n\nfree_dofs: Free degrees of freedom\n\n\n\n\n\n\n\n\nRelated functions\n\nassembly\n\n\n\nassembly(model::Mdof)\nAssembly of the mass, stiffness and damping matrices of a mdof system\nInput\n\nmodel: Mdof model\n\n\nOutputs\n\nK: Stiffness matrix\n\nM: Mass matrix\n\nC: Damping matrix (if viscous dampers are defined in model)\n\n\n\n\n\n\n\n\n\napply_bc\n\n\n\napply_bc(A, mesh)\nApply boundary conditions to a given matrix\nInputs\n\nA: Matrix to apply the boundary conditions\n\nmesh: Mesh of the system\n\n\nOutput\n\nA_bc: Matrix with boundary conditions applied\n\n\n\n\n\n\n\n\n\neigenmode\n\n\n\neigenmode(K, M, n = size(K, 1))\nComputes the eigenmodes of a system defined by its mass and stiffness matrices.\nInputs\n\nK: Stiffness matrix\n\nM: Mass matrix\n\nn: Number of modes to be keep in the modal basis\n\n\nOutputs\n\nω: Vector of natural frequencies\n\nΦ: Mass-normalized mode shapes\n\n\n\n\n\n\n\n\n\nmodal_matrices\n\n\n\nmodal_matrices(ωn, ξn)\nComputes the modal mass, stiffness, and damping matrices\nInputs\n\nωn: Vector of natural frequencies\n\nξn: Modal damping\n\n\nOutputs\n\nKn: Generalized stiffness matrix\n\nMn: Generalized mass matrix (identity matrix, due to mass normalization)\n\nCn: Generalized damping matrix\n\n\n\n\n\n\n\n\n\nmodal_effective_mass\n\n\n\nmodal_effective_mass(M, ϕn, r)\nComputes the effective mass of a mode\nInputs\n\nM: Mass matrix\n\nϕn: Mode shape\n\nr: Influence vector (rigid body mode)\n\n\nOutputs\n\nmeff: Modal effective mass\n\n\nNote: The modeshapes are supposed to be mass-normalized\n\n\n\n\n\n\n\n\n2.2.2 Example\n# Definition of the structural parameters\nk_mdof = [1., 1.]\nm_mdof = ones(3)\nc_mdof = [0.1, 0.1]\n\n# Initialization of Mdof\nmdof = Mdof(k_mdof, m_mdof, c_mdof)\n\n# Definition of a MdofMesh\nmdof_mesh = MdofMesh(mdof, bc = :CF)\n\n# System assembly\nK_mdof, M_mdof, C_mdof = assembly(mdof)\n\n# Apply boundary conditions (if any)\nK_bc = apply_bc(K_mdof, mdof_mesh)\nM_bc = apply_bc(M_mdof, mdof_mesh)\nC_bc = apply_bc(C_mdof, mdof_mesh)\n\n# Compute the eigenmodes of the systems\nωn, Φn = eigenmode(K_bc, M_bc)\n\n# Computation of the modal matrices\nKmodal, Mmodal, Cmodal = modal_matrices(ωn, 0.01)\n\n# Computation of modal effective mass\nmeff = modal_effective_mass(M_bc, Φn, ones(2))\n\n\n\n2.3 FE model\nFinite element models are available for the 1D continuous systems defined in Section 1.1.\n\n2.3.1 API\nData type\n\nOneDMesh\n\n\n\nOneDMesh(model, xmin, Nelt, bc)\nConstruct a mesh for a beam with Nelt elements, length L and starting at xmin.\nConstructor parameters\n\nmodel: Structure containing the data related to the 1D system\n\nxmin: starting position of the beam\n\nNelt: number of elements\n\nbc: Boundary conditions type\n\n:CC: Clamped - Clamped\n\n:FF: Free - Free\n\n:CF: Clamped - Free\n\n:SS: Simply Supported - Simply Supported (specific to beam)\n\n:CS: Clamped - Simply Supported (specific to beam)\n\n:SF: Simply Supported - Free (specific to beam)\n\n\n\n\nFields\n\nxmin: Starting position of the beam\n\nL: Length of the beam\n\nNodes: Nodes of the mesh\n\nElt: Elements of the mesh\n\nNdof_per_node`: Number of degrees of freedom per node\n\nelem_size: Size of the elements\n\nconstrained_dofs: Constrained degrees of freedom\n\nfree_dofs: Free degrees of freedom\n\n\n\n\n\n\n\n\nRelated functions\n\nassemby\n\n\n\nassembly(model::OneDstructure, mesh::OneDMesh)\nCompute the global stiffness and mass matrices for a 1D structure with a given mesh.\nInputs\n\nmodel: OneDStructure\n\nBeam: Beam model\n\nWaveEquation: Bar, Rod or String model\n\n\n\nmesh: OneDMesh\n\n\nOutputs\n\nK: global stiffness matrix\n\nM: global mass matrix\n\n\n\n\n\n\n\n\n\nrayleigh_damping_matrix\n\n\n\nrayleigh_damping_matrix(K, M, α, β)\nrayleigh_damping_matrix(K, M, ω1, ω2, ξ1, ξ2)\nCompute the Rayleigh damping matrix for a given stiffness and mass matrices\nInputs\n\nK: Stiffness matrix\n\nM: Mass matrix\n\nConstruction parameters\n\nMethod 1\n\nα: Mass proportional damping coefficient\n\nβ: Stiffness proportional damping coefficient\n\n\n\nMethod 2\n\nω1: First natural frequency\n\nω2: Second natural frequency\n\nξ1: Damping ratio for the first natural frequency\n\nξ2: Damping ratio for the second natural frequency\n\n\n\n\n\n\nOutput\n\nC: Rayleigh damping matrix\n\n\n\n\n\n\n\n\n\nmodal_damping_matrix\n\n\n\nmodal_damping_matrix(M, ωn, ξn, Φn)\nCompute the damping matrix C from modal parameters\nInputs\n\nM: Mass matrix\n\nωn: Natural angular frequencies\n\nξn: Damping ratios\n\nΦn: Mass-normalized mode shapes\n\n\nOutput\n\nC: Damping matrix\n\n\n\n\n\n\n\n\n\nSelection matrix\n\n\n\nselection_matrix(mesh, selected_dofs)\nCompute the selection matrix for the selected dofs.\nInputs\n\nmesh: OneDmesh\n\nselected_dofs: Selected dofs\n\n\nOutput\n\nS: Selection matrix\n\n\n\n\n\n\n\n\n\napply_bc - See Section 2.2.1.\n\n\neigenmode - See Section 2.2.1.\n\n\nmodal_matrices - See Section 2.2.1.\n\n\nmodal_effective_mass - See Section 2.2.1.\n\n\n\n2.3.2 Example\n# Dimensions\nL = 1.\nd = 3e-2\n\n# Section features\nS = π*d^2/4\nIz = π*d^4/64\n\n# Material\nE = 2.1e11\nρ = 7800.\n\n# Computation parameters\nfmax = 2000.\n\n# Initialization of the data types\nbeam = Beam(L, S, Iz, E, ρ)\n\n# Mesh definition\noned_mesh = OneDMesh(beam, 0., 20, :SS)\n\n# Construction of K and M\nKfe, Mfe = assembly(beam, oned_mesh)\n\n# Application of the BCs\nKbc = apply_bc(Kfe, oned_mesh)\nMbc = apply_bc(Mfe, oned_mesh)\n\n# Computation ofthe eigenmodes of the structure\nωfe, Φfe = eigenmode(Kbc, Mbc)\n\n# Calculation of the damping matrix\nCray = rayleigh_damping_matrix(Kbc, Mbc, 1., 1.)\nCmodal = modal_damping_matrix(Mbc, ωfe, 0.01, Φfe)",
    "crumbs": [
      "Models",
      "Mechanical models"
    ]
  },
  {
    "objectID": "models/index.html#state-space-representation",
    "href": "models/index.html#state-space-representation",
    "title": "Mechanical models",
    "section": "3 State space representation",
    "text": "3 State space representation\nThe state space representation of a mechanical system is expressed as: \\[\n\\dot{\\mathbf{z}}(t) = \\mathbf{A}_c \\mathbf{z}(t) + \\mathbf{B}_c \\mathbf{u}(t),\n\\] where:\n\n\\(\\mathbf{z}(t)\\): State vector\n\\(\\mathbf{u}(t)\\): Input vector\n\\(\\mathbf{A}_c\\): System matrix\n\\(\\mathbf{B}_c\\): Input matrix\n\n\n3.1 Continuous-time models\nFor a mechanical system, whose equation of motion is: \\[\n\\mathbf{M}\\ddot{\\mathbf{x}}(t) + \\mathbf{C}\\dot{\\mathbf{x}}(t) + \\mathbf{K x}(t) = \\mathbf{u}(t),\n\\] the corresponding continuous-time state equation is given by: \\[\n\\begin{bmatrix}\n\\dot{\\mathbf{x}}(t) \\\\\n\\ddot{\\mathbf{x}}(t)\n\\end{bmatrix} = \\begin{bmatrix}\n\\mathbf{0} & \\mathbf{I} \\\\\n-\\mathbf{M}^{-1}\\mathbf{K} & -\\mathbf{M}^{-1}\\mathbf{C}\n\\end{bmatrix}\\begin{bmatrix}\n\\mathbf{x}(t) \\\\\n\\dot{\\mathbf{x}}(t)\n\\end{bmatrix}+ \\begin{bmatrix}\n\\mathbf{0} \\\\\n\\mathbf{M}^{-1}\n\\end{bmatrix}\\mathbf{u}(t).\n\\]\nWhen using a modal expansion such that \\[\n\\mathbf{x}(t) = \\mathbf{\\Phi}\\mathbf{q}(t),\n\\] where \\(\\mathbf{\\Phi}\\) is the mode shapes matrix and \\(\\mathbf{q}(t)\\) is the modal coordinate vector, a modal state space equation can be obtained. The latter is written: \\[\n\\begin{bmatrix}\n\\dot{\\mathbf{q}}(t) \\\\\n\\ddot{\\mathbf{q}}(t)\n\\end{bmatrix} = \\begin{bmatrix}\n\\mathbf{0} & \\mathbf{I} \\\\\n-\\mathbf{\\Omega}^2 & -\\mathbf{\\Xi}\n\\end{bmatrix}\\begin{bmatrix}\n\\mathbf{q}(t) \\\\\n\\dot{\\mathbf{q}}(t)\n\\end{bmatrix}+ \\begin{bmatrix}\n\\mathbf{0} \\\\\n\\mathbf{\\Phi}^\\mathsf{T}\n\\end{bmatrix}\\mathbf{u}(t),\n\\] where \\(\\mathbf{\\Omega}^2 = \\text{diag}(\\omega_1^2, \\dots, \\omega_N^2)\\) and \\(\\mathbf{\\Xi} = \\text{diag}(2\\xi_1\\omega_1, \\dots, 2\\xi_N\\omega_N)\\).\n\n3.1.1 API\nData type\n\nContinuousStateSpace\n\n\n\nContinuousStateSpace(Ac, Bc)\nContinuous-time state-space model\nFields\n\nAc: Continuous-time state matrix A\n\nBc: Continuous-time input matrix B\n\n\n\n\n\n\n\n\nRelated functions\n\nss_model\n\n\n\nss_model(K, M, C)\nGenerates a continuous-time state-space model from the mass, damping, and stiffness matrices\nInputs\n\nK: Stiffness matrix\n\nM: Mass matrix\n\nC: Damping matrix\n\n\nOutput\n\ncss: ContinuousStateSpace\n\n\n\n\n\n\n\n\n\nss_modal_model\n\n\n\nss_modal_model(ωn, ξn, ϕn)\nGenerates a continuous-time state-space model from the mass, damping, and stiffness matrices\nInputs\n\nωn: Natural angular frequencies\n\nξn: Damping ratios\n\nϕn: Mass-normalized mode shapes\n\n\nOutput\n\ncss: ContinuousStateSpace\n\n\n\n\n\n\n\n\n\neigenmode\n\n\n\neigenmode(K, M, n = size(K, 1))\nComputes the eigenmodes of a system defined by its mass and stiffness matrices.\nInputs\n\nK: Stiffness matrix\n\nM: Mass matrix\n\nn: Number of modes to be keep in the modal basis\n\n\nOutputs\n\nω: Vector of natural frequencies\n\nΦ: Mass-normalized mode shapes\n\n\n\n\n\n\n\n\n\nmodal_parameters\n\n\n\nmodal_parameters(λ)\nComputes the natural angular frequencies and damping ratios from the complex eigenvalues\nInput\n\nλ: Complex eigenvalues\n\n\nOutputs\n\nωn: Natural angular frequencies\n\nξn: Damping ratios\n\n\n\n\n\n\n\n\n\nc2r_modeshape\n\n\n\nc2r_modeshape(Ψ)\nConverts the complex modes to real modes\nInput\n\nΨ: Complex modes\n\n\nOutput\n\nϕn: Real modes\n\n\n\n\n\n\n\n\n\n\n3.1.2 Example\n# System matrices\nm_ss = Diagonal([2., 1.])\nk_ss = [6. -2.; -2. 4.]\nc_ss = [0.67 -0.11; -0.11 0.39]\n\n# Continuous-time state space from system matrices\ncss = ss_model(k_ss, m_ss, c_ss)\nλ, Ψ = eigenmode(css.Ac)\nω, ξ = modal_parameters(λss)\nΨr = c2r_modeshape(Ψ[1:2:end, :])\n\n# Continuous-time state space from modal information\nωn, ϕn = eigenmode(k_ss, m_ss)\ncss_modal = ss_modal_model(ωn, 0.01, ϕn)\n\n\n\n3.2 Discrete-time models\nDiscrete-time models can be either be obtained using sampled strategies from direct-time integration methods (e.g. Newmark’s scheme). However, both approaches lead to a discrete-time state equation of the form: \\[\n    \\mathbf{z}_{k+1} = \\mathbf{A}\\, \\mathbf{z}_k + \\mathbf{B}_f\\, \\mathbf{u}_k + \\mathbf{B}_g\\, \\mathbf{u}_{k+1},\n\\]\nThe previous formulation is rather non-standard, since the state vector at frequency step \\(k + 1\\) requires the knowledge of the input vector at time steps \\(k\\) and \\(k + 1\\). To reduce the state-space representation to its standard form, a reduced state \\(\\mathbf{\\overline{z}}_{k+1}\\) is introduced: \\[\n    \\mathbf{z}_{k+1} = \\mathbf{A}\\, \\mathbf{x}_k + \\mathbf{B}_f\\, \\mathbf{u}_k,\n\\]\nIn doing so, the discretized state equation becomes: \\[\n    \\mathbf{\\overline{z}}_{k+1} = \\mathbf{A}\\, \\mathbf{\\overline{z}}_k + \\mathbf{B}\\, \\mathbf{u}_k\n\\] where \\(\\mathbf{B} = \\mathbf{B}_f + \\mathbf{A\\, B}_g\\).\n\n3.2.1 Sampling methods\nSampling methods are based on the discretization of the solution of the continuous-time state equation. Once discretized, the state equation can be written as: \\[\n\\mathbf{z}_{k+1} = \\mathbf{A} \\, \\mathbf{z}_k + \\mathbf{A}\\, \\int_{0}^{h} e^{-\\mathbf{A_c}\\tau}\\, \\mathbf{B_c}\\,\\mathbf{u}(\\tau + kh)\\, d\\tau,\n\\] where \\(\\mathbf{A} = e^{\\mathbf{A_c} h}\\) is the the discretized system matrix and \\(h\\) is the discretization timestep.\nTo cover a wide range of situations, the input vector is assumed to be parameterized as follows: \\[\n\\mathbf{u}(\\tau + kh) = f(\\tau)\\, \\mathbf{u}_k + g(\\tau)\\, \\mathbf{u}_{k+1},\n\\] where the basis function \\(f(\\tau)\\) and \\(g(\\tau)\\) control the evolution of the input vector between two time steps.\nIntroducing the parameterization of the input vector into the convolution integral, one obtains the following state equation: \\[\n    \\mathbf{z}_{k+1} = \\mathbf{A}\\, \\mathbf{z}_k + \\mathbf{B}_f\\, \\mathbf{u}_k + \\mathbf{B}_g\\, \\mathbf{u}_{k+1},\n\\] where \\(\\mathbf{B}_f\\) and \\(\\mathbf{B}_g\\) are the discretized input matrices defined such that: \\[\n    \\mathbf{B}_f = \\mathbf{A}\\, \\int_{0}^{h} e^{-\\mathbf{A_c}\\tau}\\, \\mathbf{B_c}\\,f(\\tau)\\, d\\tau \\; \\text{ and } \\; \\mathbf{B}_g = \\mathbf{A}\\, \\int_{0}^{h} e^{-\\mathbf{A_c}\\tau}\\, \\mathbf{B_c}\\,g(\\tau)\\, d\\tau.\n\\]\nIn the literature, the most commonly used sampling methods are the following1:\n\nThe Zero-Order Hold (ZOH) strategy, which assumes that the input vector is constant between two samples. This assumption is satisfied for \\(f(\\tau) = 1\\) and \\(g(\\tau) = 0\\) and leads to: \\[\n     \\mathbf{B} = \\mathbf{B}_f = (\\mathbf{A} - \\mathbf{I})\\, \\mathbf{A}_\\mathbf{c}^{-1}\\, \\mathbf{B_c}.\n\\]\nThe First-Order Hold (FOH) sampling method, which assumes that the input vector varies linearly between two samples. This assumption is satisfied for \\(f(\\tau) = 1 - \\tau/h\\) and \\(g(\\tau) = \\tau/h\\) and leads to: \\[\n      \\begin{split}\n          &\\mathbf{B}_f + \\mathbf{B}_g = (\\mathbf{A} - \\mathbf{I})\\, \\mathbf{A}_\\mathbf{c}^{-1}\\, \\mathbf{B_c}, \\\\\n          &\\mathbf{B}_g = (\\mathbf{A} - \\mathbf{A_c}h - \\mathbf{I})\\mathbf{A}_\\mathbf{c}^{-2}\\, \\mathbf{B_c}/h.\n      \\end{split}\n\\]\nThe Band-Limited Hold (BLH) sampling method, which assumes that the input signal can be approximated as a band-limited signal (i.e. the energy of the signal is concentrated in a defined frequency range). This assumption is satisfied for \\(f(\\tau) = h\\, \\delta(\\tau)\\) and \\(g(\\tau) = 0\\), where \\(\\delta(\\tau)\\) is the Dirac delta function and leads to: \\[\n      \\mathbf{B} = \\mathbf{B}_f = \\mathbf{A}\\, \\mathbf{B_c}\\, h.\n\\]\n\n\n\n3.2.2 Direct-time integration based methods\nDespite several methods can be found in the literature, such as the Newmark’s family schemes, this package only provides the Runge-Kutta approach, because it is an explicit method (i.e. does not require any matrix inversion). After some calculation not detailed here2, the discrete system and input matrices are expressed as: \\[\n    \\begin{split}\n    &\\mathbf{A} = \\frac{1}{24}\\left[24\\,(\\mathbf{I} + \\mathbf{A_c}\\, h) + 12\\, \\mathbf{A}_\\mathbf{c}^2\\, h^2 + 4\\, \\mathbf{A}_\\mathbf{c}^3\\, h^3 + \\mathbf{A}_\\mathbf{c}^4\\, h^4\\right], \\\\\n    &\\mathbf{B}_f = \\frac{h}{24}\\left[12\\, \\mathbf{I} + 8\\, \\mathbf{A_c}\\, h + 3 \\mathbf{A}_\\mathbf{c}^2\\, h^2 + \\mathbf{A}_\\mathbf{c}^3\\, h^3\\right]\\mathbf{B_c}, \\\\\n    &\\mathbf{B}_g = \\frac{h}{24}\\left[12\\, \\mathbf{I} + 4\\, \\mathbf{A_c}\\, h + \\mathbf{A}_\\mathbf{c}^2\\, h^2\\right]\\mathbf{B_c}.\n    \\end{split}\n\\]\n\n\n3.2.3 API\nData type\n\nDiscreteStateSpace\n\n\n\nDiscreteStateSpace(Ad, Bd, Bdp)\nDiscrete-time state-space model\nFields\n\nAd: Discrete-time state matrix A\n\nBd: Discrete-time input matrix B\n\nBdp: Discrete-time input matrix Bp (only for :foh method)\n\n\n\n\n\n\n\n\nRelated function\n\nc2d\n\n\n\nc2d(css::ContinuouStateSpace, h::Float64, method::Symbol)\nConverts a continuous-time state-space model to a discrete-time state-space model.\nInputs\n\ncss: Continuous-time state-space model\n\nh: Sampling time.\n\nmethod: Discretization method\n\n:zoh: Zero-order Hold method\n\n:foh: First-order Hold method\n\n:blh: Band-limited Hold method\n\n:rk4: 4th order Runge-Kutta method\n\n\n\n\nOutput\n\nDiscreteStateSpace: Discrete-time state-space model\n\nAd: Discrete-time state-space matrix A\n\nBd: Discrete-time state-space matrix B\n\nBdp: Discrete-time state-space matrix Bp (only for :foh and :rk4 methods)\n\n\n\n\n\n\n\n\n\n\n\n\n3.2.4 Example\ndss = c2d(css, 0.01, :zoh)",
    "crumbs": [
      "Models",
      "Mechanical models"
    ]
  },
  {
    "objectID": "models/index.html#footnotes",
    "href": "models/index.html#footnotes",
    "title": "Mechanical models",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nD. Bernal. “Optimal discrete to continuous transfer for band limited inputs”, Journal of Engineering Mechanics, vol. 133 (12), pp. 1370-1377, 2007.↩︎\nFor further details, see: J. Ghibaudo. “Inverse estimation of sparse mechanical excitation sources by Bayesian filtering”, PhD thesis, Conservatoire national des arts et métiers, 2024.↩︎",
    "crumbs": [
      "Models",
      "Mechanical models"
    ]
  },
  {
    "objectID": "solvers/state_space_solvers.html",
    "href": "solvers/state_space_solvers.html",
    "title": "State-space solvers",
    "section": "",
    "text": "For solving time-domain problems, the StructuralVibration.jl package provides two different approach. The first one consist in solving the problem using the discrete-time state equation (see Mechanical solvers - Section 3.2 for details). In this case, four discretization methods are available: Zero-Order Hold (:zoh), First-Order Hold (:foh), Band-Limited Hold (:blh), and Fourth order Runge-Kutta scheme (:rk4).\nThe second approach is to solve the problem using the continuous-time state equation. In this case, the user can build a continuous state-space model and solve it using DifferentialEquations.jl to take advantage of one of its numerous solvers or use the Fourth order Runge-Kutta scheme implemented in the package.\n\n\nData type\n\nStateSpaceTimeProblem\n\n\n\nStateSpaceProblem(css::ContinuousStateSpace, u0::Vector{Float64}, h::Float64, F::Matrix{Float64})\nStructure containing data for the state-space model\nConstructor\n\ncss: Continuous-time state space model\n\nu0: Initial conditions\n\nF: External force matrix\n\nt: Time vector\n\n\nFields\n\ncss: ContinuousStateSpace\n\nF: External force matrix\n\nu0: Initial conditions\n\nh: Time step\n\n\n\n\n\n\n\n\nRelated function\n\nsolve\n\n\n\nsolve(prob::StateSpaceTimeProblem, method = :zoh; progress = true)\nSolves a discrete-time problem using the state-space model\nInputs\n\nprob: Discrete-time problem\n\nmethod: Discretization method\n\n:zoh: Zero-order Hold method\n\n:foh: First-order Hold method\n\n:blh: Band-limited Hold method\n\n:rk4: Runge-Kutta 4th order method\n\n\n\nprogress: Show progress bar (default = true)\n\n\nOutput\n\nStateSpaceSolution: Solution of the state-space model\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Structural parameters\nM = Diagonal([2., 1.])\nK = [6. -2.; -2. 4.]\nξ = 0.05\n\nω, Φ = eigenmode(K, M)\nC = modal_damping_matrix(M, ω, ξ, Φ)\n\n# Time vector\nt = 0.:1e-2:30.\n\n# State-space model\ncss = ss_model(K, M, C)\n\n# Force\nF_free = zeros(2, length(t))\n\n# Initial conditions\nx0 = [0.2, 0.1]\nv0 = zeros(2)\nu0 = [x0; v0]\n\n# Problem definition\nprob_free = StateSpaceTimeProblem(css, F_free, u0, t)\nx_free_zoh = solve(prob_free).u\nx_free_foh = solve(prob_free, :foh).u\nx_free_blh = solve(prob_free, :blh).u\nx_free_rk = solve(prob_free, RK4()).u\n# Other possibility\n# x_free_rk = solve(prob_free, :rk4).u\n\nprob_free_modal =  FreeModalTimeProblem(K, M, ξ, (x0, v0), t)\nx_free_modal = solve(prob_free_modal).u\n\n\n\n\n\n\n\n\n\n\n# Structural parameters\nM = Diagonal([2., 1.])\nK = [6. -2.; -2. 4.]\nξ = 0.05\n\nω, Φ = eigenmode(K, M)\nC = modal_damping_matrix(M, ω, ξ, Φ)\n\n# Time vector\nt = 0.:1e-2:30.\n\n# State-space model\ncss = ss_model(K, M, C)\n\nF0 = 10.\ntstart = 2.\nduration = 5.\nhaversine = HaverSine(F0, tstart, duration)\nF0 = excitation(haversine, t)\nF = zeros(2, length(t))\nF[1, :] .= F0\n\n# Initial conditions\nx0 = zeros(2)\nv0 = zeros(2)\nu0 = [x0; v0]\n\n# Problem definition\nprob_forced = StateSpaceTimeProblem(css, F, u0, t)\nx_forced_zoh = solve(prob_forced).u\nx_forced_foh = solve(prob_forced, :foh).u\nx_forced_blh = solve(prob_forced, :blh).u\nx_forced_rk = solve(prob_forced, :rk4).u\n\nprob_forced_modal = ForcedModalTimeProblem(K, M, ξ, F, (x0, v0), t)\nx_forced_modal = solve(prob_forced_modal).u",
    "crumbs": [
      "Solvers",
      "State-space solvers"
    ]
  },
  {
    "objectID": "solvers/state_space_solvers.html#time-domain-solvers",
    "href": "solvers/state_space_solvers.html#time-domain-solvers",
    "title": "State-space solvers",
    "section": "",
    "text": "For solving time-domain problems, the StructuralVibration.jl package provides two different approach. The first one consist in solving the problem using the discrete-time state equation (see Mechanical solvers - Section 3.2 for details). In this case, four discretization methods are available: Zero-Order Hold (:zoh), First-Order Hold (:foh), Band-Limited Hold (:blh), and Fourth order Runge-Kutta scheme (:rk4).\nThe second approach is to solve the problem using the continuous-time state equation. In this case, the user can build a continuous state-space model and solve it using DifferentialEquations.jl to take advantage of one of its numerous solvers or use the Fourth order Runge-Kutta scheme implemented in the package.\n\n\nData type\n\nStateSpaceTimeProblem\n\n\n\nStateSpaceProblem(css::ContinuousStateSpace, u0::Vector{Float64}, h::Float64, F::Matrix{Float64})\nStructure containing data for the state-space model\nConstructor\n\ncss: Continuous-time state space model\n\nu0: Initial conditions\n\nF: External force matrix\n\nt: Time vector\n\n\nFields\n\ncss: ContinuousStateSpace\n\nF: External force matrix\n\nu0: Initial conditions\n\nh: Time step\n\n\n\n\n\n\n\n\nRelated function\n\nsolve\n\n\n\nsolve(prob::StateSpaceTimeProblem, method = :zoh; progress = true)\nSolves a discrete-time problem using the state-space model\nInputs\n\nprob: Discrete-time problem\n\nmethod: Discretization method\n\n:zoh: Zero-order Hold method\n\n:foh: First-order Hold method\n\n:blh: Band-limited Hold method\n\n:rk4: Runge-Kutta 4th order method\n\n\n\nprogress: Show progress bar (default = true)\n\n\nOutput\n\nStateSpaceSolution: Solution of the state-space model\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Structural parameters\nM = Diagonal([2., 1.])\nK = [6. -2.; -2. 4.]\nξ = 0.05\n\nω, Φ = eigenmode(K, M)\nC = modal_damping_matrix(M, ω, ξ, Φ)\n\n# Time vector\nt = 0.:1e-2:30.\n\n# State-space model\ncss = ss_model(K, M, C)\n\n# Force\nF_free = zeros(2, length(t))\n\n# Initial conditions\nx0 = [0.2, 0.1]\nv0 = zeros(2)\nu0 = [x0; v0]\n\n# Problem definition\nprob_free = StateSpaceTimeProblem(css, F_free, u0, t)\nx_free_zoh = solve(prob_free).u\nx_free_foh = solve(prob_free, :foh).u\nx_free_blh = solve(prob_free, :blh).u\nx_free_rk = solve(prob_free, RK4()).u\n# Other possibility\n# x_free_rk = solve(prob_free, :rk4).u\n\nprob_free_modal =  FreeModalTimeProblem(K, M, ξ, (x0, v0), t)\nx_free_modal = solve(prob_free_modal).u\n\n\n\n\n\n\n\n\n\n\n# Structural parameters\nM = Diagonal([2., 1.])\nK = [6. -2.; -2. 4.]\nξ = 0.05\n\nω, Φ = eigenmode(K, M)\nC = modal_damping_matrix(M, ω, ξ, Φ)\n\n# Time vector\nt = 0.:1e-2:30.\n\n# State-space model\ncss = ss_model(K, M, C)\n\nF0 = 10.\ntstart = 2.\nduration = 5.\nhaversine = HaverSine(F0, tstart, duration)\nF0 = excitation(haversine, t)\nF = zeros(2, length(t))\nF[1, :] .= F0\n\n# Initial conditions\nx0 = zeros(2)\nv0 = zeros(2)\nu0 = [x0; v0]\n\n# Problem definition\nprob_forced = StateSpaceTimeProblem(css, F, u0, t)\nx_forced_zoh = solve(prob_forced).u\nx_forced_foh = solve(prob_forced, :foh).u\nx_forced_blh = solve(prob_forced, :blh).u\nx_forced_rk = solve(prob_forced, :rk4).u\n\nprob_forced_modal = ForcedModalTimeProblem(K, M, ξ, F, (x0, v0), t)\nx_forced_modal = solve(prob_forced_modal).u",
    "crumbs": [
      "Solvers",
      "State-space solvers"
    ]
  },
  {
    "objectID": "solvers/state_space_solvers.html#frequency-domain-solvers",
    "href": "solvers/state_space_solvers.html#frequency-domain-solvers",
    "title": "State-space solvers",
    "section": "2 Frequency-domain solvers",
    "text": "2 Frequency-domain solvers\nThe frequency-domain solvers are based on the state-space representation of the system, which includes both the state equation and the output equation. It is given that: \\[\n\\begin{cases}\n\\dot{\\mathbf{z}}(t) &= \\mathbf{A}_c \\mathbf{z}(t) + \\mathbf{B}_c \\mathbf{u}(t) \\\\\n\\mathbf{y}(t) &= \\mathbf{C}_c \\mathbf{z}(t) + \\mathbf{D}_c \\mathbf{u}(t)\n\\end{cases},\n\\] where:\n\n\\(\\mathbf{z}(t)\\): State vector\n\\(\\mathbf{u}(t)\\): Input vector\n\\(\\mathbf{y}(t)\\): Output vector\n\\(\\mathbf{A}_c\\): System matrix\n\\(\\mathbf{B}_c\\): Input matrix\n\\(\\mathbf{C}_c\\): Observation matrix\n\\(\\mathbf{D}_c\\): Direct feedthrough matrix\n\nIt is also possible to express the state-space system. To this end, the state-space representation is transformed into modal coordinates, i.e., \\(\\mathbf{z} = \\mathbf{\\Psi} \\mathbf{q}\\), where \\(\\mathbf{\\Psi}\\) is the matrix of eigenvectors of the system matrix \\(\\mathbf{A}_c\\). The modal state-space representation is given by: \\[\n\\begin{cases}\n\\dot{\\mathbf{q}}(t) &= \\mathbf{\\Lambda} \\mathbf{q}(t) + \\mathbf{B}_m \\mathbf{u}(t) \\\\\n\\mathbf{y}(t) &= \\mathbf{C}_m \\mathbf{q}(t) + \\mathbf{D}_m \\mathbf{u}(t)\n\\end{cases},\n\\] where:\n\n\\(\\mathbf{q}(t)\\): Modal state vector\n\\(\\Lambda = \\text{diag}(\\lambda_1, \\lambda_1^\\ast, \\dots, \\lambda_N, \\lambda_N^\\ast)\\): Eigenvalues matrix\n\\(\\mathbf{B}_m = \\mathbf{\\Psi}^{-1} \\mathbf{B}_c\\): Modal input matrix\n\\(\\mathbf{C}_m = \\mathbf{C}_c \\mathbf{\\Psi}\\): Modal observation matrix\n\\(\\mathbf{D}_m = \\mathbf{D}_c\\): Modal direct feedthrough matrix\n\nFinally\n\n2.1 Frequency Response Function\nThe Frequency Response Function (FRF) is a complex function that describes the steady-state response of a system to a sinusoidal input. The FRF is defined as the ratio of the output to the input in the frequency domain. From the state-space representation, the transfer function of the system at a given angular frequency \\(\\omega\\) can be obtained in a straightforward manner and is given by: \\[\n\\mathbf{H}(\\omega) = \\mathbf{C}_c (j\\omega \\mathbf{I} - \\mathbf{A}_c)^{-1} \\mathbf{B}_c + \\mathbf{D}_c,\n\\] or equivalently from the modes of the system: \\[\n\\mathbf{H}(\\omega) = \\mathbf{C}_m (j\\omega \\mathbf{I} - \\mathbf{\\Lambda} )^{-1} \\mathbf{B}_m + \\mathbf{D}_m.\n\\]\nFinally, it should be noted that the FRF can be computed for a given set of response dofs and a given set of excitation dofs by introducing the appropriate selection matrices \\(\\mathbf{S}_o\\) and \\(\\mathbf{S}_e\\). In this case, the FRF is given by: \\[\n\\mathbf{H}_{oe}(\\omega) = \\mathbf{S}_o\\mathbf{H}(\\omega)\\mathbf{S}_e.\n\\]\n\n\n\n\n\n\nNote\n\n\n\n\nFor the admittance : \\(\\mathbf{C}_c = [\\mathbf{I},\\quad \\mathbf{0}]\\) and \\(\\mathbf{D}_c = \\mathbf{0}\\).\nFor the mobility : \\(\\mathbf{C}_c = [\\mathbf{0}, \\quad \\mathbf{I}]\\) and \\(\\mathbf{D}_c = \\mathbf{0}\\).\nFor the accelerance, \\(\\mathbf{C}_c = \\mathbf{A}_c[m:\\text{end}, :]\\) and \\(\\mathbf{D}_c = \\mathbf{B}_c[m:\\text{end}, :]\\) with \\(m = N/2\\) (this corresponds to a rewrite of the equation of motion).\n\n\n\n\n2.1.1 API\nData types\n\nStateSpaceFRFProblem\n\n\n\nStateSpaceFRFProblem(css::ContinuousStateSpace, freq, type, So, Se)\nStructure containing the data feeding the direct solver for calculating an FRF\nFields\n\ncss: Continuous-time state space model\n\nfreq: Frequencies of interest\n\nSo: Selection matrix for observation points\n\nSe: Selection matrix for excitation points\n\n\nNote It is assumed that the output equation is of the form y = So*x\n\n\n\n\n\n\n\nStateSpaceModalFRFProblem\n\n\n\nStateSpacemodalFRFProblem(css::ContinuousStateSpace, freq, type, So, Se, n)\nStructure containing the data feeding the direct solver for calculating an FRF\nFields\n\ncss: Continuous-time state space model\n\nfreq: Frequencies of interest\n\nSo: Selection matrix for observation points\n\nSe: Selection matrix for excitation points\n\nn: Number of modes to keep in the modal basis\n\n\n\n\n\n\n\n\nRelated function\n\nsolve\n\n\n\nsolve(prob::StateSpaceFRFProblem; type = :dis, ismat = false, progress = true)\nsolve(prob::StateSpaceModalFRFProblem; type = :dis, ismat = false, progress = true)\nComputes the FRF matrix by direct or modal method\nInputs\n\nprob: Structure containing the problem data\n\ntype: Type of FRF to compute\n\n:dis: Admittance\n\n:vel: Mobility\n\n:acc: Accelerance\n\n\n\nismat: Return the FRF matrix as a 3D array (default = false)\n\nprogress: Show progress bar (default = true)\n\n\nOutput\n\nsol: FRFSolution structure\n\nu: FRF matrix\n\n\n\n\n\n\n\n\n\n\n\n\n2.1.2 Example\n\n# Structural parameters\nM = Diagonal([2., 1.])\nK = [6. -2.; -2. 4.]\nξ = 0.05\n\nω, Φ = eigenmode(K, M)\nC = modal_damping_matrix(M, ω, ξ, Φ)\n\n# State-space model\ncss = ss_model(K, M, C)\n\n# Frequency vector\nfreq = 0.01:0.001:1.\n\n# Problem definition - Case 1 - Direct\nprob_frf = StateSpaceFRFProblem(css, freq)\nH_direct = solve(prob_frf, ismat = true).u\n\n# Problem definition - Case 2 - Modal\nprob_frf_modal = StateSpaceModalFRFProblem(css, freq)\nH_modal = solve(prob_frf_modal, ismat = true).u\n\n\n\n\n\n\n\n\n\n2.2 Response spectrum\nSimilarly to the FRF, the response spectrum is a complex function that describes the steady-state response of a system to a sinusoidal input. From the state-space representation, the response spectrum of the system at a given angular frequency \\(\\omega\\) is given by: \\[\n\\mathbf{y}(\\omega) = \\left[\\mathbf{C}_c (j\\omega \\mathbf{I} - \\mathbf{A}_c)^{-1} \\mathbf{B}_c + \\mathbf{D}_c\\right] \\mathbf{u}(\\omega),\n\\] or equivalently from the modes of the system: \\[\n\\mathbf{y}(\\omega) = \\left[\\mathbf{C}_m (j\\omega \\mathbf{I} - \\mathbf{\\Lambda} )^{-1} \\mathbf{B}_m + \\mathbf{D}_m\\right] \\mathbf{u}(\\omega).\n\\]\n\n2.2.1 API\n\nStateSpaceFreqProblem\n\n\n\nStateSpaceFreqProblem(css::ContinuousStateSpace, F, freq, So)\nStructure containing the data feeding the modal solver for calculating the frequency response\nFields\n\ncss: Continuous-time state space model\n\nF: External force matrix\n\nfreq: Frequencies of interest\n\nSo: Selection matrix for observation points\n\n\n\n\n\n\n\n\n\nStateSpaceModalFreqProblem\n\n\n\nStateSpaceModalFreqProblem(css::ContinuousStateSpace, F, freq, So, n)\nStructure containing the data feeding the modal solver for calculating the frequency response\nFields\n\ncss: Continuous-time state space model\n\nF: External force matrix\n\nfreq: Frequencies of interest\n\nSo: Selection matrix for observation points\n\nn: Number of modes to keep in the modal basis\n\n\n\n\n\n\n\n\nRelated function\n\nsolve\n\n\n\nsolve(prob::StateSpaceFreqProblem; type = :dis, progress = true)\nsolve(prob::StateSpaceFreqProblem; type = :dis, progress = true)\nComputes the frequency response by direct or modal method\nInputs\n\nprob: Structure containing the problem data\n\ntype::Symbol: Type of FRF to compute\n\n:dis: Displacement\n\n:vel: Velocity\n\n:acc: Acceleration\n\n\n\nprogress: Show progress bar\n\n\nOutput sol: Solution of the problem     * u: Response spectrum matrix\n\n\n\n\n\n\n\n\n2.2.2 Example\n\n# Structural parameters\nM = Diagonal([2., 1.])\nK = [6. -2.; -2. 4.]\nξ = 0.05\n\nω, Φ = eigenmode(K, M)\nC = modal_damping_matrix(M, ω, ξ, Φ)\n\n# State-space model\ncss = ss_model(K, M, C)\n\n# Frequency vector\nfreq = 0.01:0.001:1.\n\n# Force matrix\nF = zeros(2, length(freq))\nF[1, :] .= 10.\n\n# Problem definition - Case 1 - Direct\nprob_freq = StateSpaceFreqProblem(css, F, freq)\ny_freq = solve(prob_freq).u\n\n# Problem definition - Case 2 - Modal\nprob_freq_modal = StateSpaceModalFreqProblem(css, F, freq)\ny_freq_modal = solve(prob_freq_modal).u",
    "crumbs": [
      "Solvers",
      "State-space solvers"
    ]
  },
  {
    "objectID": "solvers/modal_time_solvers.html",
    "href": "solvers/modal_time_solvers.html",
    "title": "Modal time solvers",
    "section": "",
    "text": "The aim of this section is to describe the modal time solvers available for solving Multi-degrees of freedom (Mdof) systems. To explain, the theoretical foundations of the proposed solvers, let’s consider a Mdof system with \\(N\\) degrees of freedom. The equation of motion of the system is given by: \\[\n\\mathbf{M} \\ddot{\\mathbf{x}}(t) + \\mathbf{C} \\dot{\\mathbf{x}}(t) + \\mathbf{K} \\mathbf{x}(t) = \\mathbf{F}(t)\n\\] where \\(\\mathbf{M}\\) is the mass matrix, \\(\\mathbf{C}\\) is the damping matrix, \\(\\mathbf{K}\\) is the stiffness matrix, \\(\\mathbf{x}(t)\\) is the displacement vector, and \\(\\mathbf{F}(t)\\) is the vector of external forces.\nTo solve the previous in the modal space, the solution \\(\\mathbf{x}(t)\\) is expressed as: \\[\n\\mathbf{x}(t) = \\mathbf{\\Phi} \\mathbf{q}(t)\n\\] where \\(\\mathbf{\\Phi}\\) is the matrix of the mode shapes and \\(\\mathbf{q}(t)\\) is the vector of modal coordinates.\nSubstituting the previous expression in the equation of motion, premultiplying by \\(\\mathbf{\\Phi}^\\mathsf{T}\\), and using the orthogonality property of the mode shapes, one obtains a set of \\(N\\) independent modal equations of motion given by: \\[\n\\ddot{q}_n(t) + 2 \\xi_n \\omega_n \\dot{q}_n(t) + \\omega_n^2 q_n(t) = \\frac{f_n(t)}{m_n}\n\\] where for the n-th mode, \\(q_n(t)\\) is the generalized coordinate, \\(\\xi_n\\) is the damping ratio, \\(\\omega_n\\) is the natural angular frequency, \\(f_n(t)\\) is the modal force, and \\(m_n\\) is the modal mass.\nIt should be noticed that a modal equation of motion corresponds to the equation of motion of a Sdof system with mass \\(m_n\\), damping ratio \\(\\xi_n\\), natural angular frequency \\(\\omega_n\\).\nIt results that computing the response of an Mdof system in the modal space is equivalent to solving \\(N\\) independent Sdof systems.",
    "crumbs": [
      "Solvers",
      "Modal time solvers"
    ]
  },
  {
    "objectID": "solvers/modal_time_solvers.html#free-response",
    "href": "solvers/modal_time_solvers.html#free-response",
    "title": "Modal time solvers",
    "section": "1 Free response",
    "text": "1 Free response\nThe free response of an MDOF system is the response of the system when there are no external forces acting on it. In this case, the modal equations of motion of the system is given by: \\[\n\\ddot{q}_n(t) + 2 \\xi_n \\omega_n \\dot{q}_n(t) + \\omega_n^2 q_n(t) = 0\n\\]\nThe solution of the previous equation can be found in Sdof solvers - Section 1.1.\n\n1.1 API\nData type\n\nFreeModalTimeProblem\n\n\n\nFreeModalTimeProblem(K, M, ξn, n = size(K, 1); ismodal = false)\nStructure containing data for the modal time solver\nFields\n\nK::VecOrMat{Real}:\n\nIf ismodal = false then Matrix{Real}: Stiffness matrix\n\nIf ismodal = true then Vector{Real}: Natural angular frequencies\n\n\n\nM::AbtractMatrix:\n\nIf ismodal = false: Mass matrix\n\nIf ismodal = true: Mass-normalized mode shapes\n\n\n\nξn: Damping ratios\n\nu0::Tuple: Initial conditions\n\nu0[1]: Initial displacement (or modal displacement)\n\nu0[2]: Initial velocity (or modal velocity)\n\n\n\nt::AbstractRange: Time points at which to evaluate the response\n\nF::Matrix{Real}: External force matrix (or modal force matrix)\n\nn::Int: Number of modes to retain in the modal basis\n\nismodal::Bool: Flag to indicate if the problem contains modal data\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nTwo possibilities are offered to the user to enter the structural properties of the system.\n\nProvide the stiffness and mass matrices.\nProvide the squared natural frequencies and (mass-normalized) mode shapes. This allows to use the modal information computed analytically for continuous systems or numerically for discrete systems.\n\nIn the latter case, the initial conditions must be expressed in the modal space.\n\n\n\nRelated function\n\nsolve\n\n\n\nsolve(prob::FreeModalTimeProblem)\nCompute the free response of a multi-degrees of freedom (Mdof) system using the modal approach.\nInputs\n\nprob: Structure containing the parameters of the Mdof problem\n\n\nOutput\n\nsol: ModalTimeSolution structure containing the response of the system at the given time points\n\n\n\n\n\n\n\n\n\n\n1.2 Example\n\n# System parameters\nM = Diagonal([2., 1.])\nK = [6. -2.; -2. 4.]\nξ = 0.05\n\n# Time vector\nt = 0.:1e-2:30.\n\n# Initial conditions\nx0 = [0.2, 0.1]\nv0 = zeros(2)\n\n# Problem definition - case 1 - Provide the stiffness and mass matrices\nu0 = (x0, v0)\nprob = FreeModalTimeProblem(K, M, ξ, u0, t)\n\n# Problem definition - case 2 - Provide the squared natural frequencies and mode shapes\nωm, Φm = eigenmode(K, M)\nx0m = Φm'*M*x0\nv0m = Φm'*M*v0\nu0m = (x0m, v0m)\nprob_modal = FreeModalTimeProblem(ωm, Φm, ξ, u0m, t, ismodal = true)\n\n# Solution\nx_free = solve(prob).u\nx_free_modal = solve(prob_modal).u",
    "crumbs": [
      "Solvers",
      "Modal time solvers"
    ]
  },
  {
    "objectID": "solvers/modal_time_solvers.html#forced-response",
    "href": "solvers/modal_time_solvers.html#forced-response",
    "title": "Modal time solvers",
    "section": "2 Forced response",
    "text": "2 Forced response\nThe forced response of an Mdof system is the response of the system when external forces are acting on it. In this case, the modal equations of motion of the system is given by: \\[\n\\ddot{q}_n(t) + 2 \\xi_n \\omega_n \\dot{q}_n(t) + \\omega_n^2 q_n(t) = \\frac{f_n(t)}{m_n}\n\\]\nThe solution of the previous equation can be found in Sdof solvers - Section 1.2.\n\n2.1 Harmonic excitation\n\n2.1.1 API\nData type\n\nHarmonicModalTimeProblem\n\n\n\nHarmonicModalTimeProblem(K, M, ξn, u0, t, F, ω = 0., n = size(K, 1); ismodal = false)\nStructure containing data for the modal time solver for computing the forced response due to an harmonic excitation\nConstructor\n\nK::VecOrMat{Real}:\n\nIf ismodal = false then Matrix{Real}: Stiffness matrix\n\nIf ismodal = true then Vector{Real}: Natural angular frequencies\n\n\n\nM::AbtractMatrix:\n\nIf ismodal = false: Mass matrix\n\nIf ismodal = true: Mass-normalized mode shapes\n\n\n\nξn: Damping ratios\n\nu0::Tuple: Initial conditions\n\nu0[1]: Initial displacement (or modal displacement)\n\nu0[2]: Initial velocity (or modal velocity)\n\n\n\nt::AbstractRange: Time points at which to evaluate the response\n\nF::Real: External force matrix (or modal participation factors)\n\nfreq::Real: Excitation frequency\n\nn::Int: Number of modes to retain in the modal basis\n\nismodal::Bool: Flag to indicate if the problem contains modal data\n\n\nFields\n\nK: Stiffness matrix (or modal stiffness matrix)\n\nM: Mass matrix (or mass-normalized mode shapes)\n\nξn: Damping ratios\n\nu0: Initial conditions\n\nu0[1]: Initial displacement (or modal displacement)\n\nu0[2]: Initial velocity (or modal velocity)\n\n\n\nt: Time points at which to evaluate the response\n\nF: Amplitude vector (or modal participation vector)\n\nω: Excitation angular frequency\n\nn: Number of modes to retain in the modal basis\n\nismodal: Flag to indicate if the problem contains modal data\n\n\n\n\n\n\n\n\nRelated function\n\nsolve\n\n\n\nsolve(prob::HarmonicModalTimeProblem)\nCompute the forced response of a multi-degrees of freedom (Mdof) system due to an harmonic excitation using the modal approach.\nInputs\n\nprob: Structure containing the parameters of the Mdof problem\n\n\nOutput\n\nsol: Solution structure containing the response of the system at the given time points\n\nu: Displacement\n\ndu: Velocity\n\nddu: Acceleration\n\n\n\n\n\n\n\n\n\n\n\n\n2.1.2 Example\n\n# System parameters\nM = Diagonal([2., 1.])\nK = [6. -2.; -2. 4.]\nξ = 0.05\n\n# Time vector\nt = 0.:1e-2:30.\n\n# Initial conditions\nx0 = [0., 1e-4]\nv0 = zeros(2)\nu0 = (x0, v0)\n\n# Excitation parameters\nF = [1., 2.]\nfreq = 0.5\n\n# Problem definition - case 1 - Provide the stiffness and mass matrices\nprob_harmo = HarmonicModalTimeProblem(K, M, ξ, F, 2π*freq, u0, t)\n\n# Problem definition - case 2 - Provide the squared natural frequencies and mode shapes\nωm, Φm = eigenmode(K, M)\nx0m = Φm'*M*x0\nv0m = Φm'*M*v0\nu0m = (x0m, v0m)\nLm = Φm'*F\nprob_harmo_modal = HarmonicModalTimeProblem(ωm, Φm, ξ, Lm, 2π*freq, u0m, t, ismodal = true)\n\n# Solution\nx_harmo = solve(prob_harmo).u\nx_harmo_modal = solve(prob_harmo_modal).u\n\n\n\n\n\n\n\n\n\n2.2 Arbitrary excitation\n\n2.2.1 API\nData type\n\nForcedModalTimeProblem\n\n\n\nForcedModalTimeProblem(K, M, ξn, u0, t, F, n = size(K, 1); ismodal = false)\nStructure containing data for modal time solver for computing the forced response due to an arbitrary excitation\nFields\n\nK::VecOrMat{Real}:\n\nIf ismodal = false then Matrix{Real}: Stiffness matrix\n\nIf ismodal = true then Vector{Real}: Natural angular frequencies\n\n\n\nM::AbtractMatrix:\n\nIf ismodal = false: Mass matrix\n\nIf ismodal = true: Mass-normalized mode shapes\n\n\n\nξn: Damping ratios\n\nF::Matrix{Real}: External force matrix (or modal participation factors)\n\nu0::Tuple: Initial conditions\n\nu0[1]: Initial displacement (or modal displacement)\n\nu0[2]: Initial velocity (or modal velocity)\n\n\n\nt::AbstractRange: Time points at which to evaluate the response\n\nn::Int: Number of modes to retain in the modal basis\n\nismodal::Bool: Flag to indicate if the problem contains modal data\n\n\n\n\n\n\n\n\nRelated function\n\nsolve\n\n\n\nsolve(prob::ForcedModalTimeProblem)\nCompute the forced response of a multi-degrees of freedom (Mdof) system due to an arbitrary excitation using the modal approach.\nInputs\n\nprob: Structure containing the parameters of the Mdof problem\n\nmethod: Method to compute the Duhamel's integral\n\n:filt: Filtering using the Z-transform of the impulse response (default)\n\n:interp: Interpolation + Gaussian quadrature\n\n:conv: Convolution\n\n\n\n\nOutput\n\nsol: ModalTimeSolution structure containing the response of the system at the given time points\n\n\n\n\n\n\n\n\n\n\n2.2.2 Example\n\n# System parameters\nM = Diagonal([2., 1.])\nK = [6. -2.; -2. 4.]\nξ = 0.05\n\n# Time vector\nt = 0.:1e-2:30.\n\n# Initial conditions\nu0 = (zeros(2), zeros(2))\n\n# Excitation parameters\nF0 = 10.\ntstart = 2.\nduration = 5.\nhaversine = HaverSine(F0, tstart, duration)\nF0 = excitation(haversine, t)\nF = zeros(2, length(t))\nF[1, :] .= F0\n\n# Problem definition - case 1 - Provide the stiffness and mass matrices\nprob_forced = ForcedModalTimeProblem(K, M, ξ, F, u0, t)\n\n# Problem definition - case 2 - Provide the squared natural frequencies and mode shapes\nωm, Φm = eigenmode(K, M)\nu0m = (zeros(2), zeros(2))\nLm = Φm'*F\nprob_forced_modal = ForcedModalTimeProblem(ωm, Φm, ξ, Lm, u0m, t, ismodal = true)\n\n# Solution\nx_forced = solve(prob_forced).u\nx_forced_modal = solve(prob_forced_modal).u",
    "crumbs": [
      "Solvers",
      "Modal time solvers"
    ]
  },
  {
    "objectID": "solvers/modal_time_solvers.html#additional-function---impulse-response-matrix",
    "href": "solvers/modal_time_solvers.html#additional-function---impulse-response-matrix",
    "title": "Modal time solvers",
    "section": "3 Additional function - Impulse response matrix",
    "text": "3 Additional function - Impulse response matrix\nThe impulse response matrix of an Mdof system is obtained from the modal impulse response matrix. The modal impulse response matrix is given by: \\[\n\\mathbf{h}(t) = \\Phi \\begin{bmatrix}\nh_1(t) & & & & \\\\\n& \\ddots & & & \\\\\n& & h_n(t) & & \\\\\n& & & \\ddots & \\\\\n& & & & h_N(t)\n\\end{bmatrix}\n\\Phi^\\mathsf{T},\n\\] where \\(h_n(t)\\) is the modal impulse response of the mode \\(n\\) computed as in Sdof solvers - Section 1.3.\n\nimpulse_response\n\n\n\nimpulse_response(K::Matrix{Float64}, M::Matrix{Float64}, ξn, t, n = size(K, 1); ismat = false)\nCompute the impulse response of a multi-degrees of freedom (Mdof) system using the modal approach\nInputs\n\nK:\n\nIf ismodal = false: Stiffness matrix\n\nIf ismodal = true: Squared natural angular frequencies\n\n\n\nM:\n\nIf ismodal = false: Mass matrix\n\nIf ismodal = true: Mass-normalized mode shapes\n\n\n\nξn: Damping ratios\n\nt: Time points at which to evaluate the response\n\nn: Number of modes to retain in the modal basis\n\nismodal::Bool: Flag to indicate if the problem contains modal data\n\nismat::Bool: Flag to indicate if the output should be a matrix\n\n\nOutput\n\nsol: ModalImpulseSolution\n\nu: Impulse response matrix\n\n\n\n\n\n\n\n\n\n\n\n# System parameters\nM = Diagonal([2., 1.])\nK = [6. -2.; -2. 4.]\nξ = 0.05\n\n# Time vector\nt = 0.:1e-2:30.\n\n# Impulse response matrix\nh = impulse_response(K, M, ξ, t, ismat = true).u;",
    "crumbs": [
      "Solvers",
      "Modal time solvers"
    ]
  },
  {
    "objectID": "solvers/direct_time_solvers.html",
    "href": "solvers/direct_time_solvers.html",
    "title": "Direct-time integration solvers",
    "section": "",
    "text": "Similarly to the previous section, the aim is to describe the direct time solvers available for solving Mdof systems. As a remainder, the equation of motion of the system is given by: \\[\n\\mathbf{M} \\ddot{\\mathbf{x}}(t) + \\mathbf{C} \\dot{\\mathbf{x}}(t) + \\mathbf{K} \\mathbf{x}(t) = \\mathbf{F}(t)\n\\] where \\(\\mathbf{M}\\) is the mass matrix, \\(\\mathbf{C}\\) is the damping matrix, \\(\\mathbf{K}\\) is the stiffness matrix, \\(\\mathbf{x}(t)\\) is the displacement vector, and \\(\\mathbf{F}(t)\\) is the vector of external forces.\nDirect-time integration solvers are used to solve the previous equation in the time domain. In Julia , we have the option of using DifferentialEquations.jl which provides a wide range of solvers for solving differential equations.\nThe StructuralVibration package provides its own set of fixed-step linear second-order ODE solvers for pedagogical purposes and for the sake of completeness of the package. It should also be noted that some of the solvers implemented in the package are not available in DiffentialEquations.jl. This is the case of the solvers of the Newmark family, which are widely used in structural dynamics.\nThe solvers available in the StructuralVibration package are:",
    "crumbs": [
      "Solvers",
      "Direct-time integration solvers"
    ]
  },
  {
    "objectID": "solvers/direct_time_solvers.html#api",
    "href": "solvers/direct_time_solvers.html#api",
    "title": "Direct-time integration solvers",
    "section": "1 API",
    "text": "1 API\nData types\n\nDirectTimeProblem\n\n\n\nDirectTimeProblem(K, M, C, F, u0, t)\nStructure containing data for the time solver\nConstructor\n\nK::AbstractMatrix: Stiffness matrix\n\nM::AbstractMatrix: Mass matrix\n\nC:AbstractMatrix: Damping matrix\n\nF::AbstractMatrix: External force matrix\n\nu0::Tuple: Initial conditions\n\nu0[1]: Initial displacement (or modal displacement)\n\nu0[2]: Initial velocity (or modal velocity)\n\n\n\nt::AbstractVector: Time points at which to evaluate the response\n\n\nFields\n\nK: Stiffness matrix\n\nM: Mass matrix\n\nC: Damping matrix\n\nF: External force matrix\n\nu0: Initial conditions\n\nu0[1]: Initial displacement\n\nu0[2]: Initial velocity\n\n\n\nh::Real: Time step\n\n\n\n\n\n\n\n\n\nCentralDiff\n\n\n\nCentralDiff()\nCentral difference time solver\n\n\n\n\n\n\n\nRK4\n\n\n\nRK4()\nFourth-order Runge-Kutta time solver\n\n\n\n\n\n\n\nNewmark\n\n\n\nNewmark(; γ0 = 0.5, β0 = 0.25)\nNewmark time solver\n\n\n\n\n\n\n\nHHT\n\n\n\nHHT(; γ0 = 0.5, β0 = 0.25, ρ = 1., αf = Inf)\nHilber-Hughes-Taylor time solver\n\n\n\n\n\n\n\nWBZ\n\n\n\nWBZ(; γ0 = 0.5, β0 = 0.25, ρ = 1., αm = Inf)\nWood-Bossak-Zienkiewicz time solver\n\n\n\n\n\n\n\nFoxGoodwin\n\n\n\nFoxGoodwin()\nFox-Goodwin time solver\n\n\n\n\n\n\n\nMidPoint\n\n\n\nMidPoint()\nMid-point rule time solver\n\n\n\n\n\n\n\nGeneralizedAlpha\n\n\n\nGeneralizedAlpha(; γ0 = 0.5, β0 = 0.25, ρ = 1., αf = Inf, αm = Inf)\nGeneralized-α time solver\n\n\n\n\n\n\nRelated function\n\nsolve\n\n\n\nsolve(prob::DirectTimeProblem, alg; progress = true)\nDirect time integration solver\nInputs\n\nprob: DirectTimeProblem structure\n\nalg: Numerical integration algorithm\n\nCentralDiff(): Central difference\n\nRK4(): Fourth-order Runge-Kutta\n\nNewmark(): Newmark\n\nHHT(): Hilber-Hughes-Taylor\n\nWBZ(): Wood-Bossak-Zienkiewicz\n\nGeneralizedAlpha(): Generalized-α (default)\n\nMidPoint(): Mid-point rule\n\n\n\nprogress: Show progress bar\n\n\nOutput\n\nsol: Solution structure containing the response of the system at the given time points\n\nu: Displacement\n\ndu: Velocity\n\nddu: Acceleration",
    "crumbs": [
      "Solvers",
      "Direct-time integration solvers"
    ]
  },
  {
    "objectID": "solvers/direct_time_solvers.html#free-response",
    "href": "solvers/direct_time_solvers.html#free-response",
    "title": "Direct-time integration solvers",
    "section": "2 Free response",
    "text": "2 Free response\nThe free response of a 2-dofs system is obtained by setting the external forces to zero. In this condition, the motion of the system is initiated by non-zero initial conditions. In the following example, the response provided by the direct time solvers is compared with the solution obtained by the modal solver described in Modal time solvers - Section 1 for the purpose of cross-validation.\n\n# System parameters\nM = Diagonal([2., 1.])\nK = [6. -2.; -2. 4.]\nξ = 0.05\n\nω, Φ = eigenmode(K, M)\nC = modal_damping_matrix(M, ω, ξ, Φ)\n\n# Time vector\nt = 0.:1e-2:30.\n\n# Initial conditions\nx0 = [0.2, 0.1]\nv0 = zeros(2)\nu0 = (x0, v0)\n\n# External forces\nF_free = zeros(2, length(t))\n\n# Direct time problem\nprob_free = DirectTimeProblem(K, M, C, F_free, u0, t)\nx_free_gα = solve(prob_free).u\nx_free_cd = solve(prob_free, CentralDiff()).u\nx_free_rk = solve(prob_free, RK4()).u\n\n# Modal time problem\nprob_free_modal =  FreeModalTimeProblem(K, M, ξ, u0, t)\nx_free_modal = solve(prob_free_modal).u",
    "crumbs": [
      "Solvers",
      "Direct-time integration solvers"
    ]
  },
  {
    "objectID": "solvers/direct_time_solvers.html#forced-response",
    "href": "solvers/direct_time_solvers.html#forced-response",
    "title": "Direct-time integration solvers",
    "section": "3 Forced response",
    "text": "3 Forced response\nThe forced response of a 2-dofs system is obtained by applying a haversine excitation to the first dof of the system. As in the previous section, the response provided by the direct time solvers is compared with the solution obtained by the modal solver described in Modal time solvers - Section 2 for the purpose of cross-validation.\n\n# System parameters\nM = Diagonal([2., 1.])\nK = [6. -2.; -2. 4.]\nξ = 0.05\n\nω, Φ = eigenmode(K, M)\nC = modal_damping_matrix(M, ω, ξ, Φ)\n\n# Time vector\nt = 0.:1e-2:30.\n\n# Initial conditions\nx0 = zeros(2)\nv0 = zeros(2)\nu0 = (x0, v0)\n\n# External forces\nF0 = 10.\ntstart = 2.\nduration = 5.\nhaversine = HaverSine(F0, tstart, duration)\nF0 = excitation(haversine, t)\nF = zeros(2, length(t))\nF[1, :] .= F0\n\n# Direct time problem\nprob_forced = DirectTimeProblem(K, M, C, F, u0, t)\nx_forced_gα = solve(prob_forced).u\nx_forced_cd = solve(prob_forced, CentralDiff()).u\nx_forced_rk = solve(prob_forced, RK4()).u\n\n# Modal time problem\nprob_forced_modal = ForcedModalTimeProblem(K, M, ξ, F, u0, t)\nx_forced_modal = solve(prob_forced_modal).u",
    "crumbs": [
      "Solvers",
      "Direct-time integration solvers"
    ]
  },
  {
    "objectID": "solvers/direct_time_solvers.html#footnotes",
    "href": "solvers/direct_time_solvers.html#footnotes",
    "title": "Direct-time integration solvers",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nN. M. Newmark. “A method of computation for structural dynamics”. Journal of the Engineering Mechanics Division, 85(3), 67-94, 1959.↩︎\nH. M. Hilber, T. J. Hughes and R. L. Taylor. “Improved numerical dissipation for time integration algorithms in structural dynamics”. Earthquake Engineering & Structural Dynamics 5(3), 283–292. 1977.↩︎\nW. L. Wood, M. Bossak, O. Zienkiewicz. “An alpha modification of Newmark’s method”. International Journal for Numerical Methods in Engineering, 15(10), 1562-1566, 1980.↩︎\nL. Fox, E. T. Goodwin. “Some new methods for numerical integration of ordinary differential equations”. Mathematical Proceedings of the Cambridge Philosophical Society, 45(3), 373-388, 1949.↩︎\nM. Géradin and D. Rixen. “Mechanical Vibrations: Theory and Application to Structural Dynamics”. Third Edition. John Wiley & Sons, 2015.↩︎\nJ. Chung and G. M. Hulbert. “A time integration algorithm for structural dynamics with improved numerical dissipation: the generalized-alpha method”. Journal of Applied Mechanics, 60(2), 371-375, 1993.↩︎",
    "crumbs": [
      "Solvers",
      "Direct-time integration solvers"
    ]
  },
  {
    "objectID": "visualization/index.html",
    "href": "visualization/index.html",
    "title": "Visualization extensions",
    "section": "",
    "text": "StructuralVibration.jl is accompanied by an extension SVMakieExt.jl providing visualization capabilities. The extension provides a set of functions to visualize the results of the structural dynamics analysis.\nTo use one of these extensions, you need to import the desired plotting package by running the following command:",
    "crumbs": [
      "Visualization",
      "Visualization extensions"
    ]
  },
  {
    "objectID": "visualization/index.html#bode-plot",
    "href": "visualization/index.html#bode-plot",
    "title": "Visualization extensions",
    "section": "1 Bode plot",
    "text": "1 Bode plot\nA Bode plot is a graph of the magnitude and phase of a transfer function versus frequency.\n\nbode_plot\n\n\n\nbode_plot(freq, y...; lw = 1., xlab = \"Frequency (Hz)\",\n          ylab = \"Magnitude (dB)\", xscale = identity,\n          axis_tight = true, isdeg = false, layout = :vertical,\n          ref_dB = 1., legend = (active = false, position = :rt, entry = \" \"))\nPlot Bode diagram of a frequency response or a FRF.\nInputs\n\nfreq: Frequency range of interest\n\ny: Frequency response or FRF\n\nlw: Line width\n\nxlab: x-axis label\n\nxscale: x-axis scale (default: :log)\n\naxis_tight: Tight axis (default: false)\n\nisdeg: Phase in degrees (default: false)\n\nlayout: Layout of the plot (default: :vertical)\n\nref_dB: Reference value for magnitude (default: 1.)\n\nlegend: Legend parameters (default: (active = false, position = :rt, entry = \" \"))\n\n\nOutput\n\nfig: Figure\n\n\n\n\n\n\n\n\n\n# Initialize a Sdof type\nm = 1.\nf₀ = 10.\nξ = 0.01\nsdof = Sdof(m, f₀, ξ)\n\n# Computation parameters\nfreq = 1.:0.01:30.\n\n# Compute the FRF\nprob_frf = SdofFRFProblem(sdof, freq)\nH = solve(prob_frf).u\n\n# Bode plot\nbode_plot(freq, H)",
    "crumbs": [
      "Visualization",
      "Visualization extensions"
    ]
  },
  {
    "objectID": "visualization/index.html#nyquist-plot",
    "href": "visualization/index.html#nyquist-plot",
    "title": "Visualization extensions",
    "section": "2 Nyquist plot",
    "text": "2 Nyquist plot\nThe Nyquist plot is either a 2D or 3D plot. In 2D, it is a graph of the imaginary part versus the real part of the transfer function. In 3D, it is a graph of the imaginary part versus the real part of the transfer function and the frequency.\n\n2.1 2D plot\n\nnyquist_plot\n\n\n\nnyquist_plot(y)\nPlot Nyquist diagram\nInputs\n\ny: Complex data vector\n\n\nOutput\n\nfig: Figure\n\n\n\n\n\n\n\n\n\nnyquist_plot(H)\n\n\n\n\n\n\n2.2 3D plot\n\nnyquist_plot\n\n\n\nnyquist_plot(freq, y, xlab = \"Frequency (Hz)\";\n             projection = false)\nPlot Nyquist diagram in 3D\nInputs\n\nfreq: Frequency range\n\ny: Complex vector\n\nylabel: y-axis label\n\nprojection: Projection of the curve on the xy, yz, and xz planes (default: false)\n\non the xy plane: (freq, real(y))\n\non the yz plane: (imag(y), freq)\n\non the xz plane: (real(y), imag(y))\n\n\n\n\nOutput\n\nfig: Figure\n\n\n\n\n\n\n\n\n\nnyquist_plot(freq, H, projection = true)",
    "crumbs": [
      "Visualization",
      "Visualization extensions"
    ]
  },
  {
    "objectID": "visualization/index.html#waterfall-plot",
    "href": "visualization/index.html#waterfall-plot",
    "title": "Visualization extensions",
    "section": "3 Waterfall plot",
    "text": "3 Waterfall plot\nA waterfall plot is a 3D plot with a partial curtain along the y-axis.\n\nwaterfall_plot\n\n\n\nwaterfall_plot(x, y, z; zmin = minimum(z), lw = 1.,\n               colorline = :auto, colmap = :viridis, colorband = (:white, 1.),\n               xlabel = \"x\", ylabel = \"y\", zlabel = \"z\", edge = true,\n               axis_tight = false, xlim = [minimum(x), maximum(x)],\n               ylim = [minimum(y), maximum(y)], zlim = [zmin, maximum(z)])\nPlot a waterfall plot.\nInputs\n\nx: x-axis values\n\ny: y-axis values\n\nz: z-axis values\n\nzmin: minimum value of z-axis\n\nlw::Real: linewidth\n\ncolorline: color of the lines\n\ncolmap: Name of the colormap\n\ncolorband: Tuple defining the color of the band\n\ncolor : Color\n\nalpha : Alpha value for transparency\n\n\n\nxlabel: x-axis label\n\nylabel: y-axis label\n\nzlabel: z-axis label\n\nedge: Display edges (default: true)\n\naxis_tight: Tight axis (default: false)\n\nxlim: x-axis limits\n\nylim: y-axis limits\n\nzlim: z-axis limits\n\n\nOutput\n\nfig: Figure\n\n\n\n\n\n\n\n\nx = range(0., 2π, 100)\ny = range(0., 1., 5)\n\nnx = length(x)\nny = length(y)\nz = zeros(ny, nx)\n\nfor i in eachindex(y)\n    z[i, :] = sin.(i*x/2.)\nend\n\nwaterfall_plot(x, y, z, xlim = [-0.1, 2π + 0.1], ylim = [-0.1, 1.1])",
    "crumbs": [
      "Visualization",
      "Visualization extensions"
    ]
  },
  {
    "objectID": "visualization/index.html#sv-plot",
    "href": "visualization/index.html#sv-plot",
    "title": "Visualization extensions",
    "section": "4 SV plot",
    "text": "4 SV plot\nThe SV plot (for StructuralVibration plot) is a general function for 2D plotting. It is a helper function aiming at simplifying the plotting process.\n\nsv_plot\n\n\n\nsv_plot(x, y...; lw = 1., xscale = identity, yscale = identity,\n        axis_tight = true, title = \" \", xlabel = \"x\", ylabel = \"y\",\n        legend = (active = false, position = :right, orientation = :vertical, entry = \" \"))\nPlot a 2D plot.\nInputs\n\nx: x-axis values\n\ny: y-axis values\n\nlw: linewidth\n\nxscale: x-axis scale (default: identity)\n\nyscale: y-axis scale (default: identity)\n\naxis_tight: Tight axis (default: true)\n\ntitle: Title of the plot (default: \" \")\n\nxlabel: x-axis label\n\nylabel: y-axis label\n\nlegend: Legend parameters\n\nactive : Bool\n\nposition : Symbol\n\nentry : String\n\n\n\n\nOutput\n\nfig: Figure\n\n\n\n\n\n\n\n\n\nx = range(0., 2π, 100)\nz_sv = ntuple(i -&gt; sin.(i*x/2), 5)\n\n# SV plot\nsv_plot(x, z_sv..., lw = 2., legend = (active = true,))",
    "crumbs": [
      "Visualization",
      "Visualization extensions"
    ]
  },
  {
    "objectID": "visualization/index.html#theming",
    "href": "visualization/index.html#theming",
    "title": "Visualization extensions",
    "section": "5 Theming",
    "text": "5 Theming\nStructuralVibration.jl provides a set of themes for the plotting functions. The themes are defined in the theme_choice function.\n\ntheme_choice\n\n\n\ntheme_choice(name::Symbol; fonts = Makie.theme(:fonts),\n             titlesize = 20., labelsize = 18., ticklabelsize = 14.)\nChoose the theme for the plots.\nInputs\n\nname: Name of the theme\n\n:makie\n\n:sv\n\n\n\nfonts: Fonts of the figure (default: Makie.theme(:fonts))\n\ntitlesize: Title size (default: 20.)\n\nlabelsize: Label size (default: 18.)\n\nticklabelsize: Tick label size (default: 14.)\n\n\nOutput\n\ntheme: Theme\n\n\n\n\n\n\n\n\n\nwith_theme(theme_choice(:makie)) do\n    sv_plot(x, z_sv..., lw = 2., legend = (active = true,), title = \":makie theme\")\nend\n\n\n\n\n\nwith_theme(theme_choice(:makie)) do\n    sv_plot(x, z_sv..., lw = 2., legend = (active = true,), title = \":sv theme\")\nend",
    "crumbs": [
      "Visualization",
      "Visualization extensions"
    ]
  },
  {
    "objectID": "solvers/frequency_solvers.html",
    "href": "solvers/frequency_solvers.html",
    "title": "Frequency-domain solvers",
    "section": "",
    "text": "From a general perspective, the frequency-domain solvers are used to analyze the dynamic response of structures subjected to harmonic loads. In the frequency domain, Mdof systems are described at a given angular frequency \\(\\omega\\) by the following equation: \\[\n\\left(\\mathbf{K} + j\\omega\\mathbf{C} - \\omega^2\\mathbf{M}\\right) \\mathbf{x}(\\omega) = \\mathbf{F}(\\omega).\n\\]",
    "crumbs": [
      "Solvers",
      "Frequency-domain solvers"
    ]
  },
  {
    "objectID": "solvers/frequency_solvers.html#frequency-response-function",
    "href": "solvers/frequency_solvers.html#frequency-response-function",
    "title": "Frequency-domain solvers",
    "section": "1 Frequency response function",
    "text": "1 Frequency response function\nThe Frequency response function (FRF) is computed by assuming a unit harmonic load at the \\(i\\)-th degree of freedom (DOF) and zero loads at all other DOFs, meaning that \\(\\mathbf{F}(\\omega) = \\mathbf{I}\\).\nConsequently, broadly speaking, the FRF is defined by: \\[\n\\mathbf{H}(\\omega) = \\left(\\mathbf{K} + j\\omega\\mathbf{C} - \\omega^2\\mathbf{M}\\right)^{-1}.\n\\] This method is known as the direct method.\nAlternatively, the FRF can be computed using the modal method, which is based on the eigenvalue decomposition of the system matrices. The modal method is more efficient for large systems, as it reduces the problem to a smaller number of modes. In this case and assuming a modal damping ratio, the FRF is computed as: \\[\n\\mathbf{H}(\\omega) = \\mathbf{\\Phi}\\left(\\mathbf{\\Omega}^2 - \\omega^2\\mathbf{I} + 2j\\omega\\mathbf{\\Xi}\\right)^{-1}\\mathbf{\\Phi}^T,\n\\] where \\(\\mathbf{\\Phi}\\) is the mass-normalized mode shapes matrix and \\(\\mathbf{\\Omega}^2 = \\text{diag}(\\omega_1^2, \\dots, \\omega_n^2)\\) and \\(\\mathbf{\\Xi} = \\text{diag}(\\xi_1\\omega_1, \\dots, \\xi_n\\omega_n)\\).\n\n\n\n\n\n\nNote\n\n\n\nAs explained in State-Space solvers - Section 2.1, the FRF can be computed for a given set of response dofs and a given set of excitation dofs by introducing the appropriate selection matrices \\(\\mathbf{S}_o\\) and \\(\\mathbf{S}_e\\). In this case, the FRF is given by: \\[\n\\mathbf{H}_{oe}(\\omega) = \\mathbf{S}_o\\mathbf{H}(\\omega)\\mathbf{S}_e.\n\\]\n\n\n\n1.1 API\nData types\n\nDirectFRFProblem\n\n\n\nDirectFRFProblem(K, M, C, freq, So, Se)\nStructure containing the data feeding the direct solver for calculating an FRF\nFields\n\nK::AbstractMatrix: Stiffness matrix\n\nM::AbstractMatrix: Mass matrix\n\nC::AbstractMatrix: Damping matrix\n\nfreq::AbtractRange: Frequencies of interest\n\nSo::AbstractMatrix: Selection matrix for observation points\n\nSe::AbstractMatrix: Selection matrix for excitation points\n\n\n\n\n\n\n\n\n\nModalFRFProblem\n\n\n\nModalFRFProblem(ωn, ξn, freq, ϕo, ϕe)\nStructure containing the data feeding the modal solver for calculating an FRF\nFields\n\nωn::Vector{Real}: Natural angular frequencies\n\nξn::Vector{Real}: Modal damping ratios\n\nfreq::AbstractRange: Frequencies of interest\n\nϕe::AbstractMatrix: Mode shapes at excitation points\n\nϕo::AbstractMatrix: Mode shapes at observation points\n\n\nNote The mode shapes must be mass-normalized\n\n\n\n\n\n\nRelated function\n\nsolve\n\n\n\nsolve(prob::DirectFRF; type = :dis, ismat = false, progress = true)\nsolve(prob::ModalFRFProblem; type = :dis, ismat = false, progress = true)\nComputes the FRF matrix by direct or modal approach\nInputs\n\nprob: Structure containing the problem data\n\ntype: Type of FRF to compute\n\n:dis: Admittance (default)\n\n:vel: Mobility\n\n:acc: Accelerance\n\n\n\nismat: Return the FRF matrix as a 3D array (default = false)\n\nprogress: Show progress bar (default = true)\n\n\nOutput\n\nsol: Solution of the problem\n\nu: FRF matrix\n\n\n\n\n\n\n\n\n\n\n\n\n1.2 Example\n\n# Structural parameters\nM = Diagonal([2., 1.])\nK = [6. -2.; -2. 4.]\nξ = 0.05\n\nω, Φ = eigenmode(K, M)\nC = modal_damping_matrix(M, ω, ξ, Φ)\n\n# Frequency vector\nfreq = 0.01:0.001:1.\n\nprob_frf = DirectFRFProblem(K, M, C, freq)\nH_direct = solve(prob_frf, ismat = true).u\n\n# Problem definition - Case 2 - Modal\nprob_frf_modal = ModalFRFProblem(ω, ξ, freq, Φ, Φ)\nH_modal = solve(prob_frf_modal, ismat = true).u",
    "crumbs": [
      "Solvers",
      "Frequency-domain solvers"
    ]
  },
  {
    "objectID": "solvers/frequency_solvers.html#response-spectrum",
    "href": "solvers/frequency_solvers.html#response-spectrum",
    "title": "Frequency-domain solvers",
    "section": "2 Response spectrum",
    "text": "2 Response spectrum\nSimilarly to the FRF, the response spectrum is a complex function that describes the steady-state response of a system to a sinusoidal input. At a given angular frequency \\(\\omega\\), it is expressed as : \\[\n\\mathbf{x}(\\omega) = \\left(\\mathbf{K} + j\\omega\\mathbf{C} - \\omega^2\\mathbf{M}\\right)^{-1} \\mathbf{F}(\\omega).\n\\] or equivalently from the modes of the system: \\[\n\\mathbf{x}(\\omega) = \\mathbf{\\Phi}\\left(\\mathbf{\\Omega}^2 - \\omega^2\\mathbf{I} + 2j\\omega\\mathbf{\\Omega}\\right)^{-1}\\mathbf{L},\n\\] where \\(\\mathbf{L} = \\mathbf{\\Phi}^\\mathsf{T}\\mathbf{F}(\\omega)\\) is the modal participation factor matrix1.\n\n2.1 API\nData types\n\nDirectFreqProblem\n\n\n\nDirectFreqProblem(K, M, C, F, freq, So)\nStructure containing the data feeding the direct solver for calculating the modal frequencies\nFields\n\nK::AbstractMatrix: Stiffness matrix\n\nM::AbstractMatrix: Mass matrix\n\nC::AbstractMatrix: Damping matrix\n\nF::AbstractMatrix: Force matrix\n\nfreq::AbstractRange: Frequencies of interest\n\nSo::AbstractMatrix: Selection matrix for observation points\n\n\n\n\n\n\n\n\n\nModalFreqProblem\n\n\n\nModalFreqProblem(ωn, ξn, Fn, freq, ϕo)\nStructure containing the data feeding the modal solver for calculating the frequency response by modal approach\nFields\n\nωn::Vector{Real}: Natural angular frequencies\n\nξn::Vector{Real}: Modal damping ratios\n\nLn::AbstractMatrix: Modal participation factors\n\nfreq::AbstractRange: Frequencies of interest\n\nϕo::Matrix{Real}: Mode shapes at observation points\n\n\n\n\n\n\n\n\nRelated function\n\nsolve\n\n\n\nsolve(prob::DirectFreqProblem, type = :dis, progress = true)\nsolve(prob::ModalFreqProblem, type = :dis, progress = true)\nComputes the frequency response by direct or modal approach\nInputs\n\nprob: Structure containing the problem data\n\ntype: Type of response to compute\n\n:dis: Displacement (default)\n\n:vel: Velocity\n\n:acc: Acceleration\n\n\n\nprogress: Show progress bar (default = true)\n\n\nOutput\n\nsol: Solution of the problem\n\nu: Response spectrum matrix\n\n\n\n\n\n\n\n\n\n\n\n\n2.2 Example\n\n# Structural parameters\nM = Diagonal([2., 1.])\nK = [6. -2.; -2. 4.]\nξ = 0.05\n\nω, Φ = eigenmode(K, M)\nC = modal_damping_matrix(M, ω, ξ, Φ)\n\n# Frequency vector\nfreq = 0.01:0.001:1.\n\n# Force matrix\nF = zeros(2, length(freq))\nF[1, :] .= 10.\n\n# Problem definition - Case 1 - Direct\nprob_freq = DirectFreqProblem(K, M, C, F, freq)\ny_freq = solve(prob_freq).u\n\n# Problem definition - Case 2 - Modal\nprob_freq_modal = ModalFreqProblem(ω, ξ, Φ'*F, freq, Φ)\ny_freq_modal = solve(prob_freq_modal).u",
    "crumbs": [
      "Solvers",
      "Frequency-domain solvers"
    ]
  },
  {
    "objectID": "solvers/frequency_solvers.html#footnotes",
    "href": "solvers/frequency_solvers.html#footnotes",
    "title": "Frequency-domain solvers",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nThe expression of the modal participation factor matrix is the same as the modal force matrix, because the mode shapes are assumed to be mass-normalized.↩︎",
    "crumbs": [
      "Solvers",
      "Frequency-domain solvers"
    ]
  },
  {
    "objectID": "solvers/index.html",
    "href": "solvers/index.html",
    "title": "Sdof solvers",
    "section": "",
    "text": "The package provides a set of solvers to compute the time response of a single-degree-of-freedom (sdof) system.\n\n\nThe free response of a sdof system is the response of the system when it is subjected to initial conditions only. This means that the displacement of the mass is solution of the following ordinary differential equation: \\[\n\\begin{cases}\n  \\ddot x(t) + 2 \\xi\\omega_0\\dot x(t) + \\omega_0^2 x(t) = 0 \\\\\n  x(0) = x_0 \\\\\n  \\dot x(0) = v_0\n\\end{cases}.\n\\]\nDepending on the value of the damping ratio \\(\\xi\\) and \\(\\omega_0 &gt; 0\\), the system can have 4 different types of free response:\n\nan undamped motion when \\(\\xi = 0\\). In this case, the free response is: \\[\nx(t) = x_0\\cos\\omega_0 t + \\frac{v_0}{\\omega_0}\\sin\\omega_0 t\n\\]\nan underdamped motion when \\(0 &lt; \\xi &lt; 1\\). In this case, the free response is: \\[\nx(t) = \\left[x_0\\cos\\Omega_0 t + \\frac{v_0 + \\xi\\Omega_0 x_0}{\\Omega_0}\\sin\\Omega_0 t\\right]e^{-\\xi\\omega_0 t}\n\\] where \\(\\Omega_0 = \\omega_0\\sqrt{1 - \\xi^2}\\).\na critically damped motion when \\(\\xi = 1\\). In this case, the free response is: \\[\nx(t) = \\left[x_0 + (v_0 + \\omega_0 x_0)t\\right]e^{-\\omega_0 t}\n\\]\nan overdamped motion when \\(\\xi &gt; 1\\). In this case, the free response is: \\[\nx(t) = \\left[x_0\\text{cosh}(\\beta t) + \\frac{v_0 + \\xi\\omega_0 x_0}{\\beta}\\text{sinh}\\beta t\\right]e^{-\\xi\\omega_0 t},\n\\] where \\(\\beta = \\omega_0\\sqrt{\\xi^2 - 1}\\).\n\nFinally, if \\(\\omega = 0\\), the mass is free from constraints and the free response is: \\[\nx(t) = x_0 + v_0 t.\n\\]\n\n\nData type\n\nSdofFreeTimeProblem\n\n\n\nSdofFreeTimeProblem(sdof, u0, t)\nStructure containing the data of a time problem for a sdof system\nFields\n\nsdof::Sdof: Sdof structure\n\nu0::AbstractVector: Initial conditions\n\nx0: Initial displacement [m]\n\nv0: Initial velocity [m/s]\n\n\n\nt::AbstractRange: Time points at which to evaluate the response\n\n\n\n\n\n\n\n\nRelated function\n\nsolve\n\n\n\nsolve(prob::SdofFreeTimeProblem)\nCompute the free response of a single degree of freedom (Sdof) system.\nInput\n\nprob: Structure containing the parameters of the Sdof problem\n\n\nOutput\n\nsol: The response of the system at the given time points\n\nu: Displacement solution\n\ndu: Velocity solution\n\nddu: Acceleration solution\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Structural parameters\nm = 1.\nf0 = 1.\n\n# Time vector\nt = 0.:0.01:10.\n\n# Initial conditions\nu0 = [1., -2.]\n\n# Undamped system\nsdof_nd = Sdof(m, f0, 0.)\nprob_nd = SdofFreeTimeProblem(sdof_nd, u0, t)\nx_nd = solve(prob_nd).u\n\n# Underdamped system\nsdof_ud = Sdof(m, f0, 0.1)\nprob_ud = SdofFreeTimeProblem(sdof_ud, u0, t)\nx_ud = solve(prob_ud).u\n\n# Critically damped system\nsdof_cd = Sdof(m, f0, 1.)\nprob_cd = SdofFreeTimeProblem(sdof_cd, u0, t)\nx_cd = solve(prob_cd).u\n\n# Overdamped system\nsdof_od = Sdof(m, f0, 1.2)\nprob_od = SdofFreeTimeProblem(sdof_od, u0, t)\nx_od = solve(prob_od).u;\n\n\n\n\n\n\n\n\n\n\nThe forced response of a sdof system is the response of the system is the solution of the following ordinary differential equation: \\[\n\\begin{cases}\n  \\ddot x(t) + 2 \\xi\\omega_0\\dot x(t) + \\omega_0^2 x(t) = \\displaystyle\\frac{\\text{rhs}(t)}{m} \\\\\n  x(0) = x_0 \\\\\n  \\dot x(0) = v_0\n\\end{cases},\n\\] where \\(\\text{rhs}(t)\\) is the right-hand side of the equation and its expression depends on the type of excitation: \\[\n\\text{rhs}(t) = \\begin{cases}\nf(t) & \\text{for an external force excitation} \\\\\nm\\omega_0^2 x_b(t) + 2\\xi\\omega_0m\\dot x_b(t) & \\text{for a base excitation}\n\\end{cases}.\n\\]\nFinally, the solution of the forced response is expressed as the sum of two terms, since: \\[\nx(t) = x_h(t) + x_p(t),\n\\] where \\(x_h(t)\\) is the homogeneous solution of the equation and \\(x_p(t)\\) is the particular solution of the equation.\n\n\nWhen the excitation is harmonic, the resolution process is the following:\n\nCompute the particular solution of the equation. The particular solution is a harmonic function of the same frequency as the excitation.\nExpress the general solution of the homogeneous equation.\nCompute the remaining constants using the initial conditions. These constants depends on \\(x_p(0)\\) and \\(\\dot x_p(0)\\).\n\n\n\nData type\n\nSdofHarmonicTimeProblem\n\n\n\nSdofHarmonicTimeProblem(sdof, u0, t, F, ω, type_exc)\nStructure containing the data of a time problem for a sdof system subject to a harmonic excitation\nConstructor parameters\n\nsdof::Sdof: Sdof structure\n\nF: Amplitude of the force excitation [N] or base motion [m]\n\nf: Frequency of the excitation [Hz]\n\nu0::AbstractVector: Initial conditions\n\nx0: Initial displacement [m]\n\nv0: Initial velocity [m/s]\n\n\n\nt::AbstractRange: Time points at which to evaluate the response\n\ntype_exc::Symbol: Type of excitation\n\n:force: External force (default)\n\n:base: Base motion\n\n\n\n\nFields\n\nsdof::Sdof: Sdof structure\n\nF: Amplitude of the force excitation [N] or base motion [m]\n\nω: Frequency of the excitation [rad/s]\n\nu0::AbstractVector: Initial conditions\n\nx0: Initial displacement [m]\n\nv0: Initial velocity [m/s]\n\n\n\nt::AbstractRange: Time points at which to evaluate the response\n\ntype_exc::Symbol: Type of excitation\n\n:force: External force (default)\n\n:base: Base motion\n\n\n\n\n\n\n\n\n\n\nRelated function\n\nsolve\n\n\n\nsolve(prob::SdofHarmonicTimeProblem)\nComputes the forced response of a single degree of freedom (Sdof) system due to an harmonic external force or base motion\nInputs\n\nprob: Structure containing the parameters of the Sdof harmonic problem\n\n\nOutput\n\nsol: The response of the system at the given time points\n\nu: Displacement solution\n\ndu: Velocity solution\n\nddu: Acceleration solution\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Structural parameters\nm = 1.\nf0 = 1.\nξ = 0.1\n\n# Instantiation of the Sdof object\nsdof = Sdof(m, f0, ξ)\n\n# Harmonic excitation - Force amplitude + excitation frequency\nF0 = 10.\nf = 2.\n\n# Instantiation of the problem\nt = 0.:0.01:10.\nu0 = [1., -2.]\nprob = SdofHarmonicTimeProblem(sdof, u0, t, F0, f, :force)\n\n# Solve the problem\nx_harmo = solve(prob).u\n\n\n\n\n\n\n\n\n\n\nFor an arbitrary excitation, the solution is given by: \\[\nx(t) = x_\\text{free}(t) + \\int_0^t rhs(t - τ)h(τ)dτ,\n\\] where \\(x_\\text{free}(t)\\) is the free response of the system and \\(h(t)\\) is the impulse response of the system.\n\n\nData type\n\nSdofForcedTimeProblem\n\n\n\nSdofForcedTimeProblem(sdof, u0, t, F, ω, type_exc)\nStructure containing the data of a time problem for a sdof system subject to an arbitrary excitation\nFields\n\nsdof::Sdof: Sdof structure\n\nF::AbstractVector: Amplitude of the force excitation [N] or base motion [m]\n\nu0::AbstractVector: Initial conditions\n\nx0: Initial displacement [m]\n\nv0: Initial velocity [m/s]\n\n\n\nt::AbstractRange: Time points at which to evaluate the response\n\ntype_exc::Symbol: Type of excitation\n\n:force: External force (default)\n\n:base: Base motion\n\n\n\n\n\n\n\n\n\n\nRelated function\n\nsolve\n\n\n\nsolve(prob::SdofForcedTimeProblem)\nComputes the forced response of a single degree of freedom (Sdof) system due to an arbitrary external force or base motion\nInputs\n\nprob: Structure containing the parameters of the Sdof forced problem\n\nmethod: Method to compute the Duhamel's integral\n\n:filt: Filtering using the Z-transform of the impulse response (default)\n\n:interp: Interpolation + Gaussian quadrature\n\n:conv: Convolution product\n\n\n\n\nOutput\n\nsol: The response of the system at the given time points\n\nu: Displacement solution\n\ndu: Velocity solution\n\nddu: Acceleration solution\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Structural parameters\nm = 1.\nf0 = 1.\nξ = 0.1\n\n# Instantiation of the Sdof object\nsdof = Sdof(m, f0, ξ)\n\n# Haversine excitation signal\nF0 = 10.\ntstart = 0.5\nduration = 2.\nhaversine = HaverSine(F0, tstart, duration)\n\nt = 0.:0.01:10.\nF = excitation(haversine, t)\n\n# Instantiation of the problem\nu0 = [1, -2]\nprob = SdofForcedTimeProblem(sdof, u0, t, F, :force)\n\n# Solve the problem\nx_arb_filt = solve(prob, method = :filt).u\nx_arb_interp = solve(prob, method = :interp).u\nx_arb_conv = solve(prob, method = :conv).u;\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe impulse response of a sdof system is the response of the system when it is subjected to an impulse excitation. The impulse response is the solution of the following ordinary differential equation: \\[\n\\overset{..}{h}(t) + 2\\xi\\omega_0\\overset{.}{h}(t) + \\omega_0^2 h(t) = \\frac{\\delta(t)}{m}.\n\\]\nIt can be shown that the impulse response can be computed by solving the following problem: \\[\n\\begin{cases}\n\\overset{..}{h}(t) + 2\\xi\\omega_0\\overset{.}{h}(t) + \\omega_0^2 h(t) = 0 & \\forall t &gt; 0 \\\\\nh(t) = 0 & \\text{at } t = 0 \\\\\n\\overset{.}{h}(t) = \\displaystyle\\frac{1}{m} & \\text{at } t = 0\n\\end{cases}.\n\\]\n\nimpulse_response\n\n\n\nimpulse_response(sdof, t)\nCompute the impulse response of a single degree of freedom (Sdof) system\nInputs\n\nsdof: Sdof structure\n\nt: Time points at which to evaluate the response\n\n\nOutput\n\nh: Impulse response\n\n\n\n\n\n\n\n\n\n# Structural parameters\nm = 1.\nf0 = 1.\nξ = 0.1\n\nt = 0.:0.01:10.\n\n# Instantiation of the Sdof object\nsdof = Sdof(m, f0, ξ)\n\nh = impulse_response(sdof, t)\n\n\n\n\n\n\n\n\n\nThe shock response spectrum (SRS) is a graph of the peak acceleration response of a sdof system subjected to a base acceleration with respect to the frequency. The SRS is computed by solving the following problem: \\[\n\\ddot z(t) + 2\\xi\\omega_0\\dot z(t) + \\omega_0^2 z(t) = -\\ddot x_b(t),\n\\] where \\(z(t) = x(t) - x_b(t)\\) is the relative displacement of the system with respect to the base.\nTo compute the SRS, the following steps are performed at a given frequency \\(f\\):\n\nInstantiate a Sdof type\nsdof = Sdof(1., f, ξ)\nCompute the time response of the relative displacement \\(z(t)\\) due to a base acceleration for \\(z(0) = 0\\) and \\(\\dot z(0) = 0\\).\nCompute the acceleration \\(\\ddot x(t)\\) of the system: \\[\nx(t) = -2\\xi\\omega_0\\dot z(t) - \\omega_0^2 z(t)\n\\]\nExtract the primary or secondary part of the acceleration (i.e. until or after the end of the excitation signal).\nCompute either:\n\nThe peak acceleration of the system such that: \\[\nSRS(f) = \\max\\left(|\\ddot x(t)|\\right)\n\\]\nThe maximum positive acceleration of the system such that: \\[\nSRS(f) = \\max\\left(\\max(\\ddot x(t), 0)\\right)\n\\]\nThe maximum negative acceleration of the system such that: \\[\nSRS(f) = \\max\\left(\\max(-\\ddot x(t), 0)\\right)\n\\]\n\n\nSeveral algorithms are available to compute the SRS:\n\n:Basic: the SRS is computed by following the steps mentioned above. It is not the most efficient algorithm but it is the most versatile.\n:RecursiveInt: the SRS is computed using a recursive integration algorithm.\n:RecursiveFilt: the SRS is computed using a recursive filtering algorithm.\n:Smallwood: the SRS is computed using the Smallwood algorithm.\n\nFor the last three algorithms, more details and references can be found Mathworks - Introduction to SRS\n\nsrs\n\n\n\nsrs(base_acc::ArbitraryExc, freq, t, ξ = 0.05,\n    type = (instance = :primary, amplitude = :abs), alg = :Smallwood)\nCompute the Shock Response Spectrum (SRS)\nInputs\n\nbase_acc::ArbitraryExc: Base acceleration type - see excitation function for detatils\n\nfreq: Vector of frequencies [Hz]\n\nt: Time points at which to evaluate the response\n\nξ: Damping ratio (default = 0.05)\n\ntype: Type of SRS\n\ninstance: Instance of the SRS\n\n:primary: Primary instance (default)\n\n:secondary: Secondary instance\n\n\n\namplitude: Amplitude used of the computing SRS\n\n:abs: Maximum absolute amplitude (default)\n\n:pos: Maximum positive amplitude\n\n:neg: Maximum negative amplitude\n\n\n\n\n\nalg: Algorithm to compute the SRS\n\n:Basic: Basic algorithm\n\n:RecursiveInt: Recursive integration algorithm\n\n:RecursiveFilt: Recursive filtering algorithm\n\n:Smallwood: Smallwood algorithm (default)\n\n\n\n\nOutput\n\nsrs: Vector of the SRS values\n\n\nNote\n\nPrimary instance - response of the system during the application of the base acceleration\n\nSecondary instance - response of the system after the application of the base acceleration\n\n\n\n\n\n\n\n\n\n# Definition of the base acceleration\nt = 0.:1e-5:0.5\nbase_acc = HalfSine(10., 0., 1e-3)\n\n# Compute the SRS\nf = 50.:25:1e3\nsrs_basic = srs(base_acc, f, t)\nsrs_rec_int = srs(base_acc, f, t, alg = :RecursiveInt)\nsrs_rec_filt = srs(base_acc, f, t, alg = :RecursiveFilt)\nsrs_smallwood = srs(base_acc, f, t, alg = :Smallwood)",
    "crumbs": [
      "Solvers",
      "Sdof solvers"
    ]
  },
  {
    "objectID": "solvers/index.html#time-domain-solvers",
    "href": "solvers/index.html#time-domain-solvers",
    "title": "Sdof solvers",
    "section": "",
    "text": "The package provides a set of solvers to compute the time response of a single-degree-of-freedom (sdof) system.\n\n\nThe free response of a sdof system is the response of the system when it is subjected to initial conditions only. This means that the displacement of the mass is solution of the following ordinary differential equation: \\[\n\\begin{cases}\n  \\ddot x(t) + 2 \\xi\\omega_0\\dot x(t) + \\omega_0^2 x(t) = 0 \\\\\n  x(0) = x_0 \\\\\n  \\dot x(0) = v_0\n\\end{cases}.\n\\]\nDepending on the value of the damping ratio \\(\\xi\\) and \\(\\omega_0 &gt; 0\\), the system can have 4 different types of free response:\n\nan undamped motion when \\(\\xi = 0\\). In this case, the free response is: \\[\nx(t) = x_0\\cos\\omega_0 t + \\frac{v_0}{\\omega_0}\\sin\\omega_0 t\n\\]\nan underdamped motion when \\(0 &lt; \\xi &lt; 1\\). In this case, the free response is: \\[\nx(t) = \\left[x_0\\cos\\Omega_0 t + \\frac{v_0 + \\xi\\Omega_0 x_0}{\\Omega_0}\\sin\\Omega_0 t\\right]e^{-\\xi\\omega_0 t}\n\\] where \\(\\Omega_0 = \\omega_0\\sqrt{1 - \\xi^2}\\).\na critically damped motion when \\(\\xi = 1\\). In this case, the free response is: \\[\nx(t) = \\left[x_0 + (v_0 + \\omega_0 x_0)t\\right]e^{-\\omega_0 t}\n\\]\nan overdamped motion when \\(\\xi &gt; 1\\). In this case, the free response is: \\[\nx(t) = \\left[x_0\\text{cosh}(\\beta t) + \\frac{v_0 + \\xi\\omega_0 x_0}{\\beta}\\text{sinh}\\beta t\\right]e^{-\\xi\\omega_0 t},\n\\] where \\(\\beta = \\omega_0\\sqrt{\\xi^2 - 1}\\).\n\nFinally, if \\(\\omega = 0\\), the mass is free from constraints and the free response is: \\[\nx(t) = x_0 + v_0 t.\n\\]\n\n\nData type\n\nSdofFreeTimeProblem\n\n\n\nSdofFreeTimeProblem(sdof, u0, t)\nStructure containing the data of a time problem for a sdof system\nFields\n\nsdof::Sdof: Sdof structure\n\nu0::AbstractVector: Initial conditions\n\nx0: Initial displacement [m]\n\nv0: Initial velocity [m/s]\n\n\n\nt::AbstractRange: Time points at which to evaluate the response\n\n\n\n\n\n\n\n\nRelated function\n\nsolve\n\n\n\nsolve(prob::SdofFreeTimeProblem)\nCompute the free response of a single degree of freedom (Sdof) system.\nInput\n\nprob: Structure containing the parameters of the Sdof problem\n\n\nOutput\n\nsol: The response of the system at the given time points\n\nu: Displacement solution\n\ndu: Velocity solution\n\nddu: Acceleration solution\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Structural parameters\nm = 1.\nf0 = 1.\n\n# Time vector\nt = 0.:0.01:10.\n\n# Initial conditions\nu0 = [1., -2.]\n\n# Undamped system\nsdof_nd = Sdof(m, f0, 0.)\nprob_nd = SdofFreeTimeProblem(sdof_nd, u0, t)\nx_nd = solve(prob_nd).u\n\n# Underdamped system\nsdof_ud = Sdof(m, f0, 0.1)\nprob_ud = SdofFreeTimeProblem(sdof_ud, u0, t)\nx_ud = solve(prob_ud).u\n\n# Critically damped system\nsdof_cd = Sdof(m, f0, 1.)\nprob_cd = SdofFreeTimeProblem(sdof_cd, u0, t)\nx_cd = solve(prob_cd).u\n\n# Overdamped system\nsdof_od = Sdof(m, f0, 1.2)\nprob_od = SdofFreeTimeProblem(sdof_od, u0, t)\nx_od = solve(prob_od).u;\n\n\n\n\n\n\n\n\n\n\nThe forced response of a sdof system is the response of the system is the solution of the following ordinary differential equation: \\[\n\\begin{cases}\n  \\ddot x(t) + 2 \\xi\\omega_0\\dot x(t) + \\omega_0^2 x(t) = \\displaystyle\\frac{\\text{rhs}(t)}{m} \\\\\n  x(0) = x_0 \\\\\n  \\dot x(0) = v_0\n\\end{cases},\n\\] where \\(\\text{rhs}(t)\\) is the right-hand side of the equation and its expression depends on the type of excitation: \\[\n\\text{rhs}(t) = \\begin{cases}\nf(t) & \\text{for an external force excitation} \\\\\nm\\omega_0^2 x_b(t) + 2\\xi\\omega_0m\\dot x_b(t) & \\text{for a base excitation}\n\\end{cases}.\n\\]\nFinally, the solution of the forced response is expressed as the sum of two terms, since: \\[\nx(t) = x_h(t) + x_p(t),\n\\] where \\(x_h(t)\\) is the homogeneous solution of the equation and \\(x_p(t)\\) is the particular solution of the equation.\n\n\nWhen the excitation is harmonic, the resolution process is the following:\n\nCompute the particular solution of the equation. The particular solution is a harmonic function of the same frequency as the excitation.\nExpress the general solution of the homogeneous equation.\nCompute the remaining constants using the initial conditions. These constants depends on \\(x_p(0)\\) and \\(\\dot x_p(0)\\).\n\n\n\nData type\n\nSdofHarmonicTimeProblem\n\n\n\nSdofHarmonicTimeProblem(sdof, u0, t, F, ω, type_exc)\nStructure containing the data of a time problem for a sdof system subject to a harmonic excitation\nConstructor parameters\n\nsdof::Sdof: Sdof structure\n\nF: Amplitude of the force excitation [N] or base motion [m]\n\nf: Frequency of the excitation [Hz]\n\nu0::AbstractVector: Initial conditions\n\nx0: Initial displacement [m]\n\nv0: Initial velocity [m/s]\n\n\n\nt::AbstractRange: Time points at which to evaluate the response\n\ntype_exc::Symbol: Type of excitation\n\n:force: External force (default)\n\n:base: Base motion\n\n\n\n\nFields\n\nsdof::Sdof: Sdof structure\n\nF: Amplitude of the force excitation [N] or base motion [m]\n\nω: Frequency of the excitation [rad/s]\n\nu0::AbstractVector: Initial conditions\n\nx0: Initial displacement [m]\n\nv0: Initial velocity [m/s]\n\n\n\nt::AbstractRange: Time points at which to evaluate the response\n\ntype_exc::Symbol: Type of excitation\n\n:force: External force (default)\n\n:base: Base motion\n\n\n\n\n\n\n\n\n\n\nRelated function\n\nsolve\n\n\n\nsolve(prob::SdofHarmonicTimeProblem)\nComputes the forced response of a single degree of freedom (Sdof) system due to an harmonic external force or base motion\nInputs\n\nprob: Structure containing the parameters of the Sdof harmonic problem\n\n\nOutput\n\nsol: The response of the system at the given time points\n\nu: Displacement solution\n\ndu: Velocity solution\n\nddu: Acceleration solution\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Structural parameters\nm = 1.\nf0 = 1.\nξ = 0.1\n\n# Instantiation of the Sdof object\nsdof = Sdof(m, f0, ξ)\n\n# Harmonic excitation - Force amplitude + excitation frequency\nF0 = 10.\nf = 2.\n\n# Instantiation of the problem\nt = 0.:0.01:10.\nu0 = [1., -2.]\nprob = SdofHarmonicTimeProblem(sdof, u0, t, F0, f, :force)\n\n# Solve the problem\nx_harmo = solve(prob).u\n\n\n\n\n\n\n\n\n\n\nFor an arbitrary excitation, the solution is given by: \\[\nx(t) = x_\\text{free}(t) + \\int_0^t rhs(t - τ)h(τ)dτ,\n\\] where \\(x_\\text{free}(t)\\) is the free response of the system and \\(h(t)\\) is the impulse response of the system.\n\n\nData type\n\nSdofForcedTimeProblem\n\n\n\nSdofForcedTimeProblem(sdof, u0, t, F, ω, type_exc)\nStructure containing the data of a time problem for a sdof system subject to an arbitrary excitation\nFields\n\nsdof::Sdof: Sdof structure\n\nF::AbstractVector: Amplitude of the force excitation [N] or base motion [m]\n\nu0::AbstractVector: Initial conditions\n\nx0: Initial displacement [m]\n\nv0: Initial velocity [m/s]\n\n\n\nt::AbstractRange: Time points at which to evaluate the response\n\ntype_exc::Symbol: Type of excitation\n\n:force: External force (default)\n\n:base: Base motion\n\n\n\n\n\n\n\n\n\n\nRelated function\n\nsolve\n\n\n\nsolve(prob::SdofForcedTimeProblem)\nComputes the forced response of a single degree of freedom (Sdof) system due to an arbitrary external force or base motion\nInputs\n\nprob: Structure containing the parameters of the Sdof forced problem\n\nmethod: Method to compute the Duhamel's integral\n\n:filt: Filtering using the Z-transform of the impulse response (default)\n\n:interp: Interpolation + Gaussian quadrature\n\n:conv: Convolution product\n\n\n\n\nOutput\n\nsol: The response of the system at the given time points\n\nu: Displacement solution\n\ndu: Velocity solution\n\nddu: Acceleration solution\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Structural parameters\nm = 1.\nf0 = 1.\nξ = 0.1\n\n# Instantiation of the Sdof object\nsdof = Sdof(m, f0, ξ)\n\n# Haversine excitation signal\nF0 = 10.\ntstart = 0.5\nduration = 2.\nhaversine = HaverSine(F0, tstart, duration)\n\nt = 0.:0.01:10.\nF = excitation(haversine, t)\n\n# Instantiation of the problem\nu0 = [1, -2]\nprob = SdofForcedTimeProblem(sdof, u0, t, F, :force)\n\n# Solve the problem\nx_arb_filt = solve(prob, method = :filt).u\nx_arb_interp = solve(prob, method = :interp).u\nx_arb_conv = solve(prob, method = :conv).u;\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe impulse response of a sdof system is the response of the system when it is subjected to an impulse excitation. The impulse response is the solution of the following ordinary differential equation: \\[\n\\overset{..}{h}(t) + 2\\xi\\omega_0\\overset{.}{h}(t) + \\omega_0^2 h(t) = \\frac{\\delta(t)}{m}.\n\\]\nIt can be shown that the impulse response can be computed by solving the following problem: \\[\n\\begin{cases}\n\\overset{..}{h}(t) + 2\\xi\\omega_0\\overset{.}{h}(t) + \\omega_0^2 h(t) = 0 & \\forall t &gt; 0 \\\\\nh(t) = 0 & \\text{at } t = 0 \\\\\n\\overset{.}{h}(t) = \\displaystyle\\frac{1}{m} & \\text{at } t = 0\n\\end{cases}.\n\\]\n\nimpulse_response\n\n\n\nimpulse_response(sdof, t)\nCompute the impulse response of a single degree of freedom (Sdof) system\nInputs\n\nsdof: Sdof structure\n\nt: Time points at which to evaluate the response\n\n\nOutput\n\nh: Impulse response\n\n\n\n\n\n\n\n\n\n# Structural parameters\nm = 1.\nf0 = 1.\nξ = 0.1\n\nt = 0.:0.01:10.\n\n# Instantiation of the Sdof object\nsdof = Sdof(m, f0, ξ)\n\nh = impulse_response(sdof, t)\n\n\n\n\n\n\n\n\n\nThe shock response spectrum (SRS) is a graph of the peak acceleration response of a sdof system subjected to a base acceleration with respect to the frequency. The SRS is computed by solving the following problem: \\[\n\\ddot z(t) + 2\\xi\\omega_0\\dot z(t) + \\omega_0^2 z(t) = -\\ddot x_b(t),\n\\] where \\(z(t) = x(t) - x_b(t)\\) is the relative displacement of the system with respect to the base.\nTo compute the SRS, the following steps are performed at a given frequency \\(f\\):\n\nInstantiate a Sdof type\nsdof = Sdof(1., f, ξ)\nCompute the time response of the relative displacement \\(z(t)\\) due to a base acceleration for \\(z(0) = 0\\) and \\(\\dot z(0) = 0\\).\nCompute the acceleration \\(\\ddot x(t)\\) of the system: \\[\nx(t) = -2\\xi\\omega_0\\dot z(t) - \\omega_0^2 z(t)\n\\]\nExtract the primary or secondary part of the acceleration (i.e. until or after the end of the excitation signal).\nCompute either:\n\nThe peak acceleration of the system such that: \\[\nSRS(f) = \\max\\left(|\\ddot x(t)|\\right)\n\\]\nThe maximum positive acceleration of the system such that: \\[\nSRS(f) = \\max\\left(\\max(\\ddot x(t), 0)\\right)\n\\]\nThe maximum negative acceleration of the system such that: \\[\nSRS(f) = \\max\\left(\\max(-\\ddot x(t), 0)\\right)\n\\]\n\n\nSeveral algorithms are available to compute the SRS:\n\n:Basic: the SRS is computed by following the steps mentioned above. It is not the most efficient algorithm but it is the most versatile.\n:RecursiveInt: the SRS is computed using a recursive integration algorithm.\n:RecursiveFilt: the SRS is computed using a recursive filtering algorithm.\n:Smallwood: the SRS is computed using the Smallwood algorithm.\n\nFor the last three algorithms, more details and references can be found Mathworks - Introduction to SRS\n\nsrs\n\n\n\nsrs(base_acc::ArbitraryExc, freq, t, ξ = 0.05,\n    type = (instance = :primary, amplitude = :abs), alg = :Smallwood)\nCompute the Shock Response Spectrum (SRS)\nInputs\n\nbase_acc::ArbitraryExc: Base acceleration type - see excitation function for detatils\n\nfreq: Vector of frequencies [Hz]\n\nt: Time points at which to evaluate the response\n\nξ: Damping ratio (default = 0.05)\n\ntype: Type of SRS\n\ninstance: Instance of the SRS\n\n:primary: Primary instance (default)\n\n:secondary: Secondary instance\n\n\n\namplitude: Amplitude used of the computing SRS\n\n:abs: Maximum absolute amplitude (default)\n\n:pos: Maximum positive amplitude\n\n:neg: Maximum negative amplitude\n\n\n\n\n\nalg: Algorithm to compute the SRS\n\n:Basic: Basic algorithm\n\n:RecursiveInt: Recursive integration algorithm\n\n:RecursiveFilt: Recursive filtering algorithm\n\n:Smallwood: Smallwood algorithm (default)\n\n\n\n\nOutput\n\nsrs: Vector of the SRS values\n\n\nNote\n\nPrimary instance - response of the system during the application of the base acceleration\n\nSecondary instance - response of the system after the application of the base acceleration\n\n\n\n\n\n\n\n\n\n# Definition of the base acceleration\nt = 0.:1e-5:0.5\nbase_acc = HalfSine(10., 0., 1e-3)\n\n# Compute the SRS\nf = 50.:25:1e3\nsrs_basic = srs(base_acc, f, t)\nsrs_rec_int = srs(base_acc, f, t, alg = :RecursiveInt)\nsrs_rec_filt = srs(base_acc, f, t, alg = :RecursiveFilt)\nsrs_smallwood = srs(base_acc, f, t, alg = :Smallwood)",
    "crumbs": [
      "Solvers",
      "Sdof solvers"
    ]
  },
  {
    "objectID": "solvers/index.html#frequency-domain-solvers",
    "href": "solvers/index.html#frequency-domain-solvers",
    "title": "Sdof solvers",
    "section": "2 Frequency domain solvers",
    "text": "2 Frequency domain solvers\nThe package provides solvers for computing the Frequency Response Function (FRF) and the response spectrum of a sdof system.\n\n2.1 Frequency Response Function\nThe Frequency Response Function (FRF) of a sdof system is the ratio of the steady-state response \\(X(\\omega)\\) of the system to an external excitation \\(F(\\omega)\\) or an external base motion \\(X_b(\\omega)\\). The FRF is computed from the following equation: \\[\nH(\\omega) = \\begin{cases}\n\\displaystyle\\frac{1}{m(\\omega_0^2 - \\omega^2 + 2j\\xi\\omega\\omega_0)} & \\text{for a force excitation} \\\\\n\\displaystyle\\frac{\\omega_0^2 + 2j\\xi\\omega\\omega_0}{\\omega_0^2 - \\omega^2 + 2j\\xi\\omega\\omega_0} & \\text{for a base excitation}\n\\end{cases},\n\\] where \\(j\\) is the imaginary unit.\n\n2.1.1 API\nData type\n\nSdofFRFProblem\n\n\n\nSdofFRFProblem(sdof, freq, type_exc, type_resp)\nStructure containing the data for computing the FRF a sdof system\nFields\n\nsdof::Sdof: Sdof structure\n\nfreq::AbstractRange: Vector of frequencies [Hz]\n\ntype_exc::Symbol: Type of excitation\n\n:force: External force (default)\n\n:base: Base motion\n\n\n\ntype_resp::Symbol: Type of response\n\n:dis: Admittance (default)\n\n:vel: Mobility\n\n:acc: Accelerance\n\n\n\n\n\n\n\n\n\n\nRelated function\n\nsolve\n\n\n\nsolve(prob::SdofFRFProblem)\nCompute the FRF of a single degree of freedom (Sdof) system\nInputs\n\nprob: Structure containing the parameters of the Sdof FRF problem\n\n\nOutput\n\nsol: Solution of the FRF problem\n\nu: FRF of the system\n\n\n\n\n\n\n\n\n\n\n\n\n2.1.2 Example\n\n# Structural parameters\nm = 1.\nf0 = 10.\nξ = 0.01\n\n# Instantiation of the Sdof object\nsdof = Sdof(m, f0, ξ)\n\n# Definition of the frequency range\nf = 1.:0.1:30.\n\n# Instantiation of the problem - Force excitation\nprob = SdofFRFProblem(sdof, f)\n\n# Solve the problem\nH = solve(prob).u\n\n\n\n\n\n\n\n\n\n2.2 Response spectrum\nThe response spectrum of a sdof system is the frequency response of the system to an external force \\(F(\\omega)\\) or a base motion \\(X_b(\\omega)\\) with respect to the frequency. The response spectrum \\(Y(\\omega)\\) is computed from the following equation: \\[\nY(\\omega) = \\begin{cases}\n\\displaystyle\\frac{F(\\omega)}{m(\\omega_0^2 - \\omega^2 + 2j\\xi\\omega\\omega_0)} & \\text{for a force excitation} \\\\\n\\displaystyle\\frac{(\\omega_0^2 + 2j\\xi\\omega\\omega_0) X_b(\\omega)}{\\omega_0^2 - \\omega^2 + 2j\\xi\\omega\\omega_0} & \\text{for a base excitation}\n\\end{cases}.\n\\]\n\n2.2.1 API\nData type\n\nSdofFRFProblem\n\n\n\nSdofFrequencyProblem(sdof, F, type_exc, type_resp)\nStructure containing the data for computing the frequency response of a sdof system\nFields\n\nsdof::Sdof: Sdof structure\n\nfreq::AbstractRange: Vector of frequencies [Hz]\n\nF::AbstractVector: Vector of the force excitation [N] or base motion [m]\n\ntype_exc::Symbol: Type of excitation\n\n:force: External force (default)\n\n:base: Base motion\n\n\n\ntype_resp::Symbol: Type of response\n\n:dis: Displacement spectrum(default)\n\n:vel: Velocity spectrum\n\n:acc: Acceleration spectrum\n\n\n\n\n\n\n\n\n\n\nRelated function\n\nsolve\n\n\n\nsolve(prob::SdofFRFProblem)\nCompute the FRF of a single degree of freedom (Sdof) system\nInputs\n\nprob: Structure containing the parameters of the Sdof FRF problem\n\n\nOutput\n\nsol: Solution of the FRF problem\n\nu: FRF of the system\n\n\n\n\n\n\n\n\n\n\n\n\n2.2.2 Example\n\n# Structural parameters\nm = 1.\nf0 = 10.\nξ = 0.01\n\n# Instantiation of the Sdof object\nsdof = Sdof(m, f0, ξ)\n\n# Definition of the frequency range\nf = 1.:0.1:30.\n\n# Instantiation of the problem - Force excitation\nF = fill(10., length(f))\nprob = SdofFrequencyProblem(sdof, f, F)\n\n# Solve the problem\ny = solve(prob).u",
    "crumbs": [
      "Solvers",
      "Sdof solvers"
    ]
  },
  {
    "objectID": "models/excitation.html",
    "href": "models/excitation.html",
    "title": "Excitation models",
    "section": "",
    "text": "To define an excitation, two steps must be followed:\n\nInitialize an excitation type:\nexc_type = MyExcitation(params...)\nCompute the excitation signal corresponding to the given excitation type over a given duration t (See Section 2 for details):\nF = excitation(exc_type, t)\n\n\n\nThe rectangular signal is defined by the following equation: \\[\nF(t) = \\begin{cases}\nF_0 & \\text{if } t \\in [t_\\text{start}, t_\\text{start} + T] \\\\\n0 & \\text{otherwise}\n\\end{cases},\n\\] where \\(F_0\\) is the amplitude of the signal, \\(t_\\text{start}\\) is the start time of the signal, and \\(T\\) is the duration of the signal.\n\nRectangle\n\n\n\nRectangle(F, tstart, duration)\nStruct to define a rectangular excitation signal\nFields\n\nF::Real: Amplitude of the force [N]\n\ntstart::Real: Starting time of the excitation [s]\n\nduration::Real: Duration of the excitation [s]\n\n\n\n\n\n\n\n\n\n# Time parameters\nΔt = 1e-3\nt = 0.:Δt:10.\n\n# Excitation parameters\nF0 = 1.\ntstart = 2.5\nduration = 5.\n\n# Initialize Rectangle type\nrect = Rectangle(F0, tstart, duration)\n\n# Compute the excitation\nF_rect = excitation(rect, t)\n\n\n\n\n\n\n\n\n\nThe triangle signal is defined by the following equation: \\[\nF(t) = \\begin{cases}\n\\frac{2F_0}{T}\\left(t - t_\\text{start}\\right) & \\text{if } t \\in [t_\\text{start}, t_m] \\\\\nF_0 - \\frac{2F_0}{T}(t - t_m) & \\text{if } t \\in [t_m, t_\\text{start} + T] \\\\\n0 & \\text{otherwise}\n\\end{cases},\n\\] where \\(F_0\\) is the amplitude of the signal, \\(t_\\text{start}\\) is the start time of the signal, \\(T\\) is the duration of the signal and \\(t_m = t_\\text{start} + T/2\\) is the time at which the signal reaches its maximum value.\n\nTriangle\n\n\n\nTriangle(F, tstart, duration)\nStruct to define a triangular excitation signal\nFields\n\nF::Real: Amplitude of the force [N]\n\ntstart::Real: Starting time of the excitation [s]\n\nduration::Real: Duration of the excitation [s]\n\n\n\n\n\n\n\n\n\n# Time parameters\nΔt = 1e-3\nt = 0.:Δt:10.\n\n# Excitation parameters\nF0 = 1.\ntstart = 2.5\nduration = 5.\n\n# Initialize Triangle type\ntri = Triangle(F0, tstart, duration)\n\n# Compute the excitation\nF_tri = excitation(tri, t)\n\n\n\n\n\n\n\n\n\nThe hammer impact signal is supposed to have the shape of a Gamma distribution \\[\nF(t) = \\begin{cases}\nF_0\\left(\\frac{t_h}{p\\theta}\\right)^p \\text{exp}\\left(-\\frac{t_h}{\\theta} + p\\right), & \\text{if } t \\geq t_\\text{start} \\\\\n0, & \\text{otherwise}\n\\end{cases},\n\\] where \\(F_0\\) is the amplitude of the signal, \\(t_h = t - t_\\text{start}\\) is the time since the impact, \\(p\\) is the shape parameter, and \\(\\theta\\) is the scale parameter.\n\nHammer\n\n\n\nHammer(F, tstart, k, θ)\nStruct to define a hammer impact excitation signal\nFields\n\nF::Real: Amplitude of the force [N]\n\ntstart::Real: Starting time of the excitation [s]\n\np::Real: Shape parameter\n\nθ::Real: Intensity parameter [s]\n\n\n\n\n\n\n\n\n\n# Time parameters\nΔt = 1e-5\nt = 0.:Δt:0.05\n\n# Excitation parameters\nF0 = 1.\ntstart = 0.01\nk = 9.7\nθ = 6e-4\n\n# Initialize Hammer type\nhammer = Hammer(F0, tstart, k, θ)\n\n# Compute the excitation\nF_hammer = excitation(hammer, t)\n\n\n\n\n\n\n\n\n\nThe smooth rectangular signal (custom Tukey window) is defined by the following equation: \\[\nF(t) = \\begin{cases}\n\\frac{F_0}{2}\\left[1 - \\cos\\left(\\frac{2\\pi (t - t_\\text{start})}{\\alpha T}\\right)\\right] & \\text{if } t \\in [t_\\text{start}, t_\\text{start} + t_\\text{rise}] \\\\\nF_0 & \\text{if } t \\in [t_\\text{start} + t_\\text{rise}, t_\\text{start} + t_\\text{rise} + T_\\text{rect}] \\\\\n\\frac{F_0}{2}\\left[1 - \\cos\\left(\\frac{2\\pi (t - t_\\text{start} - t_\\text{rise} - T_\\text{rect})}{\\alpha T}\\right)\\right] & \\text{if } t \\in [t_\\text{start} + t_\\text{rise} + T_\\text{rect}, t_\\text{start} + T] \\\\\n\\end{cases},\n\\] where \\(F_0\\) is the amplitude of the signal, \\(t_\\text{start}\\) is the start time of the signal, \\(T\\) is the duration of the signal, \\(t_\\text{rise}\\) is the duration to reach \\(F_0\\) and \\(\\alpha = \\frac{2t_\\text{rise}}{T}\\) and \\(T_\\text{rect} = T - 2t_\\text{rise}\\) is the duration of the rectangular part of the signal.\n\nSmoothRect\n\n\n\nSmoothRect(F, tstart, tr, duration)\nStruct to define a smooth rectangular excitation signal\nFields\n\nF::Real: Amplitude of the force [N]\n\ntstart::Real: Starting time of the excitation [s]\n\nduration::Real: Duration of the excitation [s]\n\ntrise::Real: Rise time from 0 to F [s]\n\n\nNote: SmoothRect is actually a custom Tukey window for which the coefficient α is computed to satisfy the trise given by the user\n\n\n\n\n\n\n\n# Time parameters\nΔt = 1e-3\nt = 0.:Δt:10.\n\n# Excitation parameters\nF0 = 1.\ntstart = 2.5\nduration = 5.\ntrise = 1.\n\n# Initialize SmoothRect type\nsrect = SmoothRect(F0, tstart, duration, trise)\n\n# Compute the excitation\nF_srect = excitation(srect, t)\n\n\n\n\n\n\n\n\n\nThe sine signal is defined by the following equation: \\[\nF(t) = \\begin{cases}\nF_0 \\sin\\left(\\omega (t - t_\\text{start}) + \\theta\\right), & \\text{if } t \\in [t_\\text{start}, t_\\text{start} + T] \\\\\n0, & \\text{otherwise}\n\\end{cases},\n\\] where \\(F_0\\) is the amplitude of the signal, \\(\\omega\\) is the angular frequency of the signal, and \\(\\theta\\) is the phase of the signal.\n\n\n\n\n\n\nZero-end signal\n\n\n\n\n\nSometimes it is necessary to have a signal that ends at zero. In this case, the duration of the signal must be adjusted to ensure that the signal ends at zero. To do so, one have to find the smallest integer \\(n\\) such that at \\(t = t_\\text{start} + T\\): \\[\n\\sin(\\omega T + \\theta) = 0 \\Rightarrow \\omega T + \\theta = 2\\pi n \\Rightarrow n = \\frac{\\omega T + \\theta}{2\\pi}.\n\\]\nOnce \\(n\\) is found, the duration of the signal must be adjusted to: \\[\nT_\\text{new} = \\frac{2\\pi n - \\theta}{\\omega}.\n\\]\n\n\n\n\nSineWave\n\n\n\nSineWave(F, tstart, duration, freq; zero_end = true)\nStruct to define a sine wave excitation signal\nConstructor parameters\n\nF::Real: Amplitude of the force [N]\n\ntstart::Real: Starting time of the excitation [s]\n\nduration::Real: Duration of the excitation [s]\n\nfreq::Real: Frequency of the excitation [Hz]\n\nzero_end::Bool: Boolean to set the excitation to 0 at the end of the duration (default = true)\n\n\nFields\n\nF::Real: Amplitude of the force [N]\n\ntstart::Real: Starting time of the excitation [s]\n\nduration::Real: Duration of the excitation [s]\n\nω::Real: Frequency of the excitation [Hz]\n\nzero_end::Bool: Boolean to set the excitation to 0 at the end of the duration (default = true)\n\n\n\n\n\n\n\n\n\n# Time parameters\nΔt = 1e-3\nt = 0.:Δt:10.\n\n# Excitation parameters\nF0 = 1.\ntstart = 2.5\nduration = 5.\nf = 2.\n\n# Initialize HaverSine type\nsine = SineWave(F0, tstart, duration, f, zero_end = true)\n\n# Compute the excitation\nF_sine = excitation(sine, t)\n\n\n\n\n\n\n\n\n\nThe half-sine signal is defined by the following equation: \\[\nF(t) = \\begin{cases}\nF_0 \\sin(\\frac{\\pi (t - t_\\text{start}}{T}) & \\text{if } t \\in [t_\\text{start}, t_\\text{start} + T] \\\\\n0 & \\text{otherwise}\n\\end{cases},\n\\] where \\(F_0\\) is the amplitude of the signal, \\(t_\\text{start}\\) is the start time of the signal, and \\(T\\) is the duration of the signal.\n\nHalfSine\n\n\n\nHalfSine(F, tstart, duration)\nStruct to define a half sine excitation signal\nFields\n\nF::Real: Amplitude of the force [N]\n\ntstart::Real: Starting time of the excitation [s]\n\nduration::Real: Duration of the excitation [s]\n\n\n\n\n\n\n\n\n\n# Time parameters\nΔt = 1e-3\nt = 0.:Δt:10.\n\n# Excitation parameters\nF0 = 1.\ntstart = 2.5\nduration = 5.\n\n# Initialize HalfSine type\nhsine = HalfSine(F0, tstart, duration)\n\n# Compute the excitation\nF_hsine = excitation(hsine, t)\n\n\n\n\n\n\n\n\n\nThe haversine (or versed sine) signal is defined by the following equation: \\[\nF(t) = \\begin{cases}\nF_0\\left(1 - cos(\\frac{2\\pi t}{T}\\right) & \\text{if } t \\in [t_\\text{start}, t_\\text{start} + T] \\\\\n0 & \\text{otherwise}\n\\end{cases},\n\\] where \\(F_0\\) is the amplitude of the signal, \\(t_\\text{start}\\) is the start time of the signal, and \\(T\\) is the duration of the signal.\n\nHaverSine\n\n\n\nHaverSine(F, tstart, duration)\nStruct to define a Haversine (or versed sine) excitation signal\nFields\n\nF::Real: Amplitude of the force [N]\n\ntstart::Real: Starting time of the excitation [s]\n\nduration::Real: Duration of the excitation [s]\n\n\n\n\n\n\n\n\n\n# Time parameters\nΔt = 1e-3\nt = 0.:Δt:10.\n\n# Excitation parameters\nF0 = 1.\ntstart = 2.5\nduration = 5.\n\n# Initialize HaverSine type\nhaversine = HaverSine(F0, tstart, duration)\n\n# Compute the excitation\nF_haversine = excitation(haversine, t)\n\n\n\n\n\n\n\n\n\nThe swept sine signal is defined by the following equation: \\[\nF(t) = \\begin{cases}\nF_0 \\sin(\\theta(t)) & \\text{if } t \\in [t_\\text{start}, t_\\text{start} + T] \\\\\n0 & \\text{otherwise}\n\\end{cases},\n\\] where \\(F_0\\) is the amplitude of the signal, \\(t_\\text{start}\\) is the start time of the signal, \\(T\\) is the duration of the signal and \\(\\theta(t)\\) is the instantaneous phase.\nThe instantaneous phase is given by: \\[\n\\theta(t) = \\theta_0 + 2\\pi\\int_0^t f(\\tau) d\\tau,\n\\] where \\(f(\\tau)\\) is the instantaneous frequency of the signal at time \\(\\tau\\) and \\(\\theta_0\\) is the initial phase (set to 0 here).\nIn this package, three possible types of swept sine signals are available:\n\nLinear swept sine: \\[\nf(t) = f_\\text{start} + \\beta(t - t_\\text{start}) \\Rightarrow \\theta(t) = 2\\pi\\left(f_\\text{start}(t - t_\\text{start}) + \\frac{\\beta (t - t_\\text{start})^2}{2}\\right),\n\\] where:\n\n\\(\\beta = \\frac{f_\\text{end} - f_\\text{start}}{T}\\)\n\\(f_\\text{start}\\): Initial frequency of the signal at \\(t_\\text{start}\\)\n\\(f_\\text{end}\\): Final frequency of the signal at \\(t_\\text{start} + T\\)\n\nQuadratic swept sine: \\[\nf(t) = f_\\text{start} + \\beta (t - t_\\text{start})^2 \\Rightarrow \\theta(t) = 2\\pi\\left(f_\\text{start}(t - t_\\text{start}) + \\frac{\\beta (t - t_\\text{start})^3}{3}\\right),\n\\] where \\(\\beta = \\frac{f_\\text{end} - f_\\text{start}}{T^2}\\).\nLogarithmic swept sine: \\[\nf(t) = f_\\text{start}\\beta^{t - t_\\text{start}} \\Rightarrow \\theta(t) = \\frac{2\\pi f_\\text{start}}{\\log(\\beta)}\\left(\\beta^{t - t_\\text{start}} - 1\\right),\n\\] where \\(\\beta = \\left(\\frac{f_\\text{end}}{f_\\text{start}}\\right)^{1/T}\\).\n\n\n\n\n\n\n\nZero-end signal\n\n\n\n\n\nSimilarly to the sine signal, the duration of the signal must be adjusted to ensure that the signal ends at zero. To do so, one have to find the smallest integer \\(n\\) such that at \\(t = t_\\text{start} + T\\): \\[\n  \\theta(t) = 2\\pi n.\n\\]\nIn doing so, we have for:\n\nLinear swept sine: \\[\nn = (f_\\text{start} + f_\\text{end})\\frac{T}{2} \\Rightarrow T_\\text{new} = \\frac{2n}{f_\\text{start} + f_\\text{end}}.\n\\]\nQuadratic swept sine: \\[\nn = (2f_\\text{start} + f_\\text{end})\\frac{T}{3} \\Rightarrow T_\\text{new} = \\frac{3n}{2f_\\text{start} + f_\\text{end}}.\n\\]\nLogarithmic swept sine: \\[\nn = \\frac{f_\\text{end} - f_\\text{start}}{\\log(f_\\text{end}/f_\\text{start})}T \\Rightarrow T_\\text{new} = \\frac{n\\log(f_\\text{end}/f_\\text{start})}{f_\\text{end} - f_\\text{start}}.\n\\]\n\n\n\n\n\nSweptSine\n\n\n\nSweptSine(F, tstart, duration, fstart, fend, type)\nStruct to define a swept sine excitation signal\nFields\n\nF::Real: Amplitude of the force [N]\n\ntstart::Real: Starting time of the excitation [s]\n\nduration::Real: Duration of the excitation [s]\n\nfstart::Real: Starting frequency [Hz]\n\nfend::Real: Ending frequency [Hz]\n\ntype::Symbol: Type of sweep\n\n:lin - linear (default)\n\n:quad - quadratic\n\n:log - logarithmic\n\n\n\nzero_end::Bool: Boolean to set the excitation to 0 at the end of the duration (default = true)\n\n\n\n\n\n\n\n\n\n# Time parameters\nΔt = 1e-3\nt = 0.:Δt:10.\n\n# Excitation parameters\nF0 = 1.\ntstart = 2.5\nduration = 5.\nfstart = 1.\nfend = 6.\ntype_swept = :lin\n\n# Initialize SweptSine type\nchirp = SweptSine(F0, tstart, duration, fstart, fend, type_swept, zero_end = true)\n\n# Compute the excitation\nF_chirp = excitation(chirp, t)\n\n\n\n\n\n\n\n\n\nThe Gaussian pulse signal is defined by the following equation: \\[\nF(t) = \\begin{cases}\nF_0 \\exp\\left(-\\frac{t_p^2}{2\\sigma^2}\\right) \\cos(2\\pi f_c t_p), & \\text{if } t \\geq t_\\text{start} \\\\\n0, & \\text{otherwise}\n\\end{cases},\n\\] where \\(F_0\\) is the amplitude of the signal, \\(t_\\text{start}\\) is the start time of the signal, \\(\\sigma\\) is the standard deviation of the signal, and \\(f_c\\) is the carrier frequency. Here \\(t_p = t - t_\\text{start} - T/2\\) so that the Gaussian pulse reaches its maximum value at \\(t = t_\\text{start} + T/2\\).\n\n\n\n\n\n\nVariance calibration\n\n\n\n\n\nThe design of the Gaussian pulse assumes that it tends to zero when \\(t = t_\\text{start} + T\\). This requirement implies that the standard deviation \\(\\sigma\\) must be chosen such that the Gaussian pulse is zero at \\(t = t_\\text{start} + T\\). This condition can only be satisfied within some precision. More precisely, the idea is to find the quantile \\(n\\) such that \\(T = n\\sigma\\). Consequently, if we assume that \\(F(t_\\text{start} + T) = 10^{-p}\\) (with \\(p\\) a given precision), we have: \\[\nn = 2\\sqrt{2(p\\log 10 + \\log F_0)} \\Rightarrow \\sigma = \\frac{T}{n}.\n\\]\n\n\n\n\nGaussianPulse\n\n\n\nGaussianPulse(F, tstart, duration, fc)\nStruct to define a Gaussian pulse excitation signal\nFields\n\nF::Real: Amplitude of the force [N]\n\ntstart::Real: Starting time of the excitation [s]\n\nduration::Real: Duration of the excitation [s]\n\nfc::Real: Center frequency of the pulse [Hz]\n\nprecision::Real: Precision of the pulse (default = 4.)\n\n\nNote\nThe precision parameter calibrates the standard deviation of the pulse, so that the duration = n x σ, within some precision. If n = 1.96 then the confidence interval of the Gaussian distribution is 95%. To do so, we compute n so that at t = duration = n x σ , the amplitude of F x exp(-0.5*(t - duration/2)^2/sigma^2) = 10^(-precision)\n\n\n\n\n\n\n\n# Time parameters\nΔt = 1e-3\nt = 0.:Δt:10.\n\n# Excitation parameters\nF0 = 1.\ntstart = 2.5\nduration = 5.\nfc = 2.\n\n# Initialize GaussianPulse type\ngpulse = GaussianPulse(F0, tstart, duration, fc)\n\n# Compute the excitation\nF_gpulse = excitation(gpulse, t)\n\n\n\n\n\n\n\n\n\nColored noise is a random signal that has a power spectral density that is not (necessarily) flat over a given frequency range. In practice, colored noise is also refered to as “power-law noise” since its power spectral density is proportional to \\(f^{-\\alpha}\\) (\\(f\\): frequency) and its spectrum is proportional to \\(f^{-\\alpha/2}\\).\nIn this package, five types of colored noise are available:\n\nWhite noise: \\(\\alpha = 0\\)\nPink noise: \\(\\alpha = 1\\)\nBlue noise: \\(\\alpha = -1\\)\nBrown noise: \\(\\alpha = 2\\)\nPurple noise: \\(\\alpha = -2\\)\n\nThe general procedure to generate a colored noise signal is as follows:\n\nGenerate a white noise signal and compute its FFT\nMultiply the FFT by \\(f^{-\\alpha/2}\\) to obtain the colored noise\nCompute the inverse FFT to obtain the colored noise signal\n\nAdditional steps can be added such as:\n\nNormalization: Ensure that the colored noise has the desired variance and preserves the energy of the white noise\nFiltering: Obtain a band-limited colored noise\n\n\nColoredNoise\n\n\n\nColoredNoise(F, color)\nStruct to define a colored noise excitation signal\nFields\n\nF::Real: Mean amplitude of the force [N]\n\ntstart::Real: Starting time of the excitation [s]\n\nduration::Real: Duration of the excitation [s]\n\nσ::Real: Target standard deviation of the colored noise\n\ncolor::Symbol: Color of the noise\n\n:white (default)\n\n:pink\n\n:blue\n\n:brown\n\n:purple\n\n\n\nfrange::AbstractVector: Frequencies used to defined the bandpass filter applied to the colored noise\n\n\n\n\n\n\n\n\n\n# Time parameters\nΔt = 1e-4\nt = 0.:Δt:10.\nnt = length(t)\nfs = 1/Δt\n\n# Excitation parameters\nF0 = 1.\ntstart = 0.\nduration = 10.\nσ = 1.\n\n# Initialize ColoredNoise type\nexc_white = ColoredNoise(F0, tstart, duration, σ, color = :white)\nexc_pink = ColoredNoise(F0, tstart, duration, σ, color = :pink)\nexc_blue = ColoredNoise(F0, tstart, duration, σ, color = :blue)\nexc_brown = ColoredNoise(F0, tstart, duration, σ, color = :brown)\nexc_purple = ColoredNoise(F0, tstart, duration, σ, color = :purple)\n\n# Compute the spectrum of the colored noise\nfreq = rfftfreq(nt, fs)\nS_white = rfft(excitation(exc_white, t))\nS_pink = rfft(excitation(exc_pink, t))\nS_blue = rfft(excitation(exc_blue, t))\nS_brown = rfft(excitation(exc_brown, t))\nS_purple = rfft(excitation(exc_purple, t))",
    "crumbs": [
      "Models",
      "Excitation models"
    ]
  },
  {
    "objectID": "models/excitation.html#available-models",
    "href": "models/excitation.html#available-models",
    "title": "Excitation models",
    "section": "",
    "text": "To define an excitation, two steps must be followed:\n\nInitialize an excitation type:\nexc_type = MyExcitation(params...)\nCompute the excitation signal corresponding to the given excitation type over a given duration t (See Section 2 for details):\nF = excitation(exc_type, t)\n\n\n\nThe rectangular signal is defined by the following equation: \\[\nF(t) = \\begin{cases}\nF_0 & \\text{if } t \\in [t_\\text{start}, t_\\text{start} + T] \\\\\n0 & \\text{otherwise}\n\\end{cases},\n\\] where \\(F_0\\) is the amplitude of the signal, \\(t_\\text{start}\\) is the start time of the signal, and \\(T\\) is the duration of the signal.\n\nRectangle\n\n\n\nRectangle(F, tstart, duration)\nStruct to define a rectangular excitation signal\nFields\n\nF::Real: Amplitude of the force [N]\n\ntstart::Real: Starting time of the excitation [s]\n\nduration::Real: Duration of the excitation [s]\n\n\n\n\n\n\n\n\n\n# Time parameters\nΔt = 1e-3\nt = 0.:Δt:10.\n\n# Excitation parameters\nF0 = 1.\ntstart = 2.5\nduration = 5.\n\n# Initialize Rectangle type\nrect = Rectangle(F0, tstart, duration)\n\n# Compute the excitation\nF_rect = excitation(rect, t)\n\n\n\n\n\n\n\n\n\nThe triangle signal is defined by the following equation: \\[\nF(t) = \\begin{cases}\n\\frac{2F_0}{T}\\left(t - t_\\text{start}\\right) & \\text{if } t \\in [t_\\text{start}, t_m] \\\\\nF_0 - \\frac{2F_0}{T}(t - t_m) & \\text{if } t \\in [t_m, t_\\text{start} + T] \\\\\n0 & \\text{otherwise}\n\\end{cases},\n\\] where \\(F_0\\) is the amplitude of the signal, \\(t_\\text{start}\\) is the start time of the signal, \\(T\\) is the duration of the signal and \\(t_m = t_\\text{start} + T/2\\) is the time at which the signal reaches its maximum value.\n\nTriangle\n\n\n\nTriangle(F, tstart, duration)\nStruct to define a triangular excitation signal\nFields\n\nF::Real: Amplitude of the force [N]\n\ntstart::Real: Starting time of the excitation [s]\n\nduration::Real: Duration of the excitation [s]\n\n\n\n\n\n\n\n\n\n# Time parameters\nΔt = 1e-3\nt = 0.:Δt:10.\n\n# Excitation parameters\nF0 = 1.\ntstart = 2.5\nduration = 5.\n\n# Initialize Triangle type\ntri = Triangle(F0, tstart, duration)\n\n# Compute the excitation\nF_tri = excitation(tri, t)\n\n\n\n\n\n\n\n\n\nThe hammer impact signal is supposed to have the shape of a Gamma distribution \\[\nF(t) = \\begin{cases}\nF_0\\left(\\frac{t_h}{p\\theta}\\right)^p \\text{exp}\\left(-\\frac{t_h}{\\theta} + p\\right), & \\text{if } t \\geq t_\\text{start} \\\\\n0, & \\text{otherwise}\n\\end{cases},\n\\] where \\(F_0\\) is the amplitude of the signal, \\(t_h = t - t_\\text{start}\\) is the time since the impact, \\(p\\) is the shape parameter, and \\(\\theta\\) is the scale parameter.\n\nHammer\n\n\n\nHammer(F, tstart, k, θ)\nStruct to define a hammer impact excitation signal\nFields\n\nF::Real: Amplitude of the force [N]\n\ntstart::Real: Starting time of the excitation [s]\n\np::Real: Shape parameter\n\nθ::Real: Intensity parameter [s]\n\n\n\n\n\n\n\n\n\n# Time parameters\nΔt = 1e-5\nt = 0.:Δt:0.05\n\n# Excitation parameters\nF0 = 1.\ntstart = 0.01\nk = 9.7\nθ = 6e-4\n\n# Initialize Hammer type\nhammer = Hammer(F0, tstart, k, θ)\n\n# Compute the excitation\nF_hammer = excitation(hammer, t)\n\n\n\n\n\n\n\n\n\nThe smooth rectangular signal (custom Tukey window) is defined by the following equation: \\[\nF(t) = \\begin{cases}\n\\frac{F_0}{2}\\left[1 - \\cos\\left(\\frac{2\\pi (t - t_\\text{start})}{\\alpha T}\\right)\\right] & \\text{if } t \\in [t_\\text{start}, t_\\text{start} + t_\\text{rise}] \\\\\nF_0 & \\text{if } t \\in [t_\\text{start} + t_\\text{rise}, t_\\text{start} + t_\\text{rise} + T_\\text{rect}] \\\\\n\\frac{F_0}{2}\\left[1 - \\cos\\left(\\frac{2\\pi (t - t_\\text{start} - t_\\text{rise} - T_\\text{rect})}{\\alpha T}\\right)\\right] & \\text{if } t \\in [t_\\text{start} + t_\\text{rise} + T_\\text{rect}, t_\\text{start} + T] \\\\\n\\end{cases},\n\\] where \\(F_0\\) is the amplitude of the signal, \\(t_\\text{start}\\) is the start time of the signal, \\(T\\) is the duration of the signal, \\(t_\\text{rise}\\) is the duration to reach \\(F_0\\) and \\(\\alpha = \\frac{2t_\\text{rise}}{T}\\) and \\(T_\\text{rect} = T - 2t_\\text{rise}\\) is the duration of the rectangular part of the signal.\n\nSmoothRect\n\n\n\nSmoothRect(F, tstart, tr, duration)\nStruct to define a smooth rectangular excitation signal\nFields\n\nF::Real: Amplitude of the force [N]\n\ntstart::Real: Starting time of the excitation [s]\n\nduration::Real: Duration of the excitation [s]\n\ntrise::Real: Rise time from 0 to F [s]\n\n\nNote: SmoothRect is actually a custom Tukey window for which the coefficient α is computed to satisfy the trise given by the user\n\n\n\n\n\n\n\n# Time parameters\nΔt = 1e-3\nt = 0.:Δt:10.\n\n# Excitation parameters\nF0 = 1.\ntstart = 2.5\nduration = 5.\ntrise = 1.\n\n# Initialize SmoothRect type\nsrect = SmoothRect(F0, tstart, duration, trise)\n\n# Compute the excitation\nF_srect = excitation(srect, t)\n\n\n\n\n\n\n\n\n\nThe sine signal is defined by the following equation: \\[\nF(t) = \\begin{cases}\nF_0 \\sin\\left(\\omega (t - t_\\text{start}) + \\theta\\right), & \\text{if } t \\in [t_\\text{start}, t_\\text{start} + T] \\\\\n0, & \\text{otherwise}\n\\end{cases},\n\\] where \\(F_0\\) is the amplitude of the signal, \\(\\omega\\) is the angular frequency of the signal, and \\(\\theta\\) is the phase of the signal.\n\n\n\n\n\n\nZero-end signal\n\n\n\n\n\nSometimes it is necessary to have a signal that ends at zero. In this case, the duration of the signal must be adjusted to ensure that the signal ends at zero. To do so, one have to find the smallest integer \\(n\\) such that at \\(t = t_\\text{start} + T\\): \\[\n\\sin(\\omega T + \\theta) = 0 \\Rightarrow \\omega T + \\theta = 2\\pi n \\Rightarrow n = \\frac{\\omega T + \\theta}{2\\pi}.\n\\]\nOnce \\(n\\) is found, the duration of the signal must be adjusted to: \\[\nT_\\text{new} = \\frac{2\\pi n - \\theta}{\\omega}.\n\\]\n\n\n\n\nSineWave\n\n\n\nSineWave(F, tstart, duration, freq; zero_end = true)\nStruct to define a sine wave excitation signal\nConstructor parameters\n\nF::Real: Amplitude of the force [N]\n\ntstart::Real: Starting time of the excitation [s]\n\nduration::Real: Duration of the excitation [s]\n\nfreq::Real: Frequency of the excitation [Hz]\n\nzero_end::Bool: Boolean to set the excitation to 0 at the end of the duration (default = true)\n\n\nFields\n\nF::Real: Amplitude of the force [N]\n\ntstart::Real: Starting time of the excitation [s]\n\nduration::Real: Duration of the excitation [s]\n\nω::Real: Frequency of the excitation [Hz]\n\nzero_end::Bool: Boolean to set the excitation to 0 at the end of the duration (default = true)\n\n\n\n\n\n\n\n\n\n# Time parameters\nΔt = 1e-3\nt = 0.:Δt:10.\n\n# Excitation parameters\nF0 = 1.\ntstart = 2.5\nduration = 5.\nf = 2.\n\n# Initialize HaverSine type\nsine = SineWave(F0, tstart, duration, f, zero_end = true)\n\n# Compute the excitation\nF_sine = excitation(sine, t)\n\n\n\n\n\n\n\n\n\nThe half-sine signal is defined by the following equation: \\[\nF(t) = \\begin{cases}\nF_0 \\sin(\\frac{\\pi (t - t_\\text{start}}{T}) & \\text{if } t \\in [t_\\text{start}, t_\\text{start} + T] \\\\\n0 & \\text{otherwise}\n\\end{cases},\n\\] where \\(F_0\\) is the amplitude of the signal, \\(t_\\text{start}\\) is the start time of the signal, and \\(T\\) is the duration of the signal.\n\nHalfSine\n\n\n\nHalfSine(F, tstart, duration)\nStruct to define a half sine excitation signal\nFields\n\nF::Real: Amplitude of the force [N]\n\ntstart::Real: Starting time of the excitation [s]\n\nduration::Real: Duration of the excitation [s]\n\n\n\n\n\n\n\n\n\n# Time parameters\nΔt = 1e-3\nt = 0.:Δt:10.\n\n# Excitation parameters\nF0 = 1.\ntstart = 2.5\nduration = 5.\n\n# Initialize HalfSine type\nhsine = HalfSine(F0, tstart, duration)\n\n# Compute the excitation\nF_hsine = excitation(hsine, t)\n\n\n\n\n\n\n\n\n\nThe haversine (or versed sine) signal is defined by the following equation: \\[\nF(t) = \\begin{cases}\nF_0\\left(1 - cos(\\frac{2\\pi t}{T}\\right) & \\text{if } t \\in [t_\\text{start}, t_\\text{start} + T] \\\\\n0 & \\text{otherwise}\n\\end{cases},\n\\] where \\(F_0\\) is the amplitude of the signal, \\(t_\\text{start}\\) is the start time of the signal, and \\(T\\) is the duration of the signal.\n\nHaverSine\n\n\n\nHaverSine(F, tstart, duration)\nStruct to define a Haversine (or versed sine) excitation signal\nFields\n\nF::Real: Amplitude of the force [N]\n\ntstart::Real: Starting time of the excitation [s]\n\nduration::Real: Duration of the excitation [s]\n\n\n\n\n\n\n\n\n\n# Time parameters\nΔt = 1e-3\nt = 0.:Δt:10.\n\n# Excitation parameters\nF0 = 1.\ntstart = 2.5\nduration = 5.\n\n# Initialize HaverSine type\nhaversine = HaverSine(F0, tstart, duration)\n\n# Compute the excitation\nF_haversine = excitation(haversine, t)\n\n\n\n\n\n\n\n\n\nThe swept sine signal is defined by the following equation: \\[\nF(t) = \\begin{cases}\nF_0 \\sin(\\theta(t)) & \\text{if } t \\in [t_\\text{start}, t_\\text{start} + T] \\\\\n0 & \\text{otherwise}\n\\end{cases},\n\\] where \\(F_0\\) is the amplitude of the signal, \\(t_\\text{start}\\) is the start time of the signal, \\(T\\) is the duration of the signal and \\(\\theta(t)\\) is the instantaneous phase.\nThe instantaneous phase is given by: \\[\n\\theta(t) = \\theta_0 + 2\\pi\\int_0^t f(\\tau) d\\tau,\n\\] where \\(f(\\tau)\\) is the instantaneous frequency of the signal at time \\(\\tau\\) and \\(\\theta_0\\) is the initial phase (set to 0 here).\nIn this package, three possible types of swept sine signals are available:\n\nLinear swept sine: \\[\nf(t) = f_\\text{start} + \\beta(t - t_\\text{start}) \\Rightarrow \\theta(t) = 2\\pi\\left(f_\\text{start}(t - t_\\text{start}) + \\frac{\\beta (t - t_\\text{start})^2}{2}\\right),\n\\] where:\n\n\\(\\beta = \\frac{f_\\text{end} - f_\\text{start}}{T}\\)\n\\(f_\\text{start}\\): Initial frequency of the signal at \\(t_\\text{start}\\)\n\\(f_\\text{end}\\): Final frequency of the signal at \\(t_\\text{start} + T\\)\n\nQuadratic swept sine: \\[\nf(t) = f_\\text{start} + \\beta (t - t_\\text{start})^2 \\Rightarrow \\theta(t) = 2\\pi\\left(f_\\text{start}(t - t_\\text{start}) + \\frac{\\beta (t - t_\\text{start})^3}{3}\\right),\n\\] where \\(\\beta = \\frac{f_\\text{end} - f_\\text{start}}{T^2}\\).\nLogarithmic swept sine: \\[\nf(t) = f_\\text{start}\\beta^{t - t_\\text{start}} \\Rightarrow \\theta(t) = \\frac{2\\pi f_\\text{start}}{\\log(\\beta)}\\left(\\beta^{t - t_\\text{start}} - 1\\right),\n\\] where \\(\\beta = \\left(\\frac{f_\\text{end}}{f_\\text{start}}\\right)^{1/T}\\).\n\n\n\n\n\n\n\nZero-end signal\n\n\n\n\n\nSimilarly to the sine signal, the duration of the signal must be adjusted to ensure that the signal ends at zero. To do so, one have to find the smallest integer \\(n\\) such that at \\(t = t_\\text{start} + T\\): \\[\n  \\theta(t) = 2\\pi n.\n\\]\nIn doing so, we have for:\n\nLinear swept sine: \\[\nn = (f_\\text{start} + f_\\text{end})\\frac{T}{2} \\Rightarrow T_\\text{new} = \\frac{2n}{f_\\text{start} + f_\\text{end}}.\n\\]\nQuadratic swept sine: \\[\nn = (2f_\\text{start} + f_\\text{end})\\frac{T}{3} \\Rightarrow T_\\text{new} = \\frac{3n}{2f_\\text{start} + f_\\text{end}}.\n\\]\nLogarithmic swept sine: \\[\nn = \\frac{f_\\text{end} - f_\\text{start}}{\\log(f_\\text{end}/f_\\text{start})}T \\Rightarrow T_\\text{new} = \\frac{n\\log(f_\\text{end}/f_\\text{start})}{f_\\text{end} - f_\\text{start}}.\n\\]\n\n\n\n\n\nSweptSine\n\n\n\nSweptSine(F, tstart, duration, fstart, fend, type)\nStruct to define a swept sine excitation signal\nFields\n\nF::Real: Amplitude of the force [N]\n\ntstart::Real: Starting time of the excitation [s]\n\nduration::Real: Duration of the excitation [s]\n\nfstart::Real: Starting frequency [Hz]\n\nfend::Real: Ending frequency [Hz]\n\ntype::Symbol: Type of sweep\n\n:lin - linear (default)\n\n:quad - quadratic\n\n:log - logarithmic\n\n\n\nzero_end::Bool: Boolean to set the excitation to 0 at the end of the duration (default = true)\n\n\n\n\n\n\n\n\n\n# Time parameters\nΔt = 1e-3\nt = 0.:Δt:10.\n\n# Excitation parameters\nF0 = 1.\ntstart = 2.5\nduration = 5.\nfstart = 1.\nfend = 6.\ntype_swept = :lin\n\n# Initialize SweptSine type\nchirp = SweptSine(F0, tstart, duration, fstart, fend, type_swept, zero_end = true)\n\n# Compute the excitation\nF_chirp = excitation(chirp, t)\n\n\n\n\n\n\n\n\n\nThe Gaussian pulse signal is defined by the following equation: \\[\nF(t) = \\begin{cases}\nF_0 \\exp\\left(-\\frac{t_p^2}{2\\sigma^2}\\right) \\cos(2\\pi f_c t_p), & \\text{if } t \\geq t_\\text{start} \\\\\n0, & \\text{otherwise}\n\\end{cases},\n\\] where \\(F_0\\) is the amplitude of the signal, \\(t_\\text{start}\\) is the start time of the signal, \\(\\sigma\\) is the standard deviation of the signal, and \\(f_c\\) is the carrier frequency. Here \\(t_p = t - t_\\text{start} - T/2\\) so that the Gaussian pulse reaches its maximum value at \\(t = t_\\text{start} + T/2\\).\n\n\n\n\n\n\nVariance calibration\n\n\n\n\n\nThe design of the Gaussian pulse assumes that it tends to zero when \\(t = t_\\text{start} + T\\). This requirement implies that the standard deviation \\(\\sigma\\) must be chosen such that the Gaussian pulse is zero at \\(t = t_\\text{start} + T\\). This condition can only be satisfied within some precision. More precisely, the idea is to find the quantile \\(n\\) such that \\(T = n\\sigma\\). Consequently, if we assume that \\(F(t_\\text{start} + T) = 10^{-p}\\) (with \\(p\\) a given precision), we have: \\[\nn = 2\\sqrt{2(p\\log 10 + \\log F_0)} \\Rightarrow \\sigma = \\frac{T}{n}.\n\\]\n\n\n\n\nGaussianPulse\n\n\n\nGaussianPulse(F, tstart, duration, fc)\nStruct to define a Gaussian pulse excitation signal\nFields\n\nF::Real: Amplitude of the force [N]\n\ntstart::Real: Starting time of the excitation [s]\n\nduration::Real: Duration of the excitation [s]\n\nfc::Real: Center frequency of the pulse [Hz]\n\nprecision::Real: Precision of the pulse (default = 4.)\n\n\nNote\nThe precision parameter calibrates the standard deviation of the pulse, so that the duration = n x σ, within some precision. If n = 1.96 then the confidence interval of the Gaussian distribution is 95%. To do so, we compute n so that at t = duration = n x σ , the amplitude of F x exp(-0.5*(t - duration/2)^2/sigma^2) = 10^(-precision)\n\n\n\n\n\n\n\n# Time parameters\nΔt = 1e-3\nt = 0.:Δt:10.\n\n# Excitation parameters\nF0 = 1.\ntstart = 2.5\nduration = 5.\nfc = 2.\n\n# Initialize GaussianPulse type\ngpulse = GaussianPulse(F0, tstart, duration, fc)\n\n# Compute the excitation\nF_gpulse = excitation(gpulse, t)\n\n\n\n\n\n\n\n\n\nColored noise is a random signal that has a power spectral density that is not (necessarily) flat over a given frequency range. In practice, colored noise is also refered to as “power-law noise” since its power spectral density is proportional to \\(f^{-\\alpha}\\) (\\(f\\): frequency) and its spectrum is proportional to \\(f^{-\\alpha/2}\\).\nIn this package, five types of colored noise are available:\n\nWhite noise: \\(\\alpha = 0\\)\nPink noise: \\(\\alpha = 1\\)\nBlue noise: \\(\\alpha = -1\\)\nBrown noise: \\(\\alpha = 2\\)\nPurple noise: \\(\\alpha = -2\\)\n\nThe general procedure to generate a colored noise signal is as follows:\n\nGenerate a white noise signal and compute its FFT\nMultiply the FFT by \\(f^{-\\alpha/2}\\) to obtain the colored noise\nCompute the inverse FFT to obtain the colored noise signal\n\nAdditional steps can be added such as:\n\nNormalization: Ensure that the colored noise has the desired variance and preserves the energy of the white noise\nFiltering: Obtain a band-limited colored noise\n\n\nColoredNoise\n\n\n\nColoredNoise(F, color)\nStruct to define a colored noise excitation signal\nFields\n\nF::Real: Mean amplitude of the force [N]\n\ntstart::Real: Starting time of the excitation [s]\n\nduration::Real: Duration of the excitation [s]\n\nσ::Real: Target standard deviation of the colored noise\n\ncolor::Symbol: Color of the noise\n\n:white (default)\n\n:pink\n\n:blue\n\n:brown\n\n:purple\n\n\n\nfrange::AbstractVector: Frequencies used to defined the bandpass filter applied to the colored noise\n\n\n\n\n\n\n\n\n\n# Time parameters\nΔt = 1e-4\nt = 0.:Δt:10.\nnt = length(t)\nfs = 1/Δt\n\n# Excitation parameters\nF0 = 1.\ntstart = 0.\nduration = 10.\nσ = 1.\n\n# Initialize ColoredNoise type\nexc_white = ColoredNoise(F0, tstart, duration, σ, color = :white)\nexc_pink = ColoredNoise(F0, tstart, duration, σ, color = :pink)\nexc_blue = ColoredNoise(F0, tstart, duration, σ, color = :blue)\nexc_brown = ColoredNoise(F0, tstart, duration, σ, color = :brown)\nexc_purple = ColoredNoise(F0, tstart, duration, σ, color = :purple)\n\n# Compute the spectrum of the colored noise\nfreq = rfftfreq(nt, fs)\nS_white = rfft(excitation(exc_white, t))\nS_pink = rfft(excitation(exc_pink, t))\nS_blue = rfft(excitation(exc_blue, t))\nS_brown = rfft(excitation(exc_brown, t))\nS_purple = rfft(excitation(exc_purple, t))",
    "crumbs": [
      "Models",
      "Excitation models"
    ]
  },
  {
    "objectID": "models/excitation.html#sec-exc-api",
    "href": "models/excitation.html#sec-exc-api",
    "title": "Excitation models",
    "section": "2 excitation function",
    "text": "2 excitation function\n\nexcitation\n\n\n\nexcitation(type, t)\nComputes different types of excitation signals\nInputs\n\ntype : Excitation type\n\nTriangle\n\nRectangle\n\nHammer\n\nSmoothRect\n\nSineWave\n\nHalfSine\n\nHaverSine\n\nSweptSine\n\nGaussianPulse\n\nColoredNoise\n\n\n\nt: Time vector\n\n\nOutput\n\nF: Excitation signal",
    "crumbs": [
      "Models",
      "Excitation models"
    ]
  },
  {
    "objectID": "models/noise.html",
    "href": "models/noise.html",
    "title": "Noise models",
    "section": "",
    "text": "In real-world applications, the noise is always present in the measured data. The noise can be due to various reasons such as the sensor noise, the environmental noise, the quantization noise, etc. The noise can be modeled as a random process. The package implements various type of noise in order to cover a wide range of practical situations.",
    "crumbs": [
      "Models",
      "Noise models"
    ]
  },
  {
    "objectID": "models/noise.html#additive-gaussian-white-noise",
    "href": "models/noise.html#additive-gaussian-white-noise",
    "title": "Noise models",
    "section": "1 Additive Gaussian White noise",
    "text": "1 Additive Gaussian White noise\nWhen a signal, real or complex, \\(x\\) is corrupted by an additive Gaussian white noise \\(n\\), the measured signal \\(y\\) can be written as: \\[\n    y = x + n\n\\] where \\(n \\sim \\mathcal{N}(n| 0, \\sigma^2)\\)\n\nagwn\n\n\n\nagwn(x, snr_dB; rst = true)\nAdds a Gaussian White Noise (AGWN) to a signal x with a given SNR.\nInputs\n\nx: Signal (Real or Complex)\n\nsnr_dB: signal to noise ratio [dB]\n\nrst: Reset the random number generator - Bool\n\n\nOutput\n\ny: Noisy signal\n\n\n\n\n\n\n\n\n\n# Noiseless signal\nΔt = 1e-4\nt = 0:Δt:1\nx = sin.(2π*5*t)\n\n# Signal to noise ratio\nsnr_dB = 25.\n\n# Noisy signal\ny = agwn(x, snr_dB)",
    "crumbs": [
      "Models",
      "Noise models"
    ]
  },
  {
    "objectID": "models/noise.html#additive-colored-noise",
    "href": "models/noise.html#additive-colored-noise",
    "title": "Noise models",
    "section": "2 Additive Colored noise",
    "text": "2 Additive Colored noise\nWhen a signal, real or complex, \\(x\\) is corrupted by an additive colored noise \\(n\\), the measured signal \\(y\\) can be written as: \\[\n    y = x + n,\n\\] where \\(n\\) is a colored noise defined as in Excitation models - Colored noise.\n\nacn - Real signal\n\n\n\nacn(x, snr_dB, fs, color = :pink; frange = Float64[], rst = true)\nAdds a Colored Noise (ACN) to a signal x with a given SNR in the time domain\nInputs\n\nx: Signal\n\nsnr_dB: Signal to noise ratio [dB]\n\nfs: Sampling frequency [Hz]\n\ncolor: Color of the noise\n\n:white\n\n:pink (default)\n\n:blue\n\n:brown\n\n:purple\n\n\n\nfrange: Frequencies used to defined the bandpass filter applied to the colored noise\n\nrst: Reset the random number generator\n\n\nOutput\n\ny: Noisy signal\n\n\n\n\n\n\n\n\n\nacn - Complex signal\n\n\n\nacn(x, snr_dB, freq, color = :pink; rst = true)\nAdds a complex Random Colored Noise (ACN) to a signal x with a given SNR in the frequency domain\nInputs\n\nx::VecOrMat{Real}: Signal\n\nsnr_dB: Signal to noise ratio [dB]\n\nfreq::AbstractVector: Frequency range of interest\n\ncolor: Color of the noise\n\n:white\n\n:pink (default)\n\n:blue\n\n:brown\n\n:purple\n\n\n\nrst::Bool: Reset the random number generator\n\n\nOutput\n\ny: Noisy signal\n\n\n\n\nacn(x, snr_dB, fs, color = :pink; frange = Float64[], rst = true)\nAdds a Colored Noise (ACN) to a signal x with a given SNR in the time domain\nInputs\n\nx: Signal\n\nsnr_dB: Signal to noise ratio [dB]\n\nfs: Sampling frequency [Hz]\n\ncolor: Color of the noise\n\n:white\n\n:pink (default)\n\n:blue\n\n:brown\n\n:purple\n\n\n\nfrange: Frequencies used to defined the bandpass filter applied to the colored noise\n\nrst: Reset the random number generator\n\n\nOutput\n\ny: Noisy signal\n\n\n\n\n\n\n\n\n\n# Noiseless signal\nΔt = 1e-4\nfs = 1/Δt\nt = 0:Δt:1\nx = sin.(2π*5*t)\n\n# Signal to noise ratio\nsnr_dB = 25.\n\n# Noisy signal\ny = acn(x, snr_dB, fs, :blue)",
    "crumbs": [
      "Models",
      "Noise models"
    ]
  },
  {
    "objectID": "models/noise.html#multiplicative-gaussian-white-noise",
    "href": "models/noise.html#multiplicative-gaussian-white-noise",
    "title": "Noise models",
    "section": "3 Multiplicative Gaussian White noise",
    "text": "3 Multiplicative Gaussian White noise\nWhen a signal, real or complex, \\(x\\) is corrupted by a multiplicative Gaussian white noise \\(n\\), the measured signal \\(y\\) can be written as: \\[\n    y = (1 + n)x\n\\]\n\nmgwn\n\n\n\nmgwn(x, snr_dB; rst = true)\nAdds a multiplicative Gaussian White Noise (MGWN) to a signal x with a given SNR\nInputs\n\nx: Signal\n\nsnr_dB: Signal to noise ratio [dB]\n\nrst: Reset the random number generator\n\n\nOutput\n\ny: Noisy signal\n\n\n\n\n\n\n\n\n\n# Noiseless signal\nΔt = 1e-4\nt = 0:Δt:1\nx = sin.(2π*5*t)\n\n# Signal to noise ratio\nsnr_dB = 25.\n\n# Noisy signal\ny = mgwn(x, snr_dB)",
    "crumbs": [
      "Models",
      "Noise models"
    ]
  },
  {
    "objectID": "models/noise.html#mixed-noise",
    "href": "models/noise.html#mixed-noise",
    "title": "Noise models",
    "section": "4 Mixed noise",
    "text": "4 Mixed noise\nWhen a signal, real or complex, \\(x\\) is corrupted by a mixed noise \\(n\\), the measured signal \\(y\\) can be written as: \\[\n    y = (1 + n_m)x + n_a\n\\] where \\(n_m\\) is a multiplicative Gaussian white noise and \\(n_a\\) is an additive Gaussian white noise.\n\nmixed_noise\n\n\n\nmixed_noise(x, snr_dB; rst = true)\nAdds both additive and multiplicative Gaussian White Noise to a signal x with a given SNR\nInputs\n\nx: Signal\n\nsnr_dB: Signal to noise ratio [dB]\n\nrst: Reset the random number generator\n\n\nOutput\n\ny: Noisy signal\n\n\n\n\n\n\n\n\n\n# Noiseless signal\nΔt = 1e-4\nt = 0:Δt:1\nx = sin.(2π*5*t)\n\n# Signal to noise ratio\nsnr_dB = 25.\n\n# Noisy signal\ny = mixed_noise(x, snr_dB)",
    "crumbs": [
      "Models",
      "Noise models"
    ]
  },
  {
    "objectID": "overview/release_notes.html",
    "href": "overview/release_notes.html",
    "title": "Release Notes",
    "section": "",
    "text": "Breaking changes\n\nSdof solvers\n\nRefactor SdofHarmonicTimeProblem, SdofForcedTimeProblem and SdofFrequencyProblem to comply with DifferentialEquations.jl conventions\n\nSignal processing\n\nAdd csd function to compute the Cross Spectral Density (CSD) between two signals or between multiple input and output signals\nAdd support for matrix inputs in tfestimate function to compute the Frequency Response Function (FRF) between multiple input and output signals\nRefactor tfestimate, welch, csd and spectrum functions to accept window functions instead of pre-computed window vectors\nAdd nfft parameter to tfestimate, welch, csd and spectrum functions to specify the number of FFT points to be used\n\nModal extraction\n\nAdd LSFit() method for modal parameter extraction using least squares fitting of the frequency response function around the resonance peak\nAdd AutoEMASdofProblem and AutoEMAMdofProblem structures and solve functions to perform automatic modal extraction based on Sdof or Mdof approximations\nSolutions of AutoEMA problems are stored in EMASdofSolution or EMAMdofSolution structures containing the poles and the modal parameters\nAdd poles_extraction function to extract system poles using different Mdof methods:\n\nLeast-Squares Complex Exponential (LSCE) method\nLeast-Squares Complex Frequency-domain (LSCF) method\nPolyreference Least-Squares Complex Frequency-domain (pLSCF) method\n\nAdd modeshape_extraction function to extract mode shapes from residues and poles using Mdof methods\nAdd stabilization function to perform stabilization diagram analysis using Mdof methods\nAdd stabilization_plot function to visualize stabilization diagrams\nStabilization results are now stored in the EMAMdofStabilization structure for plotting and further analysis\nAdd frf_reconstruction function to reconstruct FRFs from extracted modal parameters\nAdd compute_residuals function to compute the lower and upper residuals of the FRF\nAdd mode2residues function to compute residues from real modes information\nAdd modal extraction indicators:\n\nModal Overlap Factor (MOF)\nMode Overcomplexity Value (MOV)\nMode Phase Collinearity (MPC)\nMode Complexity Factor (MCF)\nMode Phase Deviation (MPD)\nModal Scale Factor (MSF)\nModal Assurance Criterion (MAC)\nCoordinate Modal Assurance Criterion (COMAC)\nEnhanced Coordinate Modal Assurance Criterion (ECOMAC)\nFrequency Response Assurance Criterion (FRAC)\nComplex Mode Indicator Function (CMIF)\nPower Spectrum Indicator Function (PSIF)\n\nUtils\n\nAdd modal2poles and poles2modal functions to convert between modal parameters and system poles",
    "crumbs": [
      "Overview",
      "Release Notes"
    ]
  },
  {
    "objectID": "overview/release_notes.html#v1.0.0",
    "href": "overview/release_notes.html#v1.0.0",
    "title": "Release Notes",
    "section": "",
    "text": "Breaking changes\n\nSdof solvers\n\nRefactor SdofHarmonicTimeProblem, SdofForcedTimeProblem and SdofFrequencyProblem to comply with DifferentialEquations.jl conventions\n\nSignal processing\n\nAdd csd function to compute the Cross Spectral Density (CSD) between two signals or between multiple input and output signals\nAdd support for matrix inputs in tfestimate function to compute the Frequency Response Function (FRF) between multiple input and output signals\nRefactor tfestimate, welch, csd and spectrum functions to accept window functions instead of pre-computed window vectors\nAdd nfft parameter to tfestimate, welch, csd and spectrum functions to specify the number of FFT points to be used\n\nModal extraction\n\nAdd LSFit() method for modal parameter extraction using least squares fitting of the frequency response function around the resonance peak\nAdd AutoEMASdofProblem and AutoEMAMdofProblem structures and solve functions to perform automatic modal extraction based on Sdof or Mdof approximations\nSolutions of AutoEMA problems are stored in EMASdofSolution or EMAMdofSolution structures containing the poles and the modal parameters\nAdd poles_extraction function to extract system poles using different Mdof methods:\n\nLeast-Squares Complex Exponential (LSCE) method\nLeast-Squares Complex Frequency-domain (LSCF) method\nPolyreference Least-Squares Complex Frequency-domain (pLSCF) method\n\nAdd modeshape_extraction function to extract mode shapes from residues and poles using Mdof methods\nAdd stabilization function to perform stabilization diagram analysis using Mdof methods\nAdd stabilization_plot function to visualize stabilization diagrams\nStabilization results are now stored in the EMAMdofStabilization structure for plotting and further analysis\nAdd frf_reconstruction function to reconstruct FRFs from extracted modal parameters\nAdd compute_residuals function to compute the lower and upper residuals of the FRF\nAdd mode2residues function to compute residues from real modes information\nAdd modal extraction indicators:\n\nModal Overlap Factor (MOF)\nMode Overcomplexity Value (MOV)\nMode Phase Collinearity (MPC)\nMode Complexity Factor (MCF)\nMode Phase Deviation (MPD)\nModal Scale Factor (MSF)\nModal Assurance Criterion (MAC)\nCoordinate Modal Assurance Criterion (COMAC)\nEnhanced Coordinate Modal Assurance Criterion (ECOMAC)\nFrequency Response Assurance Criterion (FRAC)\nComplex Mode Indicator Function (CMIF)\nPower Spectrum Indicator Function (PSIF)\n\nUtils\n\nAdd modal2poles and poles2modal functions to convert between modal parameters and system poles",
    "crumbs": [
      "Overview",
      "Release Notes"
    ]
  },
  {
    "objectID": "overview/release_notes.html#v0.3.0",
    "href": "overview/release_notes.html#v0.3.0",
    "title": "Release Notes",
    "section": "v0.3.0",
    "text": "v0.3.0\nBreaking change\n\nModify the implementation of the force window following PR #5. Thanks to @JakeZw for proposing this PR.",
    "crumbs": [
      "Overview",
      "Release Notes"
    ]
  },
  {
    "objectID": "overview/release_notes.html#v0.2.0",
    "href": "overview/release_notes.html#v0.2.0",
    "title": "Release Notes",
    "section": "v0.2.0",
    "text": "v0.2.0\nBreaking change\n\nRefactor of the visualization extension following issue #3. Theming has been removed from the plotting functions (function theme_choice is now exported).",
    "crumbs": [
      "Overview",
      "Release Notes"
    ]
  },
  {
    "objectID": "overview/release_notes.html#v0.1.2",
    "href": "overview/release_notes.html#v0.1.2",
    "title": "Release Notes",
    "section": "v0.1.2",
    "text": "v0.1.2\n\nBug fix in OneDMesh (solved issue #2)",
    "crumbs": [
      "Overview",
      "Release Notes"
    ]
  },
  {
    "objectID": "overview/release_notes.html#v0.1.1",
    "href": "overview/release_notes.html#v0.1.1",
    "title": "Release Notes",
    "section": "v0.1.1",
    "text": "v0.1.1\n\nBug fixes in State space solvers",
    "crumbs": [
      "Overview",
      "Release Notes"
    ]
  },
  {
    "objectID": "overview/release_notes.html#v0.1.0",
    "href": "overview/release_notes.html#v0.1.0",
    "title": "Release Notes",
    "section": "v0.1.0",
    "text": "v0.1.0\n\nInitial release of the package",
    "crumbs": [
      "Overview",
      "Release Notes"
    ]
  },
  {
    "objectID": "signal_processing/index.html",
    "href": "signal_processing/index.html",
    "title": "Digital Signal Processing",
    "section": "",
    "text": "StructuralVibration.jl provides a set of functions complementing the DSP.jl to simulate the signal processing pipelines used in structural dynamics applications, such as modal analysis, system identification, and vibration data processing. They can for instance be used to simulate or to process experimental data, which can then be used to validate new algorithms (direct or inverse methods) and to benchmark with existing ones.",
    "crumbs": [
      "Signal processing",
      "Digital Signal Processing"
    ]
  },
  {
    "objectID": "signal_processing/index.html#window-functions",
    "href": "signal_processing/index.html#window-functions",
    "title": "Digital Signal Processing",
    "section": "1 Window functions",
    "text": "1 Window functions\nThe DSP.jl package provides a set of window functions that can be used to reduce spectral leakage in the frequency domain. The StructuralVibration.jl package exports the window functions defined in DSP.jl and provides additional ones for the sake of completeness.\n\n1.1 Windows from DSP.jl\n\n1.1.1 Rectangular window\nThe rectangular window is the simplest window function, which does not modify the signal. It is defined as: \\[\nw[n] = 1,\n\\] for \\(n \\in [0, N-1]\\), where \\(N\\) is the length of the window.\nThe rectangular window is generally not recommended for spectral analysis, as it introduces significant spectral leakage. It is mainly used for testing purposes or when no windowing is required (such as impact testing for sufficiently long acquisition duration).\n\n1.1.1.1 API\n\nrect\n\n\n\nrect\nRectangular window\nExported from DSP.jl\n\n\n\n\n\n\n\n\n1.1.1.2 Example\n\nrectwin = rect(1024)\n\n\n\n\n\n\n\n\n\n1.1.2 Hann(ing) window\nThe Hann window is a raised cosine window that tapers the signal at both ends. It is defined as: \\[\nw[n] = \\frac{1}{2} \\left[1 - \\cos\\left(\\frac{2\\pi n}{N-1}\\right)\\right],\n\\] where \\(N\\) is the length of the window and \\(n \\in [0, N-1]\\).\n\n1.1.2.1 API\n\nhann\n\n\n\nhann\nHann(ing) window\nExported from DSP.jl\n\n\n\n\n\n\n\n\n1.1.2.2 Example\n\nhannwin = hanning(1024)\n\n\n\n\n\n\n\n\n\n1.1.3 Hamming window\nThe Hamming window is a raised cosine window that tapers the signal at both ends. It is defined as: \\[\nw[n] = 0.54 - 0.46 \\cos\\left(\\frac{2\\pi n}{N-1}\\right),\n\\] where \\(N\\) is the length of the window and \\(n \\in [0, N-1]\\).\n\n1.1.3.1 API\n\nhamming\n\n\n\nhamming\nHamming window\nExported from DSP.jl\n\n\n\n\n\n\n\n\n1.1.3.2 Example\n\nhammwin = hamming(1024)\n\n\n\n\n\n\n\n\n\n1.1.4 Tukey window\nThe Tukey window (also known as the cosine-tapered window) is defined by a tapering parameter \\(\\alpha \\in [0,1]\\), which controls the proportion of the window that is tapered. The window is defined as:\n\\[\n\\begin{align*}\n& w[n] = \\frac{1}{2} \\left[1 - \\cos\\left(\\frac{2\\pi n}{\\alpha(N-1)}\\right)\\right], & 0 \\leq n &lt; \\frac{\\alpha(N-1)}{2} \\\\\n& w[n] = 1,  & \\frac{\\alpha(N-1)}{2} \\leq n \\leq \\frac{(N-1)}{2} \\\\\n& w[N-1 - n] = w[n], & 0 \\leq n \\leq \\frac{\\alpha(N-1)}{2} \\\\\n\\end{align*}\n\\]\nWhen \\(\\alpha = 0\\), the Tukey window becomes a rectangular window, and when \\(\\alpha = 1\\), it becomes equivalent to a Hann window.\n\n1.1.4.1 API\n\ntukey\n\n\n\ntukey\nTukey window\nExported from DSP.jl\n\n\n\n\n\n\n\n\n1.1.4.2 Example\n\ntukeywin = tukey(1024, 0.5)\n\n\n\n\n\n\n\n\n\n1.1.5 Cosine window\nThe cosine window is a raised cosine window that tapers the signal at both ends. It is defined as: \\[\nw[n] = \\cos\\left(\\frac{\\pi n}{N-1} - \\frac{\\pi}{2}\\right),\n\\] where \\(N\\) is the length of the window and \\(n \\in [0, N-1]\\).\n\n1.1.5.1 API\n\ncosine\n\n\n\ncosine\nCosine window\nExported from DSP.jl\n\n\n\n\n\n\n\n\n1.1.5.2 Example\n\ncoswin = cosine(1024)\n\n\n\n\n\n\n\n\n\n1.1.6 Lanczos window\nThe Lanczos window is a raised cosine window that tapers the signal at both ends. It is defined as: \\[\nw[n] = \\text{sinc}\\left(\\frac{2n}{N-1} - 1\\right),\n\\] where \\(N\\) is the length of the window and \\(n \\in [0, N-1]\\).\n\n1.1.6.1 API\n\nlanczos\n\n\n\nlanczos\nLanczos window\nExported from DSP.jl\n\n\n\n\n\n\n\n\n1.1.6.2 Example\n\nlanczoswin = lanczos(1024)\n\n\n\n\n\n\n\n\n\n1.1.7 Triangular window\nThe triangular window is a simple window function that tapers the signal at both ends. It is defined as: \\[\nw[n] = 1 - \\frac{|2n - (N-1)|}{L},\n\\] where \\(L = N/N+1\\) is \\(N\\) is even/odd and \\(n \\in [0, N-1]\\).\n\n1.1.7.1 API\n\ntriang\n\n\n\ntriang\nTriangle window\nExported from DSP.jl\n\n\n\n\n\n\n\ntriangwin = triang(1024)\n\n\n\n\n\n\n\n\n\n1.1.8 Bartlett window\nThe Bartlett window is a triangular window that tapers the signal at both ends. It is defined as: \\[\nw[n] = \\left(1 - \\frac{|n - L|}{L}\\right),\n\\] where \\(L = \\frac{N-1}{2}\\) and \\(n \\in [0, N-1]\\).\n\n1.1.8.1 API\n\nbartlett\n\n\n\nbartlett\nBartlett window\nExported from DSP.jl\n\n\n\n\n\n\n\n\n1.1.8.2 Example\n\nbartlettwin = bartlett(1024)\n\n\n\n\n\n\n\n\n\n1.1.9 Bartlett-Hann window\nThe Bartlett-Hann window is a raised cosine window that tapers the signal at both ends. It is defined as: \\[\nw[n] = 0.62 - 0.48 \\left|\\frac{n}{N-1} - 0.5\\right| + 0.38 \\cos\\left(2\\pi\\left[\\frac{n}{N-1} - 0.5\\right]\\right),\n\\] where \\(n \\in [0, N-1]\\).\n\n1.1.9.1 API\n\nbartlett_hann\n\n\n\nbartlett_hann\nBartlett-Hann window\nExported from DSP.jl\n\n\n\n\n\n\n\n\n1.1.9.2 Example\n\nbarthannwin = bartlett_hann(1024)\n\n\n\n\n\n\n\n\n\n1.1.10 Gaussian window\nThe Gaussian window is a raised cosine window that tapers the signal at both ends. It is defined as: \\[\nw[n] = \\text{exp}\\left(-\\frac{(n - \\mu)^2}{2\\sigma^2}\\right),\n\\] where \\(\\mu = \\frac{N-1}{2}\\) is the center of the window, \\(\\sigma\\) is the standard deviation, and \\(n \\in [0, N-1]\\).\n\n1.1.10.1 API\n\ngaussian\n\n\n\ngaussian\nGaussian window\nExported from DSP.jl\n\n\n\n\n\n\n\n\n1.1.10.2 Example\n\ngaussianwin = gaussian(1024, 0.2)\n\n\n\n\n\n\n\n\n\n1.1.11 Blackman window\nThe Blackman window is a raised cosine window that tapers the signal at both ends. It is defined as: \\[\nw[n] = 0.42 - 0.5 \\cos\\left(\\frac{2\\pi n}{N-1}\\right) + 0.08 \\cos\\left(\\frac{4\\pi n}{N-1}\\right),\n\\] where \\(n \\in [0, N-1]\\).\n\n1.1.11.1 API\n\nblackman\n\n\n\nblackman\nBlackman window\nExported from DSP.jl\n\n\n\n\n\n\n\n\n1.1.11.2 Example\n\nblackmanwin = blackman(1024)\n\n\n\n\n\n\n\n\n\n1.1.12 Kaiser window\nThe Kaiser window is a raised cosine window that tapers the signal at both ends. It is defined as: \\[\nw[n] = I_0\\left(\\pi\\alpha \\sqrt{1 - \\left(\\frac{2n}{N-1} - 1\\right)^2}\\right) / I_0(\\pi\\alpha),\n\\] where \\(I_0\\) is the modified Bessel function of the first kind, \\(\\beta\\) is a parameter that controls the shape of the window, and \\(n \\in [0, N-1]\\).\n\n1.1.12.1 API\n\nkaiser\n\n\n\nkaiser\nKaiser window\nExported from DSP.jl\n\n\n\n\n\n\n\n\n1.1.12.2 Example\n\nkaiserwin = kaiser(1024, 0.5)\n\n\n\n\n\n\n\n\n\n1.1.13 DPSS window\nThe DPSS (Discrete Prolate Spheroidal Sequences) window maximizes the energy concentration in the main lobe. It has no closed form expression and depends on two parameters: the length of the window \\(N\\) and the time-half-bandwidth product \\(Nw\\) which controls the energy concentration in the main lobe.\n\n1.1.13.1 API\n\ndpss\n\n\n\ndpss\nDPSS window\nExported from DSP.jl\n\n\n\n\n\n\n\n\n1.1.13.2 Example\n\ndpsswin = dpss(1024, 4, 1)\n\n\n\n\n\n\n\n\n\n\n1.2 Additional window functions\n\n1.2.1 Exponential window\nAn exponential window is a window function that tapers the signal exponentially. It is defined as: \\[\nw[n] = \\text{exp}\\left(-\\frac{\\tau n}{N-1}\\right),\n\\] where \\(n \\in [0, N-1]\\), \\(\\tau = -\\log(p)\\) is the time constant, and \\(p\\) is the percentage of the original value by the end of the acquisition block.\n\n1.2.1.1 API\n\nexponential\n\n\n\nexponential(N, exponential_end = 0.01)\nCreate an exponential window. exponential_end = 1 is a uniform window.\nInputs\n\nN: Number of points\n\nexponential_end: End value of the exponential window (0 &lt; exponential_end &lt;= 1)\n\n\nOutput\n\nw: Exponential window\n\n\n\n\n\n\n\n\n\n\n1.2.1.2 Example\n\nexponentialwin = exponential(1024, 0.1)\n\n\n\n\n\n\n\n\n\n1.2.2 Force window\nThe force window is a window function particularly useful in impact testing, where the input signal is a short impulse. The force window is the product of two distinct windows. The first one, denoted \\(w_1[n]\\), is a rectangular window whose end is tapered by a cosine function, namely: \\[\nw_1[n] = \\begin{cases}\n1, & 0 \\leq n &lt; L \\\\\n\\cos\\left(\\frac{\\pi}{2}\\left(\\frac{n - L}{M - L}\\right)\\right), & L \\leq n &lt; M \\\\\n0, & M \\leq n &lt; N\n\\end{cases},\n\\] where \\(n \\in [0, N-1]\\), \\(L = pN\\) is the width of the window, \\(M = N\\text{min}(1, L/N + 0.04)\\) is the index of the end of the cosine tapering part of the window, and \\(p\\) is the percentage of the length of the data acquisition block.\nThe second one, denoted \\(w_2[n]\\), is the exponentital window defined above. Hence, the force window is defined as: \\[\nw[n] = w_1[n] \\cdot w_2[n],\n\\] where \\(w_2[n] = \\text{exp}\\left(-\\frac{\\tau n}{N-1}\\right)\\), with \\(\\tau = -\\log(p)\\).\n\n1.2.2.1 API\n\nforce\n\n\n\nforce(N, width = 0.1, exponential_end = 0.01)\nCreate a force window according to Ref.[1].  For modal testing the exponential_end should be the same in the force and in the exponential window.\nInputs\n\nN: Number of points\n\nwidth: Width (fraction) of the force window (between 0 and 1)\n\nexponential_end: End value of the exponential window (0 &lt; exponential_end &lt;= 1)\n\n\nOutput\n\nw: Force window\n\n\nNote\nexponential_end = 1 does not apply any exponential decay.\nReference\n[1] W. A. Fladung and R. W. Rost. Cause and effect of applying the exponential window to an impact force signal. In Proceedings of IMAC XIV. Orlando, United States. 1996.\n\n\n\n\n\n\n\n\n1.2.2.2 Example\n\nforcewin = force(1024, 0.2, 1.)\nforce_expwin = force(1024, 0.2, 0.01)\n\n\n\n\n\n\n\n\n\n1.2.3 Flat-top window\nThe flat-top window is a window function that window is a partially negative-valued window that has minimal scalloping loss in the frequency domain. It is defined as: \\[\nw[n] = a_0 - a_1\\cos\\left(\\frac{2\\pi n}{N-1}\\right) + a_2\\cos\\left(\\frac{4\\pi n}{N-1}\\right) - a_3\\cos\\left(\\frac{6\\pi n}{N-1}\\right) + a_4\\cos\\left(\\frac{8\\pi n}{N-1}\\right),\n\\] where \\(n \\in [0, N-1]\\) and \\(a_0 = 0.21557895\\), \\(a_1 = 0.41663158\\), \\(a_2 = 0.277263158\\), \\(a_3 = 0.083578947\\), and \\(a_4 = 0.006947368\\).\n\n1.2.3.1 API\n\nflattop\n\n\n\nflattop(N)\nCreate a flat top window\nInput\n\nN: Number of points\n\n\nOutput\n\nw: Flattop window\n\n\n\n\n\n\n\n\n\n\n1.2.3.2 Example\n\nflattopwin = flattop(1024)\n\n\n\n\n\n\n\n\n\n1.2.4 Nuttall window\nThe Nutall window is a window function that returns a Nuttall four-term symmetric Blackman-Harris window. It produces slightly lower sidelobes than Blackman-Harris window. It is defined as: \\[\nw[n] = a_0 - a_1\\cos\\left(\\frac{2\\pi n}{N-1}\\right) + a_2\\cos\\left(\\frac{4\\pi n}{N-1}\\right) - a_3\\cos\\left(\\frac{6\\pi n}{N-1}\\right),\n\\] where \\(n \\in [0, N-1]\\) and \\(a_0 = 0.355768\\), \\(a_1 = 0.487396\\), \\(a_2 = 0.144232\\), and \\(a_3 = 0.012604\\).\n\n1.2.4.1 API\n\nnuttall\n\n\n\nnuttall(N)\nCreate a Nuttall window\nInput\n\nN: Number of points\n\n\nOutput\n\nw: Nuttall window\n\n\n\n\n\n\n\n\n\n\n1.2.4.2 Example\n\nnuttallwin = nuttall(1024)\n\n\n\n\n\n\n\n\n\n1.2.5 Blackman-Nuttall window\nThe Blackman-Nuttall window is a window function that is a modified version of the exact Blackman window. It is defined as: \\[\nw[n] = a_0 - a_1\\cos\\left(\\frac{2\\pi n}{N-1}\\right) + a_2\\cos\\left(\\frac{4\\pi n}{N-1}\\right) - a_3\\cos\\left(\\frac{6\\pi n}{N-1}\\right),\n\\] where \\(n \\in [0, N-1]\\) and \\(a_0 = 0.3635819\\), \\(a_1 = 0.4891775\\), \\(a_2 = 0.1365995\\), and \\(a_3 = 0.0106411\\).\n\n1.2.5.1 API\n\nblackman_nuttall\n\n\n\nblackman_nuttall(N)\nCreate a Blackman-Nuttall window\nInput\n\nN: Number of points\n\n\nOutput\n\nw: Blackman-Nutall window\n\n\n\n\n\n\n\n\n\n\n1.2.5.2 Example\n\nblackman_nuttallwin = blackman_nuttall(1024)\n\n\n\n\n\n\n\n\n\n1.2.6 Blackman-Harris window\nThe Blackman-Harris window is a window function that is another modified version of the exact Blackman window. It is defined as: \\[\nw[n] = a_0 - a_1\\cos\\left(\\frac{2\\pi n}{N-1}\\right) + a_2\\cos\\left(\\frac{4\\pi n}{N-1}\\right) - a_3\\cos\\left(\\frac{6\\pi n}{N-1}\\right),\n\\] where \\(n \\in [0, N-1]\\) and \\(a_0 = 0.35875\\), \\(a_1 = 0.48829\\), \\(a_2 = 0.14128\\), and \\(a_3 = 0.01168\\).\n\n1.2.6.1 API\n\nblackman_harris\n\n\n\nblackman_harris(N)\nCreate a Blackman-Harris window\nInput\n\nN: Number of points\n\n\nOutput\n\nw: Blackman-Harris window\n\n\n\n\n\n\n\n\n\n\n1.2.6.2 Example\n\nblackman_harriswin = blackman_harris(1024)\n\n\n\n\n\n\n\n\n\n1.2.7 Parzen window\nThe parzen window is a window function is defined as: \\[\nw[n] = \\begin{cases}\n1 - 6\\left(\\frac{2|n - M|}{N}\\right)^2\\left(1 - \\frac{2|n - M|}{N}\\right) &  0 \\leq |n - M| \\leq \\frac{M}{2}\\\\\n2\\left(1 - \\frac{2|n - M|}{N}\\right)^3 & \\frac{M}{2} &lt; |n - M| \\leq M\\\\\n\\end{cases}\n\\] where \\(M = \\frac{N - 1}{2}\\) and \\(n \\in [0, N-1]\\).\n\n1.2.7.1 API\n\nparzen\n\n\n\nparzen(N)\nCreate a Parzen window\nInput\n\nN: Number of points\n\n\nOutput\n\nw: Parzen window\n\n\n\n\n\n\n\n\n\n\n1.2.7.2 Example\n\nparzenwin = parzen(1024)\n\n\n\n\n\n\n\n\n\n1.2.8 Planck-taper window\nThe Planck-taper window is a window function that is defined as: \\[\nw[n] = \\begin{cases}\n0, & n = 0 \\\\\n(1 + \\text{exp}\\left(\\frac{\\epsilon N}{n} - \\frac{\\epsilon N}{\\epsilon N - n}\\right)), & 1 \\leq n &lt; \\epsilon N \\\\\n1, & \\epsilon N \\leq n &lt; N/2 \\\\\nw[N - n], & 0 \\leq n &lt; N/2 \\\\\n\\end{cases},\n\\] where \\(n \\in [0, N-1]\\) and \\(\\epsilon\\) is a parameter, defined in [0, 1] that controls the amount of tapering\n\n1.2.8.1 API\n\nplanck\n\n\n\nplanck(N, ϵ = 0.25)\nCreate a Planck-taper window\nInputs\n\nN: Number of points\n\nϵ: Parameter controlling the tapering\n\n\nOutput\n\nw: Planck-taper window\n\n\n\n\n\n\n\n\n\n\n1.2.8.2 Example\n\nplanckwin = planck(1024, 0.1)\n\n\n\n\n\n\n\n\n\n\n1.3 Choice of a window function\nThe choice of a window function depends on the application and the desired properties of the window1 2 3. Here are some general guidelines for the main windows used in structural dynamics applications:\n\nRectangular window: This window is suitable for signals which are periodic in the acquisition window or for non-periodic signals which tend to 0 whithin the time window (such as impact testing).\nHann window: This window is suitable for noisy signals. It is generally used with random signal due to its moderate impact on the frequency resolution and amplitude accuracy of porcessed signals.\nHamming window: This window is used in case of noisy measured signals as the Hann windows. However, contrary to the Hann window, the Hamming window doesn’t reach zero at its both ends.\nTukey window: This window is generally used to analyze transient data due to its shape, since it limits the alteration of the amplitude of transient signals.\nBlackman-Harris window: This window is suitable for periodic measurement signals.\nFlat-top window: This window is suitable for a calibration purposes (good reproduction of the amplitude height) and for measurements with sine excitation. However, it is not suitable for very noisy measurement signals.\nForce window: This window is an effective mechanism for reducing noise on the input channel when the input signal is impulsive.\nExponential window: This window is suitable for transient signals that decay to zero, such as acceleration signal in impact testing.",
    "crumbs": [
      "Signal processing",
      "Digital Signal Processing"
    ]
  },
  {
    "objectID": "signal_processing/index.html#anti-aliasing-filter",
    "href": "signal_processing/index.html#anti-aliasing-filter",
    "title": "Digital Signal Processing",
    "section": "2 Anti-aliasing filter",
    "text": "2 Anti-aliasing filter\nAnti-aliasing filtering is a technique used to prevent aliasing, which occurs when high-frequency components of a signal are misrepresented as lower-frequency components due to insufficient sampling. The anti_alias function in StructuralVibration.jl applies a high-order low-pass filter to the signal whose cut-off frequency is the Nyquist frequency. The proposed filter is designed using the Remez exchange algorithm implemented in DSP.jl.\n\n2.1 API\n\nanti_alias\n\n\n\nanti_alias(signal, fc; fs = 2fc)\nApply an anti-aliasing filter to a signal\nInputs\n\nsignal: Signal to be filtered\n\nfc: Cut-off frequency\n\nfs: Sampling rate\n\n\nOutput\n\nsignal: Filtered signal\n\n\n\n\n\n\n\n\n\n\n2.2 Example\n\n# Time parameters\nΔt = 1e-4\nt = 0.:Δt:10.\nfs = 1/Δt\n\n# Signal\nnt = length(t)\ny = randn(nt)\n\n# filtered signal\nyf = anti_alias(y, 2500., fs = fs)",
    "crumbs": [
      "Signal processing",
      "Digital Signal Processing"
    ]
  },
  {
    "objectID": "signal_processing/index.html#function-estimation",
    "href": "signal_processing/index.html#function-estimation",
    "title": "Digital Signal Processing",
    "section": "3 Function estimation",
    "text": "3 Function estimation\nSeveral functions can be estimated from the time domain data when operating in the frequency domain.\nThe StructuralVibration.jl package provides functions to estimate some of the most common functions used in structural dynamics applications. All the functions listed below are based on the Welch’s method and include the option to use a window function (+ its correction factor) to reduce spectral leakage and signal overlapping to reduce the variance of the estimated function or to compensate for the windowing effect.\n\n3.1 Acquisition parameters\nWhen acquiring data, the user has to define the sample rate \\(f_s\\) and the block size \\(b_s\\). The sample rate is the number of samples per second (in Hz), and the block size is the number of samples in each block. The block size is usually a power of 2, which allows for efficient computation of the FFT. From these two parameters, it is posiible to define the following parameters:\n\nSampling period: The sampling period (in s) is the time between two consecutive samples. It is defined as: \\[\n\\Delta t = \\frac{1}{f_s}.\n\\]\nAcquisition duration: The acquisition duration (in s) is the time taken to acquire a block of data. It is defined as: \\[\nT = b_s \\Delta t = \\frac{b_s}{f_s}.\n\\]\nFrequency resolution: The frequency resolution (in Hz) is the smallest frequency difference that can be resolved in the frequency domain. It is defined as: \\[\n\\Delta f = \\frac{f_s}{b_s}.\n\\]\nMaximum frequency: The maximum frequency (in Hz) is the highest frequency that can be resolved in the frequency domain and satisfying the Nyquist theorem. It is defined as: \\[\nf_{max} = \\frac{f_s}{2.56}.\n\\]\n\nAll these parameters are implemented in the FFTParameters struct, which is used in the functions to estimate the functions listed below.\n\nFFTParameters\n\n\n\nFFTParameters\nStructure to store the time and frequency parameters for the FFT analysis\nConstructor\n\nfs::Real: Sampling rate of the signal\n\nbs::Real: Block size of the signal\n\npow2::Bool: Flag for finding the next power of 2\n\n\nFields\n\nt::AbstractRange: Time vector\n\ndt::Float64: Time step\n\ntspan::Tuple{Float64, Float64}: Time span\n\nfreq::AbstractRange: Frequency vector\n\ndf::Float64: Frequency resolution\n\nfreq_span::Tuple{Float64, Float64}: Frequency span\n\nfs::Int: Sampling rate\n\nbs::Int: Block size\n\n\n\n\n\n\n\n\n\n\n3.2 Response spectrum\nThe response spectrum is basically the Fourier transform of the response of a system to a given input.\n\n3.2.1 API\n\nspectrum\n\n\n\nspectrum(input_signal, bs, window = hanning; fs = 1, overlap = 0.5,\n         nfft = bs)\nEstimation of the spectrum of a signal\nInputs\n\ninput_signal::Vector{Real}: Input signal\n\nbs::Int: Block size\n\nwindow: Window function (default: hanning)\n\nfs::Int: Sampling rate\n\noverlap: Overlap ratio between the segments\n\nnfft::Int: Number of FFT points (default: bs)\n\n\nOutputs\n\ny: Signal spectrum\n\nfreq: Frequency range\n\n\n\n\n\n\n\n\n\n\n3.2.2 Example\n\n# Structural parameters\nm = 1.\nf0 = 25.\nξ = 0.1\n\nsdof = Sdof(m, f0, ξ)\n\n# Acquisition parameters\nsample_rate = 256\nblock_size = 1024\nfft_params = FFTParameters(sample_rate, block_size)\nfreq = fft_params.freq\nt = fft_params.t\n\n# Excitation signal generation\nF0 = 10.\nchirp = SweptSine(F0, t[1], 0.8t[end], freq[1], freq[end], zero_end = true)\nx = excitation(chirp, t)\n\n# Reference signal\nprob = SdofForcedTimeProblem(sdof, [0., 0.], t, x)\ny = solve(prob).u\n\n# Frequency domain\nFx = Fx = rfft(x)[1:length(freq)]/block_size\nFx[2:end] .*= 2.\n\n# Response spectrum\nprob_y = SdofFrequencyProblem(sdof, freq, Fx)\nu = solve(prob_y).u\n\n# Spectrum stimation\nuest = spectrum(y, block_size, rect, fs = sample_rate)[1]\n\n\n\n\n\n\n\n\n\n3.3 Autopower & Cross Spectral Density functions\nAutopower functions are used to estimate the power of a signal in the frequency domain. StructuralVibration.jl allows to compute the following autopower functions:\n\nAutopower Spectrum\nAutopower Linear\nAutopower Power Spectral Density (PSD)\nAutopower Energy Spectral Density (ESD)\n\nCross Spectral Density (CSD) functions are used to estimate the relationship between two signals in the frequency domain. StructuralVibration.jl allows to compute the following CSD functions using various scaling options:\n\nCross Spectral Density (CSD)\nCross Linear\nCross Power Spectral Density (CPSD)\nCross Energy Spectral Density (CESD)\n\n\n\n\n\n\n\nNote\n\n\n\nFor a detailed discussion on the differences between these functions, please refer to this excellent blogpost The Autopower function… Demystified!.\n\n\n\n3.3.1 API\n\nwelch\n\n\n\nwelch(input_signal, bs, window = hanning; fs = 1,\n      overlap = 0.5, nfft = bs, scaling = :psd)\nEstimation of one-sided Autopower functions of a signal using the Welch method\nInputs\n\ninput_signal::AbstractVector: Input signal\n\nbs::Int: Block size\n\nwindow: Window function (default: hanning)\n\nfs::Int: Sampling rate (default: 1)\n\noverlap: Overlap ratio between the segments (default: 0.5)\n\nnfft::Int: Number of FFT points (default: bs)\n\nscaling: Scale of the PSD - see https://community.sw.siemens.com/s/article/the-autopower-function-demystified for more information\n\n:psd (default) - Power Spectral Density\n\n:esd - Autopower Energy Spectral Density\n\n:spectrum - Autopower spectrum\n\n:linear - Autopower linear\n\n\n\n\nOutputs\n\npxx: Autopower\n\nfreq: Frequency range\n\n\nNotes\n\nThe welchfunction is already implemented inDSP.jlunder the namewelch_pgram. The functionwelch` is implemented here for pedagogical purposes.\n\nThe welch function is equivalent to calling csd(x, x, ...).\n\n\n\n\n\n\n\n\n\ncsd\n\n\n\ncsd(x, y, bs, window_x = hanning, window_y = window_x; fs = 1,\n    overlap = 0.5, nfft = bs, scaling = :psd)\nEstimation of the one-sided Cross-spectral density between two signals\nInputs\n\nx::AbstractVector: First signal\n\ny::AbstractVector: Second signal\n\nbs::Int: Block size\n\nwindow_x: Window function for the first signal (default: hanning)\n\nwindow_y: Window function for the second signal (default: same as window_x)\n\nfs::Int: Sampling rate (default: 1)\n\noverlap: Overlap ratio between the segments\n\nnfft::Int: Number of FFT points (default: bs)\n\nscaling: Scale of the CSD\n\n:psd (default) - Power Spectral Density\n\n:esd - Energy Spectral Density\n\n:spectrum - Spectrum\n\n:linear - Linear\n\n\n\n\nOutputs\n\npxy: Cross-spectral density\n\nfreq: Frequency range\n\n\nNotes\n\nThe csd(x, x, ...) = welch(x, ...).\n\n\n\n\n\n\n\n\n\n\n3.3.2 Example\nThis example is based on the one provided in the DSP.jl documentation. It generates a signal composed of two sine waves at 100 Hz and 150 Hz with amplitudes equal to 1 and 2 respectively, and then estimates the power spectral density using the Welch method.\n\n# Acquisition parameters\nfs = 1000\nbs = 100\n\nfft_params = FFTParameters(fs, bs)\nfreq = fft_params.freq\nt = (1:fs)/fs\n\n# Signal generation\nf = [100 150]                      # 100Hz & 150Hz frequencies\nA = [1; 2]                         # Amplitudes\nx = sin.(2π*f.*t)*A + randn(1000)\n\n# PSD estimation from DSP.jl\npsd = DSP.welch_pgram(x, bs; fs = fs, window = hamming)\npxx_ref = DSP.power(psd)\n\n# PSD estimation from StructuralVibration.jl\npxx = welch(x, bs, hamming, fs = fs)[1]\npxx_csd = csd(x, x, bs, hamming, fs = fs)[1]\n\n\n\n\n\n\n\n\n\n3.4 Frequency Response Function\nThe frequency response function (FRF) is the relation between an input \\(x\\) and the resulting output \\(y\\) of a linear and time-invariant system. Independent of the input, it is an intrinsic property of the system describing its dynamic behavior w.r.t. the frequency.\nIn practice, the FRF is computed from estimators. In StructuralVibration.jl, the following estimators are implemented:\n\nH1 estimator: It is the most common estimator used in structural dynamics. It assumes that the noise only affects the output signal. It is defined as: \\[\nH_1(\\omega) = \\frac{S_{yx}(\\omega)}{S_{xx}(\\omega)},\n\\] where \\(S_{yx}(\\omega)\\) is the cross-power spectral density between the input and output signals, and \\(S_{xx}(\\omega)\\) is the power spectral density of the input signal.\n\nGenerally, the H1 estimator estimates the anti-resonances better than the resonances4. Furthermore, as the number of averages increases, the H1 estimator converges to the true FRF.\n\nH2 estimator: It is used when the noise is assumed to affect the input signal only. It is defined as: \\[\nH_2(\\omega) = \\frac{S_{yy}(\\omega)}{S_{yx}(\\omega)},\n\\] where \\(S_{yy}(\\omega)\\) is the power spectral density of the output signal.\n\nContrary to the H1 estimator, the H2 estimator estimates the resonances better than the anti-resonances.\n\nH3 estimator: It is used when the noise is assumed to affect both the input and output signals. It is defined as the arithmetic mean of the H1 and H2 estimators: \\[\nH_3(\\omega) = \\frac{H_1(\\omega) + H_2(\\omega)}{2}.\n\\]\n\nThis estimator offers a good compromise between the H1 and H2 estimators, but it is not as commonly used as the H1 and H2 estimators.\n\nHv estimate: It is used when the noise is assumed to affect both the input and output signals. It is defined as the geometric mean of the H1 and H2 estimators: \\[\nH_v(\\omega) = \\sqrt{H_1(\\omega) H_2(\\omega)}.\n\\]\n\nIt generally provides the best overall estimate of the FRF, because the geometric mean is less sensitive to outliers than the arithmetic mean.\nThese estimators are generally completed by other information such as the coherence function, which an averaged function that how much the output is linearly related to the input. In this sense, it can be an indicator of the quality of the FRF estimate. It can also serve to check the repeatability of individual FRF estimates. It is expressed as: \\[\n\\gamma^2(\\omega) = \\frac{S_{yx}^2(\\omega)}{S_{xx}(\\omega) S_{yy}(\\omega)} = \\frac{H_1(\\omega)}{H_2(\\omega)},\n\\] where \\(S_{yx}(\\omega)\\) is the cross-power spectral density between the input and output signals, and \\(S_{xx}(\\omega)\\) and \\(S_{yy}(\\omega)\\) are the power spectral densities of the input and output signals respectively.\n\n\n\n\n\n\nNote\n\n\n\nIn absence of averaging, the coherence is equal to 1 over all the frequency range!\n\n\n\n3.4.1 API\n\ntfestimate\n\n\n\ntfestimate(input_signal::AbstractMatrix, output_signal::AbstractMatrix, bs::Int, window_input = hanning, window_output = window_input; fs::Int = 1, overlap = 0., type = :h1)\n\ntfestimate(input_signal::AbstractVector, output_signal::AbstractVector, bs::Int, window_input = hanning, window_output = window_input; fs::Int = 1, overlap = 0., type = :h1)\nEstimation of the one-sided transfer function between two signals\nInputs\n\ninput_signal::AbstractVector or AbstractMatrix: Input signal\n\noutput_signal::AbstractVector or AbstractMatrix: Output signal\n\nbs::Int Block size\n\nwindow_input: Window function for the input signal (default: hanning)\n\nwindow_output: Window function for the output signal (default: same as window_input)\n\nfs::Int: Sampling rate (default: 1)\n\noverlap::Real: Overlap ratio between the segments (default: 0.)\n\nnfft::Int: Number of FFT points (default: bs)\n\ntype::Symbol: Type of transfer function to estimate\n\n:h1 (default)\n\n:h2\n\n:h3 - h3 = (h1 + h2)/2\n\n:hv - hv = sqrt(h1*h2)\n\n\n\n\nOutputs\n\nH: Transfer function\n\nfreq: Frequency range\n\ncoh: Coherence\n\n\n\n\n\n\n\n\n\n\n3.4.2 Example\n\n# Structural parameters\nm = 1.\nf0 = 25.\nξ = 0.1\n\nsdof = Sdof(m, f0, ξ)\n\n# Acquisition parameters for one block\nsample_rate = 256\nblock_size = 1024\nfft_params = FFTParameters(sample_rate, block_size)\n\n# Reference FRF\nfreq = fft_params.freq\nprob_frf = SdofFRFProblem(sdof, freq)\nH = solve(prob_frf).u\n\n# Signal generation - Input signal\nnblocks = 5\ntb = fft_params.t\ndt = fft_params.dt\nt = tb[1]:dt:(nblocks*(tb[end] + dt) - dt)\n\nF0 = 10.\nchirp = SweptSine(F0, tb[1], 0.8tb[end], freq[1], freq[end], zero_end = true)\nx = repeat(excitation(chirp, tb), outer = nblocks)\n\n# Signal generation - Output signal\nprob = SdofForcedTimeProblem(sdof, [0., 0.], t, x)\ny = solve(prob).u\n\n# FRF estimation\nwin(x) = tukey(x, 0.25)\nH1 = tfestimate(x, y, block_size, win, fs = sample_rate)[1]",
    "crumbs": [
      "Signal processing",
      "Digital Signal Processing"
    ]
  },
  {
    "objectID": "signal_processing/index.html#footnotes",
    "href": "signal_processing/index.html#footnotes",
    "title": "Digital Signal Processing",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nM+P International, “M+P Analyzer. User Manual Revision 5.1”. 2017.↩︎\nPolytec, “Polytec Scanning Vibrometer, Theory Manual”. 2019.↩︎\nP. Avitabile, “Modal Testing: A practioner’s guide”. John Wiley & Sons. 2018.↩︎\nSimcenter Testing Knowledge. “What is a Frequency Response Function (FRF)?”. 2020. link↩︎",
    "crumbs": [
      "Signal processing",
      "Digital Signal Processing"
    ]
  },
  {
    "objectID": "signal_processing/noise.html",
    "href": "signal_processing/noise.html",
    "title": "Noise estimation & denoising",
    "section": "",
    "text": "Noise estimation and denoising are important steps in signal processing, especially in the context of structural vibration analysis. Noise can obscure the underlying signal, making it difficult to extract meaningful information. For instance, in inverse problems, noise can significantly affects the accuracy of the estimated solution when the system is ill-posed. Another example is Kalman filtering for which the noise covariance matrix is a key parameter.\nStructuralVibration.jl provides a set of tools for estimating noise in signals and for denoising them. The implemented methods can be applied to real or complex signals.\nHere, it is assumed that the noise is additive and Gaussian. This means that the noisy signal on a sensor \\(i\\), \\(\\mathbf{y}_i\\), can thus be modeled as the sum of a noise-free signal \\(\\mathbf{x}_i\\) and a noise term \\(\\mathbf{n}_i\\): \\[\n\\mathbf{y}_i = \\mathbf{x}_i + \\mathbf{n}_i,\n\\] where \\(\\mathbf{n}_i\\) is a zero-mean Gaussian noise with covariance matrix \\(\\mathbf{R}_i\\). A common assumption is that the noise covariance matrix is isotropic, implying that: \\[\n\\mathbf{R}_i = \\sigma_i^2 \\mathbf{I}_n,\n\\] where \\(\\sigma_i^2\\) is the noise variance on the channel \\(i\\) and \\(\\mathbf{I}\\) is the identity matrix of size \\(n\\) (the number of samples in the signal).",
    "crumbs": [
      "Signal processing",
      "Noise estimation & denoising"
    ]
  },
  {
    "objectID": "signal_processing/noise.html#noise-estimation",
    "href": "signal_processing/noise.html#noise-estimation",
    "title": "Noise estimation & denoising",
    "section": "1 Noise estimation",
    "text": "1 Noise estimation\nNoise estimation is the process of quantifying the level of noise present in a signal. This can be done using various methods, such as statistical analysis, spectral analysis, or model-based approaches. In StructuralVibration.jl, two main strategies are available for noise estimation:\n\nRegularization-based : These methods involve the resolution of an optimization problem.\nFiltering-based : These methods are based on a careful analysis of the statistics of a noisy signal and do not involve optimization.\n\n\n1.1 Estimation methods\n\n1.1.1 Regularization-based noise estimation\nRegularization-based noise estimation methods involve solving an optimization problem to estimate the noise variance associated to each measurement channel. The optimization problem is typically formulated as a minimization of a cost function that balances the fidelity to the data and a regularization term.\nFrom a general perspective, the denoising problem can be formulated as: \\[\n\\widehat{\\mathbf{x}}_i = \\underset{\\mathbf{x}_i}{\\text{argmin}} \\Vert \\mathbf{y}_i - \\mathbf{x}_i \\Vert_2^2 + \\lambda \\Vert \\mathbf{D} \\mathbf{x}_i \\Vert_2^2,\n\\] where \\(\\mathbf{D}\\) is generally the second order finite difference operator, \\(\\lambda\\) is a regularization parameter.\nThe solution of the previous optimization problem is given by: \\[\n\\widehat{\\mathbf{x}}_i = \\left( \\mathbf{I} + \\lambda \\mathbf{D}^\\mathsf{T} \\mathbf{D} \\right)^{-1} \\mathbf{y}_i,\n\\]\nA classical estimator of the noise variance is the biased sample variance given by: \\[\n\\widehat{\\sigma}_i^2 = \\frac{1}{n} \\Vert \\mathbf{y}_i - \\widehat{\\mathbf{x}}_i \\Vert_2^2.\n\\]\nThe main point here is to find an appropriate regularization parameter \\(\\lambda\\). In the literature, several methods have been proposed to estimate the regularization parameter. In this package, the following methods are implemented:\n\nGeneralized Cross Validation (GCV)1\nL-curve method2\n\n\n\n\n\n\n\nNote\n\n\n\nIn practice, this estimator can be computed without computing the denoised signal \\(\\widehat{\\mathbf{x}}_i\\) explicitly. To do so, the implementation makes use of the discrete cosine transform (DCT).\n\n\n\n\n1.1.2 Filtering-based noise estimation\nHeuristic-based noise estimation methods are based on a careful analysis of the statistics of a noisy signal and often rely on the assumption that the noise is Gaussian. These methods do not involve optimization and are typically faster than regularization-based methods. They can be used to estimate the noise variance directly from the noisy signal. StructuralVibration.jl implements the method proposed John D’Errico in the Matlab function estimatenoise.m3\n\n\n\n1.2 API\nData types\n\nGCVEst\n\n\n\nGCVEst\nGeneralized Cross-Validation (GCV) noise estimation\nThis method has been proposed by Garcia in [1]\nFields\n\nnothing\n\n\nReference\n[1] Garcia, D. (2010). Robust smoothing of gridded data in one and higher dimensions with missing values. Computational Statistics and Data Analysis, 54(5), 1167-1178\n\n\n\n\n\n\n\nLCurveEst\n\n\n\nLCurveEst\nL-curve noise estimation\nThis method is based on the method proposed by Hansen in [1]\nFields\n\nnothing\n\n\nReference\n[1] Hansen, P. C. (1999). The L-curve and its use in the numerical treatment of inverse problems. Computational Inverse Problems in Electrocardiology, 119-142\n\n\n\n\n\n\n\nDerricoEst\n\n\n\nDerricoEst\nD'Errico noise estimation\nThis method has been proposed by John D'Errico in [1]\nFields\n\nnothing\n\n\nReference\n[1] John D'Errico (2023). Estimatenoise, MATLAB Central File Exchange. Retrieved December 7, 2023. (https://www.mathworks.com/matlabcentral/fileexchange/16683-estimatenoise)\n\n\n\n\n\n\nRelated function\n\nvarest\n\n\n\nvarest(x, method::NoiseEstimation; batch_size = 0, summary = mean)\nEstimates the noise variance of a signal x using a given method\nInputs\n\nx: Signal\n\nmethod: Noise estimation method\n\nBayesianEst: Bayesian noise estimation (To be implemented)\n\nGCVEst: Generalized Cross-Validation (GCV) noise estimation\n\nLCurveEst: L-curve noise estimation\n\nDerricoEst: D'Errico noise estimation\n\n\n\nbatch_size::Int: Batch size for batch processing (default = 0)\n\nsummary: Summary function for batch processing (default = mean)\n\n\n\n\n\n\n\n\n\n\n1.3 Example\n\n# Beam definition\nL = 1.\nb = 3e-2\nh = 1e-2\nE = 2.1e11\nρ = 7850.\nξn = 1e-2\nS = b*h\nIz = b*h^3/12.\n\nbeam = Beam(L, S, Iz, E, ρ)\n\n# Measurement mesh\nΔx = 5e-2\nNpoint = 20\nXm = LinRange(Δx, L - Δx, Npoint)\n\n# Modes calculation\nωn, kn = modefreq(beam, 2000.)\nϕm = modeshape(beam, kn, Xm)\nϕe = modeshape(beam, kn, Xm[13])\n\n# Modal model\nKn, Mn, Cn = modal_matrices(ωn, ξn)\n\n# Excitation\ntmax = 0.5\nnt = 10_000\nt = LinRange(0., tmax, nt)\n\nharmo = SineWave(1e4, 0., tmax, 2π*10.)\nF = excitation(harmo, t)\nFn = ϕe'*F'\n\n# Solution calculation\nu0 = (zeros(length(ωn)), zeros(length(ωn)))\nprob = DirectTimeProblem(Kn, Mn, Cn, Fn, u0, t)\nu = ϕm*solve(prob).u\n\n# Signal corruption - Additive Gaussian White Noise\nSNR_ref = 25.\ny = agwn(u, SNR_ref)\n\n# Variance estimation - Average over all channels\nv1 = varest(y, GCVEst())\nSNR_est1 = mean(estimated_SNR(y, v1))\n\nv2 = varest(y, LCurveEst())\nSNR_est2 = mean(estimated_SNR(y, v2))\n\nv3 = varest(y, DerricoEst())\nSNR_est3 = mean(estimated_SNR(y, v3))\n\n\n\n\n\nNoise variance estimation\n\n\nReference\nGCV\nL-curve\nD'Errico\n\n\n25.0 dB\n25.16 dB\n25.1 dB\n25.05 dB",
    "crumbs": [
      "Signal processing",
      "Noise estimation & denoising"
    ]
  },
  {
    "objectID": "signal_processing/noise.html#signal-denoising",
    "href": "signal_processing/noise.html#signal-denoising",
    "title": "Noise estimation & denoising",
    "section": "2 Signal denoising",
    "text": "2 Signal denoising\nSignal denoising is the process of removing noise from a signal to recover the underlying clean signal. This can be done using various methods, such as filtering, wavelet transforms, or model-based approaches. In StructuralVibration.jl, the denoising process is typically performed using the same methods as those used for noise estimation. As for noise estimation, the proposed methods can be applied to real or complex signals.\n\n2.1 Denoising methods\nStructuralVibration.jl proposes two main methods for denoising signals:\n\nRegularization-based denoising: This method involves solving an optimization problem to estimate the noise-free signal. The optimization problem is typically formulated as a minimization of a cost function that balances the fidelity to the data and a regularization term.\nFiltering-based denoising: This method is based on the implementation of a Kalman filter, which is a recursive algorithm that estimates the state of a dynamic system from a series of noisy measurements.\n\n\n2.1.1 Regularization-based denoising\nRegularization-based denoising consists in solving the minimization problem defined in Section 1.1.1. This implies a proper estimation of the regularization parameter \\(\\lambda\\). Similar to the noise estimation process, two methods are available for estimating the regularization parameter, namely GCV and L-curve methods.\n\n\n2.1.2 Filtering-based denoising\nAs stated above, filtering-based denoising is based on the implementation of a Kalman filter. For denoising problems, the Kalman filter is based on the following state-space model: \\[\n\\begin{cases}\n\\mathbf{x}_{k+1} = \\mathbf{x}_k + \\mathbf{w}_k \\\\\n\\mathbf{y}_k = \\mathbf{x}_k + \\mathbf{n}_k\n\\end{cases},\n\\] where \\(\\mathbf{x}_k\\) is the state vector (clean signal) at time \\(k\\), \\(\\mathbf{y}_k\\) is the measurement vector at time \\(k\\), \\(\\mathbf{w}_k\\) is the process noise, and \\(\\mathbf{n}_k\\) is the measurement noise. The process noise is assumed to be zero-mean Gaussian with constant covariance matrix \\(\\mathbf{Q}\\), and the measurement noise is assumed to be zero-mean Gaussian with constant covariance matrix \\(\\mathbf{R}\\).\nPractically, a Kalman filter is implemented in two steps:\n\nPrediction step: The state vector and its covariance matrix are predicted based on the knowledge of the solution at the previous step. \\[\n\\begin{align*}\n\\widetilde{\\mathbf{x}}_{k} &= \\widehat{\\mathbf{x}}_{k-1} \\\\\n\\widetilde{\\mathbf{P}}_{k} &= \\widehat{\\mathbf{P}}_{k-1} + \\mathbf{Q}\n\\end{align*},\n\\] where \\(\\widetilde{\\mathbf{x}}_{k}\\) is the predicted state vector, \\(\\widehat{\\mathbf{x}}_{k-1}\\) is the estimated state vector at step \\(k-1\\), \\(\\widetilde{\\mathbf{P}}_{k}\\) is the predicted covariance matrix, and \\(\\widehat{\\mathbf{P}}_{k-1}\\) is the estimated covariance matrix at step \\(k-1\\).\nUpdate step: The state vector and its covariance matrix are updated based on the measurement at the current step. \\[\n\\begin{align*}\n\\mathbf{i}_k &= \\mathbf{y}_k - \\widetilde{\\mathbf{x}}_{k} \\\\\n\\mathbf{S}_k &= \\widetilde{\\mathbf{P}}_{k} + \\mathbf{R} \\\\\n\\mathbf{K}_{k} &= \\widetilde{\\mathbf{P}}_{k} \\mathbf{S}_k^{-1} \\\\\n\\widehat{\\mathbf{x}}_{k} &= \\widetilde{\\mathbf{x}}_{k} + \\mathbf{K}_{k} \\mathbf{i}_k \\\\\n\\widehat{\\mathbf{P}}_{k} &= \\left( \\mathbf{I} - \\mathbf{K}_{k}\\right) \\widetilde{\\mathbf{P}}_{k}\n\\end{align*},\n\\] where \\(\\widehat{\\mathbf{x}}_{k}\\) is the updated state vector, \\(\\widehat{\\mathbf{P}}_{k}\\) is the updated covariance matrix and \\(\\mathbf{K}_{k}\\) is the Kalman gain, \\(\\mathbf{i}_k\\) is the innovation vector and \\(\\mathbf{S}_k\\) is the innovation covariance matrix.\n\nFor a successful denoising process, the Kalman filter requires a proper tuning of the noise covariance matrices \\(\\mathbf{Q}\\) and \\(\\mathbf{R}\\) as wel as a proper initialization of the state vector and its covariance matrix.\nHere, the measurement noise covariance matrix \\(\\mathbf{R}\\) is estimated using the methods described in the previous section. The process noise covariance matrix \\(\\mathbf{Q}\\) is assumed to be isotropic and its variance \\(\\sigma_x^2\\) results from the resolution of the following optimization problem: \\[\n\\widehat{\\sigma}_x^2 = \\underset{\\sigma_x^2}{\\text{argmin}} \\sum_{i = 1}^N \\left[\\log|\\mathbf{S}_k| + \\mathbf{i}_k^\\mathsf{T}\\mathbf{S}_k^{-1}\\mathbf{i}_k\\right],\n\\] where \\(N\\) is the length of the measurement sequence.\nIn addition to the filtering step, a smoothing step can be added. In the present case, a Rauch-Tung-Striebel (RTS) smoother is used. From a practical point of view, the RTS smoother is implemented as a post-processing step that uses the Kalman filter output to improve the estimate of the state vector. The RTS smoother is based on the following equations: \\[\n\\begin{align*}\n\\widehat{\\mathbf{x}}_k^s &= \\widehat{\\mathbf{x}}_k + \\mathbf{K}_k \\left( \\widehat{\\mathbf{x}}_{k+1}^s - \\widehat{\\mathbf{x}}_k \\right) \\\\\n\\widehat{\\mathbf{P}}_k^s &= \\widehat{\\mathbf{P}}_k + \\mathbf{K}_k \\left( \\widehat{\\mathbf{P}}_{k+1}^s - \\widehat{\\mathbf{P}}_k \\right) \\mathbf{K}_k^\\mathsf{T} \\\\\n\\mathbf{K}_k &= \\widehat{\\mathbf{P}}_k (\\widehat{\\mathbf{P}}_k + \\mathbf{Q})^{-1} \\\\\n\\end{align*},\n\\] where \\(\\widehat{\\mathbf{x}}_k^s\\) is the smoothed state vector, \\(\\widehat{\\mathbf{P}}_k^s\\) is the smoothed covariance matrix, and \\(\\mathbf{K}_k\\) is the Kalman gain.\n\n\n\n2.2 API\nData types\n\nGCVDenoising\n\n\n\nGCVDenoising()\nRegularization-based denoising method using the GCV method for estimating the regularization parameter\nFields\n\nnothing\n\n\nReference\n[1] Garcia, D. (2010). Robust smoothing of gridded data in one and higher dimensions with missing values. Computational Statistics and Data Analysis, 54(5), 1167-1178\n\n\n\n\n\n\n\nLCurveDenoising\n\n\n\nLCurveDenoising()\nRegularization-based denoising method using the L-curve method for estimating the regularization parameter\nFields\n\nnothing\n\n\nReference\n[1] Hansen, P. C. (1999). The L-curve and its use in the numerical treatment of inverse problems. Computational Inverse Problems in Electrocardiology, 119-142\n\n\n\n\n\n\n\nKalmanDenoising\n\n\n\nKalmanDenoising(; rts = false)\nKalman filter denoising method\nFields\n\nrts: Flag to enable the Rauch-Tung-Striebel smoother\n\n\n\n\n\n\n\n\nRelated function\n\ndenoising\n\n\n\ndenoising(y::AbstractArray, alg)\nDenoises a signal y\nInputs\n\ny: Noisy signal\n\nalg: Denoising method\n\nBayesDenoising: Bayesian Regularization denoising method (to be implemented)\n\nGCVDenoising: GCV denoising method\n\nLCurveDenoising: L-curve denoising method\n\nKalmanDenoising: Kalman filter denoising method\n\n\n\n\nOutput\n\nx: Denoised signal\n\n\n\n\n\n\n\n\n\n\n2.3 Example\n\n# Beam definition\nL = 1.\nb = 3e-2\nh = 1e-2\nE = 2.1e11\nρ = 7850.\nξn = 1e-2\nS = b*h\nIz = b*h^3/12.\n\nbeam = Beam(L, S, Iz, E, ρ)\n\n# Measurement mesh\nΔx = 5e-2\nNpoint = 20\nXm = LinRange(Δx, L - Δx, Npoint)\n\n# Modes calculation\nωn, kn = modefreq(beam, 2000.)\nϕm = modeshape(beam, kn, Xm)\nϕe = modeshape(beam, kn, Xm[13])\n\n# Modal model\nKn, Mn, Cn = modal_matrices(ωn, ξn)\n\n# Problem definition & solution\ntmax = 0.1\nnt = 5_000\nt = LinRange(0., tmax, nt)\n\nharmo = SineWave(1e4, 0., tmax, 2π*10.)\nF = excitation(harmo, t)\nFn = ϕe'*F'\n\nu0 = (zeros(length(ωn)), zeros(length(ωn)))\nprob = DirectTimeProblem(Kn, Mn, Cn, Fn, u0, t)\nsol = solve(prob)\n\nu = ϕm*sol.u\n\n# Gaussian White Noise\nsnr_dB = 10.\ny = agwn(u, snr_dB)\n\n# Regularization denoising\nyc_gcv = denoising(y, GCVDenoising())\nyc_lcurve = denoising(y, LCurveDenoising())\n\n# Kalman denoising\nyc_kalman = denoising(y, KalmanDenoising())\nyc_rts = denoising(y, KalmanDenoising(rts = true))",
    "crumbs": [
      "Signal processing",
      "Noise estimation & denoising"
    ]
  },
  {
    "objectID": "signal_processing/noise.html#footnotes",
    "href": "signal_processing/noise.html#footnotes",
    "title": "Noise estimation & denoising",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nD. Garcia. “Robust smoothing of gridded data in one and higher dimensions with missing values”. Computational Statistics & Data Analysis, 54(5), pp. 1167-1178, 2010.↩︎\nP. C. Hansen. “The L-curve and its use in the numerical treatment of inverse problems”. Computational Inverse Problems in Electrocardiology, pp. 119-142, 2001.↩︎\nJohn D’Errico. “Estimatenoise”, MATLAB Central File Exchange. Retrieved December 7, 2023. Link↩︎",
    "crumbs": [
      "Signal processing",
      "Noise estimation & denoising"
    ]
  },
  {
    "objectID": "modal_extraction/index.html",
    "href": "modal_extraction/index.html",
    "title": "Primer on EMA",
    "section": "",
    "text": "The modal approach enables the dynamic behavior of a structure to be predicted based on knowledge of its natural modes of vibration, which are intrinsic to the system. From a practical point of view, this information can be used to determine the frequencies at which the structure is most likely to vibrate. For industry, this information is invaluable, as vibrations can cause discomfort, noise, premature wear and tear, or even damage to a system. This is where Experimental Modal Analysis (EMA) comes in. Experimental identification of vibration modes can also be used to calibrate a finite element model or certify a product (e.g. ground vibration testing or regulations related to the modal behavior of the structure).\nEMA aims to estimate the natural frequencies of the system and other characteristic parameters (e.g. damping ratios and mode shapes) from the vibration measurements in order to obtain a modal model of the system under consideration. This model can then be used to determine the structure’s dynamic behaviour for a given excitation.\nTo reach these goals, it is supposed that:\nEMA is a family of inverse methods attempting to determine the modal characteristics of a structure from the responses measured at each point of the mesh.",
    "crumbs": [
      "Modal extraction",
      "Primer on EMA"
    ]
  },
  {
    "objectID": "modal_extraction/index.html#general-principles",
    "href": "modal_extraction/index.html#general-principles",
    "title": "Primer on EMA",
    "section": "1 General principles",
    "text": "1 General principles\nTo identify the modal parameters of a structure or mechanical system, EMA relies on the measurement of the structure’s transfer function matrix. By definition, the transfer function \\(H_{pq}(\\omega)\\) can be seen as the frequency response of the system at a point \\(x_p\\) to an excitation of unit amplitude at a point \\(x_q\\). Classically, the transfer function matrix (here the admittance) is given by the relation\n\\[\nH_{pq}(\\omega) = \\sum_{i = 1}^{+\\infty} \\frac{\\phi_i(x_p)\\, \\phi_i(x_q)}{M_i(\\omega_i^2 - \\omega^2 + 2j\\xi_i\\omega_i\\omega)} = \\sum_{i = 1}^{+\\infty} \\left[\\frac{{}_i R_{pq}}{(j\\omega - \\lambda_i)} + \\frac{{}_i R_{pq}^\\ast}{(j\\omega - \\lambda_i^\\ast)}\\right],\n\\] where:\n\n\\(\\lambda_i = -\\xi_i + j\\,\\Omega_i\\) is the pole related to the mode \\(i\\), with:\n\n\\(\\Omega_i = \\omega_i\\sqrt{1 - \\xi_i^2}\\) is the damped natural frequency of the mode \\(i\\), with \\(\\omega_i = \\vert \\lambda_i\\vert\\).\n\\(\\xi_i = -\\frac{\\text{Re}(\\lambda_i)}{\\omega_i}\\) the modal damping factor of the mode \\(i\\) \n\n\\({}_i R_{pq} = c_i\\, \\phi_i(x_p)\\, \\phi_i(x_q)\\) is the residue of the mode \\(i\\), with:\n\n\\(\\phi_i(x_p)\\) the mode shape of the mode \\(i\\) at point \\(x_p\\)\n\\(c_i = \\frac{1}{2jM_i\\Omega_i}\\) the normalization constant of the mode shape of the mode \\(i\\)\n\n\nThe objective of an EMA is therefore to identify the residuals \\({}_i R_{pq}\\) and the poles \\(\\lambda_i\\) of the transfer function \\(H_{pq}(\\omega)\\) in order to extract, in a second step, the modal parameters of the system under study (natural angular frequencies \\(\\omega_i\\), modal damping factors \\(\\xi_i\\) and mode shapes \\(\\phi_i\\)).",
    "crumbs": [
      "Modal extraction",
      "Primer on EMA"
    ]
  },
  {
    "objectID": "modal_extraction/index.html#modal-parameters-extraction-methods",
    "href": "modal_extraction/index.html#modal-parameters-extraction-methods",
    "title": "Primer on EMA",
    "section": "2 Modal parameters extraction methods",
    "text": "2 Modal parameters extraction methods\nIn this StructuralVibration.jl, two families of modal extraction methods are implemented:\n\nmethods based on the use of single degree of freedom (sdof) models, known as Sdof methods. These methods seek to adjust ideal transfer functions of Sdof systems to experimental curves around their resonances. These methods therefore consist of identifying the modal parameters mode by mode. To do this, the operator must select a frequency band around each resonance to perform the extraction. Currently, three Sdof methods are implemented in this package:\n\nPeak Picking method\nCircle Fit method\nLeast Squares Fit method\n\nmethods based on the use of multiple degree of freedom (mdof) models, known as Mdof methods. These methods consider that the system can be represented as a multiple degree of freedom system. They are generally based on the construction of a high-order polynomial matrix whose coefficients are estimated from the measured transfer functions.Three Mdof methods are implemented in this package:\n\nLeast-Squares Complex Exponential method\nLeast-Squares Complex Frequency-domain method\nPolyreference Least-Squares Complex Frequency-domain method",
    "crumbs": [
      "Modal extraction",
      "Primer on EMA"
    ]
  },
  {
    "objectID": "modal_extraction/mdof_methods.html",
    "href": "modal_extraction/mdof_methods.html",
    "title": "Mdof methods",
    "section": "",
    "text": "The Mdof methods are based on the assumption that the system can be represented as a multiple degree of freedom system. They are generally based on the construction of a high-order polynomial matrix whose coefficients are estimated from the measured FRFs. As for the SDOF methods, the estimation of the modal parameters is divided into two steps:",
    "crumbs": [
      "Modal extraction",
      "Mdof methods"
    ]
  },
  {
    "objectID": "modal_extraction/mdof_methods.html#natural-frequencies-and-damping-ratios-extraction",
    "href": "modal_extraction/mdof_methods.html#natural-frequencies-and-damping-ratios-extraction",
    "title": "Mdof methods",
    "section": "1 Natural frequencies and damping ratios extraction",
    "text": "1 Natural frequencies and damping ratios extraction\nThe poles of the system are then obtained as the roots of the characteristic polynomial associated with this polynomial matrix. Three methods are implemented in this package:\n\nthe Least-Squares Complex Exponential (LSCE) method,\nthe Least-Squares Complex Frequency-domain (LSCF) method.\nthe Polyreference Least-Squares Complex Frequency-domain (pLSCF) method,\n\n\n1.1 LSCE method\nThe LSCE method is based on the assumption that the system can be modeled as a sum of complex exponentials in the time domain. The impulse response function (IRF) between an output \\(o\\) (\\(o = 1, \\ldots, n_o\\)) and an input \\(i\\) (\\(i = 1, \\ldots, n_i\\)) can be modeled as: \\[\nh_{oi}(t) = \\sum_{k = 1}^n \\left(c_k e^{\\lambda_k t} + c_k^\\ast e^{-\\lambda_k^\\ast t}\\right) = 2 Re\\left(\\sum_{k = 1}^n c_k e^{\\lambda_k t}\\right).\n\\]\nWhen sampling the IRF at a sampling period \\(T_s\\), one obtains the following discrete-time model: \\[\nh_{oi}[m] = 2 Re\\left(\\sum_{k = 1}^n c_k z_k^m\\right) \\text{ with } z_k = e^{\\lambda_k T_s},\n\\] for \\(m = 0, 1, \\ldots, 2n\\), (\\(n\\) is the model order). According to the Prony’s method, the poles \\(\\lambda_k\\) can be calculated from the roots of the following characteristic polynomial: \\[\n\\sum_{m = 0}^{2n} \\beta_m z_k^m = 0 \\text{ with } \\beta_{2n} = 1.\n\\]\nThe coefficients \\(\\beta_l\\) of the characteristic polynomial can be estimated from the sampled IRF \\(h_{oi}[m]\\). Todo so, one first multiply \\(h_{oi}[m]\\) by the corresponding coefficients \\(\\beta_m\\) and then sums the resulting equations for \\(m = 0, 1, \\ldots, 2n\\). This leads to the following homogeneous set of equations: \\[\n\\sum_{m = 0}^{2n} \\beta_m h_{oi}[m] = 2 Re\\left(\\sum_{k = 1}^{n} c_k \\sum_{m = 0}^{2n} \\beta_m z_k^m\\right).\n\\]\nWhen \\(z_k\\) is a root of the characteristic polynomial, the right-hand side of the previous equation is equal to zero. Therefore, one can estimate the coefficients \\(\\beta_m\\) by solving the following set of linear equations: \\[\n\\sum_{m = 0}^{2n} \\beta_m h_{oi}[m] = 0.\n\\]\nThe previous equation can be derived using different set of data points, \\(h_{oi}[m]\\), \\(h_{oi}[m+1]\\), \\(\\ldots\\), \\(h_{oi}[m + 2n]\\) to obtain an overdetermined set of linear equations that can be solved in the least-squares sense1. In this package, the coefficients \\(\\beta_m\\) are estimated by solving the following set of equations: \\[\n\\begin{bmatrix}\nh_{oi}[0] & h_{oi}[1] & \\ldots & h_{oi}[2n-1] \\\\\nh_{oi}[1] & h_{oi}[2] & \\ldots & h_{oi}[2n] \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\nh_{oi}[2n-1] & h_{oi}[2n] & \\ldots & h_{oi}[4n-2]\n\\end{bmatrix}\n\\begin{bmatrix}\n\\beta_0 \\\\\n\\beta_1 \\\\\n\\vdots \\\\\n\\beta_{2n-1}\n\\end{bmatrix}\n= -\\begin{bmatrix}\nh_{oi}[2n] \\\\\nh_{oi}[2n+1] \\\\\n\\vdots \\\\\nh_{oi}[4n-1]\n\\end{bmatrix}\n\\]\nOnce the coefficients \\(\\beta_m\\) are estimated, the poles \\(\\lambda_k\\) can be obtained from the roots \\(z_k\\) of the characteristic polynomial.\n\n\n1.2 LSCF method\nAccording to Guillaume et al. 2, the transfer function between an output \\(o\\) (\\(o = 1, \\ldots, n_o\\)) and an input \\(i\\) (\\(i = 1, \\ldots, n_i\\)) can be modeled in the frequency domain as: \\[\n\\widehat{H}_k(\\omega) = \\frac{N_k(\\omega)}{d(\\omega)},\n\\] where \\(k = 1, \\ldots, n_o n_i\\) (\\(k = (o - 1) n_i + i\\)). Here, \\(N_k(\\omega)\\) is the \\(k\\)-th element of the numerator matrix defined as: \\[\nN_k(\\omega) = \\mathbf{\\Omega}(\\omega)^T \\boldsymbol{\\beta}_k,\n\\] while \\(d(\\omega)\\) is the common denominator polynomial defined as: \\[\nd(\\omega) = \\mathbf{\\Omega}(\\omega)^T \\boldsymbol{\\alpha}.\n\\]\nIn the previous equations, \\(\\mathbf{\\Omega}(\\omega)\\) is the vector of polynomial basis functions defined as: \\[\n\\mathbf{\\Omega}(\\omega)^T = [1, \\Omega_1(\\omega), \\ldots, \\Omega_n(\\omega)] \\text{ with } \\Omega_n(\\omega) = \\exp(-i\\omega n T_s),\n\\] where \\(n\\) is the order of the denominator polynomial (a.k.a the model order) and \\(T_s\\) is the sampling period. The vectors \\(\\boldsymbol{\\beta}_k\\) and \\(\\boldsymbol{\\alpha}\\) contain the coefficients of the numerator and denominator polynomials, respectively.\nBased on the previous formulation of the FRFs, the LSCF method consists in estimating the coefficients of the numerator \\(\\boldsymbol{\\beta}_k\\) and denominator \\(\\boldsymbol{\\alpha}\\) polynomials by minimizing the following functional: \\[\nJ(\\boldsymbol{\\theta}) = \\sum_{k=1}^{n_o n_i} \\sum_{j=1}^{n_f} \\left| W_k(\\omega_j)\\left[H_k(\\omega_j) d(\\omega_j) - N_k(\\omega_j)\\right] \\right|^2,\n\\] where \\(\\boldsymbol{\\theta} = [\\boldsymbol{\\beta}_1^T, \\ldots, \\boldsymbol{\\beta}_{n_o n_i}^T, \\boldsymbol{\\alpha}^T]^T\\) is the vector of unknown parameters to be estimated, \\(H_k(\\omega_j)\\) is the measured FRF at frequency \\(\\omega_j\\), \\(n_f\\) is the number of frequency lines used for the identification and \\(W_k(\\omega_j)\\) is an arbitrary weighting function. In this package, a unitary weighting function is used, i.e. \\(W_k(\\omega_j) = 1\\).\nThe poles of the transfer function are obtained from the roots of the characteristic polynomial associated with the denominator polynomial \\(d(\\omega)\\), which are computed after having estimated the coefficients \\(\\boldsymbol{\\alpha}\\) as the argument of the minimum of the functional \\(J(\\boldsymbol{\\theta})\\) (see Ref. [2] for details).\n\n\n1.3 pLSCF method\nThe pLSCF method is an extension of the LSCF method that makes it possible to take into account multiple reference sensors simultaneously (see Ref. [2] for details). When using only one reference sensor, the pLSCF method is equivalent to the LSCF method.\nIn this approach, the transfer function \\(\\widehat{\\mathbf{H}}_o(\\omega) \\in \\mathbb{C}^{1 \\times n_i}\\) between an output \\(o\\) (\\(o = 1, \\ldots, n_o\\)) and a set of \\(n_i\\) inputs can be modeled in the frequency domain as: \\[\n\\widehat{\\mathbf{H}}_o(\\omega) = \\mathbf{N}_o(\\omega) \\mathbf{D}(\\omega)^{-1},\n\\] where \\(\\mathbf{N}_o(\\omega) \\in \\mathbb{C}^{1 \\times n_i}\\) is the numerator matrix defined as: \\[\n\\mathbf{N}_o(\\omega) = \\mathbf{\\Omega}(\\omega)^T \\boldsymbol{\\beta}_o,\n\\] while \\(\\mathbf{D}(\\omega) \\in \\mathbb{C}^{n_i \\times n_i}\\) is the denominator matrix defined as: \\[\n\\mathbf{D}(\\omega) = \\mathbf{\\Omega}(\\omega)^T \\boldsymbol{\\alpha}.\n\\]\nBased on the previous formulation of the FRFs, the pLSCF method consists in estimating the coefficients of the numerator \\(\\boldsymbol{\\beta}_o\\) and denominator \\(\\boldsymbol{\\alpha}\\) polynomials. To this end, one defines the weighted error between the measured and modeled FRFs as: \\[\n\\boldsymbol{\\varepsilon}_o(\\omega_j, \\boldsymbol{\\theta}) = W_o(\\omega_j)\\left[\\mathbf{H}_o(\\omega_j) \\mathbf{D}(\\omega_j) - \\mathbf{N}_o(\\omega_j)\\right]\n\\]\nThen, an error matrix \\(\\mathbf{E}_o(\\boldsymbol{\\theta}) \\in \\mathbb{C}^{n_f \\times n_i}\\) is constructed by stacking the weighted errors \\(\\boldsymbol{\\varepsilon}_o(\\omega_j, \\boldsymbol{\\theta}) \\in \\mathbb{C}^{1 \\times n_i}\\) for all frequency lines, that is: \\[\n\\mathbf{E}_o(\\boldsymbol{\\theta}) = \\begin{bmatrix}\n\\boldsymbol{\\varepsilon}_o(\\omega_1, \\boldsymbol{\\theta}) \\\\\n\\vdots \\\\\n\\boldsymbol{\\varepsilon}_o(\\omega_{n_f}, \\boldsymbol{\\theta})\n\\end{bmatrix}\n\\]\nFinally, the coefficients of the numerator and denominator polynomials are estimated by minimizing the following functional: \\[\nJ(\\boldsymbol{\\theta}) = \\sum_{o=1}^{n_o} \\Vert\\mathbf{E}_o(\\boldsymbol{\\theta})\\Vert^2.\n\\]\nThe poles of the transfer function are obtained from the characteristic polynomial associated with the denominator matrix \\(\\mathbf{D}(\\omega)\\), by computing the eigenvalues of the so-called companion matrix3.\n\n\n1.4 Stabilization diagram\nWhen carrying out an EMA, the main question that arises is how many modes (or, more precisely, poles) are contained within the frequency band of interest. Analyzing the frequency response functions (transfer functions) provides an initial estimate. However, it is difficult to distinguish between multiple or nearby modes.\nThe stabilisation diagram is a fundamental EMA tool as it provides a clear and concise presentation of the poles of the system under study. The idea is to adjust the transfer function model by increasing the number of poles and displaying the results on a graph. Broadly speaking, increasing the order of the model (i.e. the number of poles) causes the true vibration modes to converge to a stable value, whereas the numerical modes appear inconsistently or randomly on the graph. Thus, as the poles converge to stable ones, markers appear on the graph to indicate the identified poles, as the order of the model is gradually increased. The selection of poles is generally based on the stability of natural frequencies, modal damping and/or mode shapes, moving from a model order \\(n\\) to an order \\(n + 1\\). In this package, the stability of the natural frequencies and damping ratios is used to identify the physical poles of the system. The stability criterion is set to 1% for the natural frequencies and 5% for the damping ratios, following common practice in the EMA field.\nIn StructuralVibration.jl, the stabilization diagram can be obtained using the stabilization function along with any of the Mdof methods described above. The identified stable poles can then be visualized using the stabilization_plot function. The stabilization function returns an EMAMdofStabilization structure that contains all the information related to the stabilization analysis, which allows the user to manually select the appropriate poles and to further analyze (e.g. by using quality and analysis indicators) and visualize the results.",
    "crumbs": [
      "Modal extraction",
      "Mdof methods"
    ]
  },
  {
    "objectID": "modal_extraction/mdof_methods.html#mode-shapes-extraction",
    "href": "modal_extraction/mdof_methods.html#mode-shapes-extraction",
    "title": "Mdof methods",
    "section": "2 Mode shapes extraction",
    "text": "2 Mode shapes extraction\nOnce the poles of the system have been identified using one of the Mdof methods described above, the residues can be computed to extract the mode shapes. In this package, the residues are computed using a least-squares approach based on the formulation of the FRFs as a sum of rational functions. The FRF between an output \\(p\\) (\\(p = 1, \\ldots, n_o\\)) and an input \\(q\\) (\\(q = 1, \\ldots, n_i\\)) can be expressed as: \\[\nH_{pq}(\\omega) = \\sum_{i = 1}^n \\left(\\frac{{}_iR_{pq}}{j\\omega - \\lambda_i} + \\frac{{}_iR_{pq}^\\ast}{j\\omega - \\lambda_i^\\ast}\\right),\n\\] where \\(R_{k, pq}\\) is the residue associated with the pole \\(\\lambda_k\\).\nAt a frequency line \\(\\omega\\), the previous equation can be rewritten in matrix form as: \\[\nH_{pq}(\\omega) = \\begin{bmatrix}\n\\frac{1}{j\\omega - \\lambda_1} & \\ldots & \\frac{1}{j\\omega - \\lambda_n} & \\frac{1}{j\\omega - \\lambda_1^\\ast} & \\ldots & \\frac{1}{j\\omega - \\lambda_n^\\ast}\n\\end{bmatrix}\n\\begin{bmatrix}\n{}_1R_{pq} \\\\\n\\vdots \\\\\n{}_nR_{pq} \\\\\n{}_1R_{pq}^\\ast \\\\\n\\vdots \\\\\n{}_nR_{pq}^\\ast\n\\end{bmatrix}\n\\]\nRepeating the previous equation for all frequency lines leads to the following system of equations: \\[\n\\begin{bmatrix}\nH_{pq}(\\omega_1) \\\\\nH_{pq}(\\omega_2) \\\\\n\\vdots \\\\\nH_{pq}(\\omega_{n_f})\n\\end{bmatrix}\n= \\begin{bmatrix}\n\\frac{1}{j\\omega_1 - \\lambda_1} & \\ldots & \\frac{1}{j\\omega_1 - \\lambda_n} & \\frac{1}{j\\omega_1 - \\lambda_1^\\ast} & \\ldots & \\frac{1}{j\\omega_1 - \\lambda_n^\\ast} \\\\\n\\frac{1}{j\\omega_2 - \\lambda_1} & \\ldots & \\frac{1}{j\\omega_2 - \\lambda_n} & \\frac{1}{j\\omega_2 - \\lambda_1^\\ast} & \\ldots & \\frac{1}{j\\omega_2 - \\lambda_n^\\ast} \\\\\n\\vdots & \\vdots & \\vdots & \\vdots & \\vdots & \\vdots & \\vdots & \\vdots \\\\\n\\frac{1}{j\\omega_{n_f} - \\lambda_1} & \\ldots & \\frac{1}{j\\omega_{n_f} - \\lambda_n} & \\frac{1}{j\\omega_{n_f} - \\lambda_1^\\ast} & \\ldots & \\frac{1}{j\\omega_{n_f} - \\lambda_n^\\ast}\n\\end{bmatrix}\n\\begin{bmatrix}\n{}_1R_{pq} \\\\\n\\vdots \\\\\n{}_nR_{pq} \\\\\n{}_1R_{pq}^\\ast \\\\\n\\vdots \\\\\n{}_nR_{pq}^\\ast\n\\end{bmatrix}\n\\]\nThis system of equations can be solved in the least-squares sense to estimate the residues \\({}_iR_{pq}\\). This procedure is implemented in the mode_residues function.\nFrom the estimated residues, the mode shapes can be extracted using the following relation: \\[\n{}_iR_{pq} = c_i \\phi_{p,i} \\phi_{q,i},\n\\] where \\(c_i\\) is a scaling factor, \\(\\phi_{p,i}\\) (resp. nd \\(\\phi_{q,i}\\)) is the \\(p\\)-th (resp. \\(q\\)-th) component of the mode shape associated with the \\(i\\)-th mode.\nTo solve for the mode shapes, a collocated measurement is required, i.e. \\(p = q\\). Thus, the mode shape components can be obtained as: \\[\n\\phi_{p,i} = \\sqrt{\\frac{{}_iR_{pp}}{c_i}} \\; \\text{ and } \\; \\phi_{q,i} = \\frac{{}_iR_{pq}}{\\sqrt{c_i\\; {}_iR_{pp}}}.\n\\]\nHere, the scaling factors \\(c_i\\) can be computed based on a normalization criterion. In this package, the scaling factors are computed such that the modal mass of each mode shape is equal to one (mass normalization). The mode shapes can then be extracted using the modeshape_extraction function.",
    "crumbs": [
      "Modal extraction",
      "Mdof methods"
    ]
  },
  {
    "objectID": "modal_extraction/mdof_methods.html#api",
    "href": "modal_extraction/mdof_methods.html#api",
    "title": "Mdof methods",
    "section": "3 API",
    "text": "3 API\nData types\n\nEMAMdofProblem\n\n\n\nEMAMdofProblem(frf, freq; frange, type_frf)\nData structure defining the inputs for EMA-MDOF modal extraction methods.\nConstructor parameters\n\nfrf::Array{Complex, 3}: 3D FRF matrix (array nm x ne x nf)\n\nfreq::AbstractArray{Real}: Vector of frequency values (Hz)\n\nfrange::Vector{Real}: Frequency range for analysis (default: [freq[1], freq[end]])\n\ntype_frf::Symbol: Type of FRF used in the analysis\n\n:dis: Admittance (default)\n\n:vel: Mobility\n\n:acc: Accelerance\n\n\n\n\nFields\n\nfrf::Array{Complex, 3}: 3D admittance matrix (array nm x ne x nf)\n\nfreq::AbstractArray{Real}: Vector of frequency values (Hz)\n\ntype_frf::Symbol: Type of FRF used in the analysis\n\n\nNote The FRF is internally converted to admittance if needed.\n\n\n\n\n\n\n\nAutoEMAMdofProblem\n\n\n\nAutoEMAMdofProblem(prob, dpi, method; modetype)\nStructure containing the input data for automatic experimental modal analysis using Mdof methods\nFields\n\nprob::EMAMdofProblem: EMA-MDOF problem containing FRF data and frequency vector\n\norder::Int: Model order (number of poles to extract)\n\ndpi::Vector{Int}: Driving point indices - default = [1, 1]\n\ndpi[1]: Driving point index on the measurement mesh\n\ndpi[2]: Driving point index on the excitation mesh\n\n\n\nmethod::MdofModalExtraction: Method to extract the poles\n\nLSCE: Least Squares Complex Exponential method\n\nLSCF`: Least Squares Complex Frequency method (default)\n\nPLSCF: Polyreference Least Squares Complex Frequency method\n\n\n\nmodetype::Symbol: Type of mode shapes to extract\n\n:real: Real mode shapes (default)\n\n:complex: Complex mode shapes\n\n\n\n\n\n\n\n\n\n\n\nEMAMdofSolution\n\n\n\nEMAMdofSolution(poles, ms, ci, res, lr, ur)\nStructure containing the solution of the automatic experimental modal analysis using Mdof methods\nFields\n\npoles::Vector{Complex}: Extracted poles\n\nms::AbstractArray{Real}: Mode shapes\n\nci::Vector{Complex}: Scaling constants for each mode\n\nres::AbstractArray{Complex}: Residues for each mode\n\nlr::Matrix{Complex}: Lower residual\n\nur::Matrix{Complex}: Upper residual\n\n\n\n\n\n\n\n\n\nEMAMdofStabilization\n\n\n\nEMAMdofStabilization(prob, poles, modefn, mode_stabfn, mode_stabdr)\nData structure summarizing the results of the stabilization analysis.\nFields\n\nprob::EMAMdofProblem: EMA-MDOF problem containing FRF data and frequency vector\n\nfrange::Vector{Real}: Frequency range used for the stabilization analysis\n\npoles::Vector{Vector{Complex}}: Vector of vectors containing extracted poles at each model order\n\nmodefn::Matrix{Real}: Matrix containing the natural frequencies (useful for plotting)\n\nmode_stabfn::Matrix{Bool}: Matrix indicating the stability of natural frequencies\n\nmode_stabdr::Matrix{Bool}: Matrix indicating the stability of damping ratios\n\n\nNote\nThis structure is returned by the stabilization function after performing a stabilization diagram analysis and used by stabilization_plot for visualization.\n\n\n\n\n\n\nRelated functions\n\npoles_extraction\n\n\n\npoles_extraction(prob, order, method; stabdiag, weighting)\nExtract complex poles from Frequency Response Function (FRF) data using the specified modal extraction method.\nInputs\n\nprob::EMAMdofProblem: EMA-MDOF problem containing FRF data and frequency vector\n\norder::Int: Model order (number of poles to extract)\n\nmethod::MdofModalExtraction: Modal extraction method\n\nLSCE: Least Squares Complex Exponential method\n\nLSCF: Least Squares Complex Frequency method (default)\n\nPLSCF: Polyreference Least Squares Complex Frequency method\n\n\n\nstabdiag: Boolean to indicate the function is used to build a stability diagram (default: false)\n\nweighting: Boolean to indicate whether to apply weighting of the FRF (default: true)\n\n\nOutput\n\npoles: Vector of extracted complex poles\n\n\nNote\nThe weighting parameter is only applicable for the LSCF and PLSCF methods.\n\n\n\n\n\n\n\nstabilization\n\n\n\nstabilization(prob, max_order, method; weighting, stabcrit)\nPerform stabilization diagram analysis using the specified modal extraction method (LSCE, LSCF, or PLSCF).\nInputs\n\nprob::EMAMdofProblem: EMA-MDOF problem containing FRF data and frequency vector\n\nmax_order::Int: Maximum model order for the stabilization analysis\n\nmethod: Modal extraction method to use\n\nLSCE(): Least Squares Complex Exponential method\n\nLSCF(): Least Squares Complex Frequency method (default)\n\nPLSCF(): Polyreference Least Squares Complex Frequency method\n\n\n\nfrange: Frequency range for analysis (default: [freq[1], freq[end]])\n\nweighting: Boolean to indicate if the weighting based on the variance of each FRF is applied (default: true)\n\nstabcrit: Vector containing the stability criteria for natural frequencies and damping ratios (default: [0.01, 0.05])\n\n\nOutput\n\nsol::EMAMdofStabilization: Data structure containing the results of the stabilization analysis\n\n\n\n\n\n\n\n\n\nstabilization_plot\n\n\n\nstabilization_plot(stab::EMAMdofStabilization, indicator)\nPlot stabilization diagram for EMA-MDOF pole stability analysis.\nInputs\n\nstab: EMA-MDOF stabilization data\n\nindicator: Indicator to plot\n\n:psif : Power spectrum indicator function (default)\n\n:cmif : Complex mode indicator function\n\n\n\n\nOutput\n\nfig: Figure\n\n\n\n\n\n\n\n\n\nmode_residues\n\n\n\nmode_residues(prob, poles)\nCompute residues of a frequency response function (FRF) given its poles.\nInputs\n\nprob: EMAMdofProblem containing FRF data and frequency vector\n\npoles: Vector of complex poles\n\n\nOutput\n\nres: Residues corresponding to each pole\n\n\n\n\n\n\n\n\n\nmodeshape_extraction\n\n\n\nmodeshape_extraction(residues, poles, dpi; type = :complex)\nExtract mode shapes using MDOF approximation\nInputs\n\nresidues: Residues matrix of size (np, nm, ne)\n\npoles: Vector of complex poles\n\ndpi: Driving point indices - default = [1, 1]\n\ndpi[1]: Driving point index on the measurement mesh\n\ndpi[2]: Driving point index on the excitation mesh\n\n\n\ntype: Type of mode shape\n\n:complex: Complex mode shapes (default)\n\n:real: Real mode shapes\n\n\n\n\nOutputs\n\nms: Mode shapes matrix\n\nci: Scaling factors vector\n\n\n\n\n\n\n\n\n\nsolve\n\n\n\nsolve(prob::AutoEMAMdofProblem)\nSolve automatically experimental modal analysis problem using Mdof methods\nInputs\n\nprob: Structure containing the input data for automatic experimental modal analysis using Mdof methods\n\n\nOutputs\n\nsol::EMAMdofSolution: Structure containing the solution of the automatic experimental modal analysis using Mdof methods",
    "crumbs": [
      "Modal extraction",
      "Mdof methods"
    ]
  },
  {
    "objectID": "modal_extraction/mdof_methods.html#example",
    "href": "modal_extraction/mdof_methods.html#example",
    "title": "Mdof methods",
    "section": "4 Example",
    "text": "4 Example\n\n4.1 Data preparation and FRF calculation\n\n# Structure parameters of the beam\nL = 1.        # Length\nb = 0.03      # Width\nh = 0.01      # Thickness\nS = b*h       # Cross-section area\nIz = b*h^3/12 # Moment of inertia\n\n# Material parameters\nE = 2.1e11  # Young's modulus\nρ = 7850.   # Density\nξ = 0.01    # Damping ratio\n\n# Mesh\nxexc = 0:0.05:L\nxm = xexc[2]\n\n# Mode calculation - Simply supported boundary conditions\nbeam = Beam(L, S, Iz, E, ρ)\nfmax = 500.\n\nωn, kn = modefreq(beam, 2fmax)\nϕexc = modeshape(beam, kn, xexc)\nϕm = modeshape(beam, kn, xm)\n\n# FRF calculation\nfreq = 1.:0.1:fmax\nprob = ModalFRFProblem(ωn, ξ, freq, ϕm, ϕexc)\nH = solve(prob; ismat = true).u\n\n\n\n4.2 Poles extraction\n\n# EMA-MDOF problem\nprob_mdof = EMAMdofProblem(H, freq)\n\n# Poles extraction\norder = 10 # Model order\np_lsce = poles_extraction(prob_mdof, order, LSCE())\np_lscf = poles_extraction(prob_mdof, order, LSCF())\np_plscf = poles_extraction(prob_mdof, order, PLSCF())\n\n# Stabilization diagram analysis using the LSCE method\nstab = stabilization(prob_mdof, order, LSCE())\n\n# Visualization of the stabilization diagram\nstabilization_plot(stab)\n\n\n\n\n\n\n\n\n\n\n\n4.3 Mode shapes extraction\n\n# Driving point indices\ndpi = [1, 2]\n\n# Computation of the mode residues\nres = mode_residues(prob_mdof, p_lsce)\n\n# Extraction of the mode shapes\nϕ_est = modeshape_extraction(res, p_lsce, dpi, type = :real)[1]\n\n# Convert to real mode shapes\nϕ_est_real = c2r_modeshape(ϕ_est)\n\n\n\n\n\n\n\n\n4.4 Automatic EMA-MDOF\n\nprob_ema = AutoEMAMdofProblem(prob_mdof, order, dpi, LSCE())\nsol_ema = solve(prob_ema)\nfn_ema, ξn_ema = poles2modal(sol_ema.poles)\nϕn_ema = sol_ema.ms",
    "crumbs": [
      "Modal extraction",
      "Mdof methods"
    ]
  },
  {
    "objectID": "modal_extraction/mdof_methods.html#footnotes",
    "href": "modal_extraction/mdof_methods.html#footnotes",
    "title": "Mdof methods",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nD. Brown, R. Allemang and R. Zimmerman and M. Mergeay. “Parameter estimation techniques for modal analysis”. SAE Technical Paper 790221, 1979.↩︎\nP. Guillaume, P. Verboven, S. Vanlanduit, H. Van der Auweraer and B. Peeters, “A poly-reference implementation of the least-squares complex frequency-domain estimator”. Proceedings of the 21st International Modal Analysis Conference, IMAC, 2003.↩︎\nM. El-Kafafy, P. Guillaume, B. Peeters, F. Marra, G. Coppotelli. “Advanced Frequency-Domain Modal Analysis for Dealing with Measurement Noise and Parameter Uncertainty”. In: Allemang R., De Clerck J., Niezrecki C., Blough J. (eds) Topics in Modal Analysis I, Volume 5. Conference Proceedings of the Society for Experimental Mechanics Series. 2012.↩︎",
    "crumbs": [
      "Modal extraction",
      "Mdof methods"
    ]
  }
]