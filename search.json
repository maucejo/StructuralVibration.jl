[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "StructuralVibration.jl",
    "section": "",
    "text": "StructuralVibration.jl is a Julia package designed to generate vibration data for mechanical systems. This package can be used for educational and research purposes. As a teacher, you can use it to illustrate vibration theory and its practical implementation. As a researcher, you can use it to test new methods on synthetic data.",
    "crumbs": [
      "Overview",
      "StructuralVibration.jl"
    ]
  },
  {
    "objectID": "index.html#features",
    "href": "index.html#features",
    "title": "StructuralVibration.jl",
    "section": "Features",
    "text": "Features\nThe package provides the following features:\n\nMechanical models\n\nDiscrete models\n\nSpring-mass-damper SDOF system\nSpring-mass-damper MDOF system\nFE models of bar, rod, strings and beams\n\nContinuous models\n\nLongitudinal bars\nTorsional bars\nStrings\nBeams\nRectangular plates\nRectangular membranes\n\nState space model\n\nContinuous state-space representation\nDiscrete state-space representation\n\nZero-order hold (ZOH)\nFirst-order hold (FOH)\nBand-limited hold (BLH)\nRK4\n\n\n\n\n\nVibration data generation\n\nExcitation signals\n\nRectangular wave\nTriangular wave\nHammer impact\nSmoothed rectangular wave\nSine wave\nHalf-sine pulse\nHarversine pulse\nSwept sine wave\nGaussian pulse\nColored noise\n\nSolution for SDOF systems\n\nFree response\nForced response due to a harmonic force or a base motion\nForced response due to any external force or base motion (Duhamel’s integral)\n\nTime-domain integration schemes for linear second order systems\n\nCentral difference scheme\nRK4\nNewmark-beta method\nLinear acceleration method\nFox-Goodwin method\nHHT\nWBZ\nGeneralized-alpha\nMid-Point rule\n\nFrequency-domain calculations for linear systems\n\nFrequency spectrum\n\nModal summation\nDirect method\n\nFrequency response function (FRF)\n\nModal summation\nDirect method\n\n\nState-space solvers\n\nTime domain\n\nRK4 for continuous systems\nZOH, FOH, BLH, RK4 for discrete models\n\nFrequency spectrum\n\nModal summation\nDirect method\n\nFrequency response function (FRF)\n\nModal summation\nDirect method\n\n\nMeasurement noise\n\nAdditive Gaussian white noise (agwn) with a prescribed SNR\nAdditive Colored noise (acn)\nMultiplicative noise\nMixed - agwn + multiplicative noise\n\nSignal processing\n\nMeasurement noise variance estimation algorithms from noisy data\n\nRegularization-based estimation\nD’Errico’s method - Link to the Matlab version\n\nSNR estimation from estimated measurement noise variance\nDenoising algorithms\n\nRegularization\nKalman filtering\n\nModal extraction - SDOF methods\n\nPeak picking method\nCircle fit method\n\nDetrending data using polynomial fit\nGradient calculation using interpolation\nSignal estimation\n\nTransfer functions estimation (H1, H2, H3, Hv)\nWelch method (PSD, ESD, Autopower, Autopower linear)\nSignal spectrum estimation\n\n\nVisualization\n\nBode plot\n2D and 3D Nyquist plot\nWaterfall plot\nGeneral 2D plot",
    "crumbs": [
      "Overview",
      "StructuralVibration.jl"
    ]
  },
  {
    "objectID": "index.html#reproducibility",
    "href": "index.html#reproducibility",
    "title": "StructuralVibration.jl",
    "section": "Reproducibility",
    "text": "Reproducibility\n\n\n\n\n\n\nProject direct dependencies\n\n\n\n\n\nProject StructuralVibration v0.1.0\nStatus\n  [717857b8] DSP v0.8.3\n  [7a1cc6ca] FFTW v1.8.1\n  [442a2c76] FastGaussQuadrature v1.0.2\n  [a98d9a8b] Interpolations v0.15.1\n  [429524aa] Optim v1.12.0\n  [18e31ff7] Peaks v0.5.3\n⌅ [aea7be01] PrecompileTools v1.2.1\n  [92933f4c] ProgressMeter v1.10.4\n  [276daf66] SpecialFunctions v2.5.0\n  [10745b16] Statistics v1.11.1\n  [37e2e46d] LinearAlgebra v1.11.0\n  [9a3f8284] Random v1.11.0\n\n\n\n\n\n\n\n\n\nJulia version and machine information\n\n\n\n\n\nJulia Version 1.11.4\nCommit 8561cc3d68 (2025-03-10 11:36 UTC)\nBuild Info:\n  Official https://julialang.org/ release\nPlatform Info:\n  OS: Windows (x86_64-w64-mingw32)\n  CPU: 8 × Intel(R) Core(TM) i7-10610U CPU @ 1.80GHz\n  WORD_SIZE: 64\n  LLVM: libLLVM-16.0.6 (ORCJIT, skylake)\nThreads: 8 default, 0 interactive, 4 GC (on 8 virtual cores)\nEnvironment:\n  JULIA_EDITOR = code",
    "crumbs": [
      "Overview",
      "StructuralVibration.jl"
    ]
  },
  {
    "objectID": "index.html#license",
    "href": "index.html#license",
    "title": "StructuralVibration.jl",
    "section": "License",
    "text": "License\nThis package is under MIT License.",
    "crumbs": [
      "Overview",
      "StructuralVibration.jl"
    ]
  },
  {
    "objectID": "solvers/state_space_solvers.html",
    "href": "solvers/state_space_solvers.html",
    "title": "State-space solvers",
    "section": "",
    "text": "For solving time-domain problems, the StructuralVibration.jl package provides two different approach. The first one consist in solving the problem using the discrete-time state equation (see Mechanical solvers - Section 3.2 for details). In this case, four discretization methods are available: Zero-Order Hold (:zoh), First-Order Hold (:foh), Band-Limited Hold (:blh), and Fourth order Runge-Kutta scheme (:rk4).\nThe second approach is to solve the problem using the continuous-time state equation. In this case, the user can build a continuous state-space model and solve it using DifferentialEquations.jl to take advantage of one of its numerous solvers or use the Fourth order Runge-Kutta scheme implemented in the package.\n\n\nData type\n\nStateSpaceTimeProblem\n\n\n\nStateSpaceProblem(css::ContinuousStateSpace, u0::Vector{Float64}, h::Float64, F::Matrix{Float64})\nStructure containing data for the state-space model\nConstructor\n\ncss: Continuous-time state space model\n\nu0: Initial conditions\n\nF: External force matrix\n\nt: Time vector\n\n\nFields\n\ncss: ContinuousStateSpace\n\nF: External force matrix\n\nu0: Initial conditions\n\nh: Time step\n\n\n\n\n\n\n\n\nRelated function\n\nsolve\n\n\n\nsolve(prob::StateSpaceTimeProblem, method = :zoh; progress = true)\nSolves a discrete-time problem using the state-space model\nInputs\n\nprob: Discrete-time problem\n\nmethod: Discretization method\n\n:zoh: Zero-order Hold method\n\n:foh: First-order Hold method\n\n:blh: Band-limited Hold method\n\n:rk4: Runge-Kutta 4th order method\n\n\n\nprogress: Show progress bar (default = true)\n\n\nOutput\n\nStateSpaceSolution: Solution of the state-space model\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Structural parameters\nM = Diagonal([2., 1.])\nK = [6. -2.; -2. 4.]\nξ = 0.05\n\nω, Φ = eigenmode(K, M)\nC = modal_damping_matrix(M, ω, ξ, Φ)\n\n# Time vector\nt = 0.:1e-2:30.\n\n# State-space model\ncss = ss_model(K, M, C)\n\n# Force\nF_free = zeros(2, length(t))\n\n# Initial conditions\nx0 = [0.2, 0.1]\nv0 = zeros(2)\nu0 = [x0; v0]\n\n# Problem definition\nprob_free = StateSpaceTimeProblem(css, F_free, u0, t)\nx_free_zoh = solve(prob_free).u\nx_free_foh = solve(prob_free, :foh).u\nx_free_blh = solve(prob_free, :blh).u\nx_free_rk = solve(prob_free, RK4()).u\n# Other possibility\n# x_free_rk = solve(prob_free, :rk4).u\n\nprob_free_modal =  FreeModalTimeProblem(K, M, ξ, (x0, v0), t)\nx_free_modal = solve(prob_free_modal).u\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Structural parameters\nM = Diagonal([2., 1.])\nK = [6. -2.; -2. 4.]\nξ = 0.05\n\nω, Φ = eigenmode(K, M)\nC = modal_damping_matrix(M, ω, ξ, Φ)\n\n# Time vector\nt = 0.:1e-2:30.\n\n# State-space model\ncss = ss_model(K, M, C)\n\nF0 = 10.\ntstart = 2.\nduration = 5.\nhaversine = HaverSine(F0, tstart, duration)\nF0 = excitation(haversine, t)\nF = zeros(2, length(t))\nF[1, :] .= F0\n\n# Initial conditions\nx0 = zeros(2)\nv0 = zeros(2)\nu0 = [x0; v0]\n\n# Problem definition\nprob_forced = StateSpaceTimeProblem(css, F, u0, t)\nx_forced_zoh = solve(prob_forced).u\nx_forced_foh = solve(prob_forced, :foh).u\nx_forced_blh = solve(prob_forced, :blh).u\nx_forced_rk = solve(prob_forced, :rk4).u\n\nprob_forced_modal = ForcedModalTimeProblem(K, M, ξ, F, (x0, v0), t)\nx_forced_modal = solve(prob_forced_modal).u",
    "crumbs": [
      "Solvers",
      "State-space solvers"
    ]
  },
  {
    "objectID": "solvers/state_space_solvers.html#time-domain-solvers",
    "href": "solvers/state_space_solvers.html#time-domain-solvers",
    "title": "State-space solvers",
    "section": "",
    "text": "For solving time-domain problems, the StructuralVibration.jl package provides two different approach. The first one consist in solving the problem using the discrete-time state equation (see Mechanical solvers - Section 3.2 for details). In this case, four discretization methods are available: Zero-Order Hold (:zoh), First-Order Hold (:foh), Band-Limited Hold (:blh), and Fourth order Runge-Kutta scheme (:rk4).\nThe second approach is to solve the problem using the continuous-time state equation. In this case, the user can build a continuous state-space model and solve it using DifferentialEquations.jl to take advantage of one of its numerous solvers or use the Fourth order Runge-Kutta scheme implemented in the package.\n\n\nData type\n\nStateSpaceTimeProblem\n\n\n\nStateSpaceProblem(css::ContinuousStateSpace, u0::Vector{Float64}, h::Float64, F::Matrix{Float64})\nStructure containing data for the state-space model\nConstructor\n\ncss: Continuous-time state space model\n\nu0: Initial conditions\n\nF: External force matrix\n\nt: Time vector\n\n\nFields\n\ncss: ContinuousStateSpace\n\nF: External force matrix\n\nu0: Initial conditions\n\nh: Time step\n\n\n\n\n\n\n\n\nRelated function\n\nsolve\n\n\n\nsolve(prob::StateSpaceTimeProblem, method = :zoh; progress = true)\nSolves a discrete-time problem using the state-space model\nInputs\n\nprob: Discrete-time problem\n\nmethod: Discretization method\n\n:zoh: Zero-order Hold method\n\n:foh: First-order Hold method\n\n:blh: Band-limited Hold method\n\n:rk4: Runge-Kutta 4th order method\n\n\n\nprogress: Show progress bar (default = true)\n\n\nOutput\n\nStateSpaceSolution: Solution of the state-space model\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Structural parameters\nM = Diagonal([2., 1.])\nK = [6. -2.; -2. 4.]\nξ = 0.05\n\nω, Φ = eigenmode(K, M)\nC = modal_damping_matrix(M, ω, ξ, Φ)\n\n# Time vector\nt = 0.:1e-2:30.\n\n# State-space model\ncss = ss_model(K, M, C)\n\n# Force\nF_free = zeros(2, length(t))\n\n# Initial conditions\nx0 = [0.2, 0.1]\nv0 = zeros(2)\nu0 = [x0; v0]\n\n# Problem definition\nprob_free = StateSpaceTimeProblem(css, F_free, u0, t)\nx_free_zoh = solve(prob_free).u\nx_free_foh = solve(prob_free, :foh).u\nx_free_blh = solve(prob_free, :blh).u\nx_free_rk = solve(prob_free, RK4()).u\n# Other possibility\n# x_free_rk = solve(prob_free, :rk4).u\n\nprob_free_modal =  FreeModalTimeProblem(K, M, ξ, (x0, v0), t)\nx_free_modal = solve(prob_free_modal).u\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Structural parameters\nM = Diagonal([2., 1.])\nK = [6. -2.; -2. 4.]\nξ = 0.05\n\nω, Φ = eigenmode(K, M)\nC = modal_damping_matrix(M, ω, ξ, Φ)\n\n# Time vector\nt = 0.:1e-2:30.\n\n# State-space model\ncss = ss_model(K, M, C)\n\nF0 = 10.\ntstart = 2.\nduration = 5.\nhaversine = HaverSine(F0, tstart, duration)\nF0 = excitation(haversine, t)\nF = zeros(2, length(t))\nF[1, :] .= F0\n\n# Initial conditions\nx0 = zeros(2)\nv0 = zeros(2)\nu0 = [x0; v0]\n\n# Problem definition\nprob_forced = StateSpaceTimeProblem(css, F, u0, t)\nx_forced_zoh = solve(prob_forced).u\nx_forced_foh = solve(prob_forced, :foh).u\nx_forced_blh = solve(prob_forced, :blh).u\nx_forced_rk = solve(prob_forced, :rk4).u\n\nprob_forced_modal = ForcedModalTimeProblem(K, M, ξ, F, (x0, v0), t)\nx_forced_modal = solve(prob_forced_modal).u",
    "crumbs": [
      "Solvers",
      "State-space solvers"
    ]
  },
  {
    "objectID": "solvers/state_space_solvers.html#frequency-domain-solvers",
    "href": "solvers/state_space_solvers.html#frequency-domain-solvers",
    "title": "State-space solvers",
    "section": "2 Frequency-domain solvers",
    "text": "2 Frequency-domain solvers\nThe frequency-domain solvers are based on the state-space representation of the system, which includes both the state equation and the output equation. It is given that: \\[\n\\begin{cases}\n\\dot{\\mathbf{z}}(t) &= \\mathbf{A}_c \\mathbf{z}(t) + \\mathbf{B}_c \\mathbf{u}(t) \\\\\n\\mathbf{y}(t) &= \\mathbf{C}_c \\mathbf{z}(t) + \\mathbf{D}_c \\mathbf{u}(t)\n\\end{cases},\n\\] where:\n\n\\(\\mathbf{z}(t)\\): State vector\n\\(\\mathbf{u}(t)\\): Input vector\n\\(\\mathbf{y}(t)\\): Output vector\n\\(\\mathbf{A}_c\\): System matrix\n\\(\\mathbf{B}_c\\): Input matrix\n\\(\\mathbf{C}_c\\): Observation matrix\n\\(\\mathbf{D}_c\\): Direct feedthrough matrix\n\nIt is also possible to express the state-space system. To this end, the state-space representation is transformed into modal coordinates, i.e., \\(\\mathbf{z} = \\mathbf{\\Psi} \\mathbf{q}\\), where \\(\\mathbf{\\Psi}\\) is the matrix of eigenvectors of the system matrix \\(\\mathbf{A}_c\\). The modal state-space representation is given by: \\[\n\\begin{cases}\n\\dot{\\mathbf{q}}(t) &= \\mathbf{\\Lambda} \\mathbf{q}(t) + \\mathbf{B}_m \\mathbf{u}(t) \\\\\n\\mathbf{y}(t) &= \\mathbf{C}_m \\mathbf{q}(t) + \\mathbf{D}_m \\mathbf{u}(t)\n\\end{cases},\n\\] where:\n\n\\(\\mathbf{q}(t)\\): Modal state vector\n\\(\\Lambda = \\text{diag}(\\lambda_1, \\lambda_1^\\ast, \\dots, \\lambda_N, \\lambda_N^\\ast)\\): Eigenvalues matrix\n\\(\\mathbf{B}_m = \\mathbf{\\Psi}^{-1} \\mathbf{B}_c\\): Modal input matrix\n\\(\\mathbf{C}_m = \\mathbf{C}_c \\mathbf{\\Psi}\\): Modal observation matrix\n\\(\\mathbf{D}_m = \\mathbf{D}_c\\): Modal direct feedthrough matrix\n\nFinally\n\n2.1 Frequency Response Function\nThe Frequency Response Function (FRF) is a complex function that describes the steady-state response of a system to a sinusoidal input. The FRF is defined as the ratio of the output to the input in the frequency domain. From the state-space representation, the transfer function of the system at a given angular frequency \\(\\omega\\) can be obtained in a straightforward manner and is given by: \\[\n\\mathbf{H}(\\omega) = \\mathbf{C}_c (j\\omega \\mathbf{I} - \\mathbf{A}_c)^{-1} \\mathbf{B}_c + \\mathbf{D}_c,\n\\] or equivalently from the modes of the system: \\[\n\\mathbf{H}(\\omega) = \\mathbf{C}_m (j\\omega \\mathbf{I} - \\mathbf{\\Lambda} )^{-1} \\mathbf{B}_m + \\mathbf{D}_m.\n\\]\nFinally, it should be noted that the FRF can be computed for a given set of response dofs and a given set of excitation dofs by introducing the appropriate selection matrices \\(\\mathbf{S}_o\\) and \\(\\mathbf{S}_e\\). In this case, the FRF is given by: \\[\n\\mathbf{H}_{oe}(\\omega) = \\mathbf{S}_o\\mathbf{H}(\\omega)\\mathbf{S}_e.\n\\]\n\n\n\n\n\n\nNote\n\n\n\n\nFor the admittance : \\(\\mathbf{C}_c = [\\mathbf{I},\\quad \\mathbf{0}]\\) and \\(\\mathbf{D}_c = \\mathbf{0}\\).\nFor the mobility : \\(\\mathbf{C}_c = [\\mathbf{0}, \\quad \\mathbf{I}]\\) and \\(\\mathbf{D}_c = \\mathbf{0}\\).\nFor the accelerance, \\(\\mathbf{C}_c = \\mathbf{A}_c[m:\\text{end}, :]\\) and \\(\\mathbf{D}_c = \\mathbf{B}_c[m:\\text{end}, :]\\) with \\(m = N/2\\) (this corresponds to a rewrite of the equation of motion).\n\n\n\n\n2.1.1 API\nData types\n\nStateSpaceFRFProblem\n\n\n\nStateSpaceFRFProblem(css::ContinuousStateSpace, freq, type, So, Se)\nStructure containing the data feeding the direct solver for calculating an FRF\nFields\n\ncss: Continuous-time state space model\n\nfreq: Frequencies of interest\n\nSo: Selection matrix for observation points\n\nSe: Selection matrix for excitation points\n\n\nNote It is assumed that the output equation is of the form y = So*x\n\n\n\n\n\n\n\nStateSpaceModalFRFProblem\n\n\n\nStateSpacemodalFRFProblem(css::ContinuousStateSpace, freq, type, So, Se, n)\nStructure containing the data feeding the direct solver for calculating an FRF\nFields\n\ncss: Continuous-time state space model\n\nfreq: Frequencies of interest\n\nSo: Selection matrix for observation points\n\nSe: Selection matrix for excitation points\n\nn: Number of modes to keep in the modal basis\n\n\n\n\n\n\n\n\nRelated function\n\nsolve\n\n\n\nsolve(prob::StateSpaceFRFProblem, type = :dis; ismat = false, progress = true)\nsolve(prob::StateSpaceModalFRFProblem, type = :dis; ismat = false, progress = true)\nComputes the FRF matrix by direct or modal method\nInputs\n\nprob: Structure containing the problem data\n\ntype: Type of FRF to compute\n\n:dis: Admittance\n\n:vel: Mobility\n\n:acc: Accelerance\n\n\n\nismat: Return the FRF matrix as a 3D array (default = false)\n\nprogress: Show progress bar (default = true)\n\n\nOutput\n\nsol: FRFSolution structure\n\nu: FRF matrix\n\n\n\n\n\n\n\n\n\n\n\n\n2.1.2 Example\n\n# Structural parameters\nM = Diagonal([2., 1.])\nK = [6. -2.; -2. 4.]\nξ = 0.05\n\nω, Φ = eigenmode(K, M)\nC = modal_damping_matrix(M, ω, ξ, Φ)\n\n# State-space model\ncss = ss_model(K, M, C)\n\n# Frequency vector\nfreq = 0.01:0.001:1.\n\n# Problem definition - Case 1 - Direct\nprob_frf = StateSpaceFRFProblem(css, freq)\nH_direct = solve(prob_frf, ismat = true).u\n\n# Problem definition - Case 2 - Modal\nprob_frf_modal = StateSpaceModalFRFProblem(css, freq)\nH_modal = solve(prob_frf_modal, ismat = true).u\n\n\n\n\n\n\n\n\n\n\n\n\n\n2.2 Response spectrum\nSimilarly to the FRF, the response spectrum is a complex function that describes the steady-state response of a system to a sinusoidal input. From the state-space representation, the response spectrum of the system at a given angular frequency \\(\\omega\\) is given by: \\[\n\\mathbf{y}(\\omega) = \\left[\\mathbf{C}_c (j\\omega \\mathbf{I} - \\mathbf{A}_c)^{-1} \\mathbf{B}_c + \\mathbf{D}_c\\right] \\mathbf{u}(\\omega),\n\\] or equivalently from the modes of the system: \\[\n\\mathbf{y}(\\omega) = \\left[\\mathbf{C}_m (j\\omega \\mathbf{I} - \\mathbf{\\Lambda} )^{-1} \\mathbf{B}_m + \\mathbf{D}_m\\right] \\mathbf{u}(\\omega).\n\\]\n\n2.2.1 API\n\nStateSpaceFreqProblem\n\n\n\nStateSpaceFreqProblem(css::ContinuousStateSpace, F, freq, So)\nStructure containing the data feeding the modal solver for calculating the frequency response\nFields\n\ncss: Continuous-time state space model\n\nF: External force matrix\n\nfreq: Frequencies of interest\n\nSo: Selection matrix for observation points\n\n\n\n\n\n\n\n\n\nStateSpaceModalFreqProblem\n\n\n\nStateSpaceModalFreqProblem(css::ContinuousStateSpace, F, freq, So, n)\nStructure containing the data feeding the modal solver for calculating the frequency response\nFields\n\ncss: Continuous-time state space model\n\nF: External force matrix\n\nfreq: Frequencies of interest\n\nSo: Selection matrix for observation points\n\nn: Number of modes to keep in the modal basis\n\n\n\n\n\n\n\n\nRelated function\n\nsolve\n\n\n\nsolve(prob::StateSpaceFreqProblem, type = :dis; progress = true)\nsolve(prob::StateSpaceFreqProblem, type::Symbol = :dis; progress = true)\nComputes the frequency response by direct or modal method\nInputs\n\nprob: Structure containing the problem data\n\ntype::Symbol: Type of FRF to compute\n\n:dis: Displacement\n\n:vel: Velocity\n\n:acc: Acceleration\n\n\n\nprogress: Show progress bar\n\n\nOutput sol: Solution of the problem     * u: Response spectrum matrix\n\n\n\n\n\n\n\n\n2.2.2 Example\n\n# Structural parameters\nM = Diagonal([2., 1.])\nK = [6. -2.; -2. 4.]\nξ = 0.05\n\nω, Φ = eigenmode(K, M)\nC = modal_damping_matrix(M, ω, ξ, Φ)\n\n# State-space model\ncss = ss_model(K, M, C)\n\n# Frequency vector\nfreq = 0.01:0.001:1.\n\n# Force matrix\nF = zeros(2, length(freq))\nF[1, :] .= 10.\n\n# Problem definition - Case 1 - Direct\nprob_freq = StateSpaceFreqProblem(css, F, freq)\ny_freq = solve(prob_freq).u\n\n# Problem definition - Case 2 - Modal\nprob_freq_modal = StateSpaceModalFreqProblem(css, F, freq)\ny_freq_modal = solve(prob_freq_modal).u",
    "crumbs": [
      "Solvers",
      "State-space solvers"
    ]
  },
  {
    "objectID": "solvers/index.html",
    "href": "solvers/index.html",
    "title": "Sdof solvers",
    "section": "",
    "text": "The package provides a set of solvers to compute the time response of a single-degree-of-freedom (sdof) system.\n\n\nThe free response of a sdof system is the response of the system when it is subjected to initial conditions only. This means that the displacement of the mass is solution of the following ordinary differential equation: \\[\n\\begin{cases}\n  \\ddot x(t) + 2 \\xi\\omega_0\\dot x(t) + \\omega_0^2 x(t) = 0 \\\\\n  x(0) = x_0 \\\\\n  \\dot x(0) = v_0\n\\end{cases}.\n\\]\nDepending on the value of the damping ratio \\(\\xi\\) and \\(\\omega_0 &gt; 0\\), the system can have 4 different types of free response:\n\nan undamped motion when \\(\\xi = 0\\). In this case, the free response is: \\[\nx(t) = x_0\\cos\\omega_0 t + \\frac{v_0}{\\omega_0}\\sin\\omega_0 t\n\\]\nan underdamped motion when \\(0 &lt; \\xi &lt; 1\\). In this case, the free response is: \\[\nx(t) = \\left[x_0\\cos\\Omega_0 t + \\frac{v_0 + \\xi\\Omega_0 x_0}{\\Omega_0}\\sin\\Omega_0 t\\right]e^{-\\xi\\omega_0 t}\n\\] where \\(\\Omega_0 = \\omega_0\\sqrt{1 - \\xi^2}\\).\na critically damped motion when \\(\\xi = 1\\). In this case, the free response is: \\[\nx(t) = \\left[x_0 + (v_0 + \\omega_0 x_0)t\\right]e^{-\\omega_0 t}\n\\]\nan overdamped motion when \\(\\xi &gt; 1\\). In this case, the free response is: \\[\nx(t) = \\left[x_0\\text{cosh}(\\beta t) + \\frac{v_0 + \\xi\\omega_0 x_0}{\\beta}\\text{sinh}\\beta t\\right]e^{-\\xi\\omega_0 t},\n\\] where \\(\\beta = \\omega_0\\sqrt{\\xi^2 - 1}\\).\n\nFinally, if \\(\\omega = 0\\), the mass is free from constraints and the free response is: \\[\nx(t) = x_0 + v_0 t.\n\\]\n\n\nData type\n\nSdofFreeTimeProblem\n\n\n\nSdofFreeTimeProblem(sdof, u0, t)\nStructure containing the data of a time problem for a sdof system\nFields\n\nsdof::Sdof: Sdof structure\n\nu0::AbstractVector: Initial conditions\n\nx0: Initial displacement [m]\n\nv0: Initial velocity [m/s]\n\n\n\nt::AbstractRange: Time points at which to evaluate the response\n\n\n\n\n\n\n\n\nRelated function\n\nsolve\n\n\n\nsolve(prob::SdofFreeTimeProblem)\nCompute the free response of a single degree of freedom (Sdof) system.\nInput\n\nprob: Structure containing the parameters of the Sdof problem\n\n\nOutput\n\nsol: The response of the system at the given time points\n\nu: Displacement solution\n\ndu: Velocity solution\n\nddu: Acceleration solution\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Structural parameters\nm = 1.\nf0 = 1.\n\n# Time vector\nt = 0.:0.01:10.\n\n# Initial conditions\nu0 = [1., -2.]\n\n# Undamped system\nsdof_nd = Sdof(m, f0, 0.)\nprob_nd = SdofFreeTimeProblem(sdof_nd, u0, t)\nx_nd = solve(prob_nd).u\n\n# Underdamped system\nsdof_ud = Sdof(m, f0, 0.1)\nprob_ud = SdofFreeTimeProblem(sdof_ud, u0, t)\nx_ud = solve(prob_ud).u\n\n# Critically damped system\nsdof_cd = Sdof(m, f0, 1.)\nprob_cd = SdofFreeTimeProblem(sdof_cd, u0, t)\nx_cd = solve(prob_cd).u\n\n# Overdamped system\nsdof_od = Sdof(m, f0, 1.2)\nprob_od = SdofFreeTimeProblem(sdof_od, u0, t)\nx_od = solve(prob_od).u;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe forced response of a sdof system is the response of the system is the solution of the following ordinary differential equation: \\[\n\\begin{cases}\n  \\ddot x(t) + 2 \\xi\\omega_0\\dot x(t) + \\omega_0^2 x(t) = \\displaystyle\\frac{\\text{rhs}(t)}{m} \\\\\n  x(0) = x_0 \\\\\n  \\dot x(0) = v_0\n\\end{cases},\n\\] where \\(\\text{rhs}(t)\\) is the right-hand side of the equation and its expression depends on the type of excitation: \\[\n\\text{rhs}(t) = \\begin{cases}\nf(t) & \\text{for an external force excitation} \\\\\nm\\omega_0^2 x_b(t) + 2\\xi\\omega_0m\\dot x_b(t) & \\text{for a base excitation}\n\\end{cases}.\n\\]\nFinally, the solution of the forced response is expressed as the sum of two terms, since: \\[\nx(t) = x_h(t) + x_p(t),\n\\] where \\(x_h(t)\\) is the homogeneous solution of the equation and \\(x_p(t)\\) is the particular solution of the equation.\n\n\nWhen the excitation is harmonic, the resolution process is the following:\n\nCompute the particular solution of the equation. The particular solution is a harmonic function of the same frequency as the excitation.\nExpress the general solution of the homogeneous equation.\nCompute the remaining constants using the initial conditions. These constants depends on \\(x_p(0)\\) and \\(\\dot x_p(0)\\).\n\n\n\nData type\n\nSdofHarmonicTimeProblem\n\n\n\nSdofHarmonicTimeProblem(sdof, u0, t, F, ω, type_exc)\nStructure containing the data of a time problem for a sdof system subject to a harmonic excitation\nConstructor parameters\n\nsdof::Sdof: Sdof structure\n\nF: Amplitude of the force excitation [N] or base motion [m]\n\nf: Frequency of the excitation [Hz]\n\nu0::AbstractVector: Initial conditions\n\nx0: Initial displacement [m]\n\nv0: Initial velocity [m/s]\n\n\n\nt::AbstractRange: Time points at which to evaluate the response\n\ntype_exc::Symbol: Type of excitation\n\n:force: External force (default)\n\n:base: Base motion\n\n\n\n\nFields\n\nsdof::Sdof: Sdof structure\n\nF: Amplitude of the force excitation [N] or base motion [m]\n\nω: Frequency of the excitation [rad/s]\n\nu0::AbstractVector: Initial conditions\n\nx0: Initial displacement [m]\n\nv0: Initial velocity [m/s]\n\n\n\nt::AbstractRange: Time points at which to evaluate the response\n\ntype_exc::Symbol: Type of excitation\n\n:force: External force (default)\n\n:base: Base motion\n\n\n\n\n\n\n\n\n\n\nRelated function\n\nsolve\n\n\n\nsolve(prob::SdofHarmonicTimeProblem)\nComputes the forced response of a single degree of freedom (Sdof) system due to an harmonic external force or base motion\nInputs\n\nprob: Structure containing the parameters of the Sdof harmonic problem\n\n\nOutput\n\nsol: The response of the system at the given time points\n\nu: Displacement solution\n\ndu: Velocity solution\n\nddu: Acceleration solution\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Structural parameters\nm = 1.\nf0 = 1.\nξ = 0.1\n\n# Instantiation of the Sdof object\nsdof = Sdof(m, f0, ξ)\n\n# Harmonic excitation - Force amplitude + excitation frequency\nF0 = 10.\nf = 2.\n\n# Instantiation of the problem\nt = 0.:0.01:10.\nu0 = [1., -2.]\nprob = SdofHarmonicTimeProblem(sdof, F0, f, u0, t, :force)\n\n# Solve the problem\nx_harmo = solve(prob).u\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFor an arbitrary excitation, the solution is given by: \\[\nx(t) = x_\\text{free}(t) + \\int_0^t rhs(t - τ)h(τ)dτ,\n\\] where \\(x_\\text{free}(t)\\) is the free response of the system and \\(h(t)\\) is the impulse response of the system.\n\n\nData type\n\nSdofForcedTimeProblem\n\n\n\nSdofForcedTimeProblem(sdof, u0, t, F, ω, type_exc)\nStructure containing the data of a time problem for a sdof system subject to an arbitrary excitation\nFields\n\nsdof::Sdof: Sdof structure\n\nF::AbstractVector: Amplitude of the force excitation [N] or base motion [m]\n\nu0::AbstractVector: Initial conditions\n\nx0: Initial displacement [m]\n\nv0: Initial velocity [m/s]\n\n\n\nt::AbstractRange: Time points at which to evaluate the response\n\ntype_exc::Symbol: Type of excitation\n\n:force: External force (default)\n\n:base: Base motion\n\n\n\n\n\n\n\n\n\n\nRelated function\n\nsolve\n\n\n\nsolve(prob::SdofForcedTimeProblem)\nComputes the forced response of a single degree of freedom (Sdof) system due to an arbitrary external force or base motion\nInputs\n\nprob: Structure containing the parameters of the Sdof forced problem\n\nmethod: Method to compute the Duhamel's integral\n\n:filt: Filtering using the Z-transform of the impulse response (default)\n\n:interp: Interpolation + Gaussian quadrature\n\n:conv: Convolution product\n\n\n\n\nOutput\n\nsol: The response of the system at the given time points\n\nu: Displacement solution\n\ndu: Velocity solution\n\nddu: Acceleration solution\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Structural parameters\nm = 1.\nf0 = 1.\nξ = 0.1\n\n# Instantiation of the Sdof object\nsdof = Sdof(m, f0, ξ)\n\n# Haversine excitation signal\nF0 = 10.\ntstart = 0.5\nduration = 2.\nhaversine = HaverSine(F0, tstart, duration)\n\nt = 0.:0.01:10.\nF = excitation(haversine, t)\n\n# Instantiation of the problem\nu0 = [1, -2]\nprob = SdofForcedTimeProblem(sdof, F, u0, t, :force)\n\n# Solve the problem\nx_arb_filt = solve(prob, method = :filt).u\nx_arb_interp = solve(prob, method = :interp).u\nx_arb_conv = solve(prob, method = :conv).u;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe impulse response of a sdof system is the response of the system when it is subjected to an impulse excitation. The impulse response is the solution of the following ordinary differential equation: \\[\n\\overset{..}{h}(t) + 2\\xi\\omega_0\\overset{.}{h}(t) + \\omega_0^2 h(t) = \\frac{\\delta(t)}{m}.\n\\]\nIt can be shown that the impulse response can be computed by solving the following problem: \\[\n\\begin{cases}\n\\overset{..}{h}(t) + 2\\xi\\omega_0\\overset{.}{h}(t) + \\omega_0^2 h(t) = 0 & \\forall t &gt; 0 \\\\\nh(t) = 0 & \\text{at } t = 0 \\\\\n\\overset{.}{h}(t) = \\displaystyle\\frac{1}{m} & \\text{at } t = 0\n\\end{cases}.\n\\]\n\nimpulse_response\n\n\n\nimpulse_response(sdof, t)\nCompute the impulse response of a single degree of freedom (Sdof) system\nInputs\n\nsdof: Sdof structure\n\nt: Time points at which to evaluate the response\n\n\nOutput\n\nh: Impulse response\n\n\n\n\n\n\n\n\n\n# Structural parameters\nm = 1.\nf0 = 1.\nξ = 0.1\n\nt = 0.:0.01:10.\n\n# Instantiation of the Sdof object\nsdof = Sdof(m, f0, ξ)\n\nh = impulse_response(sdof, t)\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe shock response spectrum (SRS) is a graph of the peak acceleration response of a sdof system subjected to a base acceleration with respect to the frequency. The SRS is computed by solving the following problem: \\[\n\\ddot z(t) + 2\\xi\\omega_0\\dot z(t) + \\omega_0^2 z(t) = -\\ddot x_b(t),\n\\] where \\(z(t) = x(t) - x_b(t)\\) is the relative displacement of the system with respect to the base.\nTo compute the SRS, the following steps are performed at a given frequency \\(f\\):\n\nInstantiate a Sdof type\nsdof = Sdof(1., f, ξ)\nCompute the time response of the relative displacement \\(z(t)\\) due to a base acceleration for \\(z(0) = 0\\) and \\(\\dot z(0) = 0\\).\nCompute the acceleration \\(\\ddot x(t)\\) of the system: \\[\nx(t) = -2\\xi\\omega_0\\dot z(t) - \\omega_0^2 z(t)\n\\]\nExtract the primary or secondary part of the acceleration (i.e. until or after the end of the excitation signal).\nCompute either:\n\nThe peak acceleration of the system such that: \\[\nSRS(f) = \\max\\left(|\\ddot x(t)|\\right)\n\\]\nThe maximum positive acceleration of the system such that: \\[\nSRS(f) = \\max\\left(\\max(\\ddot x(t), 0)\\right)\n\\]\nThe maximum negative acceleration of the system such that: \\[\nSRS(f) = \\max\\left(\\max(-\\ddot x(t), 0)\\right)\n\\]\n\n\nSeveral algorithms are available to compute the SRS:\n\n:Basic: the SRS is computed by following the steps mentioned above. It is not the most efficient algorithm but it is the most versatile.\n:RecursiveInt: the SRS is computed using a recursive integration algorithm.\n:RecursiveFilt: the SRS is computed using a recursive filtering algorithm.\n:Smallwood: the SRS is computed using the Smallwood algorithm.\n\nFor the last three algorithms, more details and references can be found Mathworks - Introduction to SRS\n\nsrs\n\n\n\nsrs(base_acc::ArbitraryExc, freq, t, ξ = 0.05,\n    type = (instance = :primary, amplitude = :abs), alg = :Smallwood)\nCompute the Shock Response Spectrum (SRS)\nInputs\n\nbase_acc::ArbitraryExc: Base acceleration type - see excitation function for detatils\n\nfreq: Vector of frequencies [Hz]\n\nt: Time points at which to evaluate the response\n\nξ: Damping ratio (default = 0.05)\n\ntype: Type of SRS\n\ninstance: Instance of the SRS\n\n:primary: Primary instance (default)\n\n:secondary: Secondary instance\n\n\n\namplitude: Amplitude used of the computing SRS\n\n:abs: Maximum absolute amplitude (default)\n\n:pos: Maximum positive amplitude\n\n:neg: Maximum negative amplitude\n\n\n\n\n\nalg: Algorithm to compute the SRS\n\n:Basic: Basic algorithm\n\n:RecursiveInt: Recursive integration algorithm\n\n:RecursiveFilt: Recursive filtering algorithm\n\n:Smallwood: Smallwood algorithm (default)\n\n\n\n\nOutput\n\nsrs: Vector of the SRS values\n\n\nNote\n\nPrimary instance - response of the system during the application of the base acceleration\n\nSecondary instance - response of the system after the application of the base acceleration\n\n\n\n\n\n\n\n\n\n# Definition of the base acceleration\nt = 0.:1e-5:0.5\nbase_acc = HalfSine(10., 0., 1e-3)\n\n# Compute the SRS\nf = 50.:25:1e3\nsrs_basic = srs(base_acc, f, t)\nsrs_rec_int = srs(base_acc, f, t, alg = :RecursiveInt)\nsrs_rec_filt = srs(base_acc, f, t, alg = :RecursiveFilt)\nsrs_smallwood = srs(base_acc, f, t, alg = :Smallwood)",
    "crumbs": [
      "Solvers",
      "Sdof solvers"
    ]
  },
  {
    "objectID": "solvers/index.html#time-domain-solvers",
    "href": "solvers/index.html#time-domain-solvers",
    "title": "Sdof solvers",
    "section": "",
    "text": "The package provides a set of solvers to compute the time response of a single-degree-of-freedom (sdof) system.\n\n\nThe free response of a sdof system is the response of the system when it is subjected to initial conditions only. This means that the displacement of the mass is solution of the following ordinary differential equation: \\[\n\\begin{cases}\n  \\ddot x(t) + 2 \\xi\\omega_0\\dot x(t) + \\omega_0^2 x(t) = 0 \\\\\n  x(0) = x_0 \\\\\n  \\dot x(0) = v_0\n\\end{cases}.\n\\]\nDepending on the value of the damping ratio \\(\\xi\\) and \\(\\omega_0 &gt; 0\\), the system can have 4 different types of free response:\n\nan undamped motion when \\(\\xi = 0\\). In this case, the free response is: \\[\nx(t) = x_0\\cos\\omega_0 t + \\frac{v_0}{\\omega_0}\\sin\\omega_0 t\n\\]\nan underdamped motion when \\(0 &lt; \\xi &lt; 1\\). In this case, the free response is: \\[\nx(t) = \\left[x_0\\cos\\Omega_0 t + \\frac{v_0 + \\xi\\Omega_0 x_0}{\\Omega_0}\\sin\\Omega_0 t\\right]e^{-\\xi\\omega_0 t}\n\\] where \\(\\Omega_0 = \\omega_0\\sqrt{1 - \\xi^2}\\).\na critically damped motion when \\(\\xi = 1\\). In this case, the free response is: \\[\nx(t) = \\left[x_0 + (v_0 + \\omega_0 x_0)t\\right]e^{-\\omega_0 t}\n\\]\nan overdamped motion when \\(\\xi &gt; 1\\). In this case, the free response is: \\[\nx(t) = \\left[x_0\\text{cosh}(\\beta t) + \\frac{v_0 + \\xi\\omega_0 x_0}{\\beta}\\text{sinh}\\beta t\\right]e^{-\\xi\\omega_0 t},\n\\] where \\(\\beta = \\omega_0\\sqrt{\\xi^2 - 1}\\).\n\nFinally, if \\(\\omega = 0\\), the mass is free from constraints and the free response is: \\[\nx(t) = x_0 + v_0 t.\n\\]\n\n\nData type\n\nSdofFreeTimeProblem\n\n\n\nSdofFreeTimeProblem(sdof, u0, t)\nStructure containing the data of a time problem for a sdof system\nFields\n\nsdof::Sdof: Sdof structure\n\nu0::AbstractVector: Initial conditions\n\nx0: Initial displacement [m]\n\nv0: Initial velocity [m/s]\n\n\n\nt::AbstractRange: Time points at which to evaluate the response\n\n\n\n\n\n\n\n\nRelated function\n\nsolve\n\n\n\nsolve(prob::SdofFreeTimeProblem)\nCompute the free response of a single degree of freedom (Sdof) system.\nInput\n\nprob: Structure containing the parameters of the Sdof problem\n\n\nOutput\n\nsol: The response of the system at the given time points\n\nu: Displacement solution\n\ndu: Velocity solution\n\nddu: Acceleration solution\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Structural parameters\nm = 1.\nf0 = 1.\n\n# Time vector\nt = 0.:0.01:10.\n\n# Initial conditions\nu0 = [1., -2.]\n\n# Undamped system\nsdof_nd = Sdof(m, f0, 0.)\nprob_nd = SdofFreeTimeProblem(sdof_nd, u0, t)\nx_nd = solve(prob_nd).u\n\n# Underdamped system\nsdof_ud = Sdof(m, f0, 0.1)\nprob_ud = SdofFreeTimeProblem(sdof_ud, u0, t)\nx_ud = solve(prob_ud).u\n\n# Critically damped system\nsdof_cd = Sdof(m, f0, 1.)\nprob_cd = SdofFreeTimeProblem(sdof_cd, u0, t)\nx_cd = solve(prob_cd).u\n\n# Overdamped system\nsdof_od = Sdof(m, f0, 1.2)\nprob_od = SdofFreeTimeProblem(sdof_od, u0, t)\nx_od = solve(prob_od).u;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe forced response of a sdof system is the response of the system is the solution of the following ordinary differential equation: \\[\n\\begin{cases}\n  \\ddot x(t) + 2 \\xi\\omega_0\\dot x(t) + \\omega_0^2 x(t) = \\displaystyle\\frac{\\text{rhs}(t)}{m} \\\\\n  x(0) = x_0 \\\\\n  \\dot x(0) = v_0\n\\end{cases},\n\\] where \\(\\text{rhs}(t)\\) is the right-hand side of the equation and its expression depends on the type of excitation: \\[\n\\text{rhs}(t) = \\begin{cases}\nf(t) & \\text{for an external force excitation} \\\\\nm\\omega_0^2 x_b(t) + 2\\xi\\omega_0m\\dot x_b(t) & \\text{for a base excitation}\n\\end{cases}.\n\\]\nFinally, the solution of the forced response is expressed as the sum of two terms, since: \\[\nx(t) = x_h(t) + x_p(t),\n\\] where \\(x_h(t)\\) is the homogeneous solution of the equation and \\(x_p(t)\\) is the particular solution of the equation.\n\n\nWhen the excitation is harmonic, the resolution process is the following:\n\nCompute the particular solution of the equation. The particular solution is a harmonic function of the same frequency as the excitation.\nExpress the general solution of the homogeneous equation.\nCompute the remaining constants using the initial conditions. These constants depends on \\(x_p(0)\\) and \\(\\dot x_p(0)\\).\n\n\n\nData type\n\nSdofHarmonicTimeProblem\n\n\n\nSdofHarmonicTimeProblem(sdof, u0, t, F, ω, type_exc)\nStructure containing the data of a time problem for a sdof system subject to a harmonic excitation\nConstructor parameters\n\nsdof::Sdof: Sdof structure\n\nF: Amplitude of the force excitation [N] or base motion [m]\n\nf: Frequency of the excitation [Hz]\n\nu0::AbstractVector: Initial conditions\n\nx0: Initial displacement [m]\n\nv0: Initial velocity [m/s]\n\n\n\nt::AbstractRange: Time points at which to evaluate the response\n\ntype_exc::Symbol: Type of excitation\n\n:force: External force (default)\n\n:base: Base motion\n\n\n\n\nFields\n\nsdof::Sdof: Sdof structure\n\nF: Amplitude of the force excitation [N] or base motion [m]\n\nω: Frequency of the excitation [rad/s]\n\nu0::AbstractVector: Initial conditions\n\nx0: Initial displacement [m]\n\nv0: Initial velocity [m/s]\n\n\n\nt::AbstractRange: Time points at which to evaluate the response\n\ntype_exc::Symbol: Type of excitation\n\n:force: External force (default)\n\n:base: Base motion\n\n\n\n\n\n\n\n\n\n\nRelated function\n\nsolve\n\n\n\nsolve(prob::SdofHarmonicTimeProblem)\nComputes the forced response of a single degree of freedom (Sdof) system due to an harmonic external force or base motion\nInputs\n\nprob: Structure containing the parameters of the Sdof harmonic problem\n\n\nOutput\n\nsol: The response of the system at the given time points\n\nu: Displacement solution\n\ndu: Velocity solution\n\nddu: Acceleration solution\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Structural parameters\nm = 1.\nf0 = 1.\nξ = 0.1\n\n# Instantiation of the Sdof object\nsdof = Sdof(m, f0, ξ)\n\n# Harmonic excitation - Force amplitude + excitation frequency\nF0 = 10.\nf = 2.\n\n# Instantiation of the problem\nt = 0.:0.01:10.\nu0 = [1., -2.]\nprob = SdofHarmonicTimeProblem(sdof, F0, f, u0, t, :force)\n\n# Solve the problem\nx_harmo = solve(prob).u\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFor an arbitrary excitation, the solution is given by: \\[\nx(t) = x_\\text{free}(t) + \\int_0^t rhs(t - τ)h(τ)dτ,\n\\] where \\(x_\\text{free}(t)\\) is the free response of the system and \\(h(t)\\) is the impulse response of the system.\n\n\nData type\n\nSdofForcedTimeProblem\n\n\n\nSdofForcedTimeProblem(sdof, u0, t, F, ω, type_exc)\nStructure containing the data of a time problem for a sdof system subject to an arbitrary excitation\nFields\n\nsdof::Sdof: Sdof structure\n\nF::AbstractVector: Amplitude of the force excitation [N] or base motion [m]\n\nu0::AbstractVector: Initial conditions\n\nx0: Initial displacement [m]\n\nv0: Initial velocity [m/s]\n\n\n\nt::AbstractRange: Time points at which to evaluate the response\n\ntype_exc::Symbol: Type of excitation\n\n:force: External force (default)\n\n:base: Base motion\n\n\n\n\n\n\n\n\n\n\nRelated function\n\nsolve\n\n\n\nsolve(prob::SdofForcedTimeProblem)\nComputes the forced response of a single degree of freedom (Sdof) system due to an arbitrary external force or base motion\nInputs\n\nprob: Structure containing the parameters of the Sdof forced problem\n\nmethod: Method to compute the Duhamel's integral\n\n:filt: Filtering using the Z-transform of the impulse response (default)\n\n:interp: Interpolation + Gaussian quadrature\n\n:conv: Convolution product\n\n\n\n\nOutput\n\nsol: The response of the system at the given time points\n\nu: Displacement solution\n\ndu: Velocity solution\n\nddu: Acceleration solution\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Structural parameters\nm = 1.\nf0 = 1.\nξ = 0.1\n\n# Instantiation of the Sdof object\nsdof = Sdof(m, f0, ξ)\n\n# Haversine excitation signal\nF0 = 10.\ntstart = 0.5\nduration = 2.\nhaversine = HaverSine(F0, tstart, duration)\n\nt = 0.:0.01:10.\nF = excitation(haversine, t)\n\n# Instantiation of the problem\nu0 = [1, -2]\nprob = SdofForcedTimeProblem(sdof, F, u0, t, :force)\n\n# Solve the problem\nx_arb_filt = solve(prob, method = :filt).u\nx_arb_interp = solve(prob, method = :interp).u\nx_arb_conv = solve(prob, method = :conv).u;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe impulse response of a sdof system is the response of the system when it is subjected to an impulse excitation. The impulse response is the solution of the following ordinary differential equation: \\[\n\\overset{..}{h}(t) + 2\\xi\\omega_0\\overset{.}{h}(t) + \\omega_0^2 h(t) = \\frac{\\delta(t)}{m}.\n\\]\nIt can be shown that the impulse response can be computed by solving the following problem: \\[\n\\begin{cases}\n\\overset{..}{h}(t) + 2\\xi\\omega_0\\overset{.}{h}(t) + \\omega_0^2 h(t) = 0 & \\forall t &gt; 0 \\\\\nh(t) = 0 & \\text{at } t = 0 \\\\\n\\overset{.}{h}(t) = \\displaystyle\\frac{1}{m} & \\text{at } t = 0\n\\end{cases}.\n\\]\n\nimpulse_response\n\n\n\nimpulse_response(sdof, t)\nCompute the impulse response of a single degree of freedom (Sdof) system\nInputs\n\nsdof: Sdof structure\n\nt: Time points at which to evaluate the response\n\n\nOutput\n\nh: Impulse response\n\n\n\n\n\n\n\n\n\n# Structural parameters\nm = 1.\nf0 = 1.\nξ = 0.1\n\nt = 0.:0.01:10.\n\n# Instantiation of the Sdof object\nsdof = Sdof(m, f0, ξ)\n\nh = impulse_response(sdof, t)\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe shock response spectrum (SRS) is a graph of the peak acceleration response of a sdof system subjected to a base acceleration with respect to the frequency. The SRS is computed by solving the following problem: \\[\n\\ddot z(t) + 2\\xi\\omega_0\\dot z(t) + \\omega_0^2 z(t) = -\\ddot x_b(t),\n\\] where \\(z(t) = x(t) - x_b(t)\\) is the relative displacement of the system with respect to the base.\nTo compute the SRS, the following steps are performed at a given frequency \\(f\\):\n\nInstantiate a Sdof type\nsdof = Sdof(1., f, ξ)\nCompute the time response of the relative displacement \\(z(t)\\) due to a base acceleration for \\(z(0) = 0\\) and \\(\\dot z(0) = 0\\).\nCompute the acceleration \\(\\ddot x(t)\\) of the system: \\[\nx(t) = -2\\xi\\omega_0\\dot z(t) - \\omega_0^2 z(t)\n\\]\nExtract the primary or secondary part of the acceleration (i.e. until or after the end of the excitation signal).\nCompute either:\n\nThe peak acceleration of the system such that: \\[\nSRS(f) = \\max\\left(|\\ddot x(t)|\\right)\n\\]\nThe maximum positive acceleration of the system such that: \\[\nSRS(f) = \\max\\left(\\max(\\ddot x(t), 0)\\right)\n\\]\nThe maximum negative acceleration of the system such that: \\[\nSRS(f) = \\max\\left(\\max(-\\ddot x(t), 0)\\right)\n\\]\n\n\nSeveral algorithms are available to compute the SRS:\n\n:Basic: the SRS is computed by following the steps mentioned above. It is not the most efficient algorithm but it is the most versatile.\n:RecursiveInt: the SRS is computed using a recursive integration algorithm.\n:RecursiveFilt: the SRS is computed using a recursive filtering algorithm.\n:Smallwood: the SRS is computed using the Smallwood algorithm.\n\nFor the last three algorithms, more details and references can be found Mathworks - Introduction to SRS\n\nsrs\n\n\n\nsrs(base_acc::ArbitraryExc, freq, t, ξ = 0.05,\n    type = (instance = :primary, amplitude = :abs), alg = :Smallwood)\nCompute the Shock Response Spectrum (SRS)\nInputs\n\nbase_acc::ArbitraryExc: Base acceleration type - see excitation function for detatils\n\nfreq: Vector of frequencies [Hz]\n\nt: Time points at which to evaluate the response\n\nξ: Damping ratio (default = 0.05)\n\ntype: Type of SRS\n\ninstance: Instance of the SRS\n\n:primary: Primary instance (default)\n\n:secondary: Secondary instance\n\n\n\namplitude: Amplitude used of the computing SRS\n\n:abs: Maximum absolute amplitude (default)\n\n:pos: Maximum positive amplitude\n\n:neg: Maximum negative amplitude\n\n\n\n\n\nalg: Algorithm to compute the SRS\n\n:Basic: Basic algorithm\n\n:RecursiveInt: Recursive integration algorithm\n\n:RecursiveFilt: Recursive filtering algorithm\n\n:Smallwood: Smallwood algorithm (default)\n\n\n\n\nOutput\n\nsrs: Vector of the SRS values\n\n\nNote\n\nPrimary instance - response of the system during the application of the base acceleration\n\nSecondary instance - response of the system after the application of the base acceleration\n\n\n\n\n\n\n\n\n\n# Definition of the base acceleration\nt = 0.:1e-5:0.5\nbase_acc = HalfSine(10., 0., 1e-3)\n\n# Compute the SRS\nf = 50.:25:1e3\nsrs_basic = srs(base_acc, f, t)\nsrs_rec_int = srs(base_acc, f, t, alg = :RecursiveInt)\nsrs_rec_filt = srs(base_acc, f, t, alg = :RecursiveFilt)\nsrs_smallwood = srs(base_acc, f, t, alg = :Smallwood)",
    "crumbs": [
      "Solvers",
      "Sdof solvers"
    ]
  },
  {
    "objectID": "solvers/index.html#frequency-domain-solvers",
    "href": "solvers/index.html#frequency-domain-solvers",
    "title": "Sdof solvers",
    "section": "2 Frequency domain solvers",
    "text": "2 Frequency domain solvers\nThe package provides solvers for computing the Frequency Response Function (FRF) and the response spectrum of a sdof system.\n\n2.1 Frequency Response Function\nThe Frequency Response Function (FRF) of a sdof system is the ratio of the steady-state response \\(X(\\omega)\\) of the system to an external excitation \\(F(\\omega)\\) or an external base motion \\(X_b(\\omega)\\). The FRF is computed from the following equation: \\[\nH(\\omega) = \\begin{cases}\n\\displaystyle\\frac{1}{m(\\omega_0^2 - \\omega^2 + 2j\\xi\\omega\\omega_0)} & \\text{for a force excitation} \\\\\n\\displaystyle\\frac{\\omega_0^2 + 2j\\xi\\omega\\omega_0}{\\omega_0^2 - \\omega^2 + 2j\\xi\\omega\\omega_0} & \\text{for a base excitation}\n\\end{cases},\n\\] where \\(j\\) is the imaginary unit.\n\n2.1.1 API\nData type\n\nSdofFRFProblem\n\n\n\nSdofFRFProblem(sdof, freq, type_exc, type_resp)\nStructure containing the data for computing the FRF a sdof system\nFields\n\nsdof::Sdof: Sdof structure\n\nfreq::AbstractRange: Vector of frequencies [Hz]\n\ntype_exc::Symbol: Type of excitation\n\n:force: External force (default)\n\n:base: Base motion\n\n\n\ntype_resp::Symbol: Type of response\n\n:dis: Admittance (default)\n\n:vel: Mobility\n\n:acc: Accelerance\n\n\n\n\n\n\n\n\n\n\nRelated function\n\nsolve\n\n\n\nsolve(prob::SdofFRFProblem)\nCompute the FRF of a single degree of freedom (Sdof) system\nInputs\n\nprob: Structure containing the parameters of the Sdof FRF problem\n\n\nOutput\n\nsol: Solution of the FRF problem\n\nu: FRF of the system\n\n\n\n\n\n\n\n\n\n\n\n\n2.1.2 Example\n\n# Structural parameters\nm = 1.\nf0 = 10.\nξ = 0.01\n\n# Instantiation of the Sdof object\nsdof = Sdof(m, f0, ξ)\n\n# Definition of the frequency range\nf = 1.:0.1:30.\n\n# Instantiation of the problem - Force excitation\nprob = SdofFRFProblem(sdof, f)\n\n# Solve the problem\nH = solve(prob).u\n\n\n\n\n\n\n\n\n\n\n\n\n\n2.2 Response spectrum\nThe response spectrum of a sdof system is the frequency response of the system to an external force \\(F(\\omega)\\) or a base motion \\(X_b(\\omega)\\) with respect to the frequency. The response spectrum \\(Y(\\omega)\\) is computed from the following equation: \\[\nY(\\omega) = \\begin{cases}\n\\displaystyle\\frac{F(\\omega)}{m(\\omega_0^2 - \\omega^2 + 2j\\xi\\omega\\omega_0)} & \\text{for a force excitation} \\\\\n\\displaystyle\\frac{(\\omega_0^2 + 2j\\xi\\omega\\omega_0) X_b(\\omega)}{\\omega_0^2 - \\omega^2 + 2j\\xi\\omega\\omega_0} & \\text{for a base excitation}\n\\end{cases}.\n\\]\n\n2.2.1 API\nData type\n\nSdofFRFProblem\n\n\n\nSdofFrequencyProblem(sdof, F, type_exc, type_resp)\nStructure containing the data for computing the frequency response of a sdof system\nFields\n\nsdof::Sdof: Sdof structure\n\nF::AbstractVector: Vector of the force excitation [N] or base motion [m]\n\nfreq::AbstractRange: Vector of frequencies [Hz]\n\ntype_exc::Symbol: Type of excitation\n\n:force: External force (default)\n\n:base: Base motion\n\n\n\ntype_resp::Symbol: Type of response\n\n:dis: Displacement spectrum(default)\n\n:vel: Velocity spectrum\n\n:acc: Acceleration spectrum\n\n\n\n\n\n\n\n\n\n\nRelated function\n\nsolve\n\n\n\nsolve(prob::SdofFRFProblem)\nCompute the FRF of a single degree of freedom (Sdof) system\nInputs\n\nprob: Structure containing the parameters of the Sdof FRF problem\n\n\nOutput\n\nsol: Solution of the FRF problem\n\nu: FRF of the system\n\n\n\n\n\n\n\n\n\n\n\n\n2.2.2 Example\n\n# Structural parameters\nm = 1.\nf0 = 10.\nξ = 0.01\n\n# Instantiation of the Sdof object\nsdof = Sdof(m, f0, ξ)\n\n# Definition of the frequency range\nf = 1.:0.1:30.\n\n# Instantiation of the problem - Force excitation\nF = fill(10., length(f))\nprob = SdofFrequencyProblem(sdof, F, f)\n\n# Solve the problem\ny = solve(prob).u",
    "crumbs": [
      "Solvers",
      "Sdof solvers"
    ]
  },
  {
    "objectID": "solvers/direct_time_solvers.html",
    "href": "solvers/direct_time_solvers.html",
    "title": "Direct-time integration solvers",
    "section": "",
    "text": "Similarly to the previous section, the aim is to describe the direct time solvers available for solving Mdof systems. As a remainder, the equation of motion of the system is given by: \\[\n\\mathbf{M} \\ddot{\\mathbf{x}}(t) + \\mathbf{C} \\dot{\\mathbf{x}}(t) + \\mathbf{K} \\mathbf{x}(t) = \\mathbf{F}(t)\n\\] where \\(\\mathbf{M}\\) is the mass matrix, \\(\\mathbf{C}\\) is the damping matrix, \\(\\mathbf{K}\\) is the stiffness matrix, \\(\\mathbf{x}(t)\\) is the displacement vector, and \\(\\mathbf{F}(t)\\) is the vector of external forces.\nDirect-time integration solvers are used to solve the previous equation in the time domain. In Julia , we have the option of using DifferentialEquations.jl which provides a wide range of solvers for solving differential equations.\nThe StructuralVibration package provides its own set of fixed-step linear second-order ODE solvers for pedagogical purposes and for the sake of completeness of the package. It should also be noted that some of the solvers implemented in the package are not available in DiffentialEquations.jl. This is the case of the solvers of the Newmark family, which are widely used in structural dynamics.\nThe solvers available in the StructuralVibration package are:",
    "crumbs": [
      "Solvers",
      "Direct-time integration solvers"
    ]
  },
  {
    "objectID": "solvers/direct_time_solvers.html#api",
    "href": "solvers/direct_time_solvers.html#api",
    "title": "Direct-time integration solvers",
    "section": "1 API",
    "text": "1 API\nData types\n\nDirectTimeProblem\n\n\n\nDirectTimeProblem(K, M, C, F, u0, t)\nStructure containing data for the time solver\nConstructor\n\nK::AbstractMatrix: Stiffness matrix\n\nM::AbstractMatrix: Mass matrix\n\nC:AbstractMatrix: Damping matrix\n\nF::AbstractMatrix: External force matrix\n\nu0::Tuple: Initial conditions\n\nu0[1]: Initial displacement (or modal displacement)\n\nu0[2]: Initial velocity (or modal velocity)\n\n\n\nt::AbstractVector: Time points at which to evaluate the response\n\n\nFields\n\nK: Stiffness matrix\n\nM: Mass matrix\n\nC: Damping matrix\n\nF: External force matrix\n\nu0: Initial conditions\n\nu0[1]: Initial displacement\n\nu0[2]: Initial velocity\n\n\n\nh::Real: Time step\n\n\n\n\n\n\n\n\n\nCentralDiff\n\n\n\nCentralDiff()\nCentral difference time solver\n\n\n\n\n\n\n\nRK4\n\n\n\nRK4()\nFourth-order Runge-Kutta time solver\n\n\n\n\n\n\n\nNewmark\n\n\n\nNewmark(; γ0 = 0.5, β0 = 0.25)\nNewmark time solver\n\n\n\n\n\n\n\nHHT\n\n\n\nHHT(; γ0 = 0.5, β0 = 0.25, ρ = 1., αf = Inf)\nHilber-Hughes-Taylor time solver\n\n\n\n\n\n\n\nWBZ\n\n\n\nWBZ(; γ0 = 0.5, β0 = 0.25, ρ = 1., αm = Inf)\nWood-Bossak-Zienkiewicz time solver\n\n\n\n\n\n\n\nFoxGoodwin\n\n\n\nFoxGoodwin()\nFox-Goodwin time solver\n\n\n\n\n\n\n\nMidPoint\n\n\n\nMidPoint()\nMid-point rule time solver\n\n\n\n\n\n\n\nGeneralizedAlpha\n\n\n\nGeneralizedAlpha(; γ0 = 0.5, β0 = 0.25, ρ = 1., αf = Inf, αm = Inf)\nGeneralized-α time solver\n\n\n\n\n\n\nRelated function\n\nsolve\n\n\n\nsolve(prob::DirectTimeProblem, alg; progress = true)\nDirect time integration solver\nInputs\n\nprob: DirectTimeProblem structure\n\nalg: Numerical integration algorithm\n\nCentralDiff(): Central difference\n\nRK4(): Fourth-order Runge-Kutta\n\nNewmark(): Newmark\n\nHHT(): Hilber-Hughes-Taylor\n\nWBZ(): Wood-Bossak-Zienkiewicz\n\nGeneralizedAlpha(): Generalized-α (default)\n\nMidPoint(): Mid-point rule\n\n\n\nprogress: Show progress bar\n\n\nOutput\n\nsol: Solution structure containing the response of the system at the given time points\n\nu: Displacement\n\ndu: Velocity\n\nddu: Acceleration",
    "crumbs": [
      "Solvers",
      "Direct-time integration solvers"
    ]
  },
  {
    "objectID": "solvers/direct_time_solvers.html#free-response",
    "href": "solvers/direct_time_solvers.html#free-response",
    "title": "Direct-time integration solvers",
    "section": "2 Free response",
    "text": "2 Free response\nThe free response of a 2-dofs system is obtained by setting the external forces to zero. In this condition, the motion of the system is initiated by non-zero initial conditions. In the following example, the response provided by the direct time solvers is compared with the solution obtained by the modal solver described in Modal time solvers - Section 1 for the purpose of cross-validation.\n\n# System parameters\nM = Diagonal([2., 1.])\nK = [6. -2.; -2. 4.]\nξ = 0.05\n\nω, Φ = eigenmode(K, M)\nC = modal_damping_matrix(M, ω, ξ, Φ)\n\n# Time vector\nt = 0.:1e-2:30.\n\n# Initial conditions\nx0 = [0.2, 0.1]\nv0 = zeros(2)\nu0 = (x0, v0)\n\n# External forces\nF_free = zeros(2, length(t))\n\n# Direct time problem\nprob_free = DirectTimeProblem(K, M, C, F_free, u0, t)\nx_free_gα = solve(prob_free).u\nx_free_cd = solve(prob_free, CentralDiff()).u\nx_free_rk = solve(prob_free, RK4()).u\n\n# Modal time problem\nprob_free_modal =  FreeModalTimeProblem(K, M, ξ, u0, t)\nx_free_modal = solve(prob_free_modal).u",
    "crumbs": [
      "Solvers",
      "Direct-time integration solvers"
    ]
  },
  {
    "objectID": "solvers/direct_time_solvers.html#forced-response",
    "href": "solvers/direct_time_solvers.html#forced-response",
    "title": "Direct-time integration solvers",
    "section": "3 Forced response",
    "text": "3 Forced response\nThe forced response of a 2-dofs system is obtained by applying a haversine excitation to the first dof of the system. As in the previous section, the response provided by the direct time solvers is compared with the solution obtained by the modal solver described in Modal time solvers - Section 2 for the purpose of cross-validation.\n\n# System parameters\nM = Diagonal([2., 1.])\nK = [6. -2.; -2. 4.]\nξ = 0.05\n\nω, Φ = eigenmode(K, M)\nC = modal_damping_matrix(M, ω, ξ, Φ)\n\n# Time vector\nt = 0.:1e-2:30.\n\n# Initial conditions\nx0 = zeros(2)\nv0 = zeros(2)\nu0 = (x0, v0)\n\n# External forces\nF0 = 10.\ntstart = 2.\nduration = 5.\nhaversine = HaverSine(F0, tstart, duration)\nF0 = excitation(haversine, t)\nF = zeros(2, length(t))\nF[1, :] .= F0\n\n# Direct time problem\nprob_forced = DirectTimeProblem(K, M, C, F, u0, t)\nx_forced_gα = solve(prob_forced).u\nx_forced_cd = solve(prob_forced, CentralDiff()).u\nx_forced_rk = solve(prob_forced, RK4()).u\n\n# Modal time problem\nprob_forced_modal = ForcedModalTimeProblem(K, M, ξ, F, u0, t)\nx_forced_modal = solve(prob_forced_modal).u",
    "crumbs": [
      "Solvers",
      "Direct-time integration solvers"
    ]
  },
  {
    "objectID": "solvers/direct_time_solvers.html#footnotes",
    "href": "solvers/direct_time_solvers.html#footnotes",
    "title": "Direct-time integration solvers",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nN. M. Newmark. “A method of computation for structural dynamics”. Journal of the Engineering Mechanics Division, 85(3), 67-94, 1959.↩︎\nH. M. Hilber, T. J. Hughes and R. L. Taylor. “Improved numerical dissipation for time integration algorithms in structural dynamics”. Earthquake Engineering & Structural Dynamics 5(3), 283–292. 1977.↩︎\nW. L. Wood, M. Bossak, O. Zienkiewicz. “An alpha modification of Newmark’s method”. International Journal for Numerical Methods in Engineering, 15(10), 1562-1566, 1980.↩︎\nL. Fox, E. T. Goodwin. “Some new methods for numerical integration of ordinary differential equations”. Mathematical Proceedings of the Cambridge Philosophical Society, 45(3), 373-388, 1949.↩︎\nM. Géradin and D. Rixen. “Mechanical Vibrations: Theory and Application to Structural Dynamics”. Third Edition. John Wiley & Sons, 2015.↩︎\nJ. Chung and G. M. Hulbert. “A time integration algorithm for structural dynamics with improved numerical dissipation: the generalized-alpha method”. Journal of Applied Mechanics, 60(2), 371-375, 1993.↩︎",
    "crumbs": [
      "Solvers",
      "Direct-time integration solvers"
    ]
  },
  {
    "objectID": "signal_processing/noise.html",
    "href": "signal_processing/noise.html",
    "title": "Noise estimation & denoising",
    "section": "",
    "text": "Noise estimation and denoising are important steps in signal processing, especially in the context of structural vibration analysis. Noise can obscure the underlying signal, making it difficult to extract meaningful information. For instance, in inverse problems, noise can significantly affects the accuracy of the estimated solution when the system is ill-posed. Another example is Kalman filtering for which the noise covariance matrix is a key parameter.\nStructuralVibration.jl provides a set of tools for estimating noise in signals and for denoising them. The implemented methods can be applied to real or complex signals.\nHere, it is assumed that the noise is additive and Gaussian. This means that the noisy signal on a sensor \\(i\\), \\(\\mathbf{y}_i\\), can thus be modeled as the sum of a noise-free signal \\(\\mathbf{x}_i\\) and a noise term \\(\\mathbf{n}_i\\): \\[\n\\mathbf{y}_i = \\mathbf{x}_i + \\mathbf{n}_i,\n\\] where \\(\\mathbf{n}_i\\) is a zero-mean Gaussian noise with covariance matrix \\(\\mathbf{R}_i\\). A common assumption is that the noise covariance matrix is isotropic, implying that: \\[\n\\mathbf{R}_i = \\sigma_i^2 \\mathbf{I}_n,\n\\] where \\(\\sigma_i^2\\) is the noise variance on the channel \\(i\\) and \\(\\mathbf{I}\\) is the identity matrix of size \\(n\\) (the number of samples in the signal).",
    "crumbs": [
      "Signal processing",
      "Noise estimation & denoising"
    ]
  },
  {
    "objectID": "signal_processing/noise.html#noise-estimation",
    "href": "signal_processing/noise.html#noise-estimation",
    "title": "Noise estimation & denoising",
    "section": "1 Noise estimation",
    "text": "1 Noise estimation\nNoise estimation is the process of quantifying the level of noise present in a signal. This can be done using various methods, such as statistical analysis, spectral analysis, or model-based approaches. In StructuralVibration.jl, two main strategies are available for noise estimation:\n\nRegularization-based : These methods involve the resolution of an optimization problem.\nFiltering-based : These methods are based on a careful analysis of the statistics of a noisy signal and do not involve optimization.\n\n\n1.1 Estimation methods\n\n1.1.1 Regularization-based noise estimation\nRegularization-based noise estimation methods involve solving an optimization problem to estimate the noise variance associated to each measurement channel. The optimization problem is typically formulated as a minimization of a cost function that balances the fidelity to the data and a regularization term.\nFrom a general perspective, the denoising problem can be formulated as: \\[\n\\widehat{\\mathbf{x}}_i = \\underset{\\mathbf{x}_i}{\\text{argmin}} \\Vert \\mathbf{y}_i - \\mathbf{x}_i \\Vert_2^2 + \\lambda \\Vert \\mathbf{D} \\mathbf{x}_i \\Vert_2^2,\n\\] where \\(\\mathbf{D}\\) is generally the second order finite difference operator, \\(\\lambda\\) is a regularization parameter.\nThe solution of the previous optimization problem is given by: \\[\n\\widehat{\\mathbf{x}}_i = \\left( \\mathbf{I} + \\lambda \\mathbf{D}^\\mathsf{T} \\mathbf{D} \\right)^{-1} \\mathbf{y}_i,\n\\]\nA classical estimator of the noise variance is the biased sample variance given by: \\[\n\\widehat{\\sigma}_i^2 = \\frac{1}{n} \\Vert \\mathbf{y}_i - \\widehat{\\mathbf{x}}_i \\Vert_2^2.\n\\]\nThe main point here is to find an appropriate regularization parameter \\(\\lambda\\). In the literature, several methods have been proposed to estimate the regularization parameter. In this package, the following methods are implemented:\n\nGeneralized Cross Validation (GCV)1\nL-curve method2\n\n\n\n\n\n\n\nNote\n\n\n\nIn practice, this estimator can be computed without computing the denoised signal \\(\\widehat{\\mathbf{x}}_i\\) explicitly. To do so, the implementation makes use of the discrete cosine transform (DCT).\n\n\n\n\n1.1.2 Filtering-based noise estimation\nHeuristic-based noise estimation methods are based on a careful analysis of the statistics of a noisy signal and often rely on the assumption that the noise is Gaussian. These methods do not involve optimization and are typically faster than regularization-based methods. They can be used to estimate the noise variance directly from the noisy signal. StructuralVibration.jl implements the method proposed John D’Errico in the Matlab function estimatenoise.m3\n\n\n\n1.2 API\nData types\n\nGCVEst\n\n\n\nGCVEst\nGeneralized Cross-Validation (GCV) noise estimation\nThis method has been proposed by Garcia in [1]\nFields\n\nnothing\n\n\nReference\n[1] Garcia, D. (2010). Robust smoothing of gridded data in one and higher dimensions with missing values. Computational Statistics and Data Analysis, 54(5), 1167-1178\n\n\n\n\n\n\n\nLCurveEst\n\n\n\nLCurveEst\nL-curve noise estimation\nThis method is based on the method proposed by Hansen in [1]\nFields\n\nnothing\n\n\nReference\n[1] Hansen, P. C. (1999). The L-curve and its use in the numerical treatment of inverse problems. Computational Inverse Problems in Electrocardiology, 119-142\n\n\n\n\n\n\n\nDerricoEst\n\n\n\nDerricoEst\nD'Errico noise estimation\nThis method has been proposed by John D'Errico in [1]\nFields\n\nnothing\n\n\nReference\n[1] John D'Errico (2023). Estimatenoise, MATLAB Central File Exchange. Retrieved December 7, 2023. (https://www.mathworks.com/matlabcentral/fileexchange/16683-estimatenoise)\n\n\n\n\n\n\nRelated function\n\nvarest\n\n\n\nvarest(x, method::NoiseEstimation; batch_size = 0, summary = mean)\nEstimates the noise variance of a signal x using a given method\nInputs\n\nx: Signal\n\nmethod: Noise estimation method\n\nBayesianEst: Bayesian noise estimation (To be implemented)\n\nGCVEst: Generalized Cross-Validation (GCV) noise estimation\n\nLCurveEst: L-curve noise estimation\n\nDerricoEst: D'Errico noise estimation\n\n\n\nbatch_size: Batch size for batch processing (default = 0)\n\nsummary: Summary function for batch processing (default = mean)\n\n\n\n\n\n\n\n\n\n\n1.3 Example\n\n# Beam definition\nL = 1.\nb = 3e-2\nh = 1e-2\nE = 2.1e11\nρ = 7850.\nξn = 1e-2\nS = b*h\nIz = b*h^3/12.\n\nbeam = Beam(L, S, Iz, E, ρ)\n\n# Measurement mesh\nΔx = 5e-2\nNpoint = 20\nXm = LinRange(Δx, L - Δx, Npoint)\n\n# Modes calculation\nωn, kn = modefreq(beam, 2000.)\nϕm = modeshape(beam, kn, Xm)\nϕe = modeshape(beam, kn, Xm[13])\n\n# Modal model\nKn, Mn, Cn = modal_matrices(ωn, ξn)\n\n# Excitation\ntmax = 0.5\nnt = 10_000\nt = LinRange(0., tmax, nt)\n\nharmo = SineWave(1e4, 0., tmax, 2π*10.)\nF = excitation(harmo, t)\nFn = ϕe'*F'\n\n# Solution calculation\nu0 = (zeros(length(ωn)), zeros(length(ωn)))\nprob = DirectTimeProblem(Kn, Mn, Cn, Fn, u0, t)\nu = ϕm*solve(prob).u\n\n# Signal corruption - Additive Gaussian White Noise\nSNR_ref = 25.\ny = agwn(u, SNR_ref)\n\n# Variance estimation - Average over all channels\nv1 = varest(y, GCVEst())\nSNR_est1 = mean(estimated_SNR(y, v1))\n\nv2 = varest(y, LCurveEst())\nSNR_est2 = mean(estimated_SNR(y, v2))\n\nv3 = varest(y, DerricoEst())\nSNR_est3 = mean(estimated_SNR(y, v3))\n\n\n\n\n\nNoise variance estimation\n\n\nReference\nGCV\nL-curve\nD'Errico\n\n\n25.0 dB\n25.16 dB\n25.1 dB\n25.05 dB",
    "crumbs": [
      "Signal processing",
      "Noise estimation & denoising"
    ]
  },
  {
    "objectID": "signal_processing/noise.html#signal-denoising",
    "href": "signal_processing/noise.html#signal-denoising",
    "title": "Noise estimation & denoising",
    "section": "2 Signal denoising",
    "text": "2 Signal denoising\nSignal denoising is the process of removing noise from a signal to recover the underlying clean signal. This can be done using various methods, such as filtering, wavelet transforms, or model-based approaches. In StructuralVibration.jl, the denoising process is typically performed using the same methods as those used for noise estimation. As for noise estimation, the proposed methods can be applied to real or complex signals.\n\n2.1 Denoising methods\nStructuralVibration.jl proposes two main methods for denoising signals:\n\nRegularization-based denoising: This method involves solving an optimization problem to estimate the noise-free signal. The optimization problem is typically formulated as a minimization of a cost function that balances the fidelity to the data and a regularization term.\nFiltering-based denoising: This method is based on the implementation of a Kalman filter, which is a recursive algorithm that estimates the state of a dynamic system from a series of noisy measurements.\n\n\n2.1.1 Regularization-based denoising\nRegularization-based denoising consists in solving the minimization problem defined in Section 1.1.1. This implies a proper estimation of the regularization parameter \\(\\lambda\\). Similar to the noise estimation process, two methods are available for estimating the regularization parameter, namely GCV and L-curve methods.\n\n\n2.1.2 Filtering-based denoising\nAs stated above, filtering-based denoising is based on the implementation of a Kalman filter. For denoising problems, the Kalman filter is based on the following state-space model: \\[\n\\begin{cases}\n\\mathbf{x}_{k+1} = \\mathbf{x}_k + \\mathbf{w}_k \\\\\n\\mathbf{y}_k = \\mathbf{x}_k + \\mathbf{n}_k\n\\end{cases},\n\\] where \\(\\mathbf{x}_k\\) is the state vector (clean signal) at time \\(k\\), \\(\\mathbf{y}_k\\) is the measurement vector at time \\(k\\), \\(\\mathbf{w}_k\\) is the process noise, and \\(\\mathbf{n}_k\\) is the measurement noise. The process noise is assumed to be zero-mean Gaussian with constant covariance matrix \\(\\mathbf{Q}\\), and the measurement noise is assumed to be zero-mean Gaussian with constant covariance matrix \\(\\mathbf{R}\\).\nPractically, a Kalman filter is implemented in two steps:\n\nPrediction step: The state vector and its covariance matrix are predicted based on the knowledge of the solution at the previous step. \\[\n\\begin{align*}\n\\widetilde{\\mathbf{x}}_{k} &= \\widehat{\\mathbf{x}}_{k-1} \\\\\n\\widetilde{\\mathbf{P}}_{k} &= \\widehat{\\mathbf{P}}_{k-1} + \\mathbf{Q}\n\\end{align*},\n\\] where \\(\\widetilde{\\mathbf{x}}_{k}\\) is the predicted state vector, \\(\\widehat{\\mathbf{x}}_{k-1}\\) is the estimated state vector at step \\(k-1\\), \\(\\widetilde{\\mathbf{P}}_{k}\\) is the predicted covariance matrix, and \\(\\widehat{\\mathbf{P}}_{k-1}\\) is the estimated covariance matrix at step \\(k-1\\).\nUpdate step: The state vector and its covariance matrix are updated based on the measurement at the current step. \\[\n\\begin{align*}\n\\mathbf{i}_k &= \\mathbf{y}_k - \\widetilde{\\mathbf{x}}_{k} \\\\\n\\mathbf{S}_k &= \\widetilde{\\mathbf{P}}_{k} + \\mathbf{R} \\\\\n\\mathbf{K}_{k} &= \\widetilde{\\mathbf{P}}_{k} \\mathbf{S}_k^{-1} \\\\\n\\widehat{\\mathbf{x}}_{k} &= \\widetilde{\\mathbf{x}}_{k} + \\mathbf{K}_{k} \\mathbf{i}_k \\\\\n\\widehat{\\mathbf{P}}_{k} &= \\left( \\mathbf{I} - \\mathbf{K}_{k}\\right) \\widetilde{\\mathbf{P}}_{k}\n\\end{align*},\n\\] where \\(\\widehat{\\mathbf{x}}_{k}\\) is the updated state vector, \\(\\widehat{\\mathbf{P}}_{k}\\) is the updated covariance matrix and \\(\\mathbf{K}_{k}\\) is the Kalman gain, \\(\\mathbf{i}_k\\) is the innovation vector and \\(\\mathbf{S}_k\\) is the innovation covariance matrix.\n\nFor a successful denoising process, the Kalman filter requires a proper tuning of the noise covariance matrices \\(\\mathbf{Q}\\) and \\(\\mathbf{R}\\) as wel as a proper initialization of the state vector and its covariance matrix.\nHere, the measurement noise covariance matrix \\(\\mathbf{R}\\) is estimated using the methods described in the previous section. The process noise covariance matrix \\(\\mathbf{Q}\\) is assumed to be isotropic and its variance \\(\\sigma_x^2\\) results from the resolution of the following optimization problem: \\[\n\\widehat{\\sigma}_x^2 = \\underset{\\sigma_x^2}{\\text{argmin}} \\sum_{i = 1}^N \\left[\\log|\\mathbf{S}_k| + \\mathbf{i}_k^\\mathsf{T}\\mathbf{S}_k^{-1}\\mathbf{i}_k\\right],\n\\] where \\(N\\) is the length of the measurement sequence.\nIn addition to the filtering step, a smoothing step can be added. In the present case, a Rauch-Tung-Striebel (RTS) smoother is used. From a practical point of view, the RTS smoother is implemented as a post-processing step that uses the Kalman filter output to improve the estimate of the state vector. The RTS smoother is based on the following equations: \\[\n\\begin{align*}\n\\widehat{\\mathbf{x}}_k^s &= \\widehat{\\mathbf{x}}_k + \\mathbf{K}_k \\left( \\widehat{\\mathbf{x}}_{k+1}^s - \\widehat{\\mathbf{x}}_k \\right) \\\\\n\\widehat{\\mathbf{P}}_k^s &= \\widehat{\\mathbf{P}}_k + \\mathbf{K}_k \\left( \\widehat{\\mathbf{P}}_{k+1}^s - \\widehat{\\mathbf{P}}_k \\right) \\mathbf{K}_k^\\mathsf{T} \\\\\n\\mathbf{K}_k &= \\widehat{\\mathbf{P}}_k (\\widehat{\\mathbf{P}}_k + \\mathbf{Q})^{-1} \\\\\n\\end{align*},\n\\] where \\(\\widehat{\\mathbf{x}}_k^s\\) is the smoothed state vector, \\(\\widehat{\\mathbf{P}}_k^s\\) is the smoothed covariance matrix, and \\(\\mathbf{K}_k\\) is the Kalman gain.\n\n\n\n2.2 API\nData types\n\nGCVDenoising\n\n\n\nGCVDenoising()\nRegularization-based denoising method using the GCV method for estimating the regularization parameter\nFields\n\nnothing\n\n\nReference\n[1] Garcia, D. (2010). Robust smoothing of gridded data in one and higher dimensions with missing values. Computational Statistics and Data Analysis, 54(5), 1167-1178\n\n\n\n\n\n\n\nLCurveDenoising\n\n\n\nLCurveDenoising()\nRegularization-based denoising method using the L-curve method for estimating the regularization parameter\nFields\n\nnothing\n\n\nReference\n[1] Hansen, P. C. (1999). The L-curve and its use in the numerical treatment of inverse problems. Computational Inverse Problems in Electrocardiology, 119-142\n\n\n\n\n\n\n\nKalmanDenoising\n\n\n\nKalmanDenoising(; rts = false)\nKalman filter denoising method\nFields\n\nrts: Flag to enable the Rauch-Tung-Striebel smoother\n\n\n\n\n\n\n\n\nRelated function\n\ndenoising\n\n\n\ndenoising(y::AbstractArray, alg)\nDenoises a signal y\nInputs\n\ny: Noisy signal\n\nalg: Denoising method\n\nBayesDenoising: Bayesian Regularization denoising method (to be implemented)\n\nGCVDenoising: GCV denoising method\n\nLCurveDenoising: L-curve denoising method\n\nKalmanDenoising: Kalman filter denoising method\n\n\n\n\nOutput\n\nx: Denoised signal\n\n\n\n\n\n\n\n\n\n\n2.3 Example\n\n# Beam definition\nL = 1.\nb = 3e-2\nh = 1e-2\nE = 2.1e11\nρ = 7850.\nξn = 1e-2\nS = b*h\nIz = b*h^3/12.\n\nbeam = Beam(L, S, Iz, E, ρ)\n\n# Measurement mesh\nΔx = 5e-2\nNpoint = 20\nXm = LinRange(Δx, L - Δx, Npoint)\n\n# Modes calculation\nωn, kn = modefreq(beam, 2000.)\nϕm = modeshape(beam, kn, Xm)\nϕe = modeshape(beam, kn, Xm[13])\n\n# Modal model\nKn, Mn, Cn = modal_matrices(ωn, ξn)\n\n# Problem definition & solution\ntmax = 0.1\nnt = 5_000\nt = LinRange(0., tmax, nt)\n\nharmo = SineWave(1e4, 0., tmax, 2π*10.)\nF = excitation(harmo, t)\nFn = ϕe'*F'\n\nu0 = (zeros(length(ωn)), zeros(length(ωn)))\nprob = DirectTimeProblem(Kn, Mn, Cn, Fn, u0, t)\nsol = solve(prob)\n\nu = ϕm*sol.u\n\n# Gaussian White Noise\nsnr_dB = 10.\ny = agwn(u, snr_dB)\n\n# Regularization denoising\nyc_gcv = denoising(y, GCVDenoising())\nyc_lcurve = denoising(y, LCurveDenoising())\n\n# Kalman denoising\nyc_kalman = denoising(y, KalmanDenoising())\nyc_rts = denoising(y, KalmanDenoising(rts = true))",
    "crumbs": [
      "Signal processing",
      "Noise estimation & denoising"
    ]
  },
  {
    "objectID": "signal_processing/noise.html#footnotes",
    "href": "signal_processing/noise.html#footnotes",
    "title": "Noise estimation & denoising",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nD. Garcia. “Robust smoothing of gridded data in one and higher dimensions with missing values”. Computational Statistics & Data Analysis, 54(5), pp. 1167-1178, 2010.↩︎\nP. C. Hansen. “The L-curve and its use in the numerical treatment of inverse problems”. Computational Inverse Problems in Electrocardiology, pp. 119-142, 2001.↩︎\nJohn D’Errico. “Estimatenoise”, MATLAB Central File Exchange. Retrieved December 7, 2023. Link↩︎",
    "crumbs": [
      "Signal processing",
      "Noise estimation & denoising"
    ]
  },
  {
    "objectID": "overview/installation.html",
    "href": "overview/installation.html",
    "title": "Installation",
    "section": "",
    "text": "Note\n\n\n\nIf you are already a Julia user, you can skip this section.\nThis section explains how to install Julia and Vibration.jl.",
    "crumbs": [
      "Overview",
      "Installation"
    ]
  },
  {
    "objectID": "overview/installation.html#install-julia",
    "href": "overview/installation.html#install-julia",
    "title": "Installation",
    "section": "Install Julia ",
    "text": "Install Julia \nThere exists several ways of installing Julia and managing versions. The recommended way consists in installing juliaup, which is a Julia version manager.\n\nWindows\nOn Windows, juliaup can be installed directly from the Windows store or from a terminal by typing the following command:\nwinget install julia -s msstore\nMacOS and Linux\nOn MacOS and Linux, juliaup can be installed from a terminal by typing:\ncurl -fsSL https://install.julialang.org | sh\nor by using software repositories:\n# MacOS\nbrew install juliaup\n\n# Arch-based distributions\nyay -S juliaup\n\nOnce juliaup is installed, the latest version of Julia can be installed from a terminal as follows:\njuliaup add release",
    "crumbs": [
      "Overview",
      "Installation"
    ]
  },
  {
    "objectID": "overview/installation.html#install-vibrationdata.jl",
    "href": "overview/installation.html#install-vibrationdata.jl",
    "title": "Installation",
    "section": "Install VibrationData.jl ",
    "text": "Install VibrationData.jl \nThe package is not yet registered in the Julia General Registry. To install the package, you can use the following command:\n(Yourenv) pkg&gt; add \"git@https://github.com/maucejo/VibrationData.jl.git\"",
    "crumbs": [
      "Overview",
      "Installation"
    ]
  },
  {
    "objectID": "models/index.html",
    "href": "models/index.html",
    "title": "Mechanical models",
    "section": "",
    "text": "Longitudinal bars, torsional rods and strings are governed by the wave equation, which can be written under the following form: \\[\nm \\ddot y(x, t) - D \\frac{\\partial^2 y(x,t)}{\\partial x^2} = p(x, t),\n\\] where:\n\n\\(y(x, t)\\): Kinematic data at location \\(x\\) and time \\(t\\)\n\\(p(x, t)\\): External excitation term\n\\(m\\): Linear inertia of the type\n\\(D\\): Stiffness of the type\n\nFor a longitudinal bar:\n\n\\(y(x, t) = u(x, t)\\)\n\n\\(u(x, t)\\): Longitudinal displacement [m]\n\n\\(p(x, t)\\): Distributed longitudinal force [N/m]\n\\(m = \\rho S\\): Linear mass density [kg/m2]\n\n\\(\\rho\\): Mass density [kg/m3]\n\\(S\\): Cross-section area [m2]\n\n\\(D = E S\\): Longitudinal stiffness [N]\n\n\\(E\\): Young’s modulus [Pa]\n\n\nFor a torsional rod:\n\n\\(y(x, t) = \\theta(x, t)\\)\n\n\\(\\theta\\): Torsion angle [rad]\n\n\\(p(x, t)\\): Distributed moment [N.m/m]\n\\(m = \\rho I_G\\): Linear rotational inertia [kg.m4]\n\n\\(I_G\\): Polar moment of area [m4]\n\n\\(D = G J_T\\): Rotational stiffness [N.m2]\n\n\\(G\\): Shear modulus [Pa]\n\\(J_T\\): Torsion constant [m4]\n\n\nFor a string:\n\n\\(y(x, y)\\): Transverse displacement [m]\n\\(m\\): Linear mass density [kg/m]\n\\(D\\): Tension force [N]\n\n\n\n\nEuler-Bernoulli beams are governed by the following equation of motion: \\[\nm\\ddot v(x, t) + D\\frac{\\partial^4 v(x, t)}{\\partial x^4} = p(x, t),\n\\] where:\n\n\\(v(x, t)\\): Transverse displacement [m]\n\\(p(x, t)\\): External excitation term [N/m]\n\\(m = \\rho S\\): Linear mass density [kg/m]\n\\(D = E I_z\\): Bending stiffness [N.m2]\n\n\\(I_z\\): Second moment of area [m4]\n\n\n\n\n\nData types\nAll the following data types are a subtype of the super type OneDtype.\n\nBar\n\n\n\nBar(L, S, E, ρ)\nStructure containing the data of a homogeneous and isotropic longitudinal bar\nConstructor parameters\n\nL: Length [m]\n\nS: Cross-section area [m²]\n\nE: Young's modulus [Pa]\n\nρ: Mass density [kg/m³]\n\n\nFields\n\nL: Length [m]\n\nm: Line mass [kg/m]\n\nD: Stiffness coefficient [Pa]\n\n\n\n\n\n\n\n\n\nRod\n\n\n\nRod(L, I, J, G, ρ)\nStructure containing the data of a homogeneous and isotropic torsional bar\nConstructor parameters\n\nL: Length [m]\n\nI: Second-moment of area [m⁴]\n\nJ: Torsion constant [m⁴]\n\nG: Shear modulus [Pa]\n\nρ: Mass density [kg/m³]\n\n\nFields\n\nL: Length [m]\n\nm: Line mass [kg/m]\n\nD: Stiffness coefficient [Pa]\n\n\n\n\n\n\n\n\n\nStrings\n\n\n\nStrings(L, S, D, ρ)\nStructure containing the data of a homogeneous and isotropic string\nConstructor parameters\n\nL: Length [m]\n\nS: Cross-section area [m²]\n\nD: Tension [N]\n\nρ: Mass density [kg/m³]\n\n\nFields\n\nL: Length [m]\n\nm: Linear mass density [kg/m]\n\nD: Tension [N]\n\n\n\n\n\n\n\n\n\nBeam\n\n\n\nBeam(L, S, I, E, ρ)\nStructure containing the data of a homogeneous and isotropic bending beam\nConstructor parameters\n\nL: Length [m]\n\nS: Cross-section area [m²]\n\nI: Second moment of area [m⁴]\n\nE: Young's modulus [Pa]\n\nρ: Density [kg/m³]\n\n\nFields\n\nL: Length [m]\n\nM: Linear mass density [kg/m]\n\nD: Bending stiffness [N.m²]\n\n\n\n\n\n\n\n\nRelated functions\n\nmodefreq\n\n\n\nmodefreq(model::Bar, fmax, bc = :CC)\nmodefreq(model::Rod, fmax, bc = :CC)\nmodefreq(model::Strings, fmax, bc = :CC)\nmodefreq(model::Beam, fmax, bc = :SS)\nComputes the natural frequencies of a longitudinal or torsional bar up to fmax\nInputs\n\nmodel: Structure containing the bar data\n\nfmax: Maximum frequency for calculating the mode shapes [Hz]\n\nbc: Boundary conditions\n\nFor all OneDStructure\n\n:CC: Clamped - Clamped\n\n:CF: Clamped - Free\n\n:FF: Free - Free\n\n\n\nFor beams\n\n:SS: Simply Supported - Simply Supported\n\n:SC: Simply Supported - Clamped\n\n:SF: Simply Supported - Free\n\n\n\n\n\n\nOutputs\n\nωn: Natural frequencies calculated up to ωmax = 2π*fmax [Hz]\n\nkn: Vector of modal wavenumbers\n\n\n\n\n\n\n\n\n\nmodeshape\n\n\n\nmodeshape(model::Bar, kn, x, bc = :CC)\nmodeshape(model::Rod, kn, x, bc = :CC)\nmodeshape(model::Strings, kn, x, bc = :CC)\nmodeshape(model::Beam, kn, x, bc = :SS)\nComputes the mass-normalized mode shapes of a longitudinal or torsional bar\nInputs\n\nmodel: Structure containing the bar data\n\nkn: Array of modal wavenumbers\n\nx: Coordinates of calculation points of the mode shapes\n\nbc: Boundary conditions\n\nFor all OneDStructure\n\n:CC: Clamped - Clamped\n\n:CF: Clamped - Free\n\n:FF: Free - Free\n\n\n\nFor beams\n\n:SS: Simply Supported - Simply Supported\n\n:SC: Simply Supported - Clamped\n\n:SF: Simply Supported - Free\n\n\n\n\n\n\nOutput\n\nϕ: Mass-normalized mode shapes\n\n\n\n\n\n\n\n\n\n\n\n# Dimensions\nL = 1.\nd = 3e-2\n\n# Section features\nS = π*d^2/4\nIz = π*d^4/64\nIG = 2Iz\nJ = IG\n\n# Tension for string\nT = 100.\n\n# Material\nE = 2.1e11\nν = 0.33\nG = E/(1 - 2*ν)\nρ = 7800.\n\n# Computation parameters\nfmax = 2000.\nx = [0.1, 0.9]\n\n# Initialization of the data types\nbar = Bar(L, S, E, ρ)\nrod = Rod(L, IG, J, G, ρ)\nstrings = Strings(L, S, T, ρ)\nbeam = Beam(L, S, Iz, E, ρ)\n\n# Computation of the natural frequencies\nωn, kn = modefreq(bar, fmax)\n\n# Computation of the corresponding mode shapes\nϕn = modeshape(bar, kn, x, :CC)\n\n\n\n\n\n\nRectangular membranes are governed by the following equation of motion: \\[\nm \\ddot w(x, y ,t) + D\\Delta w(x, y, t) = p(x, y, t),\n\\] where:\n\n\\(w(x, y, t)\\): Transverse displacement [m] at point \\((x, y)\\) and time \\(t\\)\n\\(m\\): Surface mass [kg/m]\n\\(D = \\tau\\): Linear tension [N/m]\n\\(\\Delta = \\frac{\\partial^2}{\\partial x^2} + \\frac{\\partial^2}{\\partial y^2}\\): Laplacian operator\n\n\n\n\nRectangular Kirchhoff-Love plates are governed by the following equation of motion: \\[\nm \\ddot w(x, y, t) + D \\Delta^2 w(x, y, t) = p(x, y, t),\n\\] where:\n\n\\(w(x, y, t)\\): Transverse displacement [m] at point \\((x, y)\\) and time \\(t\\)\n\\(m = \\rho h\\): Surface mass [kg/m2]\n\n\\(h\\): Thickness [m]\n\n\\(D = \\frac{Eh^3}{12(1 - \\nu^2)}\\): Bending stiffness [N.m]\n\n\\(\\nu\\): Poisson’s coefficient\n\n\\(\\Delta^2 = \\frac{\\partial^4}{\\partial x^4} + 2\\frac{\\partial^4}{\\partial x^2 \\partial y^2} + \\frac{\\partial^4}{\\partial y^4}\\): Bilaplacian operator\n\n\n\n\nData type\nAll the following data types are a subtype of the super type TwoDStructure.\n\nMembrane\n\n\n\nMembrane(L, b, m, D)\nStructure containing the data of a homogeneous and isotropic rectangular membrane\nFields\n\nL: Length [m]\n\nb: Width [m]\n\nm: Surface mass [kg/m²]\n\nD: Tension per unit length [N/m]\n\n\n\n\n\n\n\n\n\nPlate\n\n\n\nPlate(L, b, h, E, ρ, ν)\nStructure containing the data of a homogeneous and isotropic bending plate\nConstructor parameters\n\nL: Length [m]\n\nb: Width [m]\n\nE: Young's modulus [Pa]\n\nρ: Density [kg/m³]\n\nν: Poisson's ratio\n\n\nFields\n\nL: Length [m]\n\nb: Width [m]\n\nm: Surface mass [kg/m²]\n\nD: Bending stiffness [N.m]\n\n\n\n\n\n\n\n\nRelated functions\n\nmodefreq\n\n\n\nmodefreq(model::Plate, fmax)\nmodefreq(model::Membrane, fmax)\nComputes the natural frequencies of a simply supported rectangular plate or a clamped rectangular membrane up to fmax\nInputs\n\nmodel: Structure containing the data related to the plate\n\nfmax: Maximum frequency for calculating the modal shapes [Hz]\n\n\nOutputs\n\nωmn: Natural frequencies calculated up to ωmax = 2π*fmax [Hz]\n\nkmn: Matrix of modal wave numbers\n\n\n\n\n\n\n\n\n\nmodeshape\n\n\n\nmodeshape(model::Plate, kpq, x, y)\nmodeshape(model::Membrane, kpq, x, y)\nComputes the mass-normalized mode shapes of a simply supported rectangular plate or a clamped rectangular membrane\nInputs\n\nmodel: Structure containing the data related to the structure\n\nkmn: Matrix of modal wave numbers\n\n(x, y): Coordinates of the points where the mode shapes are calculated\n\n\nOutput\n\nϕ: Mass-normalized mode shapes\n\n\n\n\n\n\n\n\n\n\n\n# Dimensions\nLp = 0.6\nbp = 0.4\nhp = 1e-3\n\n# Material parameters\nE = 2.1e11\nρ = 7800.\nν = 0.33\n\n# Computation parameters\nfmax = 1000.\nxp = [0.1, 0.5]\nyp = [0.1, 0.3]\n\n# Initialization of the data types\nplate = Plate(Lp, bp, hp, E, ρ, ν)\n\n# Computation of the natural frequencies\nωn, kn = modefreq(plate, fmax)\n\n# Computation of the corresponding mode shapes\nϕn = modeshape(plate, kn, xp, yp)",
    "crumbs": [
      "Models",
      "Mechanical models"
    ]
  },
  {
    "objectID": "models/index.html#continuous-models",
    "href": "models/index.html#continuous-models",
    "title": "Mechanical models",
    "section": "",
    "text": "Longitudinal bars, torsional rods and strings are governed by the wave equation, which can be written under the following form: \\[\nm \\ddot y(x, t) - D \\frac{\\partial^2 y(x,t)}{\\partial x^2} = p(x, t),\n\\] where:\n\n\\(y(x, t)\\): Kinematic data at location \\(x\\) and time \\(t\\)\n\\(p(x, t)\\): External excitation term\n\\(m\\): Linear inertia of the type\n\\(D\\): Stiffness of the type\n\nFor a longitudinal bar:\n\n\\(y(x, t) = u(x, t)\\)\n\n\\(u(x, t)\\): Longitudinal displacement [m]\n\n\\(p(x, t)\\): Distributed longitudinal force [N/m]\n\\(m = \\rho S\\): Linear mass density [kg/m2]\n\n\\(\\rho\\): Mass density [kg/m3]\n\\(S\\): Cross-section area [m2]\n\n\\(D = E S\\): Longitudinal stiffness [N]\n\n\\(E\\): Young’s modulus [Pa]\n\n\nFor a torsional rod:\n\n\\(y(x, t) = \\theta(x, t)\\)\n\n\\(\\theta\\): Torsion angle [rad]\n\n\\(p(x, t)\\): Distributed moment [N.m/m]\n\\(m = \\rho I_G\\): Linear rotational inertia [kg.m4]\n\n\\(I_G\\): Polar moment of area [m4]\n\n\\(D = G J_T\\): Rotational stiffness [N.m2]\n\n\\(G\\): Shear modulus [Pa]\n\\(J_T\\): Torsion constant [m4]\n\n\nFor a string:\n\n\\(y(x, y)\\): Transverse displacement [m]\n\\(m\\): Linear mass density [kg/m]\n\\(D\\): Tension force [N]\n\n\n\n\nEuler-Bernoulli beams are governed by the following equation of motion: \\[\nm\\ddot v(x, t) + D\\frac{\\partial^4 v(x, t)}{\\partial x^4} = p(x, t),\n\\] where:\n\n\\(v(x, t)\\): Transverse displacement [m]\n\\(p(x, t)\\): External excitation term [N/m]\n\\(m = \\rho S\\): Linear mass density [kg/m]\n\\(D = E I_z\\): Bending stiffness [N.m2]\n\n\\(I_z\\): Second moment of area [m4]\n\n\n\n\n\nData types\nAll the following data types are a subtype of the super type OneDtype.\n\nBar\n\n\n\nBar(L, S, E, ρ)\nStructure containing the data of a homogeneous and isotropic longitudinal bar\nConstructor parameters\n\nL: Length [m]\n\nS: Cross-section area [m²]\n\nE: Young's modulus [Pa]\n\nρ: Mass density [kg/m³]\n\n\nFields\n\nL: Length [m]\n\nm: Line mass [kg/m]\n\nD: Stiffness coefficient [Pa]\n\n\n\n\n\n\n\n\n\nRod\n\n\n\nRod(L, I, J, G, ρ)\nStructure containing the data of a homogeneous and isotropic torsional bar\nConstructor parameters\n\nL: Length [m]\n\nI: Second-moment of area [m⁴]\n\nJ: Torsion constant [m⁴]\n\nG: Shear modulus [Pa]\n\nρ: Mass density [kg/m³]\n\n\nFields\n\nL: Length [m]\n\nm: Line mass [kg/m]\n\nD: Stiffness coefficient [Pa]\n\n\n\n\n\n\n\n\n\nStrings\n\n\n\nStrings(L, S, D, ρ)\nStructure containing the data of a homogeneous and isotropic string\nConstructor parameters\n\nL: Length [m]\n\nS: Cross-section area [m²]\n\nD: Tension [N]\n\nρ: Mass density [kg/m³]\n\n\nFields\n\nL: Length [m]\n\nm: Linear mass density [kg/m]\n\nD: Tension [N]\n\n\n\n\n\n\n\n\n\nBeam\n\n\n\nBeam(L, S, I, E, ρ)\nStructure containing the data of a homogeneous and isotropic bending beam\nConstructor parameters\n\nL: Length [m]\n\nS: Cross-section area [m²]\n\nI: Second moment of area [m⁴]\n\nE: Young's modulus [Pa]\n\nρ: Density [kg/m³]\n\n\nFields\n\nL: Length [m]\n\nM: Linear mass density [kg/m]\n\nD: Bending stiffness [N.m²]\n\n\n\n\n\n\n\n\nRelated functions\n\nmodefreq\n\n\n\nmodefreq(model::Bar, fmax, bc = :CC)\nmodefreq(model::Rod, fmax, bc = :CC)\nmodefreq(model::Strings, fmax, bc = :CC)\nmodefreq(model::Beam, fmax, bc = :SS)\nComputes the natural frequencies of a longitudinal or torsional bar up to fmax\nInputs\n\nmodel: Structure containing the bar data\n\nfmax: Maximum frequency for calculating the mode shapes [Hz]\n\nbc: Boundary conditions\n\nFor all OneDStructure\n\n:CC: Clamped - Clamped\n\n:CF: Clamped - Free\n\n:FF: Free - Free\n\n\n\nFor beams\n\n:SS: Simply Supported - Simply Supported\n\n:SC: Simply Supported - Clamped\n\n:SF: Simply Supported - Free\n\n\n\n\n\n\nOutputs\n\nωn: Natural frequencies calculated up to ωmax = 2π*fmax [Hz]\n\nkn: Vector of modal wavenumbers\n\n\n\n\n\n\n\n\n\nmodeshape\n\n\n\nmodeshape(model::Bar, kn, x, bc = :CC)\nmodeshape(model::Rod, kn, x, bc = :CC)\nmodeshape(model::Strings, kn, x, bc = :CC)\nmodeshape(model::Beam, kn, x, bc = :SS)\nComputes the mass-normalized mode shapes of a longitudinal or torsional bar\nInputs\n\nmodel: Structure containing the bar data\n\nkn: Array of modal wavenumbers\n\nx: Coordinates of calculation points of the mode shapes\n\nbc: Boundary conditions\n\nFor all OneDStructure\n\n:CC: Clamped - Clamped\n\n:CF: Clamped - Free\n\n:FF: Free - Free\n\n\n\nFor beams\n\n:SS: Simply Supported - Simply Supported\n\n:SC: Simply Supported - Clamped\n\n:SF: Simply Supported - Free\n\n\n\n\n\n\nOutput\n\nϕ: Mass-normalized mode shapes\n\n\n\n\n\n\n\n\n\n\n\n# Dimensions\nL = 1.\nd = 3e-2\n\n# Section features\nS = π*d^2/4\nIz = π*d^4/64\nIG = 2Iz\nJ = IG\n\n# Tension for string\nT = 100.\n\n# Material\nE = 2.1e11\nν = 0.33\nG = E/(1 - 2*ν)\nρ = 7800.\n\n# Computation parameters\nfmax = 2000.\nx = [0.1, 0.9]\n\n# Initialization of the data types\nbar = Bar(L, S, E, ρ)\nrod = Rod(L, IG, J, G, ρ)\nstrings = Strings(L, S, T, ρ)\nbeam = Beam(L, S, Iz, E, ρ)\n\n# Computation of the natural frequencies\nωn, kn = modefreq(bar, fmax)\n\n# Computation of the corresponding mode shapes\nϕn = modeshape(bar, kn, x, :CC)\n\n\n\n\n\n\nRectangular membranes are governed by the following equation of motion: \\[\nm \\ddot w(x, y ,t) + D\\Delta w(x, y, t) = p(x, y, t),\n\\] where:\n\n\\(w(x, y, t)\\): Transverse displacement [m] at point \\((x, y)\\) and time \\(t\\)\n\\(m\\): Surface mass [kg/m]\n\\(D = \\tau\\): Linear tension [N/m]\n\\(\\Delta = \\frac{\\partial^2}{\\partial x^2} + \\frac{\\partial^2}{\\partial y^2}\\): Laplacian operator\n\n\n\n\nRectangular Kirchhoff-Love plates are governed by the following equation of motion: \\[\nm \\ddot w(x, y, t) + D \\Delta^2 w(x, y, t) = p(x, y, t),\n\\] where:\n\n\\(w(x, y, t)\\): Transverse displacement [m] at point \\((x, y)\\) and time \\(t\\)\n\\(m = \\rho h\\): Surface mass [kg/m2]\n\n\\(h\\): Thickness [m]\n\n\\(D = \\frac{Eh^3}{12(1 - \\nu^2)}\\): Bending stiffness [N.m]\n\n\\(\\nu\\): Poisson’s coefficient\n\n\\(\\Delta^2 = \\frac{\\partial^4}{\\partial x^4} + 2\\frac{\\partial^4}{\\partial x^2 \\partial y^2} + \\frac{\\partial^4}{\\partial y^4}\\): Bilaplacian operator\n\n\n\n\nData type\nAll the following data types are a subtype of the super type TwoDStructure.\n\nMembrane\n\n\n\nMembrane(L, b, m, D)\nStructure containing the data of a homogeneous and isotropic rectangular membrane\nFields\n\nL: Length [m]\n\nb: Width [m]\n\nm: Surface mass [kg/m²]\n\nD: Tension per unit length [N/m]\n\n\n\n\n\n\n\n\n\nPlate\n\n\n\nPlate(L, b, h, E, ρ, ν)\nStructure containing the data of a homogeneous and isotropic bending plate\nConstructor parameters\n\nL: Length [m]\n\nb: Width [m]\n\nE: Young's modulus [Pa]\n\nρ: Density [kg/m³]\n\nν: Poisson's ratio\n\n\nFields\n\nL: Length [m]\n\nb: Width [m]\n\nm: Surface mass [kg/m²]\n\nD: Bending stiffness [N.m]\n\n\n\n\n\n\n\n\nRelated functions\n\nmodefreq\n\n\n\nmodefreq(model::Plate, fmax)\nmodefreq(model::Membrane, fmax)\nComputes the natural frequencies of a simply supported rectangular plate or a clamped rectangular membrane up to fmax\nInputs\n\nmodel: Structure containing the data related to the plate\n\nfmax: Maximum frequency for calculating the modal shapes [Hz]\n\n\nOutputs\n\nωmn: Natural frequencies calculated up to ωmax = 2π*fmax [Hz]\n\nkmn: Matrix of modal wave numbers\n\n\n\n\n\n\n\n\n\nmodeshape\n\n\n\nmodeshape(model::Plate, kpq, x, y)\nmodeshape(model::Membrane, kpq, x, y)\nComputes the mass-normalized mode shapes of a simply supported rectangular plate or a clamped rectangular membrane\nInputs\n\nmodel: Structure containing the data related to the structure\n\nkmn: Matrix of modal wave numbers\n\n(x, y): Coordinates of the points where the mode shapes are calculated\n\n\nOutput\n\nϕ: Mass-normalized mode shapes\n\n\n\n\n\n\n\n\n\n\n\n# Dimensions\nLp = 0.6\nbp = 0.4\nhp = 1e-3\n\n# Material parameters\nE = 2.1e11\nρ = 7800.\nν = 0.33\n\n# Computation parameters\nfmax = 1000.\nxp = [0.1, 0.5]\nyp = [0.1, 0.3]\n\n# Initialization of the data types\nplate = Plate(Lp, bp, hp, E, ρ, ν)\n\n# Computation of the natural frequencies\nωn, kn = modefreq(plate, fmax)\n\n# Computation of the corresponding mode shapes\nϕn = modeshape(plate, kn, xp, yp)",
    "crumbs": [
      "Models",
      "Mechanical models"
    ]
  },
  {
    "objectID": "models/index.html#discrete-models",
    "href": "models/index.html#discrete-models",
    "title": "Mechanical models",
    "section": "2 Discrete models",
    "text": "2 Discrete models\n\n2.1 Sdof systems\nSingle degree of freedom (Sdof) systems are classically composed of a mass \\(m\\), a stiffness \\(k\\) and a viscous damper \\(c\\) (see Figure 1).\n\n\n\n\n\n\nFigure 1: Classical representation of an Sdof system\n\n\n\nMathematically, their dynamic behavior is governed by the following normalized equation of motion : \\[\n\\ddot x(t) + 2\\xi\\,\\omega_0\\, \\dot x(t) + \\omega_0^2 x(t) = \\frac{F(t)}{m}.\n\\] where \\(F(t)\\) can be either a base or an external excitation applied to the system.\nThe Sdof system can thus be defined by:\n\nits mass \\(m\\)\nits natural angular frequency \\(\\omega_0\\) (or its natural frequency \\(f_0\\))\nits damping ratio \\(\\xi\\)\n\n\n2.1.1 API\n\nSdof\n\n\n\nSdof(m, ω0, ξ)\nStructure containing the data of a sdof system\nConstructor\n\nm: Mass [kg]\n\nf0: Natural frequency [Hz]\n\nξ: Damping ratio\n\n\nFields\n\nm: Mass [kg]\n\nω0: Natural frequency [rad/s]\n\nξ: Damping ratio\n\n\n\n\n\n\n\n\n\n\n2.1.2 Example\n# Definition of the structural parameters\nm = 1.\nf₀ = 10.\nξ = 0.01\n\n# Initialization of Sdof\nsdof = Sdof(m, f₀, ξ)\n\n\n\n2.2 Mdof systems\nStructuralVibration.jl considers Multi-degrees of freedom (Mdof) systems, which topology is presented in Figure 2. This choice has been made, because it allows modeling a large variety of possible configurations.\n\n\n\n\n\n\nFigure 2: General topology of an Mdof system\n\n\n\nThe dynamic behavior of such a system is governed by the following matrix system: \\[\n\\mathbf{M} \\ddot{\\mathbf{x}}(t) + \\mathbf{K}\\mathbf{x}(t) = \\mathbf{f}(t),\n\\] where:\n\n\\(\\mathbf{M} = \\text{diag}(m_1, \\dots, m_j, \\dots, m_N)\\) is the mass matrix.\n\\(\\mathbf{K}\\) is the stiffness matrix such that: \\[\n\\mathbf{K} = \\begin{bmatrix}\nk_1 & -k_1 & 0 & \\ldots & 0 & 0 \\\\\n-k_1 & k_1 + k_2 & -k_2 & \\ddots & \\vdots & \\vdots \\\\\n0 & -k_2 & \\ddots & \\ddots & 0 & \\vdots \\\\\n\\vdots & 0 & \\ddots & \\ddots & -k_{N-1} & 0 \\\\\n\\vdots & \\vdots & \\ddots & -k_{N-1} & k_{N-1} + k_N & -k_N \\\\\n0 & 0 & \\ldots & 0 & -k_N & k_N\n\\end{bmatrix}.\n\\]\n\\(\\mathbf{x}(t) = \\left[x_1(t), \\dots, x_j(t), \\dots, x_N(t)\\right]^\\mathsf{T}\\) is the displacement vector.\n\\(\\mathbf{f}(t) = \\left[F_1(t), \\dots, F_j(t), \\dots, F_N(t)\\right]^\\mathsf{T}\\) is the external force vector.\n\n\n2.2.1 API\nData types\n\nMdof\n\n\n\nMdof(k, m, c = Float64[])\nStructure containing the data for building a mdof system\nFields\n\nk: Stiffness coefficients of the spring elements\n\nm: Masses of the mdof system\n\nc: Damping coefficients of the viscous dampers\n\n\n\n\n\n\n\n\n\n\n\n\n\nAbout the damping matrix C\n\n\n\n\n\nIf viscous dampers are defined, the damping matrix \\(\\mathbf{C}\\) is consistent with the stiffness matrix \\(\\mathbf{K}\\), meaning that: \\[\n\\mathbf{C} = \\begin{bmatrix}\nc_1 & -c_1 & 0 & \\ldots & 0 & 0 \\\\\n-c_1 & c_1 + c_2 & -c_2 & \\ddots & \\vdots & \\vdots \\\\\n0 & -k_2 & \\ddots & \\ddots & 0 & \\vdots \\\\\n\\vdots & 0 & \\ddots & \\ddots & -c_{N-1} & 0 \\\\\n\\vdots & \\vdots & \\ddots & -c_{N-1} & c_{N-1} + c_N & -c_N \\\\\n0 & 0 & \\ldots & 0 & -c_N & c_N\n\\end{bmatrix}.\n\\]\n\n\n\n\n\nMdofMesh\n\n\n\nMdofMesh(Elt, constrained_dofs, free_dofs)\nStructure containing the data for building a mdof mesh\nConstructor\n\nmodel: Mdof model\n\nbc: Boundary conditions\n\n:CC: Clamped - Clamped\n\n:CF: Clamped - Free\n\n:FF: Free - Free\n\n\n\n\nFields\n\nElt: Element connectivity matrix\n\nconstrained_dofs: Constrained degrees of freedom\n\nfree_dofs: Free degrees of freedom\n\n\n\n\n\n\n\n\nRelated functions\n\nassembly\n\n\n\nassembly(model::Mdof)\nAssembly of the mass, stiffness and damping matrices of a mdof system\nInput\n\nmodel: Mdof model\n\n\nOutputs\n\nK: Stiffness matrix\n\nM: Mass matrix\n\nC: Damping matrix (if viscous dampers are defined in model)\n\n\n\n\n\n\n\n\n\napply_bc\n\n\n\napply_bc(A, mesh)\nApply boundary conditions to a given matrix\nInputs\n\nA: Matrix to apply the boundary conditions\n\nmesh: Mesh of the system\n\n\nOutput\n\nA_bc: Matrix with boundary conditions applied\n\n\n\n\n\n\n\n\n\neigenmode\n\n\n\neigenmode(K, M, n = size(K, 1))\nComputes the eigenmodes of a system defined by its mass and stiffness matrices.\nInputs\n\nK: Stiffness matrix\n\nM: Mass matrix\n\nn: Number of modes to be keep in the modal basis\n\n\nOutputs\n\nω: Vector of natural frequencies\n\nΦ: Mass-normalized mode shapes\n\n\n\n\n\n\n\n\n\nmodal_matrices\n\n\n\nmodal_matrices(ωn, ξn)\nComputes the modal mass, stiffness, and damping matrices\nInputs\n\nωn: Vector of natural frequencies\n\nξn: Modal damping\n\n\nOutputs\n\nKn: Generalized stiffness matrix\n\nMn: Generalized mass matrix (identity matrix, due to mass normalization)\n\nCn: Generalized damping matrix\n\n\n\n\n\n\n\n\n\nmodal_effective_mass\n\n\n\nmodal_effective_mass(M, ϕn, r)\nComputes the effective mass of a mode\nInputs\n\nM: Mass matrix\n\nϕn: Mode shape\n\nr: Influence vector (rigid body mode)\n\n\nOutputs\n\nmeff: Modal effective mass\n\n\nNote: The modeshapes are supposed to be mass-normalized\n\n\n\n\n\n\n\n\n2.2.2 Example\n# Definition of the structural parameters\nk_mdof = [1., 1.]\nm_mdof = ones(3)\nc_mdof = [0.1, 0.1]\n\n# Initialization of Mdof\nmdof = Mdof(k_mdof, m_mdof, c_mdof)\n\n# Definition of a MdofMesh\nmdof_mesh = MdofMesh(mdof, bc = :CF)\n\n# System assembly\nK_mdof, M_mdof, C_mdof = assembly(mdof)\n\n# Apply boundary conditions (if any)\nK_bc = apply_bc(K_mdof, mdof_mesh)\nM_bc = apply_bc(M_mdof, mdof_mesh)\nC_bc = apply_bc(C_mdof, mdof_mesh)\n\n# Compute the eigenmodes of the systems\nωn, Φn = eigenmode(K_bc, M_bc)\n\n# Computation of the modal matrices\nKmodal, Mmodal, Cmodal = modal_matrices(ωn, 0.01)\n\n# Computation of modal effective mass\nmeff = modal_effective_mass(M_bc, Φn, ones(2))\n\n\n\n2.3 FE model\nFinite element models are available for the 1D continuous systems defined in Section 1.1.\n\n2.3.1 API\nData type\n\nOneDMesh\n\n\n\nOneDMesh(model, xmin, Nelt, bc)\nConstruct a mesh for a beam with Nelt elements, length L and starting at xmin.\nConstructor parameters\n\nmodel: Structure containing the data related to the 1D system\n\nxmin: starting position of the beam\n\nNelt: number of elements\n\nbc: Boundary conditions type\n\n:CC: Clamped - Clamped\n\n:FF: Free - Free\n\n:CF: Clamped - Free\n\n:SS: Simply Supported - Simply Supported (specific to beam)\n\n:CS: Clamped - Simply Supported (specific to beam)\n\n:SF: Simply Supported - Free (specific to beam)\n\n\n\n\nFields\n\nxmin: Starting position of the beam\n\nL: Length of the beam\n\nNodes: Nodes of the mesh\n\nElt: Elements of the mesh\n\nNdof_per_node`: Number of degrees of freedom per node\n\nelem_size: Size of the elements\n\nconstrained_dofs: Constrained degrees of freedom\n\nfree_dofs: Free degrees of freedom\n\n\n\n\n\n\n\n\nRelated functions\n\nassemby\n\n\n\nassembly(model::OneDstructure, mesh::OneDMesh)\nCompute the global stiffness and mass matrices for a 1D structure with a given mesh.\nInputs\n\nmodel: OneDStructure\n\nBeam: Beam model\n\nWaveEquation: Bar, Rod or String model\n\n\n\nmesh: OneDMesh\n\n\nOutputs\n\nK: global stiffness matrix\n\nM: global mass matrix\n\n\n\n\n\n\n\n\n\nrayleigh_damping_matrix\n\n\n\nrayleigh_damping_matrix(K, M, α, β)\nrayleigh_damping_matrix(K, M, ω1, ω2, ξ1, ξ2)\nCompute the Rayleigh damping matrix for a given stiffness and mass matrices\nInputs\n\nK: Stiffness matrix\n\nM: Mass matrix\n\nConstruction parameters\n\nMethod 1\n\nα: Mass proportional damping coefficient\n\nβ: Stiffness proportional damping coefficient\n\n\n\nMethod 2\n\nω1: First natural frequency\n\nω2: Second natural frequency\n\nξ1: Damping ratio for the first natural frequency\n\nξ2: Damping ratio for the second natural frequency\n\n\n\n\n\n\nOutput\n\nC: Rayleigh damping matrix\n\n\n\n\n\n\n\n\n\nmodal_damping_matrix\n\n\n\nmodal_damping_matrix(M, ωn, ξn, Φn)\nCompute the damping matrix C from modal parameters\nInputs\n\nM: Mass matrix\n\nωn: Natural angular frequencies\n\nξn: Damping ratios\n\nΦn: Mass-normalized mode shapes\n\n\nOutput\n\nC: Damping matrix\n\n\n\n\n\n\n\n\n\nSelection matrix\n\n\n\nselection_matrix(mesh, selected_dofs)\nCompute the selection matrix for the selected dofs.\nInputs\n\nmesh: OneDmesh\n\nselected_dofs: Selected dofs\n\n\nOutput\n\nS: Selection matrix\n\n\n\n\n\n\n\n\n\napply_bc - See Section 2.2.1.\n\n\neigenmode - See Section 2.2.1.\n\n\nmodal_matrices - See Section 2.2.1.\n\n\nmodal_effective_mass - See Section 2.2.1.\n\n\n\n2.3.2 Example\n# Dimensions\nL = 1.\nd = 3e-2\n\n# Section features\nS = π*d^2/4\nIz = π*d^4/64\n\n# Material\nE = 2.1e11\nρ = 7800.\n\n# Computation parameters\nfmax = 2000.\n\n# Initialization of the data types\nbeam = Beam(L, S, Iz, E, ρ)\n\n# Mesh definition\noned_mesh = OneDMesh(beam, 0., 20, :SS)\n\n# Construction of K and M\nKfe, Mfe = assembly(beam, oned_mesh)\n\n# Application of the BCs\nKbc = apply_bc(Kfe, oned_mesh)\nMbc = apply_bc(Mfe, oned_mesh)\n\n# Computation ofthe eigenmodes of the structure\nωfe, Φfe = eigenmode(Kbc, Mbc)\n\n# Calculation of the damping matrix\nCray = rayleigh_damping_matrix(Kbc, Mbc, 1., 1.)\nCmodal = modal_damping_matrix(Mbc, ωfe, 0.01, Φfe)",
    "crumbs": [
      "Models",
      "Mechanical models"
    ]
  },
  {
    "objectID": "models/index.html#state-space-representation",
    "href": "models/index.html#state-space-representation",
    "title": "Mechanical models",
    "section": "3 State space representation",
    "text": "3 State space representation\nThe state space representation of a mechanical system is expressed as: \\[\n\\dot{\\mathbf{z}}(t) = \\mathbf{A}_c \\mathbf{z}(t) + \\mathbf{B}_c \\mathbf{u}(t),\n\\] where:\n\n\\(\\mathbf{z}(t)\\): State vector\n\\(\\mathbf{u}(t)\\): Input vector\n\\(\\mathbf{A}_c\\): System matrix\n\\(\\mathbf{B}_c\\): Input matrix\n\n\n3.1 Continuous-time models\nFor a mechanical system, whose equation of motion is: \\[\n\\mathbf{M}\\ddot{\\mathbf{x}}(t) + \\mathbf{C}\\dot{\\mathbf{x}}(t) + \\mathbf{K x}(t) = \\mathbf{u}(t),\n\\] the corresponding continuous-time state equation is given by: \\[\n\\begin{bmatrix}\n\\dot{\\mathbf{x}}(t) \\\\\n\\ddot{\\mathbf{x}}(t)\n\\end{bmatrix} = \\begin{bmatrix}\n\\mathbf{0} & \\mathbf{I} \\\\\n-\\mathbf{M}^{-1}\\mathbf{K} & -\\mathbf{M}^{-1}\\mathbf{C}\n\\end{bmatrix}\\begin{bmatrix}\n\\mathbf{x}(t) \\\\\n\\dot{\\mathbf{x}}(t)\n\\end{bmatrix}+ \\begin{bmatrix}\n\\mathbf{0} \\\\\n\\mathbf{M}^{-1}\n\\end{bmatrix}\\mathbf{u}(t).\n\\]\nWhen using a modal expansion such that \\[\n\\mathbf{x}(t) = \\mathbf{\\Phi}\\mathbf{q}(t),\n\\] where \\(\\mathbf{\\Phi}\\) is the mode shapes matrix and \\(\\mathbf{q}(t)\\) is the modal coordinate vector, a modal state space equation can be obtained. The latter is written: \\[\n\\begin{bmatrix}\n\\dot{\\mathbf{q}}(t) \\\\\n\\ddot{\\mathbf{q}}(t)\n\\end{bmatrix} = \\begin{bmatrix}\n\\mathbf{0} & \\mathbf{I} \\\\\n-\\mathbf{\\Omega}^2 & -\\mathbf{\\Xi}\n\\end{bmatrix}\\begin{bmatrix}\n\\mathbf{q}(t) \\\\\n\\dot{\\mathbf{q}}(t)\n\\end{bmatrix}+ \\begin{bmatrix}\n\\mathbf{0} \\\\\n\\mathbf{\\Phi}^\\mathsf{T}\n\\end{bmatrix}\\mathbf{u}(t),\n\\] where \\(\\mathbf{\\Omega}^2 = \\text{diag}(\\omega_1^2, \\dots, \\omega_N^2)\\) and \\(\\mathbf{\\Xi} = \\text{diag}(2\\xi_1\\omega_1, \\dots, 2\\xi_N\\omega_N)\\).\n\n3.1.1 API\nData type\n\nContinuousStateSpace\n\n\n\nContinuousStateSpace(Ac, Bc)\nContinuous-time state-space model\nFields\n\nAc: Continuous-time state matrix A\n\nBc: Continuous-time input matrix B\n\n\n\n\n\n\n\n\nRelated functions\n\nss_model\n\n\n\nss_model(K, M, C)\nGenerates a continuous-time state-space model from the mass, damping, and stiffness matrices\nInputs\n\nK: Stiffness matrix\n\nM: Mass matrix\n\nC: Damping matrix\n\n\nOutput\n\ncss: ContinuousStateSpace\n\n\n\n\n\n\n\n\n\nss_modal_model\n\n\n\nss_modal_model(ωn, ξn, ϕn)\nGenerates a continuous-time state-space model from the mass, damping, and stiffness matrices\nInputs\n\nωn: Natural angular frequencies\n\nξn: Damping ratios\n\nϕn: Mass-normalized mode shapes\n\n\nOutput\n\ncss: ContinuousStateSpace\n\n\n\n\n\n\n\n\n\neigenmode\n\n\n\neigenmode(K, M, n = size(K, 1))\nComputes the eigenmodes of a system defined by its mass and stiffness matrices.\nInputs\n\nK: Stiffness matrix\n\nM: Mass matrix\n\nn: Number of modes to be keep in the modal basis\n\n\nOutputs\n\nω: Vector of natural frequencies\n\nΦ: Mass-normalized mode shapes\n\n\n\n\n\n\n\n\n\nmodal_parameters\n\n\n\nmodal_parameters(λ)\nComputes the natural angular frequencies and damping ratios from the complex eigenvalues\nInput\n\nλ: Complex eigenvalues\n\n\nOutputs\n\nωn: Natural angular frequencies\n\nξn: Damping ratios\n\n\n\n\n\n\n\n\n\nc2r_modeshape\n\n\n\nc2r_modeshape(Ψ)\nConverts the complex modes to real modes\nInput\n\nΨ: Complex modes\n\n\nOutput\n\nϕn: Real modes\n\n\n\n\n\n\n\n\n\n\n3.1.2 Example\n# System matrices\nm_ss = Diagonal([2., 1.])\nk_ss = [6. -2.; -2. 4.]\nc_ss = [0.67 -0.11; -0.11 0.39]\n\n# Continuous-time state space from system matrices\ncss = ss_model(k_ss, m_ss, c_ss)\nλ, Ψ = eigenmode(css.Ac)\nω, ξ = modal_parameters(λss)\nΨr = c2r_modeshape(Ψ)\n\n# Continuous-time state space from modal information\nωn, ϕn = eigenmode(k_ss, m_ss)\ncss_modal = ss_modal_model(ωn, 0.01, ϕn)\n\n\n\n3.2 Discrete-time models\nDiscrete-time models can be either be obtained using sampled strategies from direct-time integration methods (e.g. Newmark’s scheme). However, both approaches lead to a discrete-time state equation of the form: \\[\n    \\mathbf{z}_{k+1} = \\mathbf{A}\\, \\mathbf{z}_k + \\mathbf{B}_f\\, \\mathbf{u}_k + \\mathbf{B}_g\\, \\mathbf{u}_{k+1},\n\\]\nThe previous formulation is rather non-standard, since the state vector at frequency step \\(k + 1\\) requires the knowledge of the input vector at time steps \\(k\\) and \\(k + 1\\). To reduce the state-space representation to its standard form, a reduced state \\(\\mathbf{\\overline{z}}_{k+1}\\) is introduced: \\[\n    \\mathbf{z}_{k+1} = \\mathbf{A}\\, \\mathbf{x}_k + \\mathbf{B}_f\\, \\mathbf{u}_k,\n\\]\nIn doing so, the discretized state equation becomes: \\[\n    \\mathbf{\\overline{z}}_{k+1} = \\mathbf{A}\\, \\mathbf{\\overline{z}}_k + \\mathbf{B}\\, \\mathbf{u}_k\n\\] where \\(\\mathbf{B} = \\mathbf{B}_f + \\mathbf{A\\, B}_g\\).\n\n3.2.1 Sampling methods\nSampling methods are based on the discretization of the solution of the continuous-time state equation. Once discretized, the state equation can be written as: \\[\n\\mathbf{z}_{k+1} = \\mathbf{A} \\, \\mathbf{z}_k + \\mathbf{A}\\, \\int_{0}^{h} e^{-\\mathbf{A_c}\\tau}\\, \\mathbf{B_c}\\,\\mathbf{u}(\\tau + kh)\\, d\\tau,\n\\] where \\(\\mathbf{A} = e^{\\mathbf{A_c} h}\\) is the the discretized system matrix and \\(h\\) is the discretization timestep.\nTo cover a wide range of situations, the input vector is assumed to be parameterized as follows: \\[\n\\mathbf{u}(\\tau + kh) = f(\\tau)\\, \\mathbf{u}_k + g(\\tau)\\, \\mathbf{u}_{k+1},\n\\] where the basis function \\(f(\\tau)\\) and \\(g(\\tau)\\) control the evolution of the input vector between two time steps.\nIntroducing the parameterization of the input vector into the convolution integral, one obtains the following state equation: \\[\n    \\mathbf{z}_{k+1} = \\mathbf{A}\\, \\mathbf{z}_k + \\mathbf{B}_f\\, \\mathbf{u}_k + \\mathbf{B}_g\\, \\mathbf{u}_{k+1},\n\\] where \\(\\mathbf{B}_f\\) and \\(\\mathbf{B}_g\\) are the discretized input matrices defined such that: \\[\n    \\mathbf{B}_f = \\mathbf{A}\\, \\int_{0}^{h} e^{-\\mathbf{A_c}\\tau}\\, \\mathbf{B_c}\\,f(\\tau)\\, d\\tau \\; \\text{ and } \\; \\mathbf{B}_g = \\mathbf{A}\\, \\int_{0}^{h} e^{-\\mathbf{A_c}\\tau}\\, \\mathbf{B_c}\\,g(\\tau)\\, d\\tau.\n\\]\nIn the literature, the most commonly used sampling methods are the following1:\n\nThe Zero-Order Hold (ZOH) strategy, which assumes that the input vector is constant between two samples. This assumption is satisfied for \\(f(\\tau) = 1\\) and \\(g(\\tau) = 0\\) and leads to: \\[\n     \\mathbf{B} = \\mathbf{B}_f = (\\mathbf{A} - \\mathbf{I})\\, \\mathbf{A}_\\mathbf{c}^{-1}\\, \\mathbf{B_c}.\n\\]\nThe First-Order Hold (FOH) sampling method, which assumes that the input vector varies linearly between two samples. This assumption is satisfied for \\(f(\\tau) = 1 - \\tau/h\\) and \\(g(\\tau) = \\tau/h\\) and leads to: \\[\n      \\begin{split}\n          &\\mathbf{B}_f + \\mathbf{B}_g = (\\mathbf{A} - \\mathbf{I})\\, \\mathbf{A}_\\mathbf{c}^{-1}\\, \\mathbf{B_c}, \\\\\n          &\\mathbf{B}_g = (\\mathbf{A} - \\mathbf{A_c}h - \\mathbf{I})\\mathbf{A}_\\mathbf{c}^{-2}\\, \\mathbf{B_c}/h.\n      \\end{split}\n\\]\nThe Band-Limited Hold (BLH) sampling method, which assumes that the input signal can be approximated as a band-limited signal (i.e. the energy of the signal is concentrated in a defined frequency range). This assumption is satisfied for \\(f(\\tau) = h\\, \\delta(\\tau)\\) and \\(g(\\tau) = 0\\), where \\(\\delta(\\tau)\\) is the Dirac delta function and leads to: \\[\n      \\mathbf{B} = \\mathbf{B}_f = \\mathbf{A}\\, \\mathbf{B_c}\\, h.\n\\]\n\n\n\n3.2.2 Direct-time integration based methods\nDespite several methods can be found in the literature, such as the Newmark’s family schemes, this package only provides the Runge-Kutta approach, because it is an explicit method (i.e. does not require any matrix inversion). After some calculation not detailed here2, the discrete system and input matrices are expressed as: \\[\n    \\begin{split}\n    &\\mathbf{A} = \\frac{1}{24}\\left[24\\,(\\mathbf{I} + \\mathbf{A_c}\\, h) + 12\\, \\mathbf{A}_\\mathbf{c}^2\\, h^2 + 4\\, \\mathbf{A}_\\mathbf{c}^3\\, h^3 + \\mathbf{A}_\\mathbf{c}^4\\, h^4\\right], \\\\\n    &\\mathbf{B}_f = \\frac{h}{24}\\left[12\\, \\mathbf{I} + 8\\, \\mathbf{A_c}\\, h + 3 \\mathbf{A}_\\mathbf{c}^2\\, h^2 + \\mathbf{A}_\\mathbf{c}^3\\, h^3\\right]\\mathbf{B_c}, \\\\\n    &\\mathbf{B}_g = \\frac{h}{24}\\left[12\\, \\mathbf{I} + 4\\, \\mathbf{A_c}\\, h + \\mathbf{A}_\\mathbf{c}^2\\, h^2\\right]\\mathbf{B_c}.\n    \\end{split}\n\\]\n\n\n3.2.3 API\nData type\n\nDiscreteStateSpace\n\n\n\nDiscreteStateSpace(Ad, Bd, Bdp)\nDiscrete-time state-space model\nFields\n\nAd: Discrete-time state matrix A\n\nBd: Discrete-time input matrix B\n\nBdp: Discrete-time input matrix Bp (only for :foh method)\n\n\n\n\n\n\n\n\nRelated function\n\nc2d\n\n\n\nc2d(css::ContinuouStateSpace, h::Float64, method::Symbol)\nConverts a continuous-time state-space model to a discrete-time state-space model.\nInputs\n\ncss: Continuous-time state-space model\n\nh: Sampling time.\n\nmethod: Discretization method\n\n:zoh: Zero-order Hold method\n\n:foh: First-order Hold method\n\n:blh: Band-limited Hold method\n\n:rk4: 4th order Runge-Kutta method\n\n\n\n\nOutput\n\nDiscreteStateSpace: Discrete-time state-space model\n\nAd: Discrete-time state-space matrix A\n\nBd: Discrete-time state-space matrix B\n\nBdp: Discrete-time state-space matrix Bp (only for :foh and :rk4 methods)\n\n\n\n\n\n\n\n\n\n\n\n\n3.2.4 Example\ndss = c2d(css, 0.01, :zoh)",
    "crumbs": [
      "Models",
      "Mechanical models"
    ]
  },
  {
    "objectID": "models/index.html#footnotes",
    "href": "models/index.html#footnotes",
    "title": "Mechanical models",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nD. Bernal. “Optimal discrete to continuous transfer for band limited inputs”, Journal of Engineering Mechanics, vol. 133 (12), pp. 1370-1377, 2007.↩︎\nFor further details, see: J. Ghibaudo. “Inverse estimation of sparse mechanical excitation sources by Bayesian filtering”, PhD thesis, Conservatoire national des arts et métiers, 2024.↩︎",
    "crumbs": [
      "Models",
      "Mechanical models"
    ]
  },
  {
    "objectID": "modal_extraction/frf_reconstruction.html",
    "href": "modal_extraction/frf_reconstruction.html",
    "title": "FRF reconstruction",
    "section": "",
    "text": "To be implemented.",
    "crumbs": [
      "Modal extraction",
      "FRF reconstruction"
    ]
  },
  {
    "objectID": "modal_extraction/mdof_methods.html",
    "href": "modal_extraction/mdof_methods.html",
    "title": "Mdof methods",
    "section": "",
    "text": "To be implemented.",
    "crumbs": [
      "Modal extraction",
      "Mdof methods"
    ]
  },
  {
    "objectID": "modal_extraction/index.html",
    "href": "modal_extraction/index.html",
    "title": "Sdof methods",
    "section": "",
    "text": "The Sdof methods are based on the assumption that the system can be represented as a single degree of freedom system. This means that the system can be described by a single natural frequency, damping ratio, and mode shape. The Sdof methods are typically used for systems that are lightly damped and for which the modes are well separated.\nFor these methods, it is assumed that the FRF (admittance) is given by: \\[\nH_{pq}(\\omega) = \\sum_{i = 1}^N\\frac{_{i}A_{pq}}{\\omega_i^2 - \\omega^2 + j\\eta_i\\omega_i^2}\n\\] where, for a mode \\(i\\), \\(_{i}A_{pq} = \\Phi_i(x_p)\\Phi_i(x_q)\\) is the residue, \\(\\omega_i\\) is the natural frequency, \\(\\eta_i\\) is the modal damping factor, and \\(\\Phi_i(x_p)\\) is the mass-normalized mode shape at the point \\(x_p\\).\nWhen the natural frequencies of the modes are sufficiently spaced and the damping is low, one can write at a frequency \\(\\omega\\) close to the natural frequency \\(\\omega_i\\): \\[\nH_{pq}(\\omega) \\approx \\frac{\\Phi_i(x_p)\\Phi_i(x_q)}{M_i\\left(\\omega_i^2 - \\omega^2 + j\\eta_i\\omega_i^2\\right)}.\n\\]",
    "crumbs": [
      "Modal extraction",
      "Sdof methods"
    ]
  },
  {
    "objectID": "modal_extraction/index.html#natural-frequencies-and-damping-ratios-extraction",
    "href": "modal_extraction/index.html#natural-frequencies-and-damping-ratios-extraction",
    "title": "Sdof methods",
    "section": "1 Natural frequencies and damping ratios extraction",
    "text": "1 Natural frequencies and damping ratios extraction\nStructuralDynamics.jl provides two SDOF methods for extracting the natural frequencies and damping ratios of a system from its frequency response function (FRF):\n\nPeak picking method\nCircle fit method\n\n\n1.1 Peak picking method\nThe peak picking method is a simple and effective way to extract the natural frequencies and damping ratios of a system. The method consists of the following steps:\n\nIdentification of natural frequencies\nThey are identified from the peaks of the amplitude of the FRF. The natural frequencies are identified as the frequencies at which the FRF has a local maximum. The local maxima are determined using Peaks.jl.\nEstimation of modal damping factors\nTo estimate the value of the damping factor for mode \\(i\\), the half power bandwidth method is used. This procedure, valid for low damping (\\(\\eta_i &lt; 0.1\\)), first determines the frequencies \\(\\omega_1\\) and \\(\\omega_2\\) such that: \\[\n\\vert H_{pq}(\\omega_1)\\vert = \\vert H_{pq}(\\omega_2)\\vert = \\frac{\\vert H_{pq}(\\omega_i)\\vert}{\\sqrt{2}},\n\\] with \\(\\omega_i \\in [\\omega_1, \\omega_2]\\).\nKnowing the values of \\(\\omega_i\\), \\(\\omega_1\\), and \\(\\omega_2\\), the damping ratio for mode \\(i\\) is determined using the formula: \\[\n\\eta_i = \\frac{\\omega_2^2 - \\omega_1^2}{2\\omega_i^2}.\n\\]\n\n\n\n\n\n\n\nNote\n\n\n\nIf we consider that the shape of a resonance peak is symmetric then \\(\\omega_i = \\frac{\\omega_1 + \\omega_2}{2}\\).\nIt comes that: \\[\n\\omega_2^2 - \\omega_1^2 \\approx 2\\omega_i(\\omega_2 - \\omega_1).\n\\]\nHence, the damping ratio can be approximated as: \\[\n\\eta_i \\approx \\frac{\\omega_2 - \\omega_1}{\\omega_i}.\n\\]\nThis formula is often given in textbooks when dealing with the half power bandwidth method.\n\n\n\n\n\n\n\n\nWarning\n\n\n\nThanks to its extreme simplicity, this method allows for quick analysis. However, this method generally does not provide satisfactory results, as it relies on measuring the resonance peak, which is very difficult to measure precisely. This is why this method is mainly applicable to lightly damped structures with well-separated modes, whose transfer functions have been measured with good frequency resolution.\n\n\n\n\n1.2 Circle fit method\nThe circle fit method is a more sophisticated method for extracting the natural frequencies and damping ratios of a system. It allows for more accurate results than the peak picking method. It is based on the fact that the admittance forms a circle (Nyquist circle) when plotted in the complex plane (see Figure 1). Indeed, assuming that the modes are mass-normalized, it can be shown that: \\[\nRe\\left[H_{pq}(\\omega)\\right]^2 + \\left(Im\\left[H_{pq}(\\omega)\\right] + \\frac{\\Phi_i(x_p)\\Phi_i(x_q)}{2\\eta_i\\omega_i^2}\\right)^2 = \\left(\\frac{\\Phi_i(x_p)\\Phi_i(x_q)}{2\\eta_i\\omega_i^2}\\right)^2,\n\\] which is the equation of a circle of radius \\(R = \\frac{\\vert\\Phi_i(x_p)\\Phi_i(x_q)\\vert}{2\\eta_i\\omega_i^2}\\) and center \\((x_c,y_c) = \\Bigl(0,-\\frac{\\Phi_i(x_p)\\Phi_i(x_q)}{2\\eta_i\\omega_i^2}\\Bigr)\\).\n\n\n\n\n\n\nFigure 1: Typical Nyquist circle of an admittance \\(H_{pq}(\\omega)\\)\n\n\n\nThe circle fit method consists of the following steps:\n\nIdentification of natural frequencies\nTo identify the natural frequency of a mode \\(i\\), we start by parameterizing the Nyquist circle by defining the angles \\(\\psi\\) and \\(\\theta\\) as shown in Figure 1. Mathematically, it can then be shown that: \\[\n\\omega_i^2 = \\frac{\\omega_1^2\\tan\\frac{\\theta_2}{2} - \\omega_2^2\\tan\\frac{\\theta_1}{2}}{\\tan\\frac{\\theta_2}{2} - \\tan\\frac{\\theta_1}{2}},\n\\] where \\(\\omega_1\\) and \\(\\omega_2\\) are the angular frequencies such that \\(\\omega_1 &lt; \\omega_i &lt; \\omega_2\\), while \\(\\theta_1\\) and \\(\\theta_2\\) are the corresponding angles of the Nyquist circle.\nEstimation of modal damping factors\nThe damping ratio is estimated using the following formula: \\[\n\\eta_i = \\frac{\\omega_2^2 - \\omega_1^2}{\\omega_i^2}\\frac{1}{\\tan\\frac{\\theta_1}{2} - \\tan\\frac{\\theta_2}{2}}.\n\\]\n\n\n\n\n\n\n\nNote\n\n\n\nGenerally, the angles \\(\\theta_1\\) and \\(\\theta_2\\) are chosen so that: \\[\n\\theta_1 = \\frac{\\pi}{2} \\text{ and } \\theta_2 = -\\frac{\\pi}{2}.\n\\]\nIn doing so, we have: \\[\n\\omega_i^2 = \\frac{\\omega_1^2 + \\omega_2^2}{2} \\text{ and } \\eta_i = \\frac{\\omega_2^2 - \\omega_1^2}{2\\omega_i^2}.\n\\]",
    "crumbs": [
      "Modal extraction",
      "Sdof methods"
    ]
  },
  {
    "objectID": "modal_extraction/index.html#mode-shapes-extraction",
    "href": "modal_extraction/index.html#mode-shapes-extraction",
    "title": "Sdof methods",
    "section": "2 Mode shapes extraction",
    "text": "2 Mode shapes extraction\nThe mode shapes are extracted from the admittance matrix at the resonance frequency \\(\\omega_i\\). In this situation, the admittance matrix is defined as: \\[\n\\mathbf{H} = \\frac{1}{j\\eta_i\\omega_i^2}\n  \\begin{bmatrix}\n    \\Phi_i(x_1)^2 & \\Phi_i(x_1)\\Phi_i(x_2) & \\ldots\\ & \\Phi_i(x_1)\\Phi_i(x_N) \\\\\n    \\Phi_i(x_2)\\Phi_i(x_1) & \\Phi_i(x_2)^2 &  & \\Phi_i(x_2)\\Phi_i(x_N) \\\\\n    \\vdots & & \\ddots & \\vdots \\\\\n    \\Phi_i(x_N)\\Phi_i(x_1) & \\ldots & \\ldots & \\Phi_i(x_N)^2\n  \\end{bmatrix},\n\\] where \\(\\omega_i\\) and \\(\\eta_i\\) have been determined using the peak picking method or the circle fit method.\nTo determine the mode shapes from the knowledge of a column \\(q\\) (or a row \\(p\\)), proceed as follows:\n\nFrom the measurement of an input admittance (diagonal term of the admittance matrix), the mode shape value at point \\(x_q\\) is obtained: \\[\n\\Phi_i(x_q)^2 = -\\eta_i\\omega_i^2 \\text{Im}(H_{qq}(\\omega_i)).\n\\]\nFrom the cross-admittances (off-diagonal terms of the admittance matrix), the mode shape value at a point \\(x_p\\) is calculated: \\[\n\\Phi_i(x_p)\\Phi_i(x_q) = -\\eta_i\\omega_i^2 \\text{Im}(H_{pq}(\\omega_i))\n\\]",
    "crumbs": [
      "Modal extraction",
      "Sdof methods"
    ]
  },
  {
    "objectID": "modal_extraction/index.html#api",
    "href": "modal_extraction/index.html#api",
    "title": "Sdof methods",
    "section": "3 API",
    "text": "3 API\n\nfreq_extraction\n\n\n\nfreq_extraction(freq, H, method::SdofModalExtraction; type = :dis)\nExtract natural frequencies and damping ratios from the Bode diagram fitting method\nInputs\n\nfreq: Frequency vector\n\nH: Frequency response function\n\nmethod: Method to extract the natural frequencies and damping ratios\n\nPeakPicking: Peak picking method (default)\n\nCircleFit: Circle fitting method\n\n\n\ntype: Type of FRF used to extract the natural frequencies and damping ratios\n\n:dis: Admittance (default)\n\n:vel: Mobility\n\n:acc: Accelerance\n\n\n\n\nOutputs\n\nfn: Natural frequencies\n\nξn: Damping ratios\n\n\nNote It is supposed that H is a row or a column of the FRF, meaning that H is a Vector\n\n\n\n\n\n\n\nmodeshape_extraction\n\n\n\nmodeshape_extraction(freq, H, fn, ξn, dpi; type = :dis)\nExtract mode shapes using Sdof approximation\nInputs\n\nfreq: Frequency vector\n\nH: Frequency response function\n\nfn: Natural frequencies\n\nξn: Damping ratios\n\ndpi: Driving point indices\n\ndpi[1]: Driving point index on the measurement mesh\n\ndpi[2]: Driving point index on the excitation mesh\n\n\n\nmethod: Method to extract the mode shapes\n\nPeakPicking: Peak picking method (default)\n\nCircleFit: Circle fitting method\n\n\n\ntype: Type of FRF used to extract the natural frequencies and damping ratios\n\n:dis: Admittance (default)\n\n:vel: Mobility\n\n:acc: Accelerance\n\n\n\n\nOutput\n\nϕn: Mode shapes\n\n\nNote If the number of measurement points is less than the number of excitation points, the mode shapes are estimated at the excitation points (roving hammer test). Otherwise, the mode shapes are estimated at the measurement points (roving accelerometer test).",
    "crumbs": [
      "Modal extraction",
      "Sdof methods"
    ]
  },
  {
    "objectID": "modal_extraction/index.html#example",
    "href": "modal_extraction/index.html#example",
    "title": "Sdof methods",
    "section": "4 Example",
    "text": "4 Example\n\n# Structure parameters of the beam\nL = 1.        # Length\nb = 0.03      # Width\nh = 0.01      # Thickness\nS = b*h       # Cross-section area\nIz = b*h^3/12 # Moment of inertia\n\n# Material parameters\nE = 2.1e11  # Young's modulus\nρ = 7850.   # Density\nξ = 0.01    # Damping ratio\n\n# Mesh\nxexc = 0:0.05:L\nxm = xexc[2]\n\n# Mode calculation - Simply supported boundary conditions\nbeam = Beam(L, S, Iz, E, ρ)\nfmax = 500\n\nωn, kn = modefreq(beam, 2fmax)\nϕexc = modeshape(beam, kn, xexc)\nϕm = modeshape(beam, kn, xm)\n\n# FRF calculation\nfreq = 1.:0.1:fmax\nprob = ModalFRFProblem(ωn, ξ, freq, ϕm, ϕexc)\nH = solve(prob; ismat = true).u\n\n# Natural frequencies and damping ratios extraction\nfn_pp, ξn_pp = freq_extraction(freq, H[1, 2, :], PeakPicking())\nfn_cf, ξn_cf = freq_extraction(freq, H[1, 2, :], CircleFit())\n\n# Mode shape extraction\nϕid = modeshape_extraction(freq, H, fn_cf, ξn_cf, [1, 2])",
    "crumbs": [
      "Modal extraction",
      "Sdof methods"
    ]
  },
  {
    "objectID": "modal_extraction/indicators.html",
    "href": "modal_extraction/indicators.html",
    "title": "Quality and analysis indicators",
    "section": "",
    "text": "To be implemented.",
    "crumbs": [
      "Modal extraction",
      "Quality and analysis indicators"
    ]
  },
  {
    "objectID": "models/excitation.html",
    "href": "models/excitation.html",
    "title": "Excitation models",
    "section": "",
    "text": "To define an excitation, two steps must be followed:\n\nInitialize an excitation type:\nexc_type = MyExcitation(params...)\nCompute the excitation signal corresponding to the given excitation type over a given duration t (See Section 2 for details):\nF = excitation(exc_type, t)\n\n\n\nThe rectangular signal is defined by the following equation: \\[\nF(t) = \\begin{cases}\nF_0 & \\text{if } t \\in [t_\\text{start}, t_\\text{start} + T] \\\\\n0 & \\text{otherwise}\n\\end{cases},\n\\] where \\(F_0\\) is the amplitude of the signal, \\(t_\\text{start}\\) is the start time of the signal, and \\(T\\) is the duration of the signal.\n\nRectangle\n\n\n\nRectangle(F, tstart, duration)\nStruct to define a rectangular excitation signal\nFields\n\nF::Real: Amplitude of the force [N]\n\ntstart::Real: Starting time of the excitation [s]\n\nduration::Real: Duration of the excitation [s]\n\n\n\n\n\n\n\n\n\n# Time parameters\nΔt = 1e-3\nt = 0.:Δt:10.\n\n# Excitation parameters\nF0 = 1.\ntstart = 2.5\nduration = 5.\n\n# Initialize Rectangle type\nrect = Rectangle(F0, tstart, duration)\n\n# Compute the excitation\nF_rect = excitation(rect, t)\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe triangle signal is defined by the following equation: \\[\nF(t) = \\begin{cases}\n\\frac{2F_0}{T}\\left(t - t_\\text{start}\\right) & \\text{if } t \\in [t_\\text{start}, t_m] \\\\\nF_0 - \\frac{2F_0}{T}(t - t_m) & \\text{if } t \\in [t_m, t_\\text{start} + T] \\\\\n0 & \\text{otherwise}\n\\end{cases},\n\\] where \\(F_0\\) is the amplitude of the signal, \\(t_\\text{start}\\) is the start time of the signal, \\(T\\) is the duration of the signal and \\(t_m = t_\\text{start} + T/2\\) is the time at which the signal reaches its maximum value.\n\nTriangle\n\n\n\nTriangle(F, tstart, duration)\nStruct to define a triangular excitation signal\nFields\n\nF::Real: Amplitude of the force [N]\n\ntstart::Real: Starting time of the excitation [s]\n\nduration::Real: Duration of the excitation [s]\n\n\n\n\n\n\n\n\n\n# Time parameters\nΔt = 1e-3\nt = 0.:Δt:10.\n\n# Excitation parameters\nF0 = 1.\ntstart = 2.5\nduration = 5.\n\n# Initialize Triangle type\ntri = Triangle(F0, tstart, duration)\n\n# Compute the excitation\nF_tri = excitation(tri, t)\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe hammer impact signal is supposed to have the shape of a Gamma distribution \\[\nF(t) = \\begin{cases}\nF_0\\left(\\frac{t_h}{p\\theta}\\right)^p \\text{exp}\\left(-\\frac{t_h}{\\theta} + p\\right), & \\text{if } t \\geq t_\\text{start} \\\\\n0, & \\text{otherwise}\n\\end{cases},\n\\] where \\(F_0\\) is the amplitude of the signal, \\(t_h = t - t_\\text{start}\\) is the time since the impact, \\(p\\) is the shape parameter, and \\(\\theta\\) is the scale parameter.\n\nHammer\n\n\n\nHammer(F, tstart, k, θ)\nStruct to define a hammer impact excitation signal\nFields\n\nF::Real: Amplitude of the force [N]\n\ntstart::Real: Starting time of the excitation [s]\n\np::Real: Shape parameter\n\nθ::Real: Intensity parameter [s]\n\n\n\n\n\n\n\n\n\n# Time parameters\nΔt = 1e-5\nt = 0.:Δt:0.05\n\n# Excitation parameters\nF0 = 1.\ntstart = 0.01\nk = 9.7\nθ = 6e-4\n\n# Initialize Hammer type\nhammer = Hammer(F0, tstart, k, θ)\n\n# Compute the excitation\nF_hammer = excitation(hammer, t)\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe smooth rectangular signal (custom Tukey window) is defined by the following equation: \\[\nF(t) = \\begin{cases}\n\\frac{F_0}{2}\\left[1 - \\cos\\left(\\frac{2\\pi (t - t_\\text{start})}{\\alpha T}\\right)\\right] & \\text{if } t \\in [t_\\text{start}, t_\\text{start} + t_\\text{rise}] \\\\\nF_0 & \\text{if } t \\in [t_\\text{start} + t_\\text{rise}, t_\\text{start} + t_\\text{rise} + T_\\text{rect}] \\\\\n\\frac{F_0}{2}\\left[1 - \\cos\\left(\\frac{2\\pi (t - t_\\text{start} - t_\\text{rise} - T_\\text{rect})}{\\alpha T}\\right)\\right] & \\text{if } t \\in [t_\\text{start} + t_\\text{rise} + T_\\text{rect}, t_\\text{start} + T] \\\\\n\\end{cases},\n\\] where \\(F_0\\) is the amplitude of the signal, \\(t_\\text{start}\\) is the start time of the signal, \\(T\\) is the duration of the signal, \\(t_\\text{rise}\\) is the duration to reach \\(F_0\\) and \\(\\alpha = \\frac{2t_\\text{rise}}{T}\\) and \\(T_\\text{rect} = T - 2t_\\text{rise}\\) is the duration of the rectangular part of the signal.\n\nSmoothRect\n\n\n\nSmoothRect(F, tstart, tr, duration)\nStruct to define a smooth rectangular excitation signal\nFields\n\nF::Real: Amplitude of the force [N]\n\ntstart::Real: Starting time of the excitation [s]\n\nduration::Real: Duration of the excitation [s]\n\ntrise::Real: Rise time from 0 to F [s]\n\n\nNote: SmoothRect is actually a custom Tukey window for which the coefficient α is computed to satisfy the trise given by the user\n\n\n\n\n\n\n\n# Time parameters\nΔt = 1e-3\nt = 0.:Δt:10.\n\n# Excitation parameters\nF0 = 1.\ntstart = 2.5\nduration = 5.\ntrise = 1.\n\n# Initialize SmoothRect type\nsrect = SmoothRect(F0, tstart, duration, trise)\n\n# Compute the excitation\nF_srect = excitation(srect, t)\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe sine signal is defined by the following equation: \\[\nF(t) = \\begin{cases}\nF_0 \\sin\\left(\\omega (t - t_\\text{start}) + \\theta\\right), & \\text{if } t \\in [t_\\text{start}, t_\\text{start} + T] \\\\\n0, & \\text{otherwise}\n\\end{cases},\n\\] where \\(F_0\\) is the amplitude of the signal, \\(\\omega\\) is the angular frequency of the signal, and \\(\\theta\\) is the phase of the signal.\n\n\n\n\n\n\nZero-end signal\n\n\n\n\n\nSometimes it is necessary to have a signal that ends at zero. In this case, the duration of the signal must be adjusted to ensure that the signal ends at zero. To do so, one have to find the smallest integer \\(n\\) such that at \\(t = t_\\text{start} + T\\): \\[\n\\sin(\\omega T + \\theta) = 0 \\Rightarrow \\omega T + \\theta = 2\\pi n \\Rightarrow n = \\frac{\\omega T + \\theta}{2\\pi}.\n\\]\nOnce \\(n\\) is found, the duration of the signal must be adjusted to: \\[\nT_\\text{new} = \\frac{2\\pi n - \\theta}{\\omega}.\n\\]\n\n\n\n\nSineWave\n\n\n\nSineWave(F, tstart, duration, freq; zero_end = true)\nStruct to define a sine wave excitation signal\nConstructor parameters\n\nF::Real: Amplitude of the force [N]\n\ntstart::Real: Starting time of the excitation [s]\n\nduration::Real: Duration of the excitation [s]\n\nfreq::Real: Frequency of the excitation [Hz]\n\nzero_end::Bool: Boolean to set the excitation to 0 at the end of the duration (default = true)\n\n\nFields\n\nF::Real: Amplitude of the force [N]\n\ntstart::Real: Starting time of the excitation [s]\n\nduration::Real: Duration of the excitation [s]\n\nω::Real: Frequency of the excitation [Hz]\n\nzero_end::Bool: Boolean to set the excitation to 0 at the end of the duration (default = true)\n\n\n\n\n\n\n\n\n\n# Time parameters\nΔt = 1e-3\nt = 0.:Δt:10.\n\n# Excitation parameters\nF0 = 1.\ntstart = 2.5\nduration = 5.\nf = 2.\n\n# Initialize HaverSine type\nsine = SineWave(F0, tstart, duration, f, zero_end = true)\n\n# Compute the excitation\nF_sine = excitation(sine, t)\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe half-sine signal is defined by the following equation: \\[\nF(t) = \\begin{cases}\nF_0 \\sin(\\frac{\\pi (t - t_\\text{start}}{T}) & \\text{if } t \\in [t_\\text{start}, t_\\text{start} + T] \\\\\n0 & \\text{otherwise}\n\\end{cases},\n\\] where \\(F_0\\) is the amplitude of the signal, \\(t_\\text{start}\\) is the start time of the signal, and \\(T\\) is the duration of the signal.\n\nHalfSine\n\n\n\nHalfSine(F, tstart, duration)\nStruct to define a half sine excitation signal\nFields\n\nF::Real: Amplitude of the force [N]\n\ntstart::Real: Starting time of the excitation [s]\n\nduration::Real: Duration of the excitation [s]\n\n\n\n\n\n\n\n\n\n# Time parameters\nΔt = 1e-3\nt = 0.:Δt:10.\n\n# Excitation parameters\nF0 = 1.\ntstart = 2.5\nduration = 5.\n\n# Initialize HalfSine type\nhsine = HalfSine(F0, tstart, duration)\n\n# Compute the excitation\nF_hsine = excitation(hsine, t)\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe haversine (or versed sine) signal is defined by the following equation: \\[\nF(t) = \\begin{cases}\nF_0\\left(1 - cos(\\frac{2\\pi t}{T}\\right) & \\text{if } t \\in [t_\\text{start}, t_\\text{start} + T] \\\\\n0 & \\text{otherwise}\n\\end{cases},\n\\] where \\(F_0\\) is the amplitude of the signal, \\(t_\\text{start}\\) is the start time of the signal, and \\(T\\) is the duration of the signal.\n\nHaverSine\n\n\n\nHaverSine(F, tstart, duration)\nStruct to define a Haversine (or versed sine) excitation signal\nFields\n\nF::Real: Amplitude of the force [N]\n\ntstart::Real: Starting time of the excitation [s]\n\nduration::Real: Duration of the excitation [s]\n\n\n\n\n\n\n\n\n\n# Time parameters\nΔt = 1e-3\nt = 0.:Δt:10.\n\n# Excitation parameters\nF0 = 1.\ntstart = 2.5\nduration = 5.\n\n# Initialize HaverSine type\nhaversine = HaverSine(F0, tstart, duration)\n\n# Compute the excitation\nF_haversine = excitation(haversine, t)\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe swept sine signal is defined by the following equation: \\[\nF(t) = \\begin{cases}\nF_0 \\sin(\\theta(t)) & \\text{if } t \\in [t_\\text{start}, t_\\text{start} + T] \\\\\n0 & \\text{otherwise}\n\\end{cases},\n\\] where \\(F_0\\) is the amplitude of the signal, \\(t_\\text{start}\\) is the start time of the signal, \\(T\\) is the duration of the signal and \\(\\theta(t)\\) is the instantaneous phase.\nThe instantaneous phase is given by: \\[\n\\theta(t) = \\theta_0 + 2\\pi\\int_0^t f(\\tau) d\\tau,\n\\] where \\(f(\\tau)\\) is the instantaneous frequency of the signal at time \\(\\tau\\) and \\(\\theta_0\\) is the initial phase (set to 0 here).\nIn this package, three possible types of swept sine signals are available:\n\nLinear swept sine: \\[\nf(t) = f_\\text{start} + \\beta(t - t_\\text{start}) \\Rightarrow \\theta(t) = 2\\pi\\left(f_\\text{start}(t - t_\\text{start}) + \\frac{\\beta (t - t_\\text{start})^2}{2}\\right),\n\\] where:\n\n\\(\\beta = \\frac{f_\\text{end} - f_\\text{start}}{T}\\)\n\\(f_\\text{start}\\): Initial frequency of the signal at \\(t_\\text{start}\\)\n\\(f_\\text{end}\\): Final frequency of the signal at \\(t_\\text{start} + T\\)\n\nQuadratic swept sine: \\[\nf(t) = f_\\text{start} + \\beta (t - t_\\text{start})^2 \\Rightarrow \\theta(t) = 2\\pi\\left(f_\\text{start}(t - t_\\text{start}) + \\frac{\\beta (t - t_\\text{start})^3}{3}\\right),\n\\] where \\(\\beta = \\frac{f_\\text{end} - f_\\text{start}}{T^2}\\).\nLogarithmic swept sine: \\[\nf(t) = f_\\text{start}\\beta^{t - t_\\text{start}} \\Rightarrow \\theta(t) = \\frac{2\\pi f_\\text{start}}{\\log(\\beta)}\\left(\\beta^{t - t_\\text{start}} - 1\\right),\n\\] where \\(\\beta = \\left(\\frac{f_\\text{end}}{f_\\text{start}}\\right)^{1/T}\\).\n\n\n\n\n\n\n\nZero-end signal\n\n\n\n\n\nSimilarly to the sine signal, the duration of the signal must be adjusted to ensure that the signal ends at zero. To do so, one have to find the smallest integer \\(n\\) such that at \\(t = t_\\text{start} + T\\): \\[\n  \\theta(t) = 2\\pi n.\n\\]\nIn doing so, we have for:\n\nLinear swept sine: \\[\nn = (f_\\text{start} + f_\\text{end})\\frac{T}{2} \\Rightarrow T_\\text{new} = \\frac{2n}{f_\\text{start} + f_\\text{end}}.\n\\]\nQuadratic swept sine: \\[\nn = (2f_\\text{start} + f_\\text{end})\\frac{T}{3} \\Rightarrow T_\\text{new} = \\frac{3n}{2f_\\text{start} + f_\\text{end}}.\n\\]\nLogarithmic swept sine: \\[\nn = \\frac{f_\\text{end} - f_\\text{start}}{\\log(f_\\text{end}/f_\\text{start})}T \\Rightarrow T_\\text{new} = \\frac{n\\log(f_\\text{end}/f_\\text{start})}{f_\\text{end} - f_\\text{start}}.\n\\]\n\n\n\n\n\nSweptSine\n\n\n\nSweptSine(F, tstart, duration, fstart, fend, type)\nStruct to define a swept sine excitation signal\nFields\n\nF::Real: Amplitude of the force [N]\n\ntstart::Real: Starting time of the excitation [s]\n\nduration::Real: Duration of the excitation [s]\n\nfstart::Real: Starting frequency [Hz]\n\nfend::Real: Ending frequency [Hz]\n\ntype::Symbol: Type of sweep\n\n:lin - linear (default)\n\n:quad - quadratic\n\n:log - logarithmic\n\n\n\nzero_end::Bool: Boolean to set the excitation to 0 at the end of the duration (default = true)\n\n\n\n\n\n\n\n\n\n# Time parameters\nΔt = 1e-3\nt = 0.:Δt:10.\n\n# Excitation parameters\nF0 = 1.\ntstart = 2.5\nduration = 5.\nfstart = 1.\nfend = 6.\ntype_swept = :lin\n\n# Initialize SweptSine type\nchirp = SweptSine(F0, tstart, duration, fstart, fend, type_swept, zero_end = true)\n\n# Compute the excitation\nF_chirp = excitation(chirp, t)\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe Gaussian pulse signal is defined by the following equation: \\[\nF(t) = \\begin{cases}\nF_0 \\exp\\left(-\\frac{t_p^2}{2\\sigma^2}\\right) \\cos(2\\pi f_c t_p), & \\text{if } t \\geq t_\\text{start} \\\\\n0, & \\text{otherwise}\n\\end{cases},\n\\] where \\(F_0\\) is the amplitude of the signal, \\(t_\\text{start}\\) is the start time of the signal, \\(\\sigma\\) is the standard deviation of the signal, and \\(f_c\\) is the carrier frequency. Here \\(t_p = t - t_\\text{start} - T/2\\) so that the Gaussian pulse reaches its maximum value at \\(t = t_\\text{start} + T/2\\).\n\n\n\n\n\n\nVariance calibration\n\n\n\n\n\nThe design of the Gaussian pulse assumes that it tends to zero when \\(t = t_\\text{start} + T\\). This requirement implies that the standard deviation \\(\\sigma\\) must be chosen such that the Gaussian pulse is zero at \\(t = t_\\text{start} + T\\). This condition can only be satisfied within some precision. More precisely, the idea is to find the quantile \\(n\\) such that \\(T = n\\sigma\\). Consequently, if we assume that \\(F(t_\\text{start} + T) = 10^{-p}\\) (with \\(p\\) a given precision), we have: \\[\nn = 2\\sqrt{2(p\\log 10 + \\log F_0)} \\Rightarrow \\sigma = \\frac{T}{n}.\n\\]\n\n\n\n\nGaussianPulse\n\n\n\nGaussianPulse(F, tstart, duration, fc)\nStruct to define a Gaussian pulse excitation signal\nFields\n\nF::Real: Amplitude of the force [N]\n\ntstart::Real: Starting time of the excitation [s]\n\nduration::Real: Duration of the excitation [s]\n\nfc::Real: Center frequency of the pulse [Hz]\n\nprecision::Real: Precision of the pulse (default = 4.)\n\n\nNote\nThe precision parameter calibrates the standard deviation of the pulse, so that the duration = n x σ, within some precision. If n = 1.96 then the confidence interval of the Gaussian distribution is 95%. To do so, we compute n so that at t = duration = n x σ , the amplitude of F x exp(-0.5*(t - duration/2)^2/sigma^2) = 10^(-precision)\n\n\n\n\n\n\n\n# Time parameters\nΔt = 1e-3\nt = 0.:Δt:10.\n\n# Excitation parameters\nF0 = 1.\ntstart = 2.5\nduration = 5.\nfc = 2.\n\n# Initialize GaussianPulse type\ngpulse = GaussianPulse(F0, tstart, duration, fc)\n\n# Compute the excitation\nF_gpulse = excitation(gpulse, t)\n\n\n\n\n\n\n\n\n\n\n\n\n\nColored noise is a random signal that has a power spectral density that is not (necessarily) flat over a given frequency range. In practice, colored noise is also refered to as “power-law noise” since its power spectral density is proportional to \\(f^{-\\alpha}\\) (\\(f\\): frequency) and its spectrum is proportional to \\(f^{-\\alpha/2}\\).\nIn this package, five types of colored noise are available:\n\nWhite noise: \\(\\alpha = 0\\)\nPink noise: \\(\\alpha = 1\\)\nBlue noise: \\(\\alpha = -1\\)\nBrown noise: \\(\\alpha = 2\\)\nPurple noise: \\(\\alpha = -2\\)\n\nThe general procedure to generate a colored noise signal is as follows:\n\nGenerate a white noise signal and compute its FFT\nMultiply the FFT by \\(f^{-\\alpha/2}\\) to obtain the colored noise\nCompute the inverse FFT to obtain the colored noise signal\n\nAdditional steps can be added such as:\n\nNormalization: Ensure that the colored noise has the desired variance and preserves the energy of the white noise\nFiltering: Obtain a band-limited colored noise\n\n\nColoredNoise\n\n\n\nColoredNoise(F, color)\nStruct to define a colored noise excitation signal\nFields\n\nF::Real: Mean amplitude of the force [N]\n\ntstart::Real: Starting time of the excitation [s]\n\nduration::Real: Duration of the excitation [s]\n\nσ::Real: Target standard deviation of the colored noise\n\ncolor::Symbol: Color of the noise\n\n:white (default)\n\n:pink\n\n:blue\n\n:brown\n\n:purple\n\n\n\nband_freq::AbstractVector: Frequencies used to defined the bandpass filter applied to the colored noise\n\n\n\n\n\n\n\n\n\n# Time parameters\nΔt = 1e-4\nt = 0.:Δt:10.\nnt = length(t)\nfs = 1/Δt\n\n# Excitation parameters\nF0 = 1.\ntstart = 0.\nduration = 10.\nσ = 1.\n\n# Initialize ColoredNoise type\nexc_white = ColoredNoise(F0, tstart, duration, σ, color = :white)\nexc_pink = ColoredNoise(F0, tstart, duration, σ, color = :pink)\nexc_blue = ColoredNoise(F0, tstart, duration, σ, color = :blue)\nexc_brown = ColoredNoise(F0, tstart, duration, σ, color = :brown)\nexc_purple = ColoredNoise(F0, tstart, duration, σ, color = :purple)\n\n# Compute the spectrum of the colored noise\nfreq = rfftfreq(nt, fs)\nS_white = rfft(excitation(exc_white, t))\nS_pink = rfft(excitation(exc_pink, t))\nS_blue = rfft(excitation(exc_blue, t))\nS_brown = rfft(excitation(exc_brown, t))\nS_purple = rfft(excitation(exc_purple, t))",
    "crumbs": [
      "Models",
      "Excitation models"
    ]
  },
  {
    "objectID": "models/excitation.html#available-models",
    "href": "models/excitation.html#available-models",
    "title": "Excitation models",
    "section": "",
    "text": "To define an excitation, two steps must be followed:\n\nInitialize an excitation type:\nexc_type = MyExcitation(params...)\nCompute the excitation signal corresponding to the given excitation type over a given duration t (See Section 2 for details):\nF = excitation(exc_type, t)\n\n\n\nThe rectangular signal is defined by the following equation: \\[\nF(t) = \\begin{cases}\nF_0 & \\text{if } t \\in [t_\\text{start}, t_\\text{start} + T] \\\\\n0 & \\text{otherwise}\n\\end{cases},\n\\] where \\(F_0\\) is the amplitude of the signal, \\(t_\\text{start}\\) is the start time of the signal, and \\(T\\) is the duration of the signal.\n\nRectangle\n\n\n\nRectangle(F, tstart, duration)\nStruct to define a rectangular excitation signal\nFields\n\nF::Real: Amplitude of the force [N]\n\ntstart::Real: Starting time of the excitation [s]\n\nduration::Real: Duration of the excitation [s]\n\n\n\n\n\n\n\n\n\n# Time parameters\nΔt = 1e-3\nt = 0.:Δt:10.\n\n# Excitation parameters\nF0 = 1.\ntstart = 2.5\nduration = 5.\n\n# Initialize Rectangle type\nrect = Rectangle(F0, tstart, duration)\n\n# Compute the excitation\nF_rect = excitation(rect, t)\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe triangle signal is defined by the following equation: \\[\nF(t) = \\begin{cases}\n\\frac{2F_0}{T}\\left(t - t_\\text{start}\\right) & \\text{if } t \\in [t_\\text{start}, t_m] \\\\\nF_0 - \\frac{2F_0}{T}(t - t_m) & \\text{if } t \\in [t_m, t_\\text{start} + T] \\\\\n0 & \\text{otherwise}\n\\end{cases},\n\\] where \\(F_0\\) is the amplitude of the signal, \\(t_\\text{start}\\) is the start time of the signal, \\(T\\) is the duration of the signal and \\(t_m = t_\\text{start} + T/2\\) is the time at which the signal reaches its maximum value.\n\nTriangle\n\n\n\nTriangle(F, tstart, duration)\nStruct to define a triangular excitation signal\nFields\n\nF::Real: Amplitude of the force [N]\n\ntstart::Real: Starting time of the excitation [s]\n\nduration::Real: Duration of the excitation [s]\n\n\n\n\n\n\n\n\n\n# Time parameters\nΔt = 1e-3\nt = 0.:Δt:10.\n\n# Excitation parameters\nF0 = 1.\ntstart = 2.5\nduration = 5.\n\n# Initialize Triangle type\ntri = Triangle(F0, tstart, duration)\n\n# Compute the excitation\nF_tri = excitation(tri, t)\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe hammer impact signal is supposed to have the shape of a Gamma distribution \\[\nF(t) = \\begin{cases}\nF_0\\left(\\frac{t_h}{p\\theta}\\right)^p \\text{exp}\\left(-\\frac{t_h}{\\theta} + p\\right), & \\text{if } t \\geq t_\\text{start} \\\\\n0, & \\text{otherwise}\n\\end{cases},\n\\] where \\(F_0\\) is the amplitude of the signal, \\(t_h = t - t_\\text{start}\\) is the time since the impact, \\(p\\) is the shape parameter, and \\(\\theta\\) is the scale parameter.\n\nHammer\n\n\n\nHammer(F, tstart, k, θ)\nStruct to define a hammer impact excitation signal\nFields\n\nF::Real: Amplitude of the force [N]\n\ntstart::Real: Starting time of the excitation [s]\n\np::Real: Shape parameter\n\nθ::Real: Intensity parameter [s]\n\n\n\n\n\n\n\n\n\n# Time parameters\nΔt = 1e-5\nt = 0.:Δt:0.05\n\n# Excitation parameters\nF0 = 1.\ntstart = 0.01\nk = 9.7\nθ = 6e-4\n\n# Initialize Hammer type\nhammer = Hammer(F0, tstart, k, θ)\n\n# Compute the excitation\nF_hammer = excitation(hammer, t)\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe smooth rectangular signal (custom Tukey window) is defined by the following equation: \\[\nF(t) = \\begin{cases}\n\\frac{F_0}{2}\\left[1 - \\cos\\left(\\frac{2\\pi (t - t_\\text{start})}{\\alpha T}\\right)\\right] & \\text{if } t \\in [t_\\text{start}, t_\\text{start} + t_\\text{rise}] \\\\\nF_0 & \\text{if } t \\in [t_\\text{start} + t_\\text{rise}, t_\\text{start} + t_\\text{rise} + T_\\text{rect}] \\\\\n\\frac{F_0}{2}\\left[1 - \\cos\\left(\\frac{2\\pi (t - t_\\text{start} - t_\\text{rise} - T_\\text{rect})}{\\alpha T}\\right)\\right] & \\text{if } t \\in [t_\\text{start} + t_\\text{rise} + T_\\text{rect}, t_\\text{start} + T] \\\\\n\\end{cases},\n\\] where \\(F_0\\) is the amplitude of the signal, \\(t_\\text{start}\\) is the start time of the signal, \\(T\\) is the duration of the signal, \\(t_\\text{rise}\\) is the duration to reach \\(F_0\\) and \\(\\alpha = \\frac{2t_\\text{rise}}{T}\\) and \\(T_\\text{rect} = T - 2t_\\text{rise}\\) is the duration of the rectangular part of the signal.\n\nSmoothRect\n\n\n\nSmoothRect(F, tstart, tr, duration)\nStruct to define a smooth rectangular excitation signal\nFields\n\nF::Real: Amplitude of the force [N]\n\ntstart::Real: Starting time of the excitation [s]\n\nduration::Real: Duration of the excitation [s]\n\ntrise::Real: Rise time from 0 to F [s]\n\n\nNote: SmoothRect is actually a custom Tukey window for which the coefficient α is computed to satisfy the trise given by the user\n\n\n\n\n\n\n\n# Time parameters\nΔt = 1e-3\nt = 0.:Δt:10.\n\n# Excitation parameters\nF0 = 1.\ntstart = 2.5\nduration = 5.\ntrise = 1.\n\n# Initialize SmoothRect type\nsrect = SmoothRect(F0, tstart, duration, trise)\n\n# Compute the excitation\nF_srect = excitation(srect, t)\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe sine signal is defined by the following equation: \\[\nF(t) = \\begin{cases}\nF_0 \\sin\\left(\\omega (t - t_\\text{start}) + \\theta\\right), & \\text{if } t \\in [t_\\text{start}, t_\\text{start} + T] \\\\\n0, & \\text{otherwise}\n\\end{cases},\n\\] where \\(F_0\\) is the amplitude of the signal, \\(\\omega\\) is the angular frequency of the signal, and \\(\\theta\\) is the phase of the signal.\n\n\n\n\n\n\nZero-end signal\n\n\n\n\n\nSometimes it is necessary to have a signal that ends at zero. In this case, the duration of the signal must be adjusted to ensure that the signal ends at zero. To do so, one have to find the smallest integer \\(n\\) such that at \\(t = t_\\text{start} + T\\): \\[\n\\sin(\\omega T + \\theta) = 0 \\Rightarrow \\omega T + \\theta = 2\\pi n \\Rightarrow n = \\frac{\\omega T + \\theta}{2\\pi}.\n\\]\nOnce \\(n\\) is found, the duration of the signal must be adjusted to: \\[\nT_\\text{new} = \\frac{2\\pi n - \\theta}{\\omega}.\n\\]\n\n\n\n\nSineWave\n\n\n\nSineWave(F, tstart, duration, freq; zero_end = true)\nStruct to define a sine wave excitation signal\nConstructor parameters\n\nF::Real: Amplitude of the force [N]\n\ntstart::Real: Starting time of the excitation [s]\n\nduration::Real: Duration of the excitation [s]\n\nfreq::Real: Frequency of the excitation [Hz]\n\nzero_end::Bool: Boolean to set the excitation to 0 at the end of the duration (default = true)\n\n\nFields\n\nF::Real: Amplitude of the force [N]\n\ntstart::Real: Starting time of the excitation [s]\n\nduration::Real: Duration of the excitation [s]\n\nω::Real: Frequency of the excitation [Hz]\n\nzero_end::Bool: Boolean to set the excitation to 0 at the end of the duration (default = true)\n\n\n\n\n\n\n\n\n\n# Time parameters\nΔt = 1e-3\nt = 0.:Δt:10.\n\n# Excitation parameters\nF0 = 1.\ntstart = 2.5\nduration = 5.\nf = 2.\n\n# Initialize HaverSine type\nsine = SineWave(F0, tstart, duration, f, zero_end = true)\n\n# Compute the excitation\nF_sine = excitation(sine, t)\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe half-sine signal is defined by the following equation: \\[\nF(t) = \\begin{cases}\nF_0 \\sin(\\frac{\\pi (t - t_\\text{start}}{T}) & \\text{if } t \\in [t_\\text{start}, t_\\text{start} + T] \\\\\n0 & \\text{otherwise}\n\\end{cases},\n\\] where \\(F_0\\) is the amplitude of the signal, \\(t_\\text{start}\\) is the start time of the signal, and \\(T\\) is the duration of the signal.\n\nHalfSine\n\n\n\nHalfSine(F, tstart, duration)\nStruct to define a half sine excitation signal\nFields\n\nF::Real: Amplitude of the force [N]\n\ntstart::Real: Starting time of the excitation [s]\n\nduration::Real: Duration of the excitation [s]\n\n\n\n\n\n\n\n\n\n# Time parameters\nΔt = 1e-3\nt = 0.:Δt:10.\n\n# Excitation parameters\nF0 = 1.\ntstart = 2.5\nduration = 5.\n\n# Initialize HalfSine type\nhsine = HalfSine(F0, tstart, duration)\n\n# Compute the excitation\nF_hsine = excitation(hsine, t)\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe haversine (or versed sine) signal is defined by the following equation: \\[\nF(t) = \\begin{cases}\nF_0\\left(1 - cos(\\frac{2\\pi t}{T}\\right) & \\text{if } t \\in [t_\\text{start}, t_\\text{start} + T] \\\\\n0 & \\text{otherwise}\n\\end{cases},\n\\] where \\(F_0\\) is the amplitude of the signal, \\(t_\\text{start}\\) is the start time of the signal, and \\(T\\) is the duration of the signal.\n\nHaverSine\n\n\n\nHaverSine(F, tstart, duration)\nStruct to define a Haversine (or versed sine) excitation signal\nFields\n\nF::Real: Amplitude of the force [N]\n\ntstart::Real: Starting time of the excitation [s]\n\nduration::Real: Duration of the excitation [s]\n\n\n\n\n\n\n\n\n\n# Time parameters\nΔt = 1e-3\nt = 0.:Δt:10.\n\n# Excitation parameters\nF0 = 1.\ntstart = 2.5\nduration = 5.\n\n# Initialize HaverSine type\nhaversine = HaverSine(F0, tstart, duration)\n\n# Compute the excitation\nF_haversine = excitation(haversine, t)\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe swept sine signal is defined by the following equation: \\[\nF(t) = \\begin{cases}\nF_0 \\sin(\\theta(t)) & \\text{if } t \\in [t_\\text{start}, t_\\text{start} + T] \\\\\n0 & \\text{otherwise}\n\\end{cases},\n\\] where \\(F_0\\) is the amplitude of the signal, \\(t_\\text{start}\\) is the start time of the signal, \\(T\\) is the duration of the signal and \\(\\theta(t)\\) is the instantaneous phase.\nThe instantaneous phase is given by: \\[\n\\theta(t) = \\theta_0 + 2\\pi\\int_0^t f(\\tau) d\\tau,\n\\] where \\(f(\\tau)\\) is the instantaneous frequency of the signal at time \\(\\tau\\) and \\(\\theta_0\\) is the initial phase (set to 0 here).\nIn this package, three possible types of swept sine signals are available:\n\nLinear swept sine: \\[\nf(t) = f_\\text{start} + \\beta(t - t_\\text{start}) \\Rightarrow \\theta(t) = 2\\pi\\left(f_\\text{start}(t - t_\\text{start}) + \\frac{\\beta (t - t_\\text{start})^2}{2}\\right),\n\\] where:\n\n\\(\\beta = \\frac{f_\\text{end} - f_\\text{start}}{T}\\)\n\\(f_\\text{start}\\): Initial frequency of the signal at \\(t_\\text{start}\\)\n\\(f_\\text{end}\\): Final frequency of the signal at \\(t_\\text{start} + T\\)\n\nQuadratic swept sine: \\[\nf(t) = f_\\text{start} + \\beta (t - t_\\text{start})^2 \\Rightarrow \\theta(t) = 2\\pi\\left(f_\\text{start}(t - t_\\text{start}) + \\frac{\\beta (t - t_\\text{start})^3}{3}\\right),\n\\] where \\(\\beta = \\frac{f_\\text{end} - f_\\text{start}}{T^2}\\).\nLogarithmic swept sine: \\[\nf(t) = f_\\text{start}\\beta^{t - t_\\text{start}} \\Rightarrow \\theta(t) = \\frac{2\\pi f_\\text{start}}{\\log(\\beta)}\\left(\\beta^{t - t_\\text{start}} - 1\\right),\n\\] where \\(\\beta = \\left(\\frac{f_\\text{end}}{f_\\text{start}}\\right)^{1/T}\\).\n\n\n\n\n\n\n\nZero-end signal\n\n\n\n\n\nSimilarly to the sine signal, the duration of the signal must be adjusted to ensure that the signal ends at zero. To do so, one have to find the smallest integer \\(n\\) such that at \\(t = t_\\text{start} + T\\): \\[\n  \\theta(t) = 2\\pi n.\n\\]\nIn doing so, we have for:\n\nLinear swept sine: \\[\nn = (f_\\text{start} + f_\\text{end})\\frac{T}{2} \\Rightarrow T_\\text{new} = \\frac{2n}{f_\\text{start} + f_\\text{end}}.\n\\]\nQuadratic swept sine: \\[\nn = (2f_\\text{start} + f_\\text{end})\\frac{T}{3} \\Rightarrow T_\\text{new} = \\frac{3n}{2f_\\text{start} + f_\\text{end}}.\n\\]\nLogarithmic swept sine: \\[\nn = \\frac{f_\\text{end} - f_\\text{start}}{\\log(f_\\text{end}/f_\\text{start})}T \\Rightarrow T_\\text{new} = \\frac{n\\log(f_\\text{end}/f_\\text{start})}{f_\\text{end} - f_\\text{start}}.\n\\]\n\n\n\n\n\nSweptSine\n\n\n\nSweptSine(F, tstart, duration, fstart, fend, type)\nStruct to define a swept sine excitation signal\nFields\n\nF::Real: Amplitude of the force [N]\n\ntstart::Real: Starting time of the excitation [s]\n\nduration::Real: Duration of the excitation [s]\n\nfstart::Real: Starting frequency [Hz]\n\nfend::Real: Ending frequency [Hz]\n\ntype::Symbol: Type of sweep\n\n:lin - linear (default)\n\n:quad - quadratic\n\n:log - logarithmic\n\n\n\nzero_end::Bool: Boolean to set the excitation to 0 at the end of the duration (default = true)\n\n\n\n\n\n\n\n\n\n# Time parameters\nΔt = 1e-3\nt = 0.:Δt:10.\n\n# Excitation parameters\nF0 = 1.\ntstart = 2.5\nduration = 5.\nfstart = 1.\nfend = 6.\ntype_swept = :lin\n\n# Initialize SweptSine type\nchirp = SweptSine(F0, tstart, duration, fstart, fend, type_swept, zero_end = true)\n\n# Compute the excitation\nF_chirp = excitation(chirp, t)\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe Gaussian pulse signal is defined by the following equation: \\[\nF(t) = \\begin{cases}\nF_0 \\exp\\left(-\\frac{t_p^2}{2\\sigma^2}\\right) \\cos(2\\pi f_c t_p), & \\text{if } t \\geq t_\\text{start} \\\\\n0, & \\text{otherwise}\n\\end{cases},\n\\] where \\(F_0\\) is the amplitude of the signal, \\(t_\\text{start}\\) is the start time of the signal, \\(\\sigma\\) is the standard deviation of the signal, and \\(f_c\\) is the carrier frequency. Here \\(t_p = t - t_\\text{start} - T/2\\) so that the Gaussian pulse reaches its maximum value at \\(t = t_\\text{start} + T/2\\).\n\n\n\n\n\n\nVariance calibration\n\n\n\n\n\nThe design of the Gaussian pulse assumes that it tends to zero when \\(t = t_\\text{start} + T\\). This requirement implies that the standard deviation \\(\\sigma\\) must be chosen such that the Gaussian pulse is zero at \\(t = t_\\text{start} + T\\). This condition can only be satisfied within some precision. More precisely, the idea is to find the quantile \\(n\\) such that \\(T = n\\sigma\\). Consequently, if we assume that \\(F(t_\\text{start} + T) = 10^{-p}\\) (with \\(p\\) a given precision), we have: \\[\nn = 2\\sqrt{2(p\\log 10 + \\log F_0)} \\Rightarrow \\sigma = \\frac{T}{n}.\n\\]\n\n\n\n\nGaussianPulse\n\n\n\nGaussianPulse(F, tstart, duration, fc)\nStruct to define a Gaussian pulse excitation signal\nFields\n\nF::Real: Amplitude of the force [N]\n\ntstart::Real: Starting time of the excitation [s]\n\nduration::Real: Duration of the excitation [s]\n\nfc::Real: Center frequency of the pulse [Hz]\n\nprecision::Real: Precision of the pulse (default = 4.)\n\n\nNote\nThe precision parameter calibrates the standard deviation of the pulse, so that the duration = n x σ, within some precision. If n = 1.96 then the confidence interval of the Gaussian distribution is 95%. To do so, we compute n so that at t = duration = n x σ , the amplitude of F x exp(-0.5*(t - duration/2)^2/sigma^2) = 10^(-precision)\n\n\n\n\n\n\n\n# Time parameters\nΔt = 1e-3\nt = 0.:Δt:10.\n\n# Excitation parameters\nF0 = 1.\ntstart = 2.5\nduration = 5.\nfc = 2.\n\n# Initialize GaussianPulse type\ngpulse = GaussianPulse(F0, tstart, duration, fc)\n\n# Compute the excitation\nF_gpulse = excitation(gpulse, t)\n\n\n\n\n\n\n\n\n\n\n\n\n\nColored noise is a random signal that has a power spectral density that is not (necessarily) flat over a given frequency range. In practice, colored noise is also refered to as “power-law noise” since its power spectral density is proportional to \\(f^{-\\alpha}\\) (\\(f\\): frequency) and its spectrum is proportional to \\(f^{-\\alpha/2}\\).\nIn this package, five types of colored noise are available:\n\nWhite noise: \\(\\alpha = 0\\)\nPink noise: \\(\\alpha = 1\\)\nBlue noise: \\(\\alpha = -1\\)\nBrown noise: \\(\\alpha = 2\\)\nPurple noise: \\(\\alpha = -2\\)\n\nThe general procedure to generate a colored noise signal is as follows:\n\nGenerate a white noise signal and compute its FFT\nMultiply the FFT by \\(f^{-\\alpha/2}\\) to obtain the colored noise\nCompute the inverse FFT to obtain the colored noise signal\n\nAdditional steps can be added such as:\n\nNormalization: Ensure that the colored noise has the desired variance and preserves the energy of the white noise\nFiltering: Obtain a band-limited colored noise\n\n\nColoredNoise\n\n\n\nColoredNoise(F, color)\nStruct to define a colored noise excitation signal\nFields\n\nF::Real: Mean amplitude of the force [N]\n\ntstart::Real: Starting time of the excitation [s]\n\nduration::Real: Duration of the excitation [s]\n\nσ::Real: Target standard deviation of the colored noise\n\ncolor::Symbol: Color of the noise\n\n:white (default)\n\n:pink\n\n:blue\n\n:brown\n\n:purple\n\n\n\nband_freq::AbstractVector: Frequencies used to defined the bandpass filter applied to the colored noise\n\n\n\n\n\n\n\n\n\n# Time parameters\nΔt = 1e-4\nt = 0.:Δt:10.\nnt = length(t)\nfs = 1/Δt\n\n# Excitation parameters\nF0 = 1.\ntstart = 0.\nduration = 10.\nσ = 1.\n\n# Initialize ColoredNoise type\nexc_white = ColoredNoise(F0, tstart, duration, σ, color = :white)\nexc_pink = ColoredNoise(F0, tstart, duration, σ, color = :pink)\nexc_blue = ColoredNoise(F0, tstart, duration, σ, color = :blue)\nexc_brown = ColoredNoise(F0, tstart, duration, σ, color = :brown)\nexc_purple = ColoredNoise(F0, tstart, duration, σ, color = :purple)\n\n# Compute the spectrum of the colored noise\nfreq = rfftfreq(nt, fs)\nS_white = rfft(excitation(exc_white, t))\nS_pink = rfft(excitation(exc_pink, t))\nS_blue = rfft(excitation(exc_blue, t))\nS_brown = rfft(excitation(exc_brown, t))\nS_purple = rfft(excitation(exc_purple, t))",
    "crumbs": [
      "Models",
      "Excitation models"
    ]
  },
  {
    "objectID": "models/excitation.html#sec-exc-api",
    "href": "models/excitation.html#sec-exc-api",
    "title": "Excitation models",
    "section": "2 excitation function",
    "text": "2 excitation function\n\nexcitation\n\n\n\nexcitation(type, t)\nComputes different types of excitation signals\nInputs\n\ntype : Excitation type\n\nTriangle\n\nRectangle\n\nHammer\n\nSmoothRect\n\nSineWave\n\nHalfSine\n\nHaverSine\n\nSweptSine\n\nGaussianPulse\n\nColoredNoise\n\n\n\nt: Time vector\n\n\nOutput\n\nF: Excitation signal",
    "crumbs": [
      "Models",
      "Excitation models"
    ]
  },
  {
    "objectID": "models/noise.html",
    "href": "models/noise.html",
    "title": "Noise models",
    "section": "",
    "text": "In real-world applications, the noise is always present in the measured data. The noise can be due to various reasons such as the sensor noise, the environmental noise, the quantization noise, etc. The noise can be modeled as a random process. The package implements various type of noise in order to cover a wide range of practical situations.",
    "crumbs": [
      "Models",
      "Noise models"
    ]
  },
  {
    "objectID": "models/noise.html#additive-gaussian-white-noise",
    "href": "models/noise.html#additive-gaussian-white-noise",
    "title": "Noise models",
    "section": "1 Additive Gaussian White noise",
    "text": "1 Additive Gaussian White noise\nWhen a signal, real or complex, \\(x\\) is corrupted by an additive Gaussian white noise \\(n\\), the measured signal \\(y\\) can be written as: \\[\n    y = x + n\n\\] where \\(n \\sim \\mathcal{N}(n| 0, \\sigma^2)\\)\n\nagwn\n\n\n\nagwn(x, snr_dB; rst = true)\nAdds a Gaussian White Noise (AGWN) to a signal x with a given SNR.\nInputs\n\nx: Signal (Real or Complex)\n\nsnr_dB: signal to noise ratio [dB]\n\nrst: Reset the random number generator - Bool\n\n\nOutput\n\ny: Noisy signal\n\n\n\n\n\n\n\n\n\n# Noiseless signal\nΔt = 1e-4\nt = 0:Δt:1\nx = sin.(2π*5*t)\n\n# Signal to noise ratio\nsnr_dB = 25.\n\n# Noisy signal\ny = agwn(x, snr_dB)",
    "crumbs": [
      "Models",
      "Noise models"
    ]
  },
  {
    "objectID": "models/noise.html#additive-colored-noise",
    "href": "models/noise.html#additive-colored-noise",
    "title": "Noise models",
    "section": "2 Additive Colored noise",
    "text": "2 Additive Colored noise\nWhen a signal, real or complex, \\(x\\) is corrupted by an additive colored noise \\(n\\), the measured signal \\(y\\) can be written as: \\[\n    y = x + n,\n\\] where \\(n\\) is a colored noise defined as in Excitation models - Colored noise.\n\nacn - Real signal\n\n\n\nacn(x, snr_dB, fs, color = :pink; band_freq = Float64[], rst = true)\nAdds a complex Colored Noise (ACN) to a signal x with a given SNR\nInputs\n\nx: Signal\n\nsnr_dB: Signal to noise ratio [dB]\n\nfs: Sampling frequency [Hz]\n\ncolor: Color of the noise\n\n:white\n\n:pink (default)\n\n:blue\n\n:brown\n\n:purple\n\n\n\nband_freq: Frequencies used to defined the bandpass filter applied to the colored noise\n\nrst: Reset the random number generator\n\n\nOutput\n\ny: Noisy signal\n\n\n\n\n\n\n\n\n\nacn - Complex signal\n\n\n\nacn(x, snr_dB, freq, color = :pink; rst = true)\nAdds a complex Random Colored Noise (ACN) to a signal x with a given SNR\nInputs\n\nx::VecOrMat{Real}: Signal\n\nsnr_dB: Signal to noise ratio [dB]\n\nfreq::AbstractVector: Frequency range of interest\n\ncolor: Color of the noise\n\n:white\n\n:pink (default)\n\n:blue\n\n:brown\n\n:purple\n\n\n\nrst::Bool: Reset the random number generator\n\n\nOutput\n\ny: Noisy signal\n\n\n\n\nacn(x, snr_dB, fs, color = :pink; band_freq = Float64[], rst = true)\nAdds a complex Colored Noise (ACN) to a signal x with a given SNR\nInputs\n\nx: Signal\n\nsnr_dB: Signal to noise ratio [dB]\n\nfs: Sampling frequency [Hz]\n\ncolor: Color of the noise\n\n:white\n\n:pink (default)\n\n:blue\n\n:brown\n\n:purple\n\n\n\nband_freq: Frequencies used to defined the bandpass filter applied to the colored noise\n\nrst: Reset the random number generator\n\n\nOutput\n\ny: Noisy signal\n\n\n\n\n\n\n\n\n\n# Noiseless signal\nΔt = 1e-4\nfs = 1/Δt\nt = 0:Δt:1\nx = sin.(2π*5*t)\n\n# Signal to noise ratio\nsnr_dB = 25.\n\n# Noisy signal\ny = acn(x, snr_dB, fs, :blue)",
    "crumbs": [
      "Models",
      "Noise models"
    ]
  },
  {
    "objectID": "models/noise.html#multiplicative-gaussian-white-noise",
    "href": "models/noise.html#multiplicative-gaussian-white-noise",
    "title": "Noise models",
    "section": "3 Multiplicative Gaussian White noise",
    "text": "3 Multiplicative Gaussian White noise\nWhen a signal, real or complex, \\(x\\) is corrupted by a multiplicative Gaussian white noise \\(n\\), the measured signal \\(y\\) can be written as: \\[\n    y = (1 + n)x\n\\]\n\nmgwn\n\n\n\nmgwn(x, snr_dB; rst = true)\nAdds a multiplicative Gaussian White Noise (MGWN) to a signal x with a given SNR\nInputs\n\nx: Signal\n\nsnr_dB: Signal to noise ratio [dB]\n\nrst: Reset the random number generator\n\n\nOutput\n\ny: Noisy signal\n\n\n\n\n\n\n\n\n\n# Noiseless signal\nΔt = 1e-4\nt = 0:Δt:1\nx = sin.(2π*5*t)\n\n# Signal to noise ratio\nsnr_dB = 25.\n\n# Noisy signal\ny = mgwn(x, snr_dB)",
    "crumbs": [
      "Models",
      "Noise models"
    ]
  },
  {
    "objectID": "models/noise.html#mixed-noise",
    "href": "models/noise.html#mixed-noise",
    "title": "Noise models",
    "section": "4 Mixed noise",
    "text": "4 Mixed noise\nWhen a signal, real or complex, \\(x\\) is corrupted by a mixed noise \\(n\\), the measured signal \\(y\\) can be written as: \\[\n    y = (1 + n_m)x + n_a\n\\] where \\(n_m\\) is a multiplicative Gaussian white noise and \\(n_a\\) is an additive Gaussian white noise.\n\nmixed_noise\n\n\n\nmixed_noise(x, snr_dB; rst = true)\nAdds both additive and multiplicative Gaussian White Noise to a signal x with a given SNR\nInputs\n\nx: Signal\n\nsnr_dB: Signal to noise ratio [dB]\n\nrst: Reset the random number generator\n\n\nOutput\n\ny: Noisy signal\n\n\n\n\n\n\n\n\n\n# Noiseless signal\nΔt = 1e-4\nt = 0:Δt:1\nx = sin.(2π*5*t)\n\n# Signal to noise ratio\nsnr_dB = 25.\n\n# Noisy signal\ny = mixed_noise(x, snr_dB)",
    "crumbs": [
      "Models",
      "Noise models"
    ]
  },
  {
    "objectID": "signal_processing/index.html",
    "href": "signal_processing/index.html",
    "title": "Digital Signal Processing",
    "section": "",
    "text": "StructuralVibration.jl provides a set of functions complementing the DSP.jl to simulate the signal processing pipelines used in structural dynamics applications, such as modal analysis, system identification, and vibration data processing. They can for instance be used to simulate or to process experimental data, which can then be used to validate new algorithms (direct or inverse methods) and to benchmark with existing ones.",
    "crumbs": [
      "Signal processing",
      "Digital Signal Processing"
    ]
  },
  {
    "objectID": "signal_processing/index.html#window-functions",
    "href": "signal_processing/index.html#window-functions",
    "title": "Digital Signal Processing",
    "section": "1 Window functions",
    "text": "1 Window functions\nThe DSP.jl package provides a set of window functions that can be used to reduce spectral leakage in the frequency domain. The StructuralVibration.jl package exports the window functions defined in DSP.jl and provides additional ones for the sake of completeness.\n\n1.1 Windows from DSP.jl\n\n1.1.1 Rectangular window\nThe rectangular window is the simplest window function, which does not modify the signal. It is defined as: \\[\nw[n] = 1,\n\\] for \\(n \\in [0, N-1]\\), where \\(N\\) is the length of the window.\nThe rectangular window is generally not recommended for spectral analysis, as it introduces significant spectral leakage. It is mainly used for testing purposes or when no windowing is required (such as impact testing for sufficiently long acquisition duration).\n\n1.1.1.1 API\n\nrect\n\n\n\nrect\nRectangular window\nExported from DSP.jl\n\n\n\n\n\n\n\n\n1.1.1.2 Example\n\nrectwin = rect(1024)\n\n\n\n\n\n\n\n\n\n\n\n\n\n1.1.2 Hann(ing) window\nThe Hann window is a raised cosine window that tapers the signal at both ends. It is defined as: \\[\nw[n] = \\frac{1}{2} \\left[1 - \\cos\\left(\\frac{2\\pi n}{N-1}\\right)\\right],\n\\] where \\(N\\) is the length of the window and \\(n \\in [0, N-1]\\).\n\n1.1.2.1 API\n\nhann\n\n\n\nhann\nHann(ing) window\nExported from DSP.jl\n\n\n\n\n\n\n\n\n1.1.2.2 Example\n\nhannwin = hanning(1024)\n\n\n\n\n\n\n\n\n\n\n\n\n\n1.1.3 Hamming window\nThe Hamming window is a raised cosine window that tapers the signal at both ends. It is defined as: \\[\nw[n] = 0.54 - 0.46 \\cos\\left(\\frac{2\\pi n}{N-1}\\right),\n\\] where \\(N\\) is the length of the window and \\(n \\in [0, N-1]\\).\n\n1.1.3.1 API\n\nhamming\n\n\n\nhamming\nHamming window\nExported from DSP.jl\n\n\n\n\n\n\n\n\n1.1.3.2 Example\n\nhammwin = hamming(1024)\n\n\n\n\n\n\n\n\n\n\n\n\n\n1.1.4 Tukey window\nThe Tukey window (also known as the cosine-tapered window) is defined by a tapering parameter \\(\\alpha \\in [0,1]\\), which controls the proportion of the window that is tapered. The window is defined as:\n\\[\n\\begin{align*}\n& w[n] = \\frac{1}{2} \\left[1 - \\cos\\left(\\frac{2\\pi n}{\\alpha(N-1)}\\right)\\right], & 0 \\leq n &lt; \\frac{\\alpha(N-1)}{2} \\\\\n& w[n] = 1,  & \\frac{\\alpha(N-1)}{2} \\leq n \\leq \\frac{(N-1)}{2} \\\\\n& w[N-1 - n] = w[n], & 0 \\leq n \\leq \\frac{\\alpha(N-1)}{2} \\\\\n\\end{align*}\n\\]\nWhen \\(\\alpha = 0\\), the Tukey window becomes a rectangular window, and when \\(\\alpha = 1\\), it becomes equivalent to a Hann window.\n\n1.1.4.1 API\n\ntukey\n\n\n\ntukey\nTukey window\nExported from DSP.jl\n\n\n\n\n\n\n\n\n1.1.4.2 Example\n\ntukeywin = tukey(1024, 0.5)\n\n\n\n\n\n\n\n\n\n\n\n\n\n1.1.5 Cosine window\nThe cosine window is a raised cosine window that tapers the signal at both ends. It is defined as: \\[\nw[n] = \\cos\\left(\\frac{\\pi n}{N-1} - \\frac{\\pi}{2}\\right),\n\\] where \\(N\\) is the length of the window and \\(n \\in [0, N-1]\\).\n\n1.1.5.1 API\n\ncosine\n\n\n\ncosine\nCosine window\nExported from DSP.jl\n\n\n\n\n\n\n\n\n1.1.5.2 Example\n\ncoswin = cosine(1024)\n\n\n\n\n\n\n\n\n\n\n\n\n\n1.1.6 Lanczos window\nThe Lanczos window is a raised cosine window that tapers the signal at both ends. It is defined as: \\[\nw[n] = \\text{sinc}\\left(\\frac{2n}{N-1} - 1\\right),\n\\] where \\(N\\) is the length of the window and \\(n \\in [0, N-1]\\).\n\n1.1.6.1 API\n\nlanczos\n\n\n\nlanczos\nLanczos window\nExported from DSP.jl\n\n\n\n\n\n\n\n\n1.1.6.2 Example\n\nlanczoswin = lanczos(1024)\n\n\n\n\n\n\n\n\n\n\n\n\n\n1.1.7 Triangular window\nThe triangular window is a simple window function that tapers the signal at both ends. It is defined as: \\[\nw[n] = 1 - \\frac{|2n - (N-1)|}{L},\n\\] where \\(L = N/N+1\\) is \\(N\\) is even/odd and \\(n \\in [0, N-1]\\).\n\n1.1.7.1 API\n\ntriang\n\n\n\ntriang\nTriangle window\nExported from DSP.jl\n\n\n\n\n\n\n\ntriangwin = triang(1024)\n\n\n\n\n\n\n\n\n\n\n\n\n\n1.1.8 Bartlett window\nThe Bartlett window is a triangular window that tapers the signal at both ends. It is defined as: \\[\nw[n] = \\left(1 - \\frac{|n - L|}{L}\\right),\n\\] where \\(L = \\frac{N-1}{2}\\) and \\(n \\in [0, N-1]\\).\n\n1.1.8.1 API\n\nbartlett\n\n\n\nbartlett\nBartlett window\nExported from DSP.jl\n\n\n\n\n\n\n\n\n1.1.8.2 Example\n\nbartlettwin = bartlett(1024)\n\n\n\n\n\n\n\n\n\n\n\n\n\n1.1.9 Bartlett-Hann window\nThe Bartlett-Hann window is a raised cosine window that tapers the signal at both ends. It is defined as: \\[\nw[n] = 0.62 - 0.48 \\left|\\frac{n}{N-1} - 0.5\\right| + 0.38 \\cos\\left(2\\pi\\left[\\frac{n}{N-1} - 0.5\\right]\\right),\n\\] where \\(n \\in [0, N-1]\\).\n\n1.1.9.1 API\n\nbartlett_hann\n\n\n\nbartlett_hann\nBartlett-Hann window\nExported from DSP.jl\n\n\n\n\n\n\n\n\n1.1.9.2 Example\n\nbarthannwin = bartlett_hann(1024)\n\n\n\n\n\n\n\n\n\n\n\n\n\n1.1.10 Gaussian window\nThe Gaussian window is a raised cosine window that tapers the signal at both ends. It is defined as: \\[\nw[n] = \\text{exp}\\left(-\\frac{(n - \\mu)^2}{2\\sigma^2}\\right),\n\\] where \\(\\mu = \\frac{N-1}{2}\\) is the center of the window, \\(\\sigma\\) is the standard deviation, and \\(n \\in [0, N-1]\\).\n\n1.1.10.1 API\n\ngaussian\n\n\n\ngaussian\nGaussian window\nExported from DSP.jl\n\n\n\n\n\n\n\n\n1.1.10.2 Example\n\ngaussianwin = gaussian(1024, 0.2)\n\n\n\n\n\n\n\n\n\n\n\n\n\n1.1.11 Blackman window\nThe Blackman window is a raised cosine window that tapers the signal at both ends. It is defined as: \\[\nw[n] = 0.42 - 0.5 \\cos\\left(\\frac{2\\pi n}{N-1}\\right) + 0.08 \\cos\\left(\\frac{4\\pi n}{N-1}\\right),\n\\] where \\(n \\in [0, N-1]\\).\n\n1.1.11.1 API\n\nblackman\n\n\n\nblackman\nBlackman window\nExported from DSP.jl\n\n\n\n\n\n\n\n\n1.1.11.2 Example\n\nblackmanwin = blackman(1024)\n\n\n\n\n\n\n\n\n\n\n\n\n\n1.1.12 Kaiser window\nThe Kaiser window is a raised cosine window that tapers the signal at both ends. It is defined as: \\[\nw[n] = I_0\\left(\\pi\\alpha \\sqrt{1 - \\left(\\frac{2n}{N-1} - 1\\right)^2}\\right) / I_0(\\pi\\alpha),\n\\] where \\(I_0\\) is the modified Bessel function of the first kind, \\(\\beta\\) is a parameter that controls the shape of the window, and \\(n \\in [0, N-1]\\).\n\n1.1.12.1 API\n\nkaiser\n\n\n\nkaiser\nKaiser window\nExported from DSP.jl\n\n\n\n\n\n\n\n\n1.1.12.2 Example\n\nkaiserwin = kaiser(1024, 0.5)\n\n\n\n\n\n\n\n\n\n\n\n\n\n1.1.13 DPSS window\nThe DPSS (Discrete Prolate Spheroidal Sequences) window maximizes the energy concentration in the main lobe. It has no closed form expression and depends on two parameters: the length of the window \\(N\\) and the time-half-bandwidth product \\(Nw\\) which controls the energy concentration in the main lobe.\n\n1.1.13.1 API\n\ndpss\n\n\n\ndpss\nDPSS window\nExported from DSP.jl\n\n\n\n\n\n\n\n\n1.1.13.2 Example\n\ndpsswin = dpss(1024, 4, 1)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n1.2 Additional window functions\n\n1.2.1 Exponential window\nAn exponential window is a window function that tapers the signal exponentially. It is defined as: \\[\nw[n] = \\text{exp}\\left(-\\frac{\\tau n}{N-1}\\right),\n\\] where \\(n \\in [0, N-1]\\), \\(\\tau = -\\log(p)\\) is the time constant, and \\(p\\) is the percentage of the original value by the end of the acquisition block.\n\n1.2.1.1 API\n\nexponential\n\n\n\nexponential(N, exponential_end = 0.01)\nCreate an exponential window\nInputs\n\nN: Number of points\n\nexponential_end: End value of the exponential window (between 0 and 1)\n\n\nOutput\n\nw: Exponential window\n\n\n\n\n\n\n\n\n\n\n1.2.1.2 Example\n\nexponentialwin = exponential(1024, 0.1)\n\n\n\n\n\n\n\n\n\n\n\n\n\n1.2.2 Force window\nThe force window is a window function a rectangular window over a given width. It is defined as: \\[\nw[n] = \\begin{cases}\n1, & 0 \\leq n &lt; L \\\\\n0, & L \\leq n &lt; N\n\\end{cases},\n\\] where \\(n \\in [0, N-1]\\), \\(L = pN\\) is the width of the window, and \\(p\\) is the percentage of the length of the data acquisition block.\n\n1.2.2.1 API\n\nforce\n\n\n\nforce(N, width = 0.1)\nCreate a force window\nInputs\n\nN: Number of points\n\nwidth: Width of the force window (between 0 and 1)\n\n\nOutput\n\nw: Force window\n\n\n\n\n\n\n\n\n\n\n1.2.2.2 Example\n\nforcewin = force(1024, 0.2)\n\n\n\n\n\n\n\n\n\n\n\n\n\n1.2.3 Flat-top window\nThe flat-top window is a window function that window is a partially negative-valued window that has minimal scalloping loss in the frequency domain. It is defined as: \\[\nw[n] = a_0 - a_1\\cos\\left(\\frac{2\\pi n}{N-1}\\right) + a_2\\cos\\left(\\frac{4\\pi n}{N-1}\\right) - a_3\\cos\\left(\\frac{6\\pi n}{N-1}\\right) + a_4\\cos\\left(\\frac{8\\pi n}{N-1}\\right),\n\\] where \\(n \\in [0, N-1]\\) and \\(a_0 = 0.21557895\\), \\(a_1 = 0.41663158\\), \\(a_2 = 0.277263158\\), \\(a_3 = 0.083578947\\), and \\(a_4 = 0.006947368\\).\n\n1.2.3.1 API\n\nflattop\n\n\n\nflattop(N)\nCreate a flat top window\nInput\n\nN: Number of points\n\n\nOutput\n\nw: Flattop window\n\n\n\n\n\n\n\n\n\n\n1.2.3.2 Example\n\nflattopwin = flattop(1024)\n\n\n\n\n\n\n\n\n\n\n\n\n\n1.2.4 Nuttall window\nThe Nutall window is a window function that returns a Nuttall four-term symmetric Blackman-Harris window. It produces slightly lower sidelobes than Blackman-Harris window. It is defined as: \\[\nw[n] = a_0 - a_1\\cos\\left(\\frac{2\\pi n}{N-1}\\right) + a_2\\cos\\left(\\frac{4\\pi n}{N-1}\\right) - a_3\\cos\\left(\\frac{6\\pi n}{N-1}\\right),\n\\] where \\(n \\in [0, N-1]\\) and \\(a_0 = 0.355768\\), \\(a_1 = 0.487396\\), \\(a_2 = 0.144232\\), and \\(a_3 = 0.012604\\).\n\n1.2.4.1 API\n\nnuttall\n\n\n\nnuttall(N)\nCreate a Nuttall window\nInput\n\nN: Number of points\n\n\nOutput\n\nw: Nuttall window\n\n\n\n\n\n\n\n\n\n\n1.2.4.2 Example\n\nnuttallwin = nuttall(1024)\n\n\n\n\n\n\n\n\n\n\n\n\n\n1.2.5 Blackman-Nuttall window\nThe Blackman-Nuttall window is a window function that is a modified version of the exact Blackman window. It is defined as: \\[\nw[n] = a_0 - a_1\\cos\\left(\\frac{2\\pi n}{N-1}\\right) + a_2\\cos\\left(\\frac{4\\pi n}{N-1}\\right) - a_3\\cos\\left(\\frac{6\\pi n}{N-1}\\right),\n\\] where \\(n \\in [0, N-1]\\) and \\(a_0 = 0.3635819\\), \\(a_1 = 0.4891775\\), \\(a_2 = 0.1365995\\), and \\(a_3 = 0.0106411\\).\n\n1.2.5.1 API\n\nblackman_nuttall\n\n\n\nblackman_nuttall(N)\nCreate a Blackman-Nuttall window\nInput\n\nN: Number of points\n\n\nOutput\n\nw: Blackman-Nutall window\n\n\n\n\n\n\n\n\n\n\n1.2.5.2 Example\n\nblackman_nuttallwin = blackman_nuttall(1024)\n\n\n\n\n\n\n\n\n\n\n\n\n\n1.2.6 Blackman-Harris window\nThe Blackman-Harris window is a window function that is another modified version of the exact Blackman window. It is defined as: \\[\nw[n] = a_0 - a_1\\cos\\left(\\frac{2\\pi n}{N-1}\\right) + a_2\\cos\\left(\\frac{4\\pi n}{N-1}\\right) - a_3\\cos\\left(\\frac{6\\pi n}{N-1}\\right),\n\\] where \\(n \\in [0, N-1]\\) and \\(a_0 = 0.35875\\), \\(a_1 = 0.48829\\), \\(a_2 = 0.14128\\), and \\(a_3 = 0.01168\\).\n\n1.2.6.1 API\n\nblackman_harris\n\n\n\nblackman_harris(N)\nCreate a Blackman-Harris window\nInput\n\nN: Number of points\n\n\nOutput\n\nw: Blackman-Harris window\n\n\n\n\n\n\n\n\n\n\n1.2.6.2 Example\n\nblackman_harriswin = blackman_harris(1024)\n\n\n\n\n\n\n\n\n\n\n\n\n\n1.2.7 Parzen window\nThe parzen window is a window function is defined as: \\[\nw[n] = \\begin{cases}\n1 - 6\\left(\\frac{2|n - M|}{N}\\right)^2\\left(1 - \\frac{2|n - M|}{N}\\right) &  0 \\leq |n - M| \\leq \\frac{M}{2}\\\\\n2\\left(1 - \\frac{2|n - M|}{N}\\right)^3 & \\frac{M}{2} &lt; |n - M| \\leq M\\\\\n\\end{cases}\n\\] where \\(M = \\frac{N - 1}{2}\\) and \\(n \\in [0, N-1]\\).\n\n1.2.7.1 API\n\nparzen\n\n\n\nparzen(N)\nCreate a Parzen window\nInput\n\nN: Number of points\n\n\nOutput\n\nw: Parzen window\n\n\n\n\n\n\n\n\n\n\n1.2.7.2 Example\n\nparzenwin = parzen(1024)\n\n\n\n\n\n\n\n\n\n\n\n\n\n1.2.8 Planck-taper window\nThe Planck-taper window is a window function that is defined as: \\[\nw[n] = \\begin{cases}\n0, & n = 0 \\\\\n(1 + \\text{exp}\\left(\\frac{\\epsilon N}{n} - \\frac{\\epsilon N}{\\epsilon N - n}\\right)), & 1 \\leq n &lt; \\epsilon N \\\\\n1, & \\epsilon N \\leq n &lt; N/2 \\\\\nw[N - n], & 0 \\leq n &lt; N/2 \\\\\n\\end{cases},\n\\] where \\(n \\in [0, N-1]\\) and \\(\\epsilon\\) is a parameter, defined in [0, 1] that controls the amount of tapering\n\n1.2.8.1 API\n\nplanck\n\n\n\nplanck(N, ϵ = 0.25)\nCreate a Planck-taper window\nInputs\n\nN: Number of points\n\nϵ: Parameter controlling the tapering\n\n\nOutput\n\nw: Planck-taper window\n\n\n\n\n\n\n\n\n\n\n1.2.8.2 Example\n\nplanckwin = planck(1024, 0.1)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n1.3 Choice of a window function\nThe choice of a window function depends on the application and the desired properties of the window1 2 3. Here are some general guidelines for the main windows used in structural dynamics applications:\n\nRectangular window: This window is suitable for signals which are periodic in the acquisition window or for non-periodic signals which tend to 0 whithin the time window (such as impact testing).\nHann window: This window is suitable for noisy signals. It is generally used with random signal due to its moderate impact on the frequency resolution and amplitude accuracy of porcessed signals.\nHamming window: This window is used in case of noisy measured signals as the Hann windows. However, contrary to the Hann window, the Hamming window doesn’t reach zero at its both ends.\nTukey window: This window is generally used to analyze transient data due to its shape, since it limits the alteration of the amplitude of transient signals.\nBlackman-Harris window: This window is suitable for periodic measurement signals.\nFlat-top window: This window is suitable for a calibration purposes (good reproduction of the amplitude height) and for measurements with sine excitation. However, it is not suitable for very noisy measurement signals.\nForce window: This window is an effective mechanism for reducing noise on the input channel when the input signal is impulsive.\nExponential window: This window is suitable for transient signals that decay to zero, such as acceleration signal in impact testing.",
    "crumbs": [
      "Signal processing",
      "Digital Signal Processing"
    ]
  },
  {
    "objectID": "signal_processing/index.html#anti-aliasing-filter",
    "href": "signal_processing/index.html#anti-aliasing-filter",
    "title": "Digital Signal Processing",
    "section": "2 Anti-aliasing filter",
    "text": "2 Anti-aliasing filter\nAnti-aliasing filtering is a technique used to prevent aliasing, which occurs when high-frequency components of a signal are misrepresented as lower-frequency components due to insufficient sampling. The anti_alias function in StructuralVibration.jl applies a high-order low-pass filter to the signal whose cut-off frequency is the Nyquist frequency. The proposed filter is designed using the Remez exchange algorithm implemented in DSP.jl.\n\n2.1 API\n\nanti_alias\n\n\n\nanti_alias(signal, fc; fs = 2fc)\nApply an anti-aliasing filter to a signal\nInputs\n\nsignal: Signal to be filtered\n\nfc: Cut-off frequency\n\nfs: Sampling rate\n\n\nOutput\n\nsignal: Filtered signal\n\n\n\n\n\n\n\n\n\n\n2.2 Example\n\n# Time parameters\nΔt = 1e-4\nt = 0.:Δt:10.\nfs = 1/Δt\n\n# Signal\nnt = length(t)\ny = randn(nt)\n\n# filtered signal\nyf = anti_alias(y, 2500., fs = fs)",
    "crumbs": [
      "Signal processing",
      "Digital Signal Processing"
    ]
  },
  {
    "objectID": "signal_processing/index.html#function-estimation",
    "href": "signal_processing/index.html#function-estimation",
    "title": "Digital Signal Processing",
    "section": "3 Function estimation",
    "text": "3 Function estimation\nSeveral functions can be estimated from the time domain data when operating in the frequency domain.\nThe StructuralVibration.jl package provides functions to estimate some of the most common functions used in structural dynamics applications. All the functions listed below are based on the Welch’s method and include the option to use a window function (+ its correction factor) to reduce spectral leakage and signal overlapping to reduce the variance of the estimated function or to compensate for the windowing effect.\n\n3.1 Acquisition parameters\nWhen acquiring data, the user has to define the sample rate \\(f_s\\) and the block size \\(b_s\\). The sample rate is the number of samples per second (in Hz), and the block size is the number of samples in each block. The block size is usually a power of 2, which allows for efficient computation of the FFT. From these two parameters, it is posiible to define the following parameters:\n\nSampling period: The sampling period (in s) is the time between two consecutive samples. It is defined as: \\[\n\\Delta t = \\frac{1}{f_s}.\n\\]\nAcquisition duration: The acquisition duration (in s) is the time taken to acquire a block of data. It is defined as: \\[\nT = b_s \\Delta t = \\frac{b_s}{f_s}.\n\\]\nFrequency resolution: The frequency resolution (in Hz) is the smallest frequency difference that can be resolved in the frequency domain. It is defined as: \\[\n\\Delta f = \\frac{f_s}{b_s}.\n\\]\nMaximum frequency: The maximum frequency (in Hz) is the highest frequency that can be resolved in the frequency domain and satisfying the Nyquist theorem. It is defined as: \\[\nf_{max} = \\frac{f_s}{2.56}.\n\\]\n\nAll these parameters are implemented in the FFTParameters struct, which is used in the functions to estimate the functions listed below.\n\nFFTParameters\n\n\n\nFFTParameters\nStructure to store the time and frequency parameters for the FFT analysis\nConstructor\n\nfs::Real: Sampling rate of the signal\n\nbs::Real: Block size of the signal\n\npow2::Bool: Flag for finding the next power of 2\n\n\nFields\n\nt::AbstractRange: Time vector\n\ndt::Float64: Time step\n\ntspan::Tuple{Float64, Float64}: Time span\n\nfreq::AbstractRange: Frequency vector\n\ndf::Float64: Frequency resolution\n\nfreq_span::Tuple{Float64, Float64}: Frequency span\n\nfs::Int: Sampling rate\n\nbs::Int: Block size\n\n\n\n\n\n\n\n\n\n\n3.2 Response spectrum\nThe response spectrum is basically the Fourier transform of the response of a system to a given input.\n\n3.2.1 API\n\nspectrum\n\n\n\nspectrum(input_signal, bs::Int, window = hanning(bs); fs::Int = 1, \n         overlap = 0.5)\nEstimation of the spectrum of a signal\nInputs\n\ninput_signal::Vector{Real}: Input signal\n\nbs::Int: Block size\n\nwindow: Window function\n\nfs::Int: Sampling rate\n\noverlap: Overlap ratio between the segments\n\n\nOutputs\n\ny: Signal spectrum\n\nfreq: Frequency range\n\n\nAvailable window functions\nFrom DSP.jl\n\nrect\n\nhann (default)\n\nhamming\n\ntukey\n\ncosine\n\nlanczos\n\ntriang\n\nbartlett\n\ngaussian\n\nbartlett_hann\n\nblackman\n\nkaiser\n\ndpss\n\n\nFrom StructuralVibration.jl\n\nexponential\n\nforce\n\nflattop\n\nnutall\n\nblackman_nutall\n\nblackman_harris\n\nparzen\n\nplanck\n\n\n\n\n\n\n\n\n\n\n3.2.2 Example\n\n# Structural parameters\nm = 1.\nf0 = 25.\nξ = 0.1\n\nsdof = Sdof(m, f0, ξ)\n\n# Acquisition parameters\nsample_rate = 256\nblock_size = 1024\nfft_params = FFTParameters(sample_rate, block_size)\nfreq = fft_params.freq\nt = fft_params.t\n\n# Excitation signal generation\nF0 = 10.\nchirp = SweptSine(F0, t[1], 0.8t[end], freq[1], freq[end], zero_end = true)\nx = excitation(chirp, t)\n\n# Reference signal\nprob = SdofForcedTimeProblem(sdof, x, [0., 0.], t)\ny = solve(prob).u\n\n# Frequency domain\nFx = Fx = rfft(x)[1:length(freq)]/block_size\nFx[2:end] .*= 2.\n\n# Response spectrum\nprob_y = SdofFrequencyProblem(sdof, Fx, freq)\nu = solve(prob_y).u\n\n# Spectrum stimation\nuest = spectrum(y, block_size, rect(block_size), fs = sample_rate)[1]\n\n\n\n\n\n\n\n\n\n\n\n\n\n3.3 Autopower functions\nAutopower functions are used to estimate the power of a signal in the frequency domain. StructuralVibration.jl allows to compute the following autopower functions:\n\nAutopower Spectrum\nAutopower Linear\nAutopower Power Spectral Density (PSD)\nAutopower Energy Spectral Density (ESD)\n\n\n\n\n\n\n\nNote\n\n\n\nFor a detailed discussion on the differences between these functions, please refer to this excellent blogpost The Autopower function… Demystified!.\n\n\n\n3.3.1 API\n\nwelch\n\n\n\nwelch(input_signal, bs::Int, window = hanning(bs); fs::Int = 1,\n      overlap = 0.5, scaling = :psd)\nEstimation of one-sided Autopower functions of a signal using the Welch method\nInputs\n\ninput_signal::Vector{Real}: Input signal\n\nbs::Int: Block size\n\nwindow: Window function\n\nfs::Int: Sampling rate\n\noverlap: Overlap ratio between the segments\n\nscaling: Scale of the PSD - see https://community.sw.siemens.com/s/article/the-autopower-function-demystified for more information\n\n:psd (default) - Power Spectral Density\n\n:esd - Autopower Energy Spectral Density\n\n:spectrum - Autopower spectrum\n\n:linear - Autopower linear\n\n\n\n\nOutputs\n\npxx: Autopower\n\nfreq: Frequency range\n\n\nAvailable window functions\nFrom DSP.jl\n\nrect\n\nhann (default)\n\nhamming\n\ntukey\n\ncosine\n\nlanczos\n\ntriang\n\nbartlett\n\ngaussian\n\nbartlett_hann\n\nblackman\n\nkaiser\n\ndpss\n\n\nFrom StructuralVibration.jl\n\nexponential\n\nforce\n\nflattop\n\nnutall\n\nblackman_nutall\n\nblackman_harris\n\nparzen\n\nplanck\n\n\nNote The welch function is already implemented in DSP.jl under the name welch_pgram. The function welch is implemented here for pedagogical purposes.\n\n\n\n\n\n\n\n\n3.3.2 Example\nThis example is based on the one provided in the DSP.jl documentation. It generates a signal composed of two sine waves at 100 Hz and 150 Hz with amplitudes equal to 1 and 2 respectively, and then estimates the power spectral density using the Welch method.\n\n# Acquisition parameters\nfs = 1000\nbs = 100\n\nfft_params = FFTParameters(fs, bs, pow2 = false)\nfreq = fft_params.freq\nt = (1:fs)/fs\n\n# Signal generation\nf = [100 150]                      # 100Hz & 150Hz frequencies\nA = [1; 2]                         # Amplitudes\nx = sin.(2π*f.*t)*A + randn(1000)\n\n# PSD estimation from DSP.jl\npsd = DSP.welch_pgram(x, bs; fs = fs, window = hamming)\npxx_ref = DSP.power(psd)\n\n# PSD estimation from StructuralVibration.jl\npxx = welch(x, bs, hamming(bs), fs = fs)[1]\n\n\n\n\n\n\n\n\n\n\n\n\n\n3.4 Frequency Response Function\nThe frequency response function (FRF) is the relation between an input \\(x\\) and the resulting output \\(y\\) of a linear and time-invariant system. Independent of the input, it is an intrinsic property of the system describing its dynamic behavior w.r.t. the frequency.\nIn practice, the FRF is computed from estimators. In StructuralVibration.jl, the following estimators are implemented:\n\nH1 estimator: It is the most common estimator used in structural dynamics. It assumes that the noise only affects the output signal. It is defined as: \\[\nH_1(\\omega) = \\frac{S_{yx}(\\omega)}{S_{xx}(\\omega)},\n\\] where \\(S_{yx}(\\omega)\\) is the cross-power spectral density between the input and output signals, and \\(S_{xx}(\\omega)\\) is the power spectral density of the input signal.\n\nGenerally, the H1 estimator estimates the anti-resonances better than the resonances4. Furthermore, as the number of averages increases, the H1 estimator converges to the true FRF.\n\nH2 estimator: It is used when the noise is assumed to affect the input signal only. It is defined as: \\[\nH_2(\\omega) = \\frac{S_{yy}(\\omega)}{S_{yx}(\\omega)},\n\\] where \\(S_{yy}(\\omega)\\) is the power spectral density of the output signal.\n\nContrary to the H1 estimator, the H2 estimator estimates the resonances better than the anti-resonances.\n\nH3 estimator: It is used when the noise is assumed to affect both the input and output signals. It is defined as the arithmetic mean of the H1 and H2 estimators: \\[\nH_3(\\omega) = \\frac{H_1(\\omega) + H_2(\\omega)}{2}.\n\\]\n\nThis estimator offers a good compromise between the H1 and H2 estimators, but it is not as commonly used as the H1 and H2 estimators.\n\nHv estimate: It is used when the noise is assumed to affect both the input and output signals. It is defined as the geometric mean of the H1 and H2 estimators: \\[\nH_v(\\omega) = \\sqrt{H_1(\\omega) H_2(\\omega)}.\n\\]\n\nIt generally provides the best overall estimate of the FRF, because the geometric mean is less sensitive to outliers than the arithmetic mean.\nThese estimators are generally completed by other information such as the coherence function, which an averaged function that how much the output is linearly related to the input. In this sense, it can be an indicator of the quality of the FRF estimate. It can also serve to check the repeatability of individual FRF estimates. It is expressed as: \\[\n\\gamma^2(\\omega) = \\frac{S_{yx}^2(\\omega)}{S_{xx}(\\omega) S_{yy}(\\omega)} = \\frac{H_1(\\omega)}{H_2(\\omega)},\n\\] where \\(S_{yx}(\\omega)\\) is the cross-power spectral density between the input and output signals, and \\(S_{xx}(\\omega)\\) and \\(S_{yy}(\\omega)\\) are the power spectral densities of the input and output signals respectively.\n\n\n\n\n\n\nNote\n\n\n\nIn absence of averaging, the coherence is equal to 1 over all the frequency range!\n\n\n\n3.4.1 API\n\ntfestimate\n\n\n\ntfestimate(input_signal, output_signal, bs::Int, window_input = hanning(bs),\n           window_output = window_input; fs::Int = 1, overlap = 0., type = :h1)\nEstimation of the one-sided transfer function between two signals\nInputs\n\ninput_signal::Vector{Real}: Input signal\n\noutput_signal::Vector{Real}: Output signal\n\nbs::Int Block size\n\nwindow_input: Window function for the input signal\n\nwindow_output: Window function for the output signal\n\nfs::Int: Sampling rate\n\noverlap::Real: Overlap ratio between the segments\n\ntype::Symbol: Type of transfer function to estimate\n\n:h1 (default)\n\n:h2\n\n:h3 - h3 = (h1 + h2)/2\n\n:hv - hv = sqrt(h1*h2)\n\n\n\n\nOutputs\n\nH: Transfer function\n\nfreq: Frequency range\n\ncoh: Coherence\n\n\nAvailable window functions\nFrom DSP.jl\n\nrect\n\nhann (default)\n\nhamming\n\ntukey\n\ncosine\n\nlanczos\n\ntriang\n\nbartlett\n\nbartlett_hann\n\ngaussian\n\nblackman\n\nkaiser\n\ndpss\n\n\nFrom StructuralVibration.jl\n\nexponential\n\nforce\n\nflattop\n\nnutall\n\nblackman_nutall\n\nblackman_harris\n\nparzen\n\nplanck\n\n\n\n\n\n\n\n\n\n\n3.4.2 Example\n\n# Structural parameters\nm = 1.\nf0 = 25.\nξ = 0.1\n\nsdof = Sdof(m, f0, ξ)\n\n# Acquisition parameters for one block\nsample_rate = 256\nblock_size = 1024\nfft_params = FFTParameters(sample_rate, block_size)\n\n# Reference FRF\nfreq = fft_params.freq\nprob_frf = SdofFRFProblem(sdof, freq)\nH = solve(prob_frf).u\n\n# Signal generation - Input signal\nnblocks = 5\ntb = fft_params.t\ndt = fft_params.dt\nt = tb[1]:dt:(nblocks*(tb[end] + dt) - dt)\n\nF0 = 10.\nchirp = SweptSine(F0, tb[1], 0.8tb[end], freq[1], freq[end], zero_end = true)\nx = repeat(excitation(chirp, tb), outer = nblocks)\n\n# Signal generation - Output signal\nprob = SdofForcedTimeProblem(sdof, x, [0., 0.], t)\ny = solve(prob).u\n\n# FRF estimation\nwin = tukey(block_size, 0.25)\nH1 = tfestimate(x, y, block_size, win, fs = sample_rate, overlap = 0.)[1]",
    "crumbs": [
      "Signal processing",
      "Digital Signal Processing"
    ]
  },
  {
    "objectID": "signal_processing/index.html#footnotes",
    "href": "signal_processing/index.html#footnotes",
    "title": "Digital Signal Processing",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nM+P International, “M+P Analyzer. User Manual Revision 5.1”. 2017.↩︎\nPolytec, “Polytec Scanning Vibrometer, Theory Manual”. 2019.↩︎\nP. Avitabile, “Modal Testing: A practioner’s guide”. John Wiley & Sons. 2018.↩︎\nSimcenter Testing Knowledge. “What is a Frequency Response Function (FRF)?”. 2020. link↩︎",
    "crumbs": [
      "Signal processing",
      "Digital Signal Processing"
    ]
  },
  {
    "objectID": "signal_processing/other.html",
    "href": "signal_processing/other.html",
    "title": "Other processing",
    "section": "",
    "text": "Other signal processing methods are available in StructuralVibration.jl.",
    "crumbs": [
      "Signal processing",
      "Other processing"
    ]
  },
  {
    "objectID": "signal_processing/other.html#detrending",
    "href": "signal_processing/other.html#detrending",
    "title": "Other processing",
    "section": "1 Detrending",
    "text": "1 Detrending\nDetrending is the process of removing trends from a signal. This is useful when you want to analyze the fluctuations around a trend. The detrend function can be used to remove linear or polynomial trends from a signal.\n\n1.1 API\n\ndetrend\n\n\n\ndetrend(t, y, order = 1, bp = [])\nDetrend a signal y with respect to time t using a polynomial of order order.\nInputs\n\nt: Time vector\n\ny: Signal to be detrended\n\norder: Order of the polynomial (default is 1)\n\nbp: Breakpoints for the polynomial (default is empty)\n\n\nOutput\n\ny_detrended: Detrended signal\n\n\nNotes\norder can be a vector if the trend is different over the segments defined by the breakpoints bp.\nThe breakpoints bp are the points where the polynomial order changes. If bp is empty, a single polynomial is fitted to the entire signal.\n\n\n\n\n\n\n\n\n1.2 Example\n\n# Signal 1\nx1 = -0.5:0.01:0.5\ny1 = @. sin(π*x1) + 0.25\ny1_const = detrend(x1, y1, 0)\ny1_lin = detrend(x1, y1, 1)\n\n# Signal 2\nx2 = 0:0.1:20\ny2 = @. 3sin(x2) + x2\ny2_const = detrend(x2, y2, 0)\ny2_lin = detrend(x2, y2, 1)",
    "crumbs": [
      "Signal processing",
      "Other processing"
    ]
  },
  {
    "objectID": "signal_processing/other.html#gradient",
    "href": "signal_processing/other.html#gradient",
    "title": "Other processing",
    "section": "2 Gradient",
    "text": "2 Gradient\nThe gradient of a signal is the rate of change of the signal with respect to time. Julia [] has a lot of packages for computing the gradient of a signal. The gradient function in StructuralVibration.jl is a simple helper function built around the gradient function in Interpolations.jl.\n\n2.1 API\n\ngradient\n\n\n\ngradient(f::Vector{Real}, t; method = :cubic)\ngradient(f::Matrix{Real}, t; method = :cubic, dims = 1)\nCompute the gradient of a function f at points t.\nInputs\n\nf: Function values\n\nt: Points at which to evaluate the gradient\n\nmethod: Interpolation method\n\n:linear: Linear interpolation\n\n:cubic: Cubic spline interpolation (default)\n\n\n\ndims: Dimension along which to compute the gradient\n\n1: Rows (default)\n\n2: Columns\n\n\n\n\nOutput\n\ndf: Gradient of the vector f at points t\n\n\nNote\nIf method is :cubic, t must be an AbstractRange.\n\n\n\n\n\n\n\n\n2.2 Example\n\n# Signal\nx = LinRange(0., 3π, 100)\ny = sin.(x)\n\n# True gradient\ndy = cos.(x)\n\n# Estimated gradient\ndy_approx = gradient(y, x)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nBeing based on interpolation, gradient is not robust against noise. For robust gradient estimation, you can compute the gradient of the signal denoised by the denoising function by using one of the numerous Julia differentiation packages if the signal is smooth enough (at least class \\(C^\\2\\)). If the latter condition is not satisfied, you can for instance use NoiseRobustDifferentiation.jl, which implements the Total variation regularized numerical differentiation method1 .",
    "crumbs": [
      "Signal processing",
      "Other processing"
    ]
  },
  {
    "objectID": "signal_processing/other.html#footnotes",
    "href": "signal_processing/other.html#footnotes",
    "title": "Other processing",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nR. Chartrand. “Numerical differentiation of noisy, nonsmooth data”. ISRN Applied Mathematics, vol. 2011, 164564, 2011.↩︎",
    "crumbs": [
      "Signal processing",
      "Other processing"
    ]
  },
  {
    "objectID": "solvers/frequency_solvers.html",
    "href": "solvers/frequency_solvers.html",
    "title": "Frequency-domain solvers",
    "section": "",
    "text": "From a general perspective, the frequency-domain solvers are used to analyze the dynamic response of structures subjected to harmonic loads. In the frequency domain, Mdof systems are described at a given angular frequency \\(\\omega\\) by the following equation: \\[\n\\left(\\mathbf{K} + j\\omega\\mathbf{C} - \\omega^2\\mathbf{M}\\right) \\mathbf{x}(\\omega) = \\mathbf{F}(\\omega).\n\\]",
    "crumbs": [
      "Solvers",
      "Frequency-domain solvers"
    ]
  },
  {
    "objectID": "solvers/frequency_solvers.html#frequency-response-function",
    "href": "solvers/frequency_solvers.html#frequency-response-function",
    "title": "Frequency-domain solvers",
    "section": "1 Frequency response function",
    "text": "1 Frequency response function\nThe Frequency response function (FRF) is computed by assuming a unit harmonic load at the \\(i\\)-th degree of freedom (DOF) and zero loads at all other DOFs, meaning that \\(\\mathbf{F}(\\omega) = \\mathbf{I}\\).\nConsequently, broadly speaking, the FRF is defined by: \\[\n\\mathbf{H}(\\omega) = \\left(\\mathbf{K} + j\\omega\\mathbf{C} - \\omega^2\\mathbf{M}\\right)^{-1}.\n\\] This method is known as the direct method.\nAlternatively, the FRF can be computed using the modal method, which is based on the eigenvalue decomposition of the system matrices. The modal method is more efficient for large systems, as it reduces the problem to a smaller number of modes. In this case and assuming a modal damping ratio, the FRF is computed as: \\[\n\\mathbf{H}(\\omega) = \\mathbf{\\Phi}\\left(\\mathbf{\\Omega}^2 - \\omega^2\\mathbf{I} + 2j\\omega\\mathbf{\\Xi}\\right)^{-1}\\mathbf{\\Phi}^T,\n\\] where \\(\\mathbf{\\Phi}\\) is the mass-normalized mode shapes matrix and \\(\\mathbf{\\Omega}^2 = \\text{diag}(\\omega_1^2, \\dots, \\omega_n^2)\\) and \\(\\mathbf{\\Xi} = \\text{diag}(\\xi_1\\omega_1, \\dots, \\xi_n\\omega_n)\\).\n\n\n\n\n\n\nNote\n\n\n\nAs explained in State-Space solvers - Section 2.1, the FRF can be computed for a given set of response dofs and a given set of excitation dofs by introducing the appropriate selection matrices \\(\\mathbf{S}_o\\) and \\(\\mathbf{S}_e\\). In this case, the FRF is given by: \\[\n\\mathbf{H}_{oe}(\\omega) = \\mathbf{S}_o\\mathbf{H}(\\omega)\\mathbf{S}_e.\n\\]\n\n\n\n1.1 API\nData types\n\nDirectFRFProblem\n\n\n\nDirectFRFProblem(K, M, C, freq, So, Se)\nStructure containing the data feeding the direct solver for calculating an FRF\nFields\n\nK::AbstractMatrix: Stiffness matrix\n\nM::AbstractMatrix: Mass matrix\n\nC::AbstractMatrix: Damping matrix\n\nfreq::AbtractRange: Frequencies of interest\n\nSo::AbstractMatrix: Selection matrix for observation points\n\nSe::AbstractMatrix: Selection matrix for excitation points\n\n\n\n\n\n\n\n\n\nModalFRFProblem\n\n\n\nModalFRFProblem(ωn, ξn, freq, ϕo, ϕe)\nStructure containing the data feeding the modal solver for calculating an FRF\nFields\n\nωn::Vector{Real}: Natural angular frequencies\n\nξn::Vector{Real}: Modal damping ratios\n\nfreq::AbstractRange: Frequencies of interest\n\nϕe::AbstractMatrix: Mode shapes at excitation points\n\nϕo::AbstractMatrix: Mode shapes at observation points\n\n\nNote The mode shapes must be mass-normalized\n\n\n\n\n\n\nRelated function\n\nsolve\n\n\n\nsolve(prob::DirectFRF; type = :dis, ismat = false, progress = true)\nsolve(prob::ModalFRFProblem; type = :dis, ismat = false, progress = true)\nComputes the FRF matrix by direct or modal approach\nInputs\n\nprob: Structure containing the problem data\n\ntype: Type of FRF to compute\n\n:dis: Admittance (default)\n\n:vel: Mobility\n\n:acc: Accelerance\n\n\n\nismat: Return the FRF matrix as a 3D array (default = false)\n\nprogress: Show progress bar (default = true)\n\n\nOutput\n\nsol: Solution of the problem\n\nu: FRF matrix\n\n\n\n\n\n\n\n\n\n\n\n\n1.2 Example\n\n# Structural parameters\nM = Diagonal([2., 1.])\nK = [6. -2.; -2. 4.]\nξ = 0.05\n\nω, Φ = eigenmode(K, M)\nC = modal_damping_matrix(M, ω, ξ, Φ)\n\n# Frequency vector\nfreq = 0.01:0.001:1.\n\nprob_frf = DirectFRFProblem(K, M, C, freq)\nH_direct = solve(prob_frf, ismat = true).u\n\n# Problem definition - Case 2 - Modal\nprob_frf_modal = ModalFRFProblem(ω, ξ, freq, Φ, Φ)\nH_modal = solve(prob_frf_modal, ismat = true).u",
    "crumbs": [
      "Solvers",
      "Frequency-domain solvers"
    ]
  },
  {
    "objectID": "solvers/frequency_solvers.html#response-spectrum",
    "href": "solvers/frequency_solvers.html#response-spectrum",
    "title": "Frequency-domain solvers",
    "section": "2 Response spectrum",
    "text": "2 Response spectrum\nSimilarly to the FRF, the response spectrum is a complex function that describes the steady-state response of a system to a sinusoidal input. At a given angular frequency \\(\\omega\\), it is expressed as : \\[\n\\mathbf{x}(\\omega) = \\left(\\mathbf{K} + j\\omega\\mathbf{C} - \\omega^2\\mathbf{M}\\right)^{-1} \\mathbf{F}(\\omega).\n\\] or equivalently from the modes of the system: \\[\n\\mathbf{x}(\\omega) = \\mathbf{\\Phi}\\left(\\mathbf{\\Omega}^2 - \\omega^2\\mathbf{I} + 2j\\omega\\mathbf{\\Omega}\\right)^{-1}\\mathbf{L},\n\\] where \\(\\mathbf{L} = \\mathbf{\\Phi}^\\mathsf{T}\\mathbf{F}(\\omega)\\) is the modal participation factor matrix1.\n\n2.1 API\nData types\n\nDirectFreqProblem\n\n\n\nDirectFreqProblem(K, M, C, F, freq, So)\nStructure containing the data feeding the direct solver for calculating the modal frequencies\nFields\n\nK::AbstractMatrix: Stiffness matrix\n\nM::AbstractMatrix: Mass matrix\n\nC::AbstractMatrix: Damping matrix\n\nF::AbstractMatrix: Force matrix\n\nfreq::AbstractRange: Frequencies of interest\n\nSo::AbstractMatrix: Selection matrix for observation points\n\n\n\n\n\n\n\n\n\nModalFreqProblem\n\n\n\nModalFreqProblem(ωn, ξn, Fn, freq, ϕo)\nStructure containing the data feeding the modal solver for calculating the frequency response by modal approach\nFields\n\nωn::Vector{Real}: Natural angular frequencies\n\nξn::Vector{Real}: Modal damping ratios\n\nLn::AbstractMatrix: Modal participation factors\n\nfreq::AbstractRange: Frequencies of interest\n\nϕo::Matrix{Real}: Mode shapes at observation points\n\n\n\n\n\n\n\n\nRelated function\n\nsolve\n\n\n\nsolve(prob::DirectFreqProblem, type = :dis, progress = true)\nsolve(prob::ModalFreqProblem, type = :dis, progress = true)\nComputes the frequency response by direct or modal approach\nInputs\n\nprob: Structure containing the problem data\n\ntype: Type of response to compute\n\n:dis: Displacement (default)\n\n:vel: Velocity\n\n:acc: Acceleration\n\n\n\nprogress: Show progress bar (default = true)\n\n\nOutput\n\nsol: Solution of the problem\n\nu: Response spectrum matrix\n\n\n\n\n\n\n\n\n\n\n\n\n2.2 Example\n\n# Structural parameters\nM = Diagonal([2., 1.])\nK = [6. -2.; -2. 4.]\nξ = 0.05\n\nω, Φ = eigenmode(K, M)\nC = modal_damping_matrix(M, ω, ξ, Φ)\n\n# Frequency vector\nfreq = 0.01:0.001:1.\n\n# Force matrix\nF = zeros(2, length(freq))\nF[1, :] .= 10.\n\n# Problem definition - Case 1 - Direct\nprob_freq = DirectFreqProblem(K, M, C, F, freq)\ny_freq = solve(prob_freq).u\n\n# Problem definition - Case 2 - Modal\nprob_freq_modal = ModalFreqProblem(ω, ξ, Φ'*F, freq, Φ)\ny_freq_modal = solve(prob_freq_modal).u",
    "crumbs": [
      "Solvers",
      "Frequency-domain solvers"
    ]
  },
  {
    "objectID": "solvers/frequency_solvers.html#footnotes",
    "href": "solvers/frequency_solvers.html#footnotes",
    "title": "Frequency-domain solvers",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nThe expression of the modal participation factor matrix is the same as the modal force matrix, because the mode shapes are assumed to be mass-normalized.↩︎",
    "crumbs": [
      "Solvers",
      "Frequency-domain solvers"
    ]
  },
  {
    "objectID": "solvers/modal_time_solvers.html",
    "href": "solvers/modal_time_solvers.html",
    "title": "Modal time solvers",
    "section": "",
    "text": "The aim of this section is to describe the modal time solvers available for solving Multi-degrees of freedom (Mdof) systems. To explain, the theoretical foundations of the proposed solvers, let’s consider a Mdof system with \\(N\\) degrees of freedom. The equation of motion of the system is given by: \\[\n\\mathbf{M} \\ddot{\\mathbf{x}}(t) + \\mathbf{C} \\dot{\\mathbf{x}}(t) + \\mathbf{K} \\mathbf{x}(t) = \\mathbf{F}(t)\n\\] where \\(\\mathbf{M}\\) is the mass matrix, \\(\\mathbf{C}\\) is the damping matrix, \\(\\mathbf{K}\\) is the stiffness matrix, \\(\\mathbf{x}(t)\\) is the displacement vector, and \\(\\mathbf{F}(t)\\) is the vector of external forces.\nTo solve the previous in the modal space, the solution \\(\\mathbf{x}(t)\\) is expressed as: \\[\n\\mathbf{x}(t) = \\mathbf{\\Phi} \\mathbf{q}(t)\n\\] where \\(\\mathbf{\\Phi}\\) is the matrix of the mode shapes and \\(\\mathbf{q}(t)\\) is the vector of modal coordinates.\nSubstituting the previous expression in the equation of motion, premultiplying by \\(\\mathbf{\\Phi}^\\mathsf{T}\\), and using the orthogonality property of the mode shapes, one obtains a set of \\(N\\) independent modal equations of motion given by: \\[\n\\ddot{q}_n(t) + 2 \\xi_n \\omega_n \\dot{q}_n(t) + \\omega_n^2 q_n(t) = \\frac{f_n(t)}{m_n}\n\\] where for the n-th mode, \\(q_n(t)\\) is the generalized coordinate, \\(\\xi_n\\) is the damping ratio, \\(\\omega_n\\) is the natural angular frequency, \\(f_n(t)\\) is the modal force, and \\(m_n\\) is the modal mass.\nIt should be noticed that a modal equation of motion corresponds to the equation of motion of a Sdof system with mass \\(m_n\\), damping ratio \\(\\xi_n\\), natural angular frequency \\(\\omega_n\\).\nIt results that computing the response of an Mdof system in the modal space is equivalent to solving \\(N\\) independent Sdof systems.",
    "crumbs": [
      "Solvers",
      "Modal time solvers"
    ]
  },
  {
    "objectID": "solvers/modal_time_solvers.html#free-response",
    "href": "solvers/modal_time_solvers.html#free-response",
    "title": "Modal time solvers",
    "section": "1 Free response",
    "text": "1 Free response\nThe free response of an MDOF system is the response of the system when there are no external forces acting on it. In this case, the modal equations of motion of the system is given by: \\[\n\\ddot{q}_n(t) + 2 \\xi_n \\omega_n \\dot{q}_n(t) + \\omega_n^2 q_n(t) = 0\n\\]\nThe solution of the previous equation can be found in Sdof solvers - Section 1.1.\n\n1.1 API\nData type\n\nFreeModalTimeProblem\n\n\n\nFreeModalTimeProblem(K, M, ξn, n = size(K, 1); ismodal = false)\nStructure containing data for the modal time solver\nFields\n\nK::VecOrMat{Real}:\n\nIf ismodal = false then Matrix{Real}: Stiffness matrix\n\nIf ismodal = true then Vector{Real}: Natural angular frequencies\n\n\n\nM::AbtractMatrix:\n\nIf ismodal = false: Mass matrix\n\nIf ismodal = true: Mass-normalized mode shapes\n\n\n\nξn: Damping ratios\n\nu0::Tuple: Initial conditions\n\nu0[1]: Initial displacement (or modal displacement)\n\nu0[2]: Initial velocity (or modal velocity)\n\n\n\nt::AbstractRange: Time points at which to evaluate the response\n\nF::Matrix{Real}: External force matrix (or modal force matrix)\n\nn::Int: Number of modes to retain in the modal basis\n\nismodal::Bool: Flag to indicate if the problem contains modal data\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nTwo possibilities are offered to the user to enter the structural properties of the system.\n\nProvide the stiffness and mass matrices.\nProvide the squared natural frequencies and (mass-normalized) mode shapes. This allows to use the modal information computed analytically for continuous systems or numerically for discrete systems.\n\nIn the latter case, the initial conditions must be expressed in the modal space.\n\n\n\nRelated function\n\nsolve\n\n\n\nsolve(prob::FreeModalTimeProblem)\nCompute the free response of a multi-degrees of freedom (Mdof) system using the modal approach.\nInputs\n\nprob: Structure containing the parameters of the Mdof problem\n\n\nOutput\n\nsol: ModalTimeSolution structure containing the response of the system at the given time points\n\n\n\n\n\n\n\n\n\n\n1.2 Example\n\n# System parameters\nM = Diagonal([2., 1.])\nK = [6. -2.; -2. 4.]\nξ = 0.05\n\n# Time vector\nt = 0.:1e-2:30.\n\n# Initial conditions\nx0 = [0.2, 0.1]\nv0 = zeros(2)\n\n# Problem definition - case 1 - Provide the stiffness and mass matrices\nu0 = (x0, v0)\nprob = FreeModalTimeProblem(K, M, ξ, u0, t)\n\n# Problem definition - case 2 - Provide the squared natural frequencies and mode shapes\nωm, Φm = eigenmode(K, M)\nx0m = Φm'*M*x0\nv0m = Φm'*M*v0\nu0m = (x0m, v0m)\nprob_modal = FreeModalTimeProblem(ωm, Φm, ξ, u0m, t, ismodal = true)\n\n# Solution\nx_free = solve(prob).u\nx_free_modal = solve(prob_modal).u",
    "crumbs": [
      "Solvers",
      "Modal time solvers"
    ]
  },
  {
    "objectID": "solvers/modal_time_solvers.html#forced-response",
    "href": "solvers/modal_time_solvers.html#forced-response",
    "title": "Modal time solvers",
    "section": "2 Forced response",
    "text": "2 Forced response\nThe forced response of an Mdof system is the response of the system when external forces are acting on it. In this case, the modal equations of motion of the system is given by: \\[\n\\ddot{q}_n(t) + 2 \\xi_n \\omega_n \\dot{q}_n(t) + \\omega_n^2 q_n(t) = \\frac{f_n(t)}{m_n}\n\\]\nThe solution of the previous equation can be found in Sdof solvers - Section 1.2.\n\n2.1 Harmonic excitation\n\n2.1.1 API\nData type\n\nHarmonicModalTimeProblem\n\n\n\nHarmonicModalTimeProblem(K, M, ξn, u0, t, F, ω = 0., n = size(K, 1); ismodal = false)\nStructure containing data for the modal time solver for computing the forced response due to an harmonic excitation\nConstructor\n\nK::VecOrMat{Real}:\n\nIf ismodal = false then Matrix{Real}: Stiffness matrix\n\nIf ismodal = true then Vector{Real}: Natural angular frequencies\n\n\n\nM::AbtractMatrix:\n\nIf ismodal = false: Mass matrix\n\nIf ismodal = true: Mass-normalized mode shapes\n\n\n\nξn: Damping ratios\n\nu0::Tuple: Initial conditions\n\nu0[1]: Initial displacement (or modal displacement)\n\nu0[2]: Initial velocity (or modal velocity)\n\n\n\nt::AbstractRange: Time points at which to evaluate the response\n\nF::Real: External force matrix (or modal participation factors)\n\nfreq::Real: Excitation frequency\n\nn::Int: Number of modes to retain in the modal basis\n\nismodal::Bool: Flag to indicate if the problem contains modal data\n\n\nFields\n\nK: Stiffness matrix (or modal stiffness matrix)\n\nM: Mass matrix (or mass-normalized mode shapes)\n\nξn: Damping ratios\n\nu0: Initial conditions\n\nu0[1]: Initial displacement (or modal displacement)\n\nu0[2]: Initial velocity (or modal velocity)\n\n\n\nt: Time points at which to evaluate the response\n\nF: Amplitude vector (or modal participation vector)\n\nω: Excitation angular frequency\n\nn: Number of modes to retain in the modal basis\n\nismodal: Flag to indicate if the problem contains modal data\n\n\n\n\n\n\n\n\nRelated function\n\nsolve\n\n\n\nsolve(prob::HarmonicModalTimeProblem)\nCompute the forced response of a multi-degrees of freedom (Mdof) system due to an harmonic excitation using the modal approach.\nInputs\n\nprob: Structure containing the parameters of the Mdof problem\n\n\nOutput\n\nsol: Solution structure containing the response of the system at the given time points\n\nu: Displacement\n\ndu: Velocity\n\nddu: Acceleration\n\n\n\n\n\n\n\n\n\n\n\n\n2.1.2 Example\n\n# System parameters\nM = Diagonal([2., 1.])\nK = [6. -2.; -2. 4.]\nξ = 0.05\n\n# Time vector\nt = 0.:1e-2:30.\n\n# Initial conditions\nx0 = [0., 1e-4]\nv0 = zeros(2)\nu0 = (x0, v0)\n\n# Excitation parameters\nF = [1., 2.]\nfreq = 0.5\n\n# Problem definition - case 1 - Provide the stiffness and mass matrices\nprob_harmo = HarmonicModalTimeProblem(K, M, ξ, F, 2π*freq, u0, t)\n\n# Problem definition - case 2 - Provide the squared natural frequencies and mode shapes\nωm, Φm = eigenmode(K, M)\nx0m = Φm'*M*x0\nv0m = Φm'*M*v0\nu0m = (x0m, v0m)\nLm = Φm'*F\nprob_harmo_modal = HarmonicModalTimeProblem(ωm, Φm, ξ, Lm, 2π*freq, u0m, t, ismodal = true)\n\n# Solution\nx_harmo = solve(prob_harmo).u\nx_harmo_modal = solve(prob_harmo_modal).u\n\n\n\n\n\n\n\n\n\n\n\n\n\n2.2 Arbitrary excitation\n\n2.2.1 API\nData type\n\nForcedModalTimeProblem\n\n\n\nForcedModalTimeProblem(K, M, ξn, u0, t, F, n = size(K, 1); ismodal = false)\nStructure containing data for modal time solver for computing the forced response due to an arbitrary excitation\nFields\n\nK::VecOrMat{Real}:\n\nIf ismodal = false then Matrix{Real}: Stiffness matrix\n\nIf ismodal = true then Vector{Real}: Natural angular frequencies\n\n\n\nM::AbtractMatrix:\n\nIf ismodal = false: Mass matrix\n\nIf ismodal = true: Mass-normalized mode shapes\n\n\n\nξn: Damping ratios\n\nF::Matrix{Real}: External force matrix (or modal participation factors)\n\nu0::Tuple: Initial conditions\n\nu0[1]: Initial displacement (or modal displacement)\n\nu0[2]: Initial velocity (or modal velocity)\n\n\n\nt::AbstractRange: Time points at which to evaluate the response\n\nn::Int: Number of modes to retain in the modal basis\n\nismodal::Bool: Flag to indicate if the problem contains modal data\n\n\n\n\n\n\n\n\nRelated function\n\nsolve\n\n\n\nsolve(prob::ForcedModalTimeProblem)\nCompute the forced response of a multi-degrees of freedom (Mdof) system due to an arbitrary excitation using the modal approach.\nInputs\n\nprob: Structure containing the parameters of the Mdof problem\n\nmethod: Method to compute the Duhamel's integral\n\n:filt: Filtering using the Z-transform of the impulse response (default)\n\n:interp: Interpolation + Gaussian quadrature\n\n:conv: Convolution\n\n\n\n\nOutput\n\nsol: ModalTimeSolution structure containing the response of the system at the given time points\n\n\n\n\n\n\n\n\n\n\n2.2.2 Example\n\n# System parameters\nM = Diagonal([2., 1.])\nK = [6. -2.; -2. 4.]\nξ = 0.05\n\n# Time vector\nt = 0.:1e-2:30.\n\n# Initial conditions\nu0 = (zeros(2), zeros(2))\n\n# Excitation parameters\nF0 = 10.\ntstart = 2.\nduration = 5.\nhaversine = HaverSine(F0, tstart, duration)\nF0 = excitation(haversine, t)\nF = zeros(2, length(t))\nF[1, :] .= F0\n\n# Problem definition - case 1 - Provide the stiffness and mass matrices\nprob_forced = ForcedModalTimeProblem(K, M, ξ, F, u0, t)\n\n# Problem definition - case 2 - Provide the squared natural frequencies and mode shapes\nωm, Φm = eigenmode(K, M)\nu0m = (zeros(2), zeros(2))\nLm = Φm'*F\nprob_forced_modal = ForcedModalTimeProblem(ωm, Φm, ξ, Lm, u0m, t, ismodal = true)\n\n# Solution\nx_forced = solve(prob_forced).u\nx_forced_modal = solve(prob_forced_modal).u",
    "crumbs": [
      "Solvers",
      "Modal time solvers"
    ]
  },
  {
    "objectID": "solvers/modal_time_solvers.html#additional-function---impulse-response-matrix",
    "href": "solvers/modal_time_solvers.html#additional-function---impulse-response-matrix",
    "title": "Modal time solvers",
    "section": "3 Additional function - Impulse response matrix",
    "text": "3 Additional function - Impulse response matrix\nThe impulse response matrix of an Mdof system is obtained from the modal impulse response matrix. The modal impulse response matrix is given by: \\[\n\\mathbf{h}(t) = \\Phi \\begin{bmatrix}\nh_1(t) & & & & \\\\\n& \\ddots & & & \\\\\n& & h_n(t) & & \\\\\n& & & \\ddots & \\\\\n& & & & h_N(t)\n\\end{bmatrix}\n\\Phi^\\mathsf{T},\n\\] where \\(h_n(t)\\) is the modal impulse response of the mode \\(n\\) computed as in Sdof solvers - Section 1.3.\n\nimpulse_response\n\n\n\nimpulse_response(K::Matrix{Float64}, M::Matrix{Float64}, ξn, t, n = size(K, 1); ismat = false)\nCompute the impulse response of a multi-degrees of freedom (Mdof) system using the modal approach\nInputs\n\nK:\n\nIf ismodal = false: Stiffness matrix\n\nIf ismodal = true: Squared natural angular frequencies\n\n\n\nM:\n\nIf ismodal = false: Mass matrix\n\nIf ismodal = true: Mass-normalized mode shapes\n\n\n\nξn: Damping ratios\n\nt: Time points at which to evaluate the response\n\nn: Number of modes to retain in the modal basis\n\nismodal::Bool: Flag to indicate if the problem contains modal data\n\nismat::Bool: Flag to indicate if the output should be a matrix\n\n\nOutput\n\nsol: ModalImpulseSolution\n\n\n\n\n\n\n\n\n\n# System parameters\nM = Diagonal([2., 1.])\nK = [6. -2.; -2. 4.]\nξ = 0.05\n\n# Time vector\nt = 0.:1e-2:30.\n\n# Impulse response matrix\nh = impulse_response(K, M, ξ, t, ismat = true);",
    "crumbs": [
      "Solvers",
      "Modal time solvers"
    ]
  },
  {
    "objectID": "visualization/index.html",
    "href": "visualization/index.html",
    "title": "Visualization extensions",
    "section": "",
    "text": "StructuralVibration.jl is accompanied by two extensions CairoMakieExt.jl and GLMakieExt.jl providing visualization capabilities. The extensions provide a set of functions to visualize the results of the structural dynamics analysis.\nTo use one of these extensions, you need to import the desired plotting package by running the following command:",
    "crumbs": [
      "Visualization",
      "Visualization extensions"
    ]
  },
  {
    "objectID": "visualization/index.html#bode-plot",
    "href": "visualization/index.html#bode-plot",
    "title": "Visualization extensions",
    "section": "1 Bode plot",
    "text": "1 Bode plot\nA Bode plot is a graph of the magnitude and phase of a transfer function versus frequency.\n\nbode_plot\n\n\n\nbode_plot(freq, y...; lw = 1., xlab = \"Frequency (Hz)\",\n          ylab = \"Magnitude (dB)\", xscale = identity,\n          axis_tight = true, isdeg = false, layout = :vertical,\n          ref_dB = 1., legend = (active = false, position = :rt, entry = \" \"),\n          fonts = DEFAULT_MAKIE_FONTS)\nPlot Bode diagram of a frequency response or a FRF.\nInputs\n\nfreq: Frequency range of interest\n\ny: Frequency response or FRF\n\nlw: Line width\n\ntheme: Theme (default: :makie)\n\nxlab: x-axis label\n\nxscale: x-axis scale (default: :log)\n\naxis_tight: Tight axis (default: false)\n\nisdeg: Phase in degrees (default: false)\n\nlayout: Layout of the plot (default: :vertical)\n\nref_dB: Reference value for magnitude (default: 1.)\n\nlegend: Legend parameters (default: (active = false, position = :rt, entry = \" \"))\n\nfonts: Fonts of the figure (default: DEFAULT_MAKIE_FONTS)\n\n\nOutput\n\nfig: Figure\n\n\n\n\n\n\n\n\n\n# Initialize a Sdof type\nm = 1.\nf₀ = 10.\nξ = 0.01\nsdof = Sdof(m, f₀, ξ)\n\n# Computation parameters\nfreq = 1.:0.01:30.\n\n# Compute the FRF\nprob_frf = SdofFRFProblem(sdof, freq)\nH = solve(prob_frf).u\n\n# Bode plot\nbode_plot(freq, H)",
    "crumbs": [
      "Visualization",
      "Visualization extensions"
    ]
  },
  {
    "objectID": "visualization/index.html#nyquist-plot",
    "href": "visualization/index.html#nyquist-plot",
    "title": "Visualization extensions",
    "section": "2 Nyquist plot",
    "text": "2 Nyquist plot\nThe Nyquist plot is either a 2D or 3D plot. In 2D, it is a graph of the imaginary part versus the real part of the transfer function. In 3D, it is a graph of the imaginary part versus the real part of the transfer function and the frequency.\n\n2.1 2D plot\n\nnyquist_plot\n\n\n\nnyquist_plot(y; theme = :makie fonts = DEFAULT_MAKIE_FONTS)\nPlot Nyquist diagram\nInputs\n\ny: Complex data vector\n\ntheme: Theme (default: :makie)\n\nfonts: Fonts of the figure (default: DEFAULT_MAKIE_FONTS)\n\n\nOutput\n\nfig: Figure\n\n\n\n\n\n\n\n\n\nnyquist_plot(H)\n\n\n\n\n\n\n\n\n\n\n2.2 3D plot\n\nnyquist_plot\n\n\n\nnyquist_plot(freq, y, xlab = \"Frequency (Hz)\"; theme = :makie,\n             projection = false, fonts = DEFAULT_MAKIE_FONTS)\nPlot Nyquist diagram in 3D\nInputs\n\nfreq: Frequency range\n\ny: Complex vector\n\nylabel: y-axis label\n\ntheme: Theme (default: :makie)\n\nprojection: Projection of the curve on the xy, yz, and xz planes (default: false)\n\non the xy plane: (freq, real(y))\n\non the yz plane: (imag(y), freq)\n\non the xz plane: (real(y), imag(y))\n\n\n\nfonts: Fonts of the figure (default: DEFAULT_MAKIE_FONTS)\n\n\nOutput\n\nfig: Figure\n\n\n\n\n\n\n\n\n\nnyquist_plot(freq, H, projection = true)",
    "crumbs": [
      "Visualization",
      "Visualization extensions"
    ]
  },
  {
    "objectID": "visualization/index.html#waterfall-plot",
    "href": "visualization/index.html#waterfall-plot",
    "title": "Visualization extensions",
    "section": "3 Waterfall plot",
    "text": "3 Waterfall plot\nA waterfall plot is a 3D plot with a partial curtain along the y-axis.\n\nwaterfall_plot\n\n\n\nwaterfall_plot(x, y, z; zmin = minimum(z), lw = 1.,\n               colorline = :auto, colmap = :viridis, colorband = (:white, 1.),\n               xlabel = \"x\", ylabel = \"y\", zlabel = \"z\", edge = true,\n               axis_tight = false, xlim = [minimum(x), maximum(x)],\n               ylim = [minimum(y), maximum(y)], zlim = [zmin, maximum(z)],\n               fonts = DEFAULT_MAKIE_FONTS)\nPlot a waterfall plot.\nInputs\n\nx: x-axis values\n\ny: y-axis values\n\nz: z-axis values\n\nzmin: minimum value of z-axis\n\nlw::Real: linewidth\n\ncolorline: color of the lines\n\ncolmap: Name of the colormap\n\ncolorband: Tuple defining the color of the band\n\ncolor : Color\n\nalpha : Alpha value for transparency\n\n\n\nxlabel: x-axis label\n\nylabel: y-axis label\n\nzlabel: z-axis label\n\nedge: Display edges (default: true)\n\naxis_tight: Tight axis (default: false)\n\nxlim: x-axis limits\n\nylim: y-axis limits\n\nzlim: z-axis limits\n\nfonts: Fonts of the figure (default: DEFAULT_MAKIE_FONTS)\n\n\nOutput\n\nfig: Figure\n\n\n\n\n\n\n\n\nx = range(0., 2π, 100)\ny = range(0., 1., 5)\n\nnx = length(x)\nny = length(y)\nz = zeros(ny, nx)\n\nfor i in eachindex(y)\n    z[i, :] = sin.(i*x/2.)\nend\n\nwaterfall_plot(x, y, z, xlim = [-0.1, 2π + 0.1], ylim = [-0.1, 1.1])",
    "crumbs": [
      "Visualization",
      "Visualization extensions"
    ]
  },
  {
    "objectID": "visualization/index.html#sv-plot",
    "href": "visualization/index.html#sv-plot",
    "title": "Visualization extensions",
    "section": "4 SV plot",
    "text": "4 SV plot\nThe SV plot (for StructuralVibration plot) is a general function for 2D plotting. It is a helper function aiming at simplifying the plotting process.\n\nsv_plot\n\n\n\nsv_plot(x, y...; lw = 1., theme = :makie, xscale = identity, yscale = identity,\naxis_tight = true, xlabel = \"x\", ylabel = \"y\",\nlegend = (active = false, position = :rt, orientation = :vertical, entry = \" \"),\nfonts = DEFAULT_MAKIE_FONTS)\nPlot a 2D plot.\nInputs\n\nx: x-axis values\n\ny: y-axis values\n\nlw: linewidth\n\ntheme: Theme (default: :makie)\n\nxscale: x-axis scale (default: identity)\n\nyscale: y-axis scale (default: identity)\n\naxis_tight: Tight axis (default: true)\n\nxlabel: x-axis label\n\nylabel: y-axis label\n\nlegend: Legend parameters\n\nactive : Bool\n\nposition : Symbol\n\nentry : String\n\n\n\nfonts: Fonts of the figure (default: DEFAULT_MAKIE_FONTS)\n\n\nOutput\n\nfig: Figure\n\n\n\n\n\n\n\n\n\nx = range(0., 2π, 100)\nz_sv = ntuple(i -&gt; sin.(i*x/2), 5)\n\n# SV plot\nsv_plot(x, z_sv..., lw = 2., legend = (active = true,))",
    "crumbs": [
      "Visualization",
      "Visualization extensions"
    ]
  }
]