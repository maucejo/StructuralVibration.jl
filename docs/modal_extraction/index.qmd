---
title: Experimental Modal Analysis
format:
  html:
    toc: true
    number-sections: true
engine: julia
execute:
  freeze: auto
  cache: true
---

```{julia}
#| echo: false
#| output: false
using StructuralVibration, ShareAdd
@usingany CairoMakie
```

The modal approach enables the dynamic behavior of a structure to be predicted based on knowledge of its natural modes of vibration, which are intrinsic to the system. From a practical point of view, this information can be used to determine the frequencies at which the structure is most likely to vibrate. For industry, this information is invaluable, as vibrations can cause discomfort, noise, premature wear and tear, or even damage to a system. This is where **Experimental Modal Analysis** (EMA) comes in. Experimental identification of vibration modes can also be used to calibrate a finite element model or certify a product (e.g. ground vibration testing or regulations related to the modal behavior of the structure).

EMA aims to estimate the natural frequencies of the system and other characteristic parameters (e.g. damping ratios and mode shapes) from the vibration measurements in order to obtain a modal model of the system under consideration. This model can then be used to determine the structure's dynamic behaviour for a given excitation.

To reach these goals, it is supposed that:

* the system is **linear and time-invariant** ;
* the modal damping is of **viscous** type.

EMA is a family of **inverse methods** attempting to determine the modal characteristics of a structure from the responses measured at each point of the mesh.

## General principles

To identify the modal parameters of a structure or mechanical system, EMA relies on the measurement of the structure's transfer function matrix. By definition, the transfer function $H_{pq}(\omega)$ can be seen as the frequency response of the system at a point $x_p$ to an excitation of unit amplitude at a point $x_q$. Classically, the transfer function matrix (here the admittance) is given by the relation

$$
H_{pq}(\omega) = \sum_{i = 1}^{+\infty} \frac{\phi_i(x_p)\, \phi_i(x_q)}{M_i(\omega_i^2 - \omega^2 + 2j\xi_i\omega_i\omega)} = \sum_{i = 1}^{+\infty} \left[\frac{{}_i R_{pq}}{j\omega - \lambda_i} + \frac{{}_i R_{pq}^\ast}{j\omega - \lambda_i^\ast}\right],
$$
where:

* $\lambda_i = -\xi_i + j\,\Omega_i$ is the pole related to the mode $i$, with:
    * $\Omega_i = \omega_i\sqrt{1 - \xi_i^2}$ is the damped natural frequency of the mode $i$, with $\omega_i = \vert \lambda_i\vert$.
    * $\xi_i = -\frac{\text{Re}(\lambda_i)}{\omega_i}$ the modal damping factor of the mode $i$ <br></br>

* ${}_i R_{pq} = c_i\, \phi_i(x_p)\, \phi_i(x_q)$ is the residue of the mode $i$, with:
    * $\phi_i(x_p)$ the mode shape of the mode $i$ at point $x_p$
    * $c_i = \frac{1}{2jM_i\Omega_i}$ the normalization constant of the mode shape of the mode $i$

The objective of an EMA is therefore to identify the residuals ${}_i R_{pq}$ and the poles $\lambda_i$ of the transfer function $H_{pq}(\omega)$ in order to extract, in a second step, the modal parameters of the system under study (natural angular frequencies $\omega_i$, modal damping factors $\xi_i$ and mode shapes $\phi_i$).

In `StructuralVibration.jl`, two families of modal extraction methods are implemented:

* methods based on the use of single degree of freedom (sdof) models, known as **Sdof methods**. These methods seek to adjust ideal transfer functions of Sdof systems to experimental curves around their resonances. These methods therefore consist of identifying the modal parameters mode by mode. To do this, the operator must select a frequency band around each resonance to perform the extraction.

* methods based on the use of multiple degree of freedom (mdof) models, known as **Mdof methods**. These methods consider that the system can be represented as a multiple degree of freedom system. They are generally based on the construction of a high-order polynomial matrix whose coefficients are estimated from the measured transfer functions.

## Sdof methods

The Sdof methods are based on the assumption that the system can be represented as a single degree of freedom system. This means that the system can be described by a single natural frequency, damping ratio, and mode shape. The Sdof methods are typically used for systems that are lightly damped and for which the modes are well separated.

For these methods, it is assumed that the FRF (admittance) is given by:
$$
H_{pq}(\omega) = \sum_{i = 1}^N\frac{_{i}R_{pq}}{\omega_i^2 - \omega^2 + j\eta_i\omega_i^2}
$$
where, for a mode $i$, $_{i}R_{pq} = \phi_i(x_p)\phi_i(x_q)$ is the residue, $\omega_i$ is the natural frequency, $\eta_i$ is the modal damping factor, and $\phi_i(x_p)$ is the mass-normalized mode shape at the point $x_p$.

When the natural frequencies of the modes are sufficiently spaced and the damping is low, one can write at a frequency $\omega$ close to the natural frequency $\omega_i$:
$$
H_{pq}(\omega) \approx \frac{\phi_i(x_p)\phi_i(x_q)}{\omega_i^2 - \omega^2 + j\eta_i\omega_i^2}.
$$

::: {.callout-note}

One can note that the modal damping factor $\eta_i$ is related to the damping ratio $\xi_i$ by the relation:
$$
\eta_i = 2\xi_i.
$$

:::

### Poles extraction

`StructuralDynamics.jl` provides three SDOF methods for extracting the poles of a system from its frequency response function (FRF):

- Peak picking method
- Circle fit method
- Least squares fit method

#### Peak picking method

The peak picking method is a simple and effective way to extract the natural frequencies and damping ratios of a system. The method consists of the following steps:

1. **Identification of natural frequencies**

    They are identified from the peaks of the amplitude of the FRF. The natural frequencies are identified as the frequencies at which the FRF has a local maximum. The local maxima are determined using `Peaks.jl`.

2. **Estimation of modal damping factors**

    To estimate the value of the damping factor for mode $i$, the half power bandwidth method is used. This procedure, valid for low damping ($\eta_i < 0.1$), first determines the frequencies $\omega_1$ and $\omega_2$ such that:
    $$
    \vert H_{pq}(\omega_1)\vert = \vert H_{pq}(\omega_2)\vert = \frac{\vert H_{pq}(\omega_i)\vert}{\sqrt{2}},
    $$
    with $\omega_i \in [\omega_1, \omega_2]$.

    Knowing the values of $\omega_i$, $\omega_1$, and $\omega_2$, the damping ratio for mode $i$ is determined using the formula:
    $$
    \eta_i = \frac{\omega_2^2 - \omega_1^2}{2\omega_i^2}.
    $$

::: {.callout-note}
If we consider that the shape of a resonance peak is symmetric then $\omega_i = \frac{\omega_1 + \omega_2}{2}$.

It comes that:
$$
\omega_2^2 - \omega_1^2 \approx 2\omega_i(\omega_2 - \omega_1).
$$

Hence, the damping ratio can be approximated as:
$$
\eta_i \approx \frac{\omega_2 - \omega_1}{\omega_i}.
$$

This formula is often given in textbooks when dealing with the half power bandwidth method.
:::

Once the natural frequencies and damping ratios have been determined, the poles are recovered using the relation:
$$
\lambda_i = -\xi_i \omega_i + j\omega_i\sqrt{1 - \xi_i^2}.
$$

::: {.callout-warning}
Thanks to its extreme simplicity, this method allows for quick analysis. However, this method generally does not provide satisfactory results, as it relies on measuring the resonance peak, which is very difficult to measure precisely. This is why this method is mainly applicable to lightly damped structures with well-separated modes, whose transfer functions have been measured with good frequency resolution.
:::

#### Circle fit method

The circle fit method is a more sophisticated method for extracting the natural frequencies and damping ratios of a system. It allows for more accurate results than the peak picking method. It is based on the fact that the admittance forms a circle (Nyquist circle) when plotted in the complex plane (see @fig-cfm). Indeed, assuming that the modes are mass-normalized, it can be shown that:
$$
Re\left[H_{pq}(\omega)\right]^2 + \left(Im\left[H_{pq}(\omega)\right] + \frac{\Phi_i(x_p)\Phi_i(x_q)}{2\eta_i\omega_i^2}\right)^2 = \left(\frac{\Phi_i(x_p)\Phi_i(x_q)}{2\eta_i\omega_i^2}\right)^2,
$$
which is the equation of a circle of radius $R = \frac{\vert\Phi_i(x_p)\Phi_i(x_q)\vert}{2\eta_i\omega_i^2}$ and center $(x_c,y_c) = \Bigl(0,-\frac{\Phi_i(x_p)\Phi_i(x_q)}{2\eta_i\omega_i^2}\Bigr)$.

::: {#fig-cfm}
![](../assets/images/cercle_nyquist.png){width=75%}

Typical Nyquist circle of an admittance $H_{pq}(\omega)$
:::

The circle fit method consists of the following steps:

1. **Identification of natural frequencies**

    To identify the natural frequency of a mode $i$, we start by parameterizing the Nyquist circle by defining the angles $\psi$ and $\theta$ as shown in @fig-cfm. Mathematically, it can then be shown that:
    $$
    \omega_i^2 = \frac{\omega_1^2\tan\frac{\theta_2}{2} - \omega_2^2\tan\frac{\theta_1}{2}}{\tan\frac{\theta_2}{2} - \tan\frac{\theta_1}{2}},
    $$
    where $\omega_1$ and $\omega_2$ are the angular frequencies such that $\omega_1 < \omega_i < \omega_2$, while $\theta_1$ and $\theta_2$ are the corresponding angles of the Nyquist circle.

2. **Estimation of modal damping factors**

    The damping ratio is estimated using the following formula:
    $$
    \eta_i = \frac{\omega_2^2 - \omega_1^2}{\omega_i^2}\frac{1}{\tan\frac{\theta_1}{2} - \tan\frac{\theta_2}{2}}.
    $$

::: {.callout-note}
Generally, the angles $\theta_1$ and $\theta_2$ are chosen so that:
$$
\theta_1 = \frac{\pi}{2} \text{ and } \theta_2 = -\frac{\pi}{2}.
$$

In doing so, we have:
$$
\omega_i^2 = \frac{\omega_1^2 + \omega_2^2}{2} \text{ and } \eta_i = \frac{\omega_2^2 - \omega_1^2}{2\omega_i^2}.
$$
:::

#### Least squares fit method

The least squares fit method is based on the idea of fitting the frequency response function (FRF) around the resonance peaks using a least squares approach[^1].

[^1]: A. Brandt. "Noise and Vibration Analysis: Signal Analysis and Experimental Procedures", Wiley, 2011.

When the natural frequencies of the modes are sufficiently spaced and the damping is low, one can write at a frequency $\omega$ close to the natural frequency $f_i$:
$$
H_{pq}(f) \approx \frac{_{i}A_{pq}}{f_i^2 - f^2 + 2j\xi_i f_i f}.
$$

The least squares fit method consists of the following steps:

1. **Definition of the system matrices**

    To construct the system matrices, we start by rewriting the previous equation as:
    $$
    H_{pq}(f) \left(f_i^2 - f^2 + 2j\xi_i f_i f\right) - _{i}A_{pq} = 0.
    $$

    This equation can be rewritten as:
    $$
    \begin{bmatrix}
    H_{pq}(f) & 2jfH_{pq}(f) & -1
    \end{bmatrix} \begin{bmatrix}
    f_i^2 \\
    \xi_i f_i \\
    _{i}A_{pq}
    \end{bmatrix} = f^2 H_{pq}(f).
    $$

    If we consider $M$ frequency points around the resonance peak, we can construct the following system of equations:
    $$
    \begin{bmatrix}
    H_{pq}(f_1) & 2jf_1H_{pq}(f_1) & -1 \\
    H_{pq}(f_2) & 2jf_2H_{pq}(f_2) & -1 \\
    \vdots & \vdots & \vdots \\
    H_{pq}(f_M) & 2jf_MH_{pq}(f_M) & -1
    \end{bmatrix} \begin{bmatrix}
    f_i^2 \\
    \xi_i f_i \\
    _{i}A_{pq}
    \end{bmatrix} = \begin{bmatrix}
    f_1^2 H_{pq}(f_1) \\
    f_2^2 H_{pq}(f_2) \\
    \vdots \\
    f_M^2 H_{pq}(f_M)
    \end{bmatrix}.
    $$

2. **Least squares solution**

    The least squares solution of the previous system of equations is given by:
    $$
    \begin{bmatrix}
    f_i^2 \\
    \xi_i f_i \\
    _{i}A_{pq}
    \end{bmatrix} = \left(\mathbf{A}^H\mathbf{A}\right)^{-1}\mathbf{A}^H\mathbf{b},
    $$
    where $\mathbf{A}$ is the matrix on the left-hand side of the system of equations, $\mathbf{b}$ is the vector on the right-hand side, and $\mathbf{A}^H$ is the conjugate transpose of $\mathbf{A}$.

::: {.callout-note}

In practice, the least squares solution is not directly computed using complex numbers, as this can lead to numerical issues. Instead, the real and imaginary parts are separated to solve a real system of double size.

:::

### Mode shape extraction

The mode shapes are extracted from the admittance matrix at the resonance frequency $\omega_i$. In this situation, the admittance matrix is defined as:
$$
\mathbf{H} = \frac{1}{j\eta_i\omega_i^2}
  \begin{bmatrix}
    \Phi_i(x_1)^2 & \Phi_i(x_1)\Phi_i(x_2) & \ldots\ & \Phi_i(x_1)\Phi_i(x_N) \\
    \Phi_i(x_2)\Phi_i(x_1) & \Phi_i(x_2)^2 &  & \Phi_i(x_2)\Phi_i(x_N) \\
    \vdots & & \ddots & \vdots \\
    \Phi_i(x_N)\Phi_i(x_1) & \ldots & \ldots & \Phi_i(x_N)^2
  \end{bmatrix},
$$

where $\omega_i$ and $\eta_i$ have been determined using the peak picking method or the circle fit method.

To determine the mode shapes from the knowledge of a column $q$ (or a row $p$), proceed as follows:

* From the measurement of an input admittance (diagonal term of the admittance matrix), the mode shape value at point $x_q$ is obtained:
  $$
  \Phi_i(x_q)^2 = -\eta_i\omega_i^2 \text{Im}(H_{qq}(\omega_i)).
  $$

* From the cross-admittances (off-diagonal terms of the admittance matrix), the mode shape value at a point $x_p$ is calculated:
  $$
  \Phi_i(x_p)\Phi_i(x_q) = -\eta_i\omega_i^2 \text{Im}(H_{pq}(\omega_i))
  $$

## Mdof methods

The Mdof methods are based on the assumption that the system can be represented as a multiple degree of freedom system. They are generally based on the construction of a high-order polynomial matrix whose coefficients are estimated from the measured FRFs. As for the SDOF methods, the estimation of the modal parameters is divided into two steps:

1. estimation of the poles of the system to extract the natural frequencies and modal damping ratios,
2. estimation of the residues to extract the mode shapes.


### Poles extraction

The poles of the system are then obtained as the roots of the characteristic polynomial associated with this polynomial matrix. Three methods are implemented in this package:

- the Least-Squares Complex Exponential (LSCE) method
- the Least-Squares Complex Frequency-domain (LSCF) method
- the Polyreference Least-Squares Complex Frequency-domain (pLSCF) method

#### LSCE method

The LSCE method is based on the assumption that the system can be modeled as a sum of complex exponentials in the time domain. The impulse response function (IRF) between an output $o$ ($o = 1, \ldots, n_o$) and an input $i$ ($i = 1, \ldots, n_i$) can be modeled as:
$$
h_{oi}(t) = \sum_{k = 1}^n \left(c_k e^{\lambda_k t} + c_k^\ast e^{-\lambda_k^\ast t}\right) = 2 Re\left(\sum_{k = 1}^n c_k e^{\lambda_k t}\right).
$$

When sampling the IRF at a sampling period $T_s$, one obtains the following discrete-time model:
$$
h_{oi}[m] = 2 Re\left(\sum_{k = 1}^n c_k z_k^m\right) \text{ with } z_k = e^{\lambda_k T_s},
$$

for $m = 0, 1, \ldots, 2n$, ($n$ is the model order). According to the Prony's method, the poles $\lambda_k$ can be calculated from the roots of the following characteristic polynomial:
$$
\sum_{m = 0}^{2n} \beta_m z_k^m = 0 \text{ with } \beta_{2n} = 1.
$$

The coefficients $\beta_l$ of the characteristic polynomial can be estimated from the sampled IRF $h_{oi}[m]$. Todo so, one first multiply $h_{oi}[m]$ by the corresponding coefficients $\beta_m$ and then sums the resulting equations for $m = 0, 1, \ldots, 2n$. This leads to the following homogeneous set of equations:
$$
\sum_{m = 0}^{2n} \beta_m h_{oi}[m] = 2 Re\left(\sum_{k = 1}^{n} c_k \sum_{m = 0}^{2n} \beta_m z_k^m\right).
$$

When $z_k$ is a root of the characteristic polynomial, the right-hand side of the previous equation is equal to zero. Therefore, one can estimate the coefficients $\beta_m$ by solving the following set of linear equations:
$$
\sum_{m = 0}^{2n} \beta_m h_{oi}[m] = 0.
$$

The previous equation can be derived using different set of data points, $h_{oi}[m]$, $h_{oi}[m+1]$, $\ldots$, $h_{oi}[m + 2n]$  to obtain an overdetermined set of linear equations that can be solved in the least-squares sense[^2]. In this package, the coefficients $\beta_m$ are estimated by solving the following set of equations:
$$
\begin{bmatrix}
h_{oi}[0] & h_{oi}[1] & \ldots & h_{oi}[2n-1] \\
h_{oi}[1] & h_{oi}[2] & \ldots & h_{oi}[2n] \\
\vdots & \vdots & \ddots & \vdots \\
h_{oi}[2n-1] & h_{oi}[2n] & \ldots & h_{oi}[4n-2]
\end{bmatrix}
\begin{bmatrix}
\beta_0 \\
\beta_1 \\
\vdots \\
\beta_{2n-1}
\end{bmatrix}
= -\begin{bmatrix}
h_{oi}[2n] \\
h_{oi}[2n+1] \\
\vdots \\
h_{oi}[4n-1]
\end{bmatrix}
$$

Once the coefficients $\beta_m$ are estimated, the poles $\lambda_k$ can be obtained from the roots $z_k$ of the characteristic polynomial.

[^2]: D. Brown, R. Allemang and R. Zimmerman and M. Mergeay. "Parameter estimation techniques for modal analysis". SAE Technical Paper 790221, 1979.

#### LSCF method

According to Guillaume et al. [^3], the transfer function between an output $o$ ($o = 1, \ldots, n_o$)  and an input $i$ ($i = 1, \ldots, n_i$) can be modeled in the frequency domain as:
$$
\widehat{H}_k(\omega) = \frac{N_k(\omega)}{d(\omega)},
$$

where $k = 1, \ldots, n_o n_i$ ($k = (o - 1) n_i + i$). Here, $N_k(\omega)$ is the $k$-th element of the numerator matrix defined as:
$$
N_k(\omega) = \mathbf{\Omega}(\omega)^T \boldsymbol{\beta}_k,
$$

while $d(\omega)$ is the common denominator polynomial defined as:
$$
d(\omega) = \mathbf{\Omega}(\omega)^T \boldsymbol{\alpha}.
$$

In the previous equations, $\mathbf{\Omega}(\omega)$ is the vector of polynomial basis functions defined as:
$$
\mathbf{\Omega}(\omega)^T = [1, \Omega_1(\omega), \ldots, \Omega_n(\omega)] \text{ with } \Omega_n(\omega) = \exp(-i\omega n T_s),
$$

where $n$ is the order of the denominator polynomial (a.k.a the model order) and $T_s$ is the sampling period. The vectors $\boldsymbol{\beta}_k$ and $\boldsymbol{\alpha}$ contain the coefficients of the numerator and denominator polynomials, respectively.

Based on the previous formulation of the FRFs, the LSCF method consists in estimating the coefficients of the numerator $\boldsymbol{\beta}_k$ and denominator $\boldsymbol{\alpha}$ polynomials by minimizing the following functional:
$$
J(\boldsymbol{\theta}) = \sum_{k=1}^{n_o n_i} \sum_{j=1}^{n_f} \left| W_k(\omega_j)\left[H_k(\omega_j) d(\omega_j) - N_k(\omega_j)\right] \right|^2,
$$

where $\boldsymbol{\theta} = [\boldsymbol{\beta}_1^T, \ldots, \boldsymbol{\beta}_{n_o n_i}^T, \boldsymbol{\alpha}^T]^T$ is the vector of unknown parameters to be estimated, $H_k(\omega_j)$ is the measured FRF at frequency $\omega_j$, $n_f$ is the number of frequency lines used for the identification and $W_k(\omega_j)$ is an arbitrary weighting function. In the package, a unitary weighting function is used, i.e. $W_k(\omega_j) = 1$.

The poles of the transfer function are obtained from the roots of the characteristic polynomial associated with the denominator polynomial $d(\omega)$, which are computed after having estimated the coefficients $\boldsymbol{\alpha}$ as the argument of the minimum of the functional $J(\boldsymbol{\theta})$ (see Ref. [2] for details).

[^3]: P. Guillaume, P. Verboven, S. Vanlanduit, H. Van der Auweraer and B. Peeters, "A poly-reference implementation of the least-squares complex frequency-domain estimator". Proceedings of the 21st International Modal Analysis Conference, IMAC, 2003.

#### pLSCF method

The pLSCF method is an extension of the LSCF method that makes it possible to take into account multiple reference sensors simultaneously (see Ref. [3] for details). When using only one reference sensor, the pLSCF method is equivalent to the LSCF method.

In this approach, the transfer function $\widehat{\mathbf{H}}_o(\omega) \in \mathbb{C}^{1 \times n_i}$ between an output $o$ ($o = 1, \ldots, n_o$) and a set of $n_i$ inputs can be modeled in the frequency domain as:
$$
\widehat{\mathbf{H}}_o(\omega) = \mathbf{N}_o(\omega) \mathbf{D}(\omega)^{-1},
$$

where $\mathbf{N}_o(\omega) \in \mathbb{C}^{1 \times n_i}$ is the numerator matrix defined as:
$$
\mathbf{N}_o(\omega) = \mathbf{\Omega}(\omega)^T \boldsymbol{\beta}_o,
$$

while $\mathbf{D}(\omega) \in \mathbb{C}^{n_i \times n_i}$ is the denominator matrix defined as:
$$
\mathbf{D}(\omega) = \mathbf{\Omega}(\omega)^T \boldsymbol{\alpha}.
$$

Based on the previous formulation of the FRFs, the pLSCF method consists in estimating the coefficients of the numerator $\boldsymbol{\beta}_o$ and denominator $\boldsymbol{\alpha}$ polynomials. To this end, one defines the weighted error between the measured and modeled FRFs as:
$$
\boldsymbol{\varepsilon}_o(\omega_j, \boldsymbol{\theta}) = W_o(\omega_j)\left[\mathbf{H}_o(\omega_j) \mathbf{D}(\omega_j) - \mathbf{N}_o(\omega_j)\right]
$$

Then, an error matrix $\mathbf{E}_o(\boldsymbol{\theta}) \in \mathbb{C}^{n_f \times n_i}$ is constructed by stacking the weighted errors $\boldsymbol{\varepsilon}_o(\omega_j, \boldsymbol{\theta}) \in \mathbb{C}^{1 \times n_i}$ for all frequency lines, that is:
$$
\mathbf{E}_o(\boldsymbol{\theta}) = \begin{bmatrix}
\boldsymbol{\varepsilon}_o(\omega_1, \boldsymbol{\theta}) \\
\vdots \\
\boldsymbol{\varepsilon}_o(\omega_{n_f}, \boldsymbol{\theta})
\end{bmatrix}
$$

Finally, the coefficients of the numerator and denominator polynomials are estimated by minimizing the following functional:
$$
J(\boldsymbol{\theta}) = \sum_{o=1}^{n_o} \Vert\mathbf{E}_o(\boldsymbol{\theta})\Vert^2.
$$

The poles of the transfer function are obtained from the characteristic polynomial associated with the denominator matrix $\mathbf{D}(\omega)$, by computing the eigenvalues of the so-called companion matrix[^4].

[^4]: M. El-Kafafy, P. Guillaume, B. Peeters, F. Marra, G. Coppotelli. "Advanced Frequency-Domain Modal Analysis for Dealing with Measurement Noise and Parameter Uncertainty". In: Allemang R., De Clerck J., Niezrecki C., Blough J. (eds) Topics in Modal Analysis I, Volume 5. Conference Proceedings of the Society for Experimental Mechanics Series. 2012.

#### Stabilization diagram

When carrying out an EMA, the main question that arises is how many modes (or, more precisely, poles) are contained within the frequency band of interest. Analyzing the frequency response functions (transfer functions) provides an initial estimate. However, it is difficult to distinguish between multiple or nearby modes.

The stabilisation diagram is a fundamental EMA tool as it provides a clear and concise presentation of the poles of the system under study. The idea is to adjust the transfer function model by increasing the number of poles and displaying the results on a graph. Broadly speaking, increasing the order of the model (i.e. the number of poles) causes the true vibration modes to converge to a stable value, whereas the numerical modes appear inconsistently or randomly on the graph. Thus, as the poles converge to stable ones, markers appear on the graph to indicate the identified poles, as the order of the model is gradually increased. The selection of poles is generally based on the stability of natural frequencies, modal damping and/or mode shapes, moving from a model order $n$ to an order $n + 1$. In this package, the stability of the natural frequencies and damping ratios is used to identify the physical poles of the system. The stability criterion is set to 1% for the natural frequencies and 5% for the damping ratios, following common practice in the EMA field.

In `StructuralVibration.jl`, the stabilization diagram can be obtained using the `stabilization` function along with any of the Mdof methods described above. The identified stable poles can then be visualized using the `stabilization_plot` function. The `stabilization` function returns an `StabilizationAnalysis` structure that contains all the information related to the stabilization analysis, which allows the user to manually select the appropriate poles and to further analyze (e.g. by using quality and analysis indicators) and visualize the results.

### Mode shape extraction

Once the poles of the system have been identified using one of the Mdof methods described above, the residues can be computed to extract the mode shapes. In this package, the residues are computed using a least-squares approach based on the formulation of the FRFs as a sum of rational functions. The FRF between an output $p$ ($p = 1, \ldots, n_o$) and an input $q$ ($q = 1, \ldots, n_i$) can be expressed as:
$$
H_{pq}(\omega) = \sum_{i = 1}^n \left(\frac{{}_iR_{pq}}{j\omega - \lambda_i} + \frac{{}_iR_{pq}^\ast}{j\omega - \lambda_i^\ast}\right),
$$

where $R_{k, pq}$ is the residue associated with the pole $\lambda_k$.

At a frequency line $\omega$, the previous equation can be rewritten in matrix form as:
$$
H_{pq}(\omega) = \begin{bmatrix}
\frac{1}{j\omega - \lambda_1} & \ldots & \frac{1}{j\omega - \lambda_n} & \frac{1}{j\omega - \lambda_1^\ast} & \ldots & \frac{1}{j\omega - \lambda_n^\ast}
\end{bmatrix}
\begin{bmatrix}
{}_1R_{pq} \\
\vdots \\
{}_nR_{pq} \\
{}_1R_{pq}^\ast \\
\vdots \\
{}_nR_{pq}^\ast
\end{bmatrix}
$$

Repeating the previous equation for all frequency lines leads to the following system of equations:
$$
\begin{bmatrix}
H_{pq}(\omega_1) \\
H_{pq}(\omega_2) \\
\vdots \\
H_{pq}(\omega_{n_f})
\end{bmatrix}
= \begin{bmatrix}
\frac{1}{j\omega_1 - \lambda_1} & \ldots & \frac{1}{j\omega_1 - \lambda_n} & \frac{1}{j\omega_1 - \lambda_1^\ast} & \ldots & \frac{1}{j\omega_1 - \lambda_n^\ast} \\
\frac{1}{j\omega_2 - \lambda_1} & \ldots & \frac{1}{j\omega_2 - \lambda_n} & \frac{1}{j\omega_2 - \lambda_1^\ast} & \ldots & \frac{1}{j\omega_2 - \lambda_n^\ast} \\
\vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots \\
\frac{1}{j\omega_{n_f} - \lambda_1} & \ldots & \frac{1}{j\omega_{n_f} - \lambda_n} & \frac{1}{j\omega_{n_f} - \lambda_1^\ast} & \ldots & \frac{1}{j\omega_{n_f} - \lambda_n^\ast}
\end{bmatrix}
\begin{bmatrix}
{}_1R_{pq} \\
\vdots \\
{}_nR_{pq} \\
{}_1R_{pq}^\ast \\
\vdots \\
{}_nR_{pq}^\ast
\end{bmatrix}
$$

This system of equations can be solved in the least-squares sense to estimate the residues ${}_iR_{pq}$. This procedure is implemented in the `mode_residues` function.

From the estimated residues, the mode shapes can be extracted using the following relation:
$$
{}_iR_{pq} = c_i \phi_{p,i} \phi_{q,i},
$$

where $c_i$ is a scaling factor, $\phi_{p,i}$ (resp. nd $\phi_{q,i}$) is the $p$-th (resp. $q$-th) component of the mode shape associated with the $i$-th mode.

To solve for the mode shapes, a collocated measurement is required, i.e. $p = q$. Thus, the mode shape components can be obtained as:
$$
\phi_{p,i} = \sqrt{\frac{{}_iR_{pp}}{c_i}} \; \text{ and } \; \phi_{q,i} = \frac{{}_iR_{pq}}{\sqrt{c_i\; {}_iR_{pp}}}.
$$

Here, the scaling factors $c_i$ can be computed based on a normalization criterion. In this package, the scaling factors are computed such that the modal mass of each mode shape is equal to one (mass normalization). The mode shapes can then be extracted using the `modeshape_extraction` function.

## FRF reconstruction

From the identified modal parameters (poles and residues), it is possible to reconstruct the frequency response functions (FRFs) of the system under study using the `frf_reconstruction` function. This function implements the following relation for a number $M$ of identified modes:

$$
H_{pq}(\omega) = \sum_{i = 1}^{M} \left[\frac{{}_i R_{pq}}{(j\omega - \lambda_i)} + \frac{{}_i R_{pq}^\ast}{(j\omega - \lambda_i^\ast)}\right],
$$

where:

* $\lambda_i = -\xi_i + j\,\Omega_i$ is the pole related to the mode $i$, with:
    * $\Omega_i = \omega_i\sqrt{1 - \xi_i^2}$ is the damped natural frequency of the mode $i$, with $\omega_i = \vert \lambda_i\vert$.
    * $\xi_i = -\frac{\text{Re}(\lambda_i)}{\omega_i}$ the modal damping factor of the mode $i$ <br></br>

* ${}_i R_{pq} = c_i\, \phi_i(x_p)\, \phi_i(x_q)$ is the residue of the mode $i$, with:
    * $\phi_i(x_p)$ the mode shape of the mode $i$ at point $x_p$
    * $c_i = \frac{1}{2jM_i\Omega_i}$ the normalization constant of the mode shape of the mode $i$

In practice, however, the reconstructed FRF may not perfectly match the experimental FRF due to the unmodeled contribution of the modes outside the frequency range of interest. To account for this, it is common to include lower and upper residuals in the FRF reconstruction. This means that the admittance matrix can be expressed as:
$$
H_{pq}(\omega) = \sum_{i = 1}^{M} \left[\frac{{}_i R_{pq}}{(j\omega - \lambda_i)} + \frac{{}_i R_{pq}^\ast}{(j\omega - \lambda_i^\ast)}\right] - \frac{L_{pq}}{\omega^2} + U_{pq},
$$

where $L_{pq}$ and $U_{pq}$ are the lower and upper residuals, respectively. These residuals can be computed using the `compute_residuals` function.

::: {.callout-note}
Theoretically, the residuals can be computed in conjunction with the estimation of the residues using a least-squares approach. However, we observed that this often leads to inaccurate estimates of the residuals. Therefore, in `StructuralVibration.jl`, the computation of the residuals is performed separately after estimating the residues and poles.
:::

Finally, when only real mode shapes are available, it is possible to compute the residues from the modal parameters using the `mode2residues` function. This function implements the following relation:
$$
{}_i R_{pq} = c_i\, \phi_i(x_p)\, \phi_i(x_q),
$$

where $\phi_i(x_p)$ is the mode shape of the mode $i$ at point $x_p$ and $c_i = \frac{1}{2jM_i\Omega_i}$ is the normalization constant of the mode shape of the mode $i$. Here, $M_i = 1$, since the mode shapes are mass-normalized. during the extraction process. -->

## API

**Data types**

::: {.api}
**EMAProblem**

---
```{julia}
#| echo: false
@doc EMAProblem
```
:::

::: {.api}
**AutoEMASdofProblem**

---
```{julia}
#| echo: false
@doc AutoEMASdofProblem
```
:::

::: {.api}
**AutoEMAMdofProblem**

---
```{julia}
#| echo: false
@doc AutoEMAMdofProblem
```
:::

::: {.api}
**EMASolution**

---
```{julia}
#| echo: false
@doc EMASolution
```
:::

::: {.api}
**StabilizationAnalysis**

---
```{julia}
#| echo: false
@doc StabilizationAnalysis
```
:::

**Related functions**

::: {.api}
**poles_extraction**

---
```{julia}
#| echo: false
@doc poles_extraction(::EMAProblem, ::CircleFit)
```
:::

::: {.api}
**modeshape_extraction**

---
```{julia}
#| echo: false
@doc modeshape_extraction(::EMAProblem, ::Vector{T}, ::CircleFit; ::Symbol) where {T <: Complex}
```
:::

::: {.api}
**modal2poles**

---
```{julia}
#| echo: false
@doc modal2poles
```
:::

::: {.api}
**poles2modal**

---
```{julia}
#| echo: false
@doc poles2modal
```
:::

::: {.api}
**solve**

---
```{julia}
#| echo: false
@doc solve(::AutoEMASdofProblem)
```
:::

::: {.api}
**frf_reconstruction**

---
```{julia}
#| echo: false
@doc frf_reconstruction
```
:::

::: {.api}
**compute_residuals**

---
```{julia}
#| echo: false
@doc compute_residuals
```
:::

::: {.api}
**mode2residues**

---
```{julia}
#| echo: false
@doc mode2residues
```
:::

## Example

### Data preparation and FRF calculation

```{julia}
#| output: false
# Structure parameters of the beam
L = 1.        # Length
b = 0.03      # Width
h = 0.01      # Thickness
S = b*h       # Cross-section area
Iz = b*h^3/12 # Moment of inertia

# Material parameters
E = 2.1e11  # Young's modulus
ρ = 7850.   # Density
ξ = 0.01    # Damping ratio

# Mesh
xexc = 0:0.05:L
xm = xexc[2]

# Mode calculation - Simply supported boundary conditions
beam = Beam(L, S, Iz, E, ρ)
fmax = 500.

ωn, kn = modefreq(beam, 2fmax)
ms_exc = modeshape(beam, kn, xexc)
ms_m = modeshape(beam, kn, xm)

# FRF calculation
freq = 1.:0.1:fmax
prob = ModalFRFProblem(ωn, ξ, freq, ms_m, ms_exc)
H = solve(prob; ismat = true).u
```

### Sdof methods

#### Modes extraction

```{julia}
#| output: false
# Natural frequencies and damping ratios extraction
prob_sdof = EMAProblem(H, freq)
poles_pp = poles_extraction(prob_sdof, PeakPicking())
poles_cf = poles_extraction(prob_sdof, CircleFit())
poles_lsf = poles_extraction(prob_sdof, LSFit())

# Mode shape extraction
dpi = [1, 2]
ms_id = modeshape_extraction(prob_sdof, poles_pp, PeakPicking(), dpi = dpi)
```

```{julia}
#| echo: false
# Natural frequencies and damping ratios
fn_pp, ξn_pp = poles2modal(poles_pp)
fn_cf, ξn_cf = poles2modal(poles_cf)
fn_lsf, ξn_lsf = poles2modal(poles_lsf)

fig_f = Figure()
ax_f1 = Axis(fig_f[1, 1], title = "Natural frequencies", xlabel = "Mode ID", ylabel = "Natural frequency [Hz]")
ax_f2 = Axis(fig_f[1, 2], title = "Damping ratios", xlabel = "Mode ID", ylabel = "Damping ratio  (%)")

scatter!(ax_f1, 1:4, ωn[1:4]/2π, marker = :rect, markersize = 25, label = "Reference")
scatter!(ax_f1, 1:4, fn_pp, markersize = 20, label = "Peak picking")
scatter!(ax_f1, 1:4, fn_cf, marker = :star4, markersize = 15, label = "Circle fit")
scatter!(ax_f1, 1:4, fn_lsf, marker = :circle, markersize = 10, label = "Least squares fit")
axislegend(ax_f1, position = :lt)

scatter!(ax_f2, 1:4, 100ξ*ones(4), marker = :rect, markersize = 25, label = "Reference")
scatter!(ax_f2, 1:4, 100ξn_pp, markersize = 20, label = "Peak picking")
scatter!(ax_f2, 1:4, 100ξn_cf, marker = :star4, markersize = 15, label = "Circle fit")
scatter!(ax_f2, 1:4, 100ξn_lsf, marker = :circle, markersize = 10, label = "Least squares fit")

display(fig_f);

# Mode shapes
fig_mode = Figure()
ax_mode1 = Axis(fig_mode[1, 1], title = "Mode shape 1", ylabel = "Value")
ax_mode2 = Axis(fig_mode[1, 2], title = "Mode shape 2")
ax_mode3 = Axis(fig_mode[2, 1], title = "Mode shape 3", xlabel = "Position [m]", ylabel = "Value")
ax_mode4 = Axis(fig_mode[2, 2], title = "Mode shape 4", xlabel = "Position [m]")

lines!(ax_mode1, xexc, ms_exc[:, 1], label = "Reference")
lines!(ax_mode1, xexc, ms_id[:, 1], linestyle = :dash, label = "Estimated")
xlims!(ax_mode1, 0, L)
axislegend(ax_mode1, position = :cb)

lines!(ax_mode2, xexc, ms_exc[:, 2], label = "Reference")
lines!(ax_mode2, xexc, ms_id[:, 2], linestyle = :dash, label = "Estimated")
xlims!(ax_mode2, 0, L)

lines!(ax_mode3, xexc, ms_exc[:, 3], label = "Reference")
lines!(ax_mode3, xexc, ms_id[:, 3], linestyle = :dash, label = "Estimated")
xlims!(ax_mode3, 0, L)

lines!(ax_mode4, xexc, ms_exc[:, 4], label = "Reference")
lines!(ax_mode4, xexc, ms_id[:, 4], linestyle = :dash, label = "Estimated")
xlims!(ax_mode4, 0, L)

display(fig_mode);
```

#### FRF reconstruction

```{julia}
#| output: false
# Computation of the mode residues
res_pp = mode2residues(ms_id, poles_pp, [2], 1:21)[1]

# FRF reconstruction - without residuals
H_sdof = frf_reconstruction(res_pp, poles_pp, freq)

# FRF reconstruction - with residuals
lr, ur = compute_residuals(prob_sdof, res_pp, poles_pp)
H_sdof2 = frf_reconstruction(res_pp, poles_pp, freq, lr = lr, ur = ur)
```

```{julia}
#| echo: false
fig = Figure()
ax = Axis(fig[1, 1], xlabel = "Frequency (Hz)", ylabel = "Admittance (dB, ref: 1 m/N)", title = "FRF Reconstruction using Sdof method")
lines!(ax, freq, 20log10.(abs.(H[1, 2, :])), label = "Original FRF")
lines!(ax, freq, 20log10.(abs.(H_sdof[1, 2, :])); linestyle = :dash, label = "Reconstructed FRF (no residuals)")
lines!(ax, freq, 20log10.(abs.(H_sdof2[1, 2, :])); linestyle = :dot, label = "Reconstructed FRF (with residuals)")
xlims!(ax, freq[1], freq[end])
axislegend(ax; position = :rt)

display(fig);
```

#### Automatic Sdof EMA

```julia
prob_ema = AutoEMASdofProblem(prob_sdof, PeakPicking(), dpi = dpi, idx_m = [2], idx_e = 1:21)
sol_ema = solve(prob_ema)
fn_ema, ξn_ema = poles2modal(sol_ema.poles)
ms_ema = sol_ema.ms
```

### Mdof methods

#### Poles extraction

```{julia}
# EMA problem
prob_mdof = EMAProblem(H, freq)

# Poles extraction
order = 10 # Model order
p_lsce = poles_extraction(prob_mdof, order, LSCE())
p_lscf = poles_extraction(prob_mdof, order, LSCF())
p_plscf = poles_extraction(prob_mdof, order, PLSCF())

# Stabilization diagram analysis using the LSCF method
stab = stabilization(prob_mdof, order, LSCF())

# Visualization of the stabilization diagram
stabilization_plot(stab)
```
```{julia}
#| echo: false
# Natural frequencies and damping ratios

fn_lsce, dr_lsce = poles2modal(p_lsce)
fn_lscf, dr_lscf = poles2modal(p_lscf)
fn_plscf, dr_plscf = poles2modal(p_plscf)

fig_f = Figure()
ax_f1 = Axis(fig_f[1, 1], title = "Natural frequencies", xlabel = "Mode ID", ylabel = "Natural frequency [Hz]")
ax_f2 = Axis(fig_f[1, 2], title = "Damping ratios", xlabel = "Mode ID", ylabel = "Damping ratio  (%)")

scatter!(ax_f1, 1:4, ωn[1:4]/2π, marker = :rect, markersize = 25, label = "Reference")
scatter!(ax_f1, 1:4, fn_lsce, markersize = 20, label = "LSCE")
scatter!(ax_f1, 1:4, fn_lscf, marker = :star4, markersize = 15, label = "LSCF")
scatter!(ax_f1, 1:4, fn_plscf, marker = :circle, markersize = 10, label = "PLSCF")
axislegend(ax_f1, position = :lt)

scatter!(ax_f2, 1:4, 100ξ*ones(4), marker = :rect, markersize = 25, label = "Reference")
scatter!(ax_f2, 1:4, 100dr_lsce, markersize = 20, label = "LSCE")
scatter!(ax_f2, 1:4, 100dr_lscf, marker = :star4, markersize = 15, label = "LSCF")
scatter!(ax_f2, 1:4, 100dr_plscf, marker = :circle, markersize = 10, label = "PLSCF")

display(fig_f);
```

#### Mode shape extraction

```{julia}
#| output: false

# Driving point indices
dpi = [1, 2]

# Computation of the mode residues
res = mode_residues(prob_mdof, p_lscf)

# Extraction of the mode shapes
ms_est = modeshape_extraction(res, p_lscf, LSCF(), dpi = dpi, modetype = :emar)[1]

# Convert to real mode shapes
ms_est_real = c2r_modeshape(ms_est)
```

```{julia}
#| echo: false
# Mode shapes
fig_mode = Figure()
ax_mode1 = Axis(fig_mode[1, 1], title = "Mode shape 1", ylabel = "Value")
ax_mode2 = Axis(fig_mode[1, 2], title = "Mode shape 2")
ax_mode3 = Axis(fig_mode[2, 1], title = "Mode shape 3", xlabel = "Position [m]", ylabel = "Value")
ax_mode4 = Axis(fig_mode[2, 2], title = "Mode shape 4", xlabel = "Position [m]")

lines!(ax_mode1, xexc, ms_exc[:, 1], label = "Reference")
lines!(ax_mode1, xexc, ms_est_real[:, 1], linestyle = :dash, label = "Estimated")
xlims!(ax_mode1, 0, L)
axislegend(ax_mode1, position = :cb)

lines!(ax_mode2, xexc, ms_exc[:, 2], label = "Reference")
lines!(ax_mode2, xexc, ms_est_real[:, 2], linestyle = :dash, label = "Estimated")
xlims!(ax_mode2, 0, L)

lines!(ax_mode3, xexc, ms_exc[:, 3], label = "Reference")
lines!(ax_mode3, xexc, ms_est_real[:, 3], linestyle = :dash, label = "Estimated")
xlims!(ax_mode3, 0, L)

lines!(ax_mode4, xexc, ms_exc[:, 4], label = "Reference")
lines!(ax_mode4, xexc, ms_est_real[:, 4], linestyle = :dash, label = "Estimated")
xlims!(ax_mode4, 0, L)

display(fig_mode);
```

#### FRF reconstruction

```{julia}
#| output: false
# Problem definition
prob_mdof = EMAProblem(H, freq)

# Poles extraction using the Least-Squares Complex Frequency-domain method
poles_lscf = poles_extraction(prob_mdof, 20, LSCF())

# Residues extraction
res_lscf = mode_residues(prob_mdof, poles_lscf)

# FRF reconstruction - without residuals
H_mdof = frf_reconstruction(res_lscf, poles_lscf, freq)

# FRF reconstruction - with residuals
lr, ur = compute_residuals(prob_mdof, res_lscf, poles_lscf)
H_mdof2 = frf_reconstruction(res_lscf, poles_lscf, freq, lr = lr, ur = ur)
```

```{julia}
#| echo: false
fig1 = Figure()
ax1 = Axis(fig1[1, 1], xlabel = "Frequency (Hz)", ylabel = "Admittance (dB, ref: 1 m/N)", title = "FRF Reconstruction using Mdof method")
lines!(ax1, freq, 20log10.(abs.(H[1, 2, :])), label = "Original FRF")
lines!(ax1, freq, 20log10.(abs.(H_mdof[1, 2, :])); linestyle = :dash, label = "Reconstructed FRF (no residuals)")
lines!(ax1, freq, 20log10.(abs.(H_mdof2[1, 2, :])); linestyle = :dot, label = "Reconstructed FRF (with residuals)")
xlims!(ax1, freq[1], freq[end])
axislegend(ax1; position = :rt)

display(fig1);
```

#### Automatic Mdof EMA

```julia
prob_ema = AutoEMAMdofProblem(prob_mdof, order, dpi, LSCF())
sol_ema = solve(prob_ema)
fn_ema, ξn_ema = poles2modal(sol_ema.poles)
ms_ema = sol_ema.ms
```