---
title: Mdof methods
format:
  html:
    toc: true
    number-sections: true
engine: julia
execute:
  freeze: auto
  cache: true
---

```{julia}
#| echo: false
#| output: false
using StructuralVibration, ShareAdd
@usingany CairoMakie
```

The Mdof methods are based on the assumption that the system can be represented as a multiple degree of freedom system. They are generally based on the construction of a high-order polynomial matrix whose coefficients are estimated from the measured FRFs. As for the SDOF methods, the estimation of the modal parameters is divided into two steps:

1. estimation of the poles of the system to extract the natural frequencies and modal damping ratios,
2. estimation of the residues to extract the mode shapes.


## Natural frequencies and damping ratios extraction
The poles of the system are then obtained as the roots of the characteristic polynomial associated with this polynomial matrix. Three methods are implemented in this package:

* the Least-Squares Complex Exponential (LSCE) method,
* the Least-Squares Complex Frequency-domain (LSCF) method.
* the Polyreference Least-Squares Complex Frequency-domain (pLSCF) method,


### LSCE method

The LSCE method is based on the assumption that the system can be modeled as a sum of complex exponentials in the time domain. The impulse response function (IRF) between an output $o$ ($o = 1, \ldots, n_o$) and an input $i$ ($i = 1, \ldots, n_i$) can be modeled as:
$$
h_{oi}(t) = \sum_{k = 1}^n \left(c_k e^{\lambda_k t} + c_k^\ast e^{-\lambda_k^\ast t}\right) = 2 Re\left(\sum_{k = 1}^n c_k e^{\lambda_k t}\right).
$$

When sampling the IRF at a sampling period $T_s$, one obtains the following discrete-time model:
$$
h_{oi}[m] = 2 Re\left(\sum_{k = 1}^n c_k z_k^m\right) \text{ with } z_k = e^{\lambda_k T_s},
$$
for $m = 0, 1, \ldots, 2n$, ($n$ is the model order). According to the Prony's method, the poles $\lambda_k$ can be calculated from the roots of the following characteristic polynomial:
$$
\sum_{m = 0}^{2n} \beta_m z_k^m = 0 \text{ with } \beta_{2n} = 1.
$$

The coefficients $\beta_l$ of the characteristic polynomial can be estimated from the sampled IRF $h_{oi}[m]$. Todo so, one first multiply $h_{oi}[m]$ by the corresponding coefficients $\beta_m$ and then sums the resulting equations for $m = 0, 1, \ldots, 2n$. This leads to the following homogeneous set of equations:
$$
\sum_{m = 0}^{2n} \beta_m h_{oi}[m] = 2 Re\left(\sum_{k = 1}^{n} c_k \sum_{m = 0}^{2n} \beta_m z_k^m\right).
$$

When $z_k$ is a root of the characteristic polynomial, the right-hand side of the previous equation is equal to zero. Therefore, one can estimate the coefficients $\beta_m$ by solving the following set of linear equations:
$$
\sum_{m = 0}^{2n} \beta_m h_{oi}[m] = 0.
$$

The previous equation can be derived using different set of data points, $h_{oi}[m]$, $h_{oi}[m+1]$, $\ldots$, $h_{oi}[m + 2n]$  to obtain an overdetermined set of linear equations that can be solved in the least-squares sense[^1]. In this package, the coefficients $\beta_m$ are estimated by solving the following set of equations:
$$
\begin{bmatrix}
h_{oi}[0] & h_{oi}[1] & \ldots & h_{oi}[2n-1] \\
h_{oi}[1] & h_{oi}[2] & \ldots & h_{oi}[2n] \\
\vdots & \vdots & \ddots & \vdots \\
h_{oi}[2n-1] & h_{oi}[2n] & \ldots & h_{oi}[4n-2]
\end{bmatrix}
\begin{bmatrix}
\beta_0 \\
\beta_1 \\
\vdots \\
\beta_{2n-1}
\end{bmatrix}
= -\begin{bmatrix}
h_{oi}[2n] \\
h_{oi}[2n+1] \\
\vdots \\
h_{oi}[4n-1]
\end{bmatrix}
$$

Once the coefficients $\beta_m$ are estimated, the poles $\lambda_k$ can be obtained from the roots $z_k$ of the characteristic polynomial.

[^1]: D. Brown, R. Allemang and R. Zimmerman and M. Mergeay. "Parameter estimation techniques for modal analysis". SAE Technical Paper 790221, 1979.

### LSCF method

According to Guillaume et al. [^2], the transfer function between an output $o$ ($o = 1, \ldots, n_o$)  and an input $i$ ($i = 1, \ldots, n_i$) can be modeled in the frequency domain as:
$$
\widehat{H}_k(\omega) = \frac{N_k(\omega)}{d(\omega)},
$$
where $k = 1, \ldots, n_o n_i$ ($k = (o - 1) n_i + i$). Here, $N_k(\omega)$ is the $k$-th element of the numerator matrix defined as:
$$
N_k(\omega) = \mathbf{\Omega}(\omega)^T \boldsymbol{\beta}_k,
$$
while $d(\omega)$ is the common denominator polynomial defined as:
$$
d(\omega) = \mathbf{\Omega}(\omega)^T \boldsymbol{\alpha}.
$$

In the previous equations, $\mathbf{\Omega}(\omega)$ is the vector of polynomial basis functions defined as:
$$
\mathbf{\Omega}(\omega)^T = [1, \Omega_1(\omega), \ldots, \Omega_n(\omega)] \text{ with } \Omega_n(\omega) = \exp(-i\omega n T_s),
$$
where $n$ is the order of the denominator polynomial (a.k.a the model order) and $T_s$ is the sampling period. The vectors $\boldsymbol{\beta}_k$ and $\boldsymbol{\alpha}$ contain the coefficients of the numerator and denominator polynomials, respectively.

Based on the previous formulation of the FRFs, the LSCF method consists in estimating the coefficients of the numerator $\boldsymbol{\beta}_k$ and denominator $\boldsymbol{\alpha}$ polynomials by minimizing the following functional:
$$
J(\boldsymbol{\theta}) = \sum_{k=1}^{n_o n_i} \sum_{j=1}^{n_f} \left| W_k(\omega_j)\left[H_k(\omega_j) d(\omega_j) - N_k(\omega_j)\right] \right|^2,
$$
where $\boldsymbol{\theta} = [\boldsymbol{\beta}_1^T, \ldots, \boldsymbol{\beta}_{n_o n_i}^T, \boldsymbol{\alpha}^T]^T$ is the vector of unknown parameters to be estimated, $H_k(\omega_j)$ is the measured FRF at frequency $\omega_j$, $n_f$ is the number of frequency lines used for the identification and $W_k(\omega_j)$ is an arbitrary weighting function. In this package, a unitary weighting function is used, i.e. $W_k(\omega_j) = 1$.

The poles of the transfer function are obtained from the roots of the characteristic polynomial associated with the denominator polynomial $d(\omega)$, which are computed after having estimated the coefficients $\boldsymbol{\alpha}$ as the argument of the minimum of the functional $J(\boldsymbol{\theta})$ (see Ref. [2] for details).

[^2]: P. Guillaume, P. Verboven, S. Vanlanduit, H. Van der Auweraer and B. Peeters, "A poly-reference implementation of the least-squares complex frequency-domain estimator". Proceedings of the 21st International Modal Analysis Conference, IMAC, 2003.

### pLSCF method

The pLSCF method is an extension of the LSCF method that makes it possible to take into account multiple reference sensors simultaneously (see Ref. [2] for details). When using only one reference sensor, the pLSCF method is equivalent to the LSCF method.

In this approach, the transfer function $\widehat{\mathbf{H}}_o(\omega) \in \mathbb{C}^{1 \times n_i}$ between an output $o$ ($o = 1, \ldots, n_o$) and a set of $n_i$ inputs can be modeled in the frequency domain as:
$$
\widehat{\mathbf{H}}_o(\omega) = \mathbf{N}_o(\omega) \mathbf{D}(\omega)^{-1},
$$
where $\mathbf{N}_o(\omega) \in \mathbb{C}^{1 \times n_i}$ is the numerator matrix defined as:
$$
\mathbf{N}_o(\omega) = \mathbf{\Omega}(\omega)^T \boldsymbol{\beta}_o,
$$
while $\mathbf{D}(\omega) \in \mathbb{C}^{n_i \times n_i}$ is the denominator matrix defined as:
$$
\mathbf{D}(\omega) = \mathbf{\Omega}(\omega)^T \boldsymbol{\alpha}.
$$

Based on the previous formulation of the FRFs, the pLSCF method consists in estimating the coefficients of the numerator $\boldsymbol{\beta}_o$ and denominator $\boldsymbol{\alpha}$ polynomials. To this end, one defines the weighted error between the measured and modeled FRFs as:
$$
\boldsymbol{\varepsilon}_o(\omega_j, \boldsymbol{\theta}) = W_o(\omega_j)\left[\mathbf{H}_o(\omega_j) \mathbf{D}(\omega_j) - \mathbf{N}_o(\omega_j)\right]
$$

Then, an error matrix $\mathbf{E}_o(\boldsymbol{\theta}) \in \mathbb{C}^{n_f \times n_i}$ is constructed by stacking the weighted errors $\boldsymbol{\varepsilon}_o(\omega_j, \boldsymbol{\theta}) \in \mathbb{C}^{1 \times n_i}$ for all frequency lines, that is:
$$
\mathbf{E}_o(\boldsymbol{\theta}) = \begin{bmatrix}
\boldsymbol{\varepsilon}_o(\omega_1, \boldsymbol{\theta}) \\
\vdots \\
\boldsymbol{\varepsilon}_o(\omega_{n_f}, \boldsymbol{\theta})
\end{bmatrix}
$$

Finally, the coefficients of the numerator and denominator polynomials are estimated by minimizing the following functional:
$$
J(\boldsymbol{\theta}) = \sum_{o=1}^{n_o} \Vert\mathbf{E}_o(\boldsymbol{\theta})\Vert^2.
$$

The poles of the transfer function are obtained from the characteristic polynomial associated with the denominator matrix $\mathbf{D}(\omega)$, by computing the eigenvalues of the so-called companion matrix[^3].

[^3]: M. El-Kafafy, P. Guillaume, B. Peeters, F. Marra, G. Coppotelli. "Advanced Frequency-Domain Modal Analysis for Dealing with Measurement Noise and Parameter Uncertainty". In: Allemang R., De Clerck J., Niezrecki C., Blough J. (eds) Topics in Modal Analysis I, Volume 5. Conference Proceedings of the Society for Experimental Mechanics Series. 2012.

### Stabilization diagram

When carrying out an EMA, the main question that arises is how many modes (or, more precisely, poles) are contained within the frequency band of interest. Analyzing the frequency response functions (transfer functions) provides an initial estimate. However, it is difficult to distinguish between multiple or nearby modes.

The stabilisation diagram is a fundamental EMA tool as it provides a clear and concise presentation of the poles of the system under study. The idea is to adjust the transfer function model by increasing the number of poles and displaying the results on a graph. Broadly speaking, increasing the order of the model (i.e. the number of poles) causes the true vibration modes to converge to a stable value, whereas the numerical modes appear inconsistently or randomly on the graph. Thus, as the poles converge to stable ones, markers appear on the graph to indicate the identified poles, as the order of the model is gradually increased. The selection of poles is generally based on the stability of natural frequencies, modal damping and/or mode shapes, moving from a model order $n$ to an order $n + 1$. In this package, the stability of the natural frequencies and damping ratios is used to identify the physical poles of the system. The stability criterion is set to 1% for the natural frequencies and 5% for the damping ratios, following common practice in the EMA field.

In `StructuralVibration.jl`, the stabilization diagram can be obtained using the `stabilization` function along with any of the Mdof methods described above. The identified stable poles can then be visualized using the `stabilization_plot` function. The `stabilization` function returns an `EMAMdofStabilization` structure that contains all the information related to the stabilization analysis, which allows the user to manually select the appropriate poles and to further analyze (e.g. by using quality and analysis indicators) and visualize the results.

## Mode shapes extraction

Once the poles of the system have been identified using one of the Mdof methods described above, the residues can be computed to extract the mode shapes. In this package, the residues are computed using a least-squares approach based on the formulation of the FRFs as a sum of rational functions. The FRF between an output $p$ ($p = 1, \ldots, n_o$) and an input $q$ ($q = 1, \ldots, n_i$) can be expressed as:
$$
H_{pq}(\omega) = \sum_{i = 1}^n \left(\frac{{}_iR_{pq}}{j\omega - \lambda_i} + \frac{{}_iR_{pq}^\ast}{j\omega - \lambda_i^\ast}\right) - \frac{L_{pq}}{\omega^2} + U_{pq}(\omega),
$$
where $R_{k, pq}$ is the residue associated with the pole $\lambda_k$ and $L_{pq}$ and $U_{pq}$ are the lower and upper residuals, respectively, which account for the effect of the modes outside the frequency band of interest.

At a frequency line $\omega$, the previous equation can be rewritten in matrix form as:
$$
H_{pq}(\omega) = \begin{bmatrix}
\frac{1}{j\omega - \lambda_1} & \ldots & \frac{1}{j\omega - \lambda_n} & \frac{1}{j\omega - \lambda_1^\ast} & \ldots & \frac{1}{j\omega - \lambda_n^\ast} & -\frac{1}{\omega^2} & 1
\end{bmatrix}
\begin{bmatrix}
{}_1R_{pq} \\
\vdots \\
{}_nR_{pq} \\
{}_1R_{pq}^\ast \\
\vdots \\
{}_nR_{pq}^\ast \\
L_{pq} \\
U_{pq}
\end{bmatrix}
$$

Repeating the previous equation for all frequency lines leads to the following system of equations:
$$
\begin{bmatrix}
H_{pq}(\omega_1) \\
H_{pq}(\omega_2) \\
\vdots \\
H_{pq}(\omega_{n_f})
\end{bmatrix}
= \begin{bmatrix}
\frac{1}{j\omega_1 - \lambda_1} & \ldots & \frac{1}{j\omega_1 - \lambda_n} & \frac{1}{j\omega_1 - \lambda_1^\ast} & \ldots & \frac{1}{j\omega_1 - \lambda_n^\ast} & -\frac{1}{\omega_1^2} & 1 \\
\frac{1}{j\omega_2 - \lambda_1} & \ldots & \frac{1}{j\omega_2 - \lambda_n} & \frac{1}{j\omega_2 - \lambda_1^\ast} & \ldots & \frac{1}{j\omega_2 - \lambda_n^\ast} & -\frac{1}{\omega_2^2} & 1 \\
\vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots \\
\frac{1}{j\omega_{n_f} - \lambda_1} & \ldots & \frac{1}{j\omega_{n_f} - \lambda_n} & \frac{1}{j\omega_{n_f} - \lambda_1^\ast} & \ldots & \frac{1}{j\omega_{n_f} - \lambda_n^\ast} & -\frac{1}{\omega_{n_f}^2} & 1
\end{bmatrix}
\begin{bmatrix}
{}_1R_{pq} \\
\vdots \\
{}_nR_{pq} \\
{}_1R_{pq}^\ast \\
\vdots \\
{}_nR_{pq}^\ast \\
L_{pq} \\
U_{pq}
\end{bmatrix}
$$

This system of equations can be solved in the least-squares sense to estimate the residues ${}_iR_{pq}$, as well as the lower and upper residuals $L_{pq}$ and $U_{pq}$. This procedure is implemented in the `mode_residues` function.

From the estimated residues, the mode shapes can be extracted using the following relation:
$$
{}_iR_{pq} = c_i \phi_{p,i} \phi_{q,i},
$$
where $c_i$ is a scaling factor, $\phi_{p,i}$ (resp. nd $\phi_{q,i}$) is the $p$-th (resp. $q$-th) component of the mode shape associated with the $i$-th mode.

To solve for the mode shapes, a collocated measurement is required, i.e. $p = q$. Thus, the mode shape components can be obtained as:
$$
\phi_{p,i} = \sqrt{\frac{{}_iR_{pp}}{c_i}} \; \text{ and } \; \phi_{q,i} = \frac{{}_iR_{pq}}{\sqrt{c_i\; {}_iR_{pp}}}.
$$

Here, the scaling factors $c_i$ can be computed based on a normalization criterion. In this package, the scaling factors are computed such that the modal mass of each mode shape is equal to one (mass normalization). The mode shapes can then be extracted using the `modeshape_extraction` function.

## API

**Data types**

::: {.api}
**EMAMdofProblem**

---
```{julia}
#| echo: false
@doc EMAMdofProblem
```
:::

::: {.api}
**AutoEMAMdofProblem**

---
```{julia}
#| echo: false
@doc AutoEMAMdofProblem
```
:::

::: {.api}
**EMAMdofSolution**

---
```{julia}
#| echo: false
@doc EMAMdofSolution
```
:::

::: {.api}
**EMAMdofStabilization**

---
```{julia}
#| echo: false
@doc EMAMdofStabilization
```
:::

**Related functions**

::: {.api}
**poles_extraction**

---
```{julia}
#| echo: false
@doc poles_extraction(::EMAMdofProblem, ::Int, ::LSCE)
```
:::

::: {.api}
**stabilization**

---
```{julia}
#| echo: false
@doc stabilization(::EMAMdofProblem)
```
:::

::: {.api}
**stabilization_plot**

---
```{julia}
#| echo: false
@doc stabilization_plot(::EMAMdofStabilization)
```
:::

::: {.api}
**mode_residues**

---
```{julia}
#| echo: false
@doc mode_residues(::EMAMdofProblem, ::Vector{T}) where {T <: Complex}
```
:::

::: {.api}
**modeshape_extraction**

---
```{julia}
#| echo: false
@doc modeshape_extraction(::Array{T, 3}, ::Vector{T}, ::Vector{Int}) where {T <: Complex}
```
:::

::: {.api}
**solve**

---
```{julia}
#| echo: false
@doc solve(::AutoEMAMdofProblem)
```
:::

## Example

### Data preparation and FRF calculation
```{julia}
#| output: false
# Structure parameters of the beam
L = 1.        # Length
b = 0.03      # Width
h = 0.01      # Thickness
S = b*h       # Cross-section area
Iz = b*h^3/12 # Moment of inertia

# Material parameters
E = 2.1e11  # Young's modulus
ρ = 7850.   # Density
ξ = 0.01    # Damping ratio

# Mesh
xexc = 0:0.05:L
xm = xexc[2]

# Mode calculation - Simply supported boundary conditions
beam = Beam(L, S, Iz, E, ρ)
fmax = 500.

ωn, kn = modefreq(beam, 2fmax)
ϕexc = modeshape(beam, kn, xexc)
ϕm = modeshape(beam, kn, xm)

# FRF calculation
freq = 1.:0.1:fmax
prob = ModalFRFProblem(ωn, ξ, freq, ϕm, ϕexc)
H = solve(prob; ismat = true).u
```

### Poles extraction

```{julia}
# EMA-MDOF problem
prob_mdof = EMAMdofProblem(H, freq)

# Poles extraction
order = 10 # Model order
p_lsce = poles_extraction(prob_mdof, order, LSCE())
p_lscf = poles_extraction(prob_mdof, order, LSCF())
p_plscf = poles_extraction(prob_mdof, order, PLSCF())

# Stabilization diagram analysis using the LSCE method
stab = stabilization(prob_mdof, order, LSCE())

# Visualization of the stabilization diagram
stabilization_plot(stab)
```
```{julia}
#| echo: false
# Natural frequencies and damping ratios

fn_lsce, dr_lsce = poles2modal(p_lsce)
fn_lscf, dr_lscf = poles2modal(p_lscf)
fn_plscf, dr_plscf = poles2modal(p_plscf)

fig_f = Figure()
ax_f1 = Axis(fig_f[1, 1], title = "Natural frequencies", xlabel = "Mode ID", ylabel = "Natural frequency [Hz]")
ax_f2 = Axis(fig_f[1, 2], title = "Damping ratios", xlabel = "Mode ID", ylabel = "Damping ratio  (%)")

scatter!(ax_f1, 1:4, ωn[1:4]/2π, marker = :rect, markersize = 25, label = "Reference")
scatter!(ax_f1, 1:4, fn_lsce, markersize = 20, label = "LSCE")
scatter!(ax_f1, 1:4, fn_lscf, marker = :star4, markersize = 15, label = "LSCF")
scatter!(ax_f1, 1:4, fn_plscf, marker = :circle, markersize = 10, label = "PLSCF")
axislegend(ax_f1, position = :lt)

scatter!(ax_f2, 1:4, 100ξ*ones(4), marker = :rect, markersize = 25, label = "Reference")
scatter!(ax_f2, 1:4, 100dr_lsce, markersize = 20, label = "LSCE")
scatter!(ax_f2, 1:4, 100dr_lscf, marker = :star4, markersize = 15, label = "LSCF")
scatter!(ax_f2, 1:4, 100dr_plscf, marker = :circle, markersize = 10, label = "PLSCF")

display(fig_f);
```

### Mode shapes extraction

```{julia}
#| output: false

# Driving point indices
dpi = [1, 2]

# Computation of the mode residues
res = mode_residues(prob_mdof, p_lsce)[1]

# Extraction of the mode shapes
ϕ_est = modeshape_extraction(res, p_lsce, dpi, type = :real)[1]

# Convert to real mode shapes
ϕ_est_real = c2r_modeshape(ϕ_est)
```

```{julia}
#| echo: false
# Mode shapes
fig_mode = Figure()
ax_mode1 = Axis(fig_mode[1, 1], title = "Mode shape 1", ylabel = "Value")
ax_mode2 = Axis(fig_mode[1, 2], title = "Mode shape 2")
ax_mode3 = Axis(fig_mode[2, 1], title = "Mode shape 3", xlabel = "Position [m]", ylabel = "Value")
ax_mode4 = Axis(fig_mode[2, 2], title = "Mode shape 4", xlabel = "Position [m]")

lines!(ax_mode1, xexc, ϕexc[:, 1], label = "Reference")
lines!(ax_mode1, xexc, ϕ_est_real[:, 1], linestyle = :dash, label = "Estimated")
xlims!(ax_mode1, 0, L)
axislegend(ax_mode1, position = :cb)

lines!(ax_mode2, xexc, ϕexc[:, 2], label = "Reference")
lines!(ax_mode2, xexc, ϕ_est_real[:, 2], linestyle = :dash, label = "Estimated")
xlims!(ax_mode2, 0, L)

lines!(ax_mode3, xexc, ϕexc[:, 3], label = "Reference")
lines!(ax_mode3, xexc, ϕ_est_real[:, 3], linestyle = :dash, label = "Estimated")
xlims!(ax_mode3, 0, L)

lines!(ax_mode4, xexc, ϕexc[:, 4], label = "Reference")
lines!(ax_mode4, xexc, ϕ_est_real[:, 4], linestyle = :dash, label = "Estimated")
xlims!(ax_mode4, 0, L)

display(fig_mode);
```

### Automatic EMA-MDOF procedure
```{julia}
#| output: false
order = 10
prob_ema = AutoEMAMdofProblem(prob_mdof, order, dpi, LSCE())
sol_ema = solve(prob_ema)
fn_ema, ξn_ema = poles2modal(sol_ema.poles)
ϕn_ema = sol_ema.ms
```