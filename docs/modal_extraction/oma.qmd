---
title: Operational Modal Analysis
format:
  html:
    toc: true
    number-sections: true
engine: julia
execute:
  freeze: auto
  cache: true
---

```{julia}
#| echo: false
#| output: false
using StructuralVibration, ShareAdd
@usingany CairoMakie
```

Operational Modal Analysis (OMA) is a technique used to extract modal parameters of a structure based solely on its response measurements, without requiring knowledge of the input excitation forces. This is particularly useful in scenarios where it is difficult or impossible to measure the input forces, such as in ambient vibration testing of large structures.

From an algorithmic perspective, OMA can be performed using various methods, including EMA-based algorithms or specific OMA techniques such as Stochastic Subspace Identification techniques. In `StructuralVibration.jl`, the following methods are implemented for OMA:

- Sdof method - Frequency-spatial domain decomposition (FSDD)

- Mdof methods:
  - EMA-based methods
  - Stochastic Subspace Identification methods

## Sdof method

The Frequency-Spatial Domain Decomposition (FSDD) method is a single-degree-of-freedom (Sdof) technique used in Operational Modal Analysis (OMA) to extract modal parameters from output-only data[^1]. The FSDD method relies on the fact that in the vicinity of a resonance frequency $\omega_k$, the cross-spectral density (CSD) matrix of the output responses can be approximated by a rank-1 matrix, which corresponds to the dominant mode shape of the structure at that frequency. In particular, this means that the CSD matrix $\mathbf{G}_{yy}(\omega_k)$ can be expressed as:
$$
\mathbf{G}_{yy}(\omega_k) \approx \mathbf{u}_1(\omega_k)\, s_1(\omega_k) \mathbf{u}_1(\omega_k)^H,
$$
where $\mathbf{u}_1(\omega_k)$ is the first singular vector of the CSD matrix, and $s_1(\omega_k)$ is the corresponding singular value.

By noting that the CSD matrix near the resonance frequency can also be expressed in terms of the mode shape $\boldsymbol{\Phi}$ and the power spectral density of the modal coordinate ${G}_{qq}(\omega)$ as:
$$
\mathbf{G}_{yy}(\omega_k) \approx \boldsymbol{\Phi}\boldsymbol{G}_{qq}(\omega_k) \boldsymbol{\Phi}^H,
$$
where $\boldsymbol{G}_{qq}(\omega)$ is dominated by the contribution of the $k$-th mode, we can establish a relationship between the singular vectors and the mode shapes. More specifically, the mode shape $\boldsymbol{\Phi}_k$ at frequency $\omega_k$ is given by the first singular vector:
$$
\boldsymbol{\Phi}_k \approx \mathbf{u}_1(\omega_k).
$$

Once the mode shapes are extracted, the FSDD utilizes the unitary property of the singular vectors to derive an enhanced output PSD $\hat{G}_{yy}(\omega)$, which is a real quantity, in the vicinity of the resonance frequency, such that:
$$
\hat{G}_{yy}(\omega) = \mathbf{u}_1(\omega_k)^H\, \mathbf{G}_{yy}(\omega)\, \mathbf{u}_1(\omega_k) \approx \frac{d_k}{\sigma_k^2 + (\omega - \Omega_k)^2},
$$
where $d_k$ is a constant related to the mode shape normalization, $\sigma_k = -\xi_k\omega_k$ , and $\Omega_k$ is the damped natural angular frequency of the $k$-th mode. By fitting a Sdof model to the enhanced PSD $\hat{G}_{yy}(\omega)$ around the resonance frequency $\omega_k$ using a least-squares approach, the modal parameters (natural frequency and damping ratio) can be estimated.

::: {.callout-note}
The FSDD method is particularly effective for structures with well-separated modes and low damping, as it relies on the dominance of a single mode in the CSD matrix near resonance frequencies. However, it may face challenges when dealing with closely spaced modes or high damping scenarios, where the rank-1 approximation may not hold true.
:::

To perform a robust FSDD, `StructuralVibration.jl` implements two additional steps during the estimation process:

1. Because the signals are often contaminated with noise, the singular vector $\mathbf{u}_1(\omega_k)$ is estimated by averaging the first left-singlular vectors within a frequency band around each resonance frequency. This aims to reduce the effects of noise on the mode shape estimates. During this process, a MAC threshold is used to select only the singular vectors that are sufficiently similar to the reference singular vector at the peak frequency. Said differently, only the singular vectors, for which the first singular value is approximately constant within the frequency band, are considered for the averaging.

    In doing so, we define the so-called Sdof-bell corresponding to the frequencies around each peak where the singular vectors are considered for averaging. It results that the left-singular vector $\mathbf{u}_1(\omega_k)$ is estimated as:
    $$
    \hat{\mathbf{u}}_1(\omega_k) = \frac{\sum_{i=1}^{N_k} w_i\, \mathbf{u}_1(\omega_i)}{\sum_{i=1}^{N_k} w_i},
    $$

    where $N_k$ is the number of selected candidates within the bell and $w_i$ are the weights assigned to each candidate. `StructuralVibration.jl` proposes two types of weights:

    * Uniform weights: $w_i = 1$ corresponding to a linear average of the selected candidates.

    * Singular value-based weights: $w_i = s_1(\omega_i)$. This weighting scheme gives more importance to candidates that are more likely to represent the true mode shape and less importance to those that may be influenced by noise or other factors.

    Knowing the Sdof-bell also allows to define the frequency range around each resonance frequency where the Sdof model is fitted to the enhanced PSD. To do so, the fitting equation is expressed as:
    $$
    \begin{bmatrix}
    \hat{G}_{yy}(\omega) & -2\omega \hat{G}_{yy}(\omega) & -1 \\
    \end{bmatrix} \begin{bmatrix}
    \omega_k^2 \\
    \Omega_k \\
    d_k
    \end{bmatrix} = -\omega^2 \hat{G}_{yy}(\omega)
    $$

    By applying this equation over all frequencies $\omega$ within the Sdof-bell, a least-squares solution can be obtained for the unknowns $\omega_k$, $\Omega_k$, and $d_k$. From these estimates, the poles $p_k$ can be computed as:
    $$
    p_k = -\sqrt{\omega_k^2 - \Omega_k^2} + j \Omega_k,
    $$

2. For lightly damped structures, the least-squares fitting may failed to provide a physical solution due to numerical inaccuracies. In this case, one typically observes that $\Omega_k > \omega_k$, leading to imaginary values for the damping ratio. To overcome this issue, `StructuralVibration.jl` uses the estimation inspired by the Enhanced Frequency Domain Decomposition (EFDD) method[^2].

    The estimation consists in taking the inverse Fourier transform of the enhanced PSD $\hat{G}_{yy}(\omega)$ to obtain the corresponding Autocorrelation function $R(\tau)$ of the Sdof system:
    $$
    R(\tau) \approx C\, e^{-\sigma_k \tau} \cos(\Omega_k \tau).
    $$

    Then, we compute the envelope $E(\tau)$ of the signal using the Hilbert transform, which gives:
    $$
    E(\tau) = C\, e^{-\sigma_k \tau}.
    $$
    By fitting a linear model to the logarithm of the envelope, we can estimate $\sigma_k$ from a least-squares regression.

    Assuming that the damped natural frequency $\Omega_k$ was properly estimated in the initial estimation, the pole $p_k$ can then be estimated as:
    $$
    p_k = -\sigma_k + j \Omega_k.
    $$

[^1]: W. Tong, Z. Lingmi and T. Yukio. "An operational modal analysis method in frequency and spatial domain". Earthquake engineering and engineering vibration, 4(2): 295-300, 2005.

[^2]: R. Brincker, C. E. Ventura and P. Andersen. "Damping estimation by Frequency Domain Decomposition". In Proceedings of IMAC XIX, Orlando, Florida, USA. 2001.

## Mdof methods

### EMA-based methods for OMA

#### General principle

The EMA-based methods for OMA in `StructuralVibration.jl` leverage the existing Mdof EMA algorithms to extract modal parameters from response-only data. For applying these methods, one has to replace the Frequency Response Function by the so-called positive half-spectrum of the response signals.

To obtain the half-spectrum, we start from the full cross-spectral density (CSD) matrix between the output responses $\mathbf{y}$, which is given by:
$$
\mathbf{G}_{yy}(\omega) = \mathbf{H}(\omega) \mathbf{G}_{ff}(\omega) \mathbf{H}^H(\omega),
$$
where $\mathbf{H}(\omega)$ is the Frequency Response Function matrix of the system, $\mathbf{G}_{ff}(\omega)$ is the cross-spectral density matrix of the input forces, and $^H$ denotes the Hermitian transpose.

Generally, OMA relies on the assumption that the input excitation are random white noise processes, implying that $\mathbf{G}_{ff}(\omega) = \mathbf{I}$. Under this assumption, a component of the cross-spectral density matrix $G_{pq}(\omega)$ can be expressed under the poles-residues form as[^3][^4]:
$$
G_{pq}(\omega) = \sum_{i=1}^{n} \left( \frac{{}_iR_{pq}}{j\omega - \lambda_i} + \frac{{}_iR_{pq}^\ast}{j\omega - \lambda_i^\ast} + \frac{{}_iS_{pq}}{-j\omega - \lambda_i} + \frac{{}_iS_{pq}^\ast}{-j\omega - \lambda_i^\ast} \right),
$$
where $\lambda_i$ and (${}_iR_{pq}$, ${}_iS_{pq}$) are the system poles and residues, respectively.

[^3]: R. Brincker and L. Zhang. "Frequency domain decomposition revisited". In PProceedings of the 3rd International Operational Modal Analysis conference (IOMAC), Portonovo, Italy, 2009.

[^4]: B. Peeters and H. Van der Auweraer. "Polymax: A revolution in operational modal analysis". In Proceedings of the 1st International Operational Modal Analysis conference (IOMAC), Copenhagen, Denmark, 2005.

From this definition, the half-spectrum $G_{pq}^+(\omega)$ is defined as the sum of the first two terms in the above expression[^5]:
$$
G_{pq}^+(\omega) = \sum_{i=1}^{n} \left( \frac{{}_iR_{pq}}{j\omega - \lambda_i} + \frac{{}_iR_{pq}^\ast}{j\omega - \lambda_i^\ast} \right).
$$

[^5]: R. Brincker and C. Ventura. "Introduction to Operational Modal Analysis". Wiley, 2015.

In `StructuralVibration.jl`, the half-spectrum can be computed using the `half_csd` function, which can proceed in two different ways. These approaches can be summarized as follows:

- First approach - Post-processing of the full CSD matrix:
  1. Compute the correlation matrix $\mathbf{R}_{yy}(\tau)$ of the response signals by applying an inverse Fourier transform to the CSD matrix $\mathbf{G}_{yy}(\omega)$.

  2. Keep only the positive time lags of the correlation matrix $\mathbf{R}_{yy}^+(\tau)$.

  3. Multiply $\mathbf{R}_{yy}^+(\tau)$ by a flat triangular window and zero-pad the negative time lags of the correlation matrix to obtain a full matrix of the same size as the original correlation matrix (See Ref. [3]). The resulting signal is noted $\tilde{\mathbf{R}}_{yy}^+(\tau)$.

  4. Compute the half-spectrum $\mathbf{G}_{yy}^+(\omega)$ by applying a Fourier transform to $\tilde{\mathbf{R}}_{yy}^+(\tau)$.

- Second approach - Direct computation from time-domain signals:

  1. Compute the discrete directe correlation matrix $\mathbf{R}^+_k$ of the response signals directly from the time-domain data, considering only the positive time lags, using the following formula:
  $$
  \mathbf{R}^+_k = \frac{1}{N - k} \sum_{n=1}^{N-k} \mathbf{y}_n \mathbf{y}_{n+k}^T
  $$
  where $N$ is the total number of samples.

  2. Multiply $\mathbf{R}_k^+$ by a flat triangular window and zero-pad the signal to obtain $\tilde{\mathbf{R}}_k^+$.

  3. Compute the half-spectrum $\mathbf{G}_{yy}^+(\omega)$ by applying a Fourier transform to $\tilde{\mathbf{R}}_k^+$.

:::{.callout-note}
If the length of the time signals are longer than the block size used for the FFT computation, the half-spectrum is computed for each block and then averaged over all blocks.
:::

#### Modal parameters extraction

Once the half-spectrum is computed, the existing Mdof EMA methods in `StructuralVibration.jl` can be directly applied to extract the poles from the half-spectrum data. More details on the usage of these methods can be found in the [Mdof EMA documentation](index.qmd). Regarding the extraction of mode shapes in OMA using EMA-based methods, a procedure similar to the one used in EMA can't be followed since the input forces are unknown. In this case, it is generally assumed that the rank of the residues is equal to 1, allowing to extract the mode shapes from the residues using a Singular Value Decomposition (SVD). Specifically, for a given mode $i$, the residue matrix ${}_i\mathbf{R}$ can be decomposed as:
$$
{}_i\mathbf{R} = \mathbf{U}_i\, \mathbf{S}_i\, \mathbf{V}_i^H,
$$

where $\mathbf{U}_i$ and $\mathbf{V}_i$ are the matrices containing the left and right singular vectors, respectively, and $\mathbf{S}_i$ is the diagonal matrix of singular values. The mode shape $\boldsymbol{\phi}_i$ is then approximated by the first left singular vector corresponding to the highest singular value:
$$
\boldsymbol{\phi}_i \approx \mathbf{U}_{i,1}
$$

where $\mathbf{U}_{i,1}$ is the first column of $\mathbf{U}_i$. However, this assumption may not always hold true, especially in cases where the input excitation is not perfectly white noise or when multiple modes are closely spaced. In this case, more than one singular singular value may be significant, and the mode shape extraction may require additional considerations. In `StructuralVibration.jl`, the following procedure is adopted to extract the mode shapes from the residues:

1. For each mode $i$, compute the SVD of the residue matrix ${}_i\mathbf{R}$ to obtain $\mathbf{U}_i$, $\mathbf{S}_i$.

2. Filter the singular values in $\mathbf{S}_i$ based on a predefined threshold to determine the number $j$ of significant singular values. Here, the threshold is set to 1% of the largest singular value.

3. For the first mode, select $\boldsymbol{\phi}_i = \mathbf{U}_{i,j}$ as the mode shape, based on energy considerations. The selected singular vector corresponds to the highest energy spread. Generally, this will be the first singular vector.

4. For subsequent modes, select the singular vector $\mathbf{U}_{i,j}$ that minimizes the Modal Assurance Criterion (MAC) with respect to the previously extracted mode shapes, ensuring orthogonality and consistency among the extracted modes.

#### Half-spectrum reconstruction

From the identified modal parameters (poles and residues), it is possible to reconstruct the half_spectrum of the system under study using the `half_csd_reconstruction` function. This function implements the following relation for a number $M$ of identified modes:

$$
G_{pq}^+(\omega) = \sum_{i = 1}^{M} \left[\frac{{}_i R_{pq}}{(j\omega - \lambda_i)} + \frac{{}_i R_{pq}^\ast}{(j\omega - \lambda_i^\ast)}\right],
$$

However, as for the FRF reconstruction in EMA, the reconstructed half-spectrum may not perfectly match the original half-spectrum due to modeling errors and noise in the data. To To account for this, it is common to include lower and upper residuals in the FRF reconstruction. This means that the admittance matrix can be expressed as:
$$
G_{pq}^+(\omega) = \sum_{i = 1}^{M} \left[\frac{{}_i R_{pq}}{(j\omega - \lambda_i)} + \frac{{}_i R_{pq}^\ast}{(j\omega - \lambda_i^\ast)}\right] + \frac{L_{pq}}{j\omega} + j\omega\, U_{pq},
$$

where $L_{pq}$ and $U_{pq}$ are the lower and upper residuals, respectively. These residuals can be computed using the `compute_residuals` function.

::: {.callout-note}
As indicated by Peeters and Van der Auweraer in Ref. [2], the lower and upper residuals are independent of the output quantity. More precisely, this means that the residuals terms are always of the form:
$$
\text{Res}_{pq} = \frac{L_{pq}}{j\omega} + j\omega\, U_{pq}.
$$
:::

### Stochastic Subspace Identification methods

Stochastic Subspace Identification (SSI) methods are a class of techniques used in Operational Modal Analysis (OMA) to extract modal parameters from output-only data. These methods are based on the concept of subspace identification, which involves constructing a state-space model of the system from the measured response data. From a mathematical standpoint, the goal is to identify the system matrices $(\mathbf{A}, \mathbf{C})$ of the state-space representation:
$$
\begin{aligned}
\dot{\mathbf{x}}_{k+1} &= \mathbf{A}\, \mathbf{x}_k + \mathbf{w}_k \\
\mathbf{y}_k &= \mathbf{C}\, \mathbf{x}_k + \mathbf{v}_k
\end{aligned}
$$
where $\mathbf{x}_k$ is the state vector, $\mathbf{y}_k$ is the output vector, and $\mathbf{w}_k$ and $\mathbf{v}_k$ are process and measurement noise, respectively. Here, the system matrix $\mathbf{A}$ is the discrete-time state transition matrix that contains information about the system dynamics. If a ZOH discretization is considered, the relationship between the continuous-time system matrix $\mathbf{A}_c$ and the discrete-time system matrix $\mathbf{A}$ is given by:
$$
\mathbf{A} = e^{\mathbf{A}_c T_s}
$$
where $T_s$ is the sampling period. The eigenvalues of $\mathbf{A}$ can be used to extract the continuous-time poles $\lambda_i$ of the system using the following relation:
$$
\lambda_i = \frac{\ln(\mu_i)}{T_s}
$$
where $\mu_i$ are the eigenvalues of $\mathbf{A}$.

The mode shapes $\boldsymbol{\phi}_i$ can be obtained from the output matrix $\mathbf{C}$ and the eigenvectors of $\mathbf{A}$ using the following relation:
$$
\boldsymbol{\phi}_i = \mathbf{C}\, \boldsymbol{\psi}_i
$$
where $\boldsymbol{\psi}_i$ are the eigenvectors of $\mathbf{A}$.

#### Covariance-driven Stochastic Subspace Identification

Covariance-driven Stochastic Subspace Identification (Cov-SSI) is a method that utilizes the covariance of the output data to identify the system matrices. The key steps involved in Cov-SSI are as follows:

1. Compute the covariance matrices $\mathbf{R}_i$ of the output data at different time lags $i$:
  $$
  \mathbf{R}_i = \frac{1}{N - i} \sum_{n = 0}^{N-i} \mathbf{y}_n\, \mathbf{y}_{n+i}^T
  $$

::: {.callout-note}
If a set of reference signals $\mathbf{y}_{ref}$ is provided, the cross-covariance matrices between the output signals and the reference signals are computed instead:
$$
\mathbf{R}_i = \frac{1}{N - i} \sum_{n=0}^{N-i} \mathbf{y}_n\, {\mathbf{y}_{n+i}^\text{ref}}^T
$$
:::

2. Construct a block Toeplitz matrix from the covariance matrices:

  $$
  \mathbf{T} = \begin{bmatrix}
  \mathbf{R}_i & \mathbf{R}_{i-1} & \cdots & \mathbf{R}_1 \\
  \mathbf{R}_{i+1} & \mathbf{R}_i & \ddots & \mathbf{R}_2 \\
  \vdots & \vdots & \ddots & \vdots \\
  \mathbf{R}_{2i-1} & \mathbf{R}_{2i-2} & \cdots & \mathbf{R}_i
  \end{bmatrix}
  $$

3. Compute the observability matrix $\mathbf{O}$ from the SVD of $\mathbf{T}$:
  $$
  \mathbf{O} = \begin{bmatrix}
  \mathbf{C} \\
  \mathbf{C} \mathbf{A} \\
  \mathbf{C} \mathbf{A}^2 \\
  \vdots \\
  \mathbf{C} \mathbf{A}^{i-1}
  \end{bmatrix}
  = \mathbf{U}_n\, \mathbf{S}_n^{1/2},
  $$
  where $\mathbf{U}_n$ and $\mathbf{S}_n$ are the matrices containing the first $n$ left singular vectors and singular values, respectively.

4. Extract the system matrices $\mathbf{A}$ and $\mathbf{C}$ from the Observability matrix
   - The output matrix $\mathbf{C}$ is obtained from the first block row of $\mathbf{O}$.
   - The system matrix $\mathbf{A}$ is obtained by solving the following equation:
  $$
  \mathbf{O}_\text{up}\, \mathbf{A} = \mathbf{O}_\text{down}
  $$
  where $\mathbf{O}_\text{up}$ and $\mathbf{O}_\text{down}$ are derived from the observability matrix removing the last and first block rows, respectively.

#### Data-driven Stochastic Subspace Identification

Data-driven Stochastic Subspace Identification (Data-SSI) is a method that directly utilizes the output data to identify the system matrices without explicitly computing the covariance matrices. The key steps involved in Data-SSI are as follows:

1. Construct a block Hankel matrix from the output data:
  $$
  \mathbf{H} = \frac{1}{\sqrt{j}}\begin{bmatrix}
  \mathbf{y}_0 & \mathbf{y}_1 & \cdots & \mathbf{y}_{j-1} \\
  \mathbf{y}_1 & \mathbf{y}_2 & \cdots & \mathbf{y}_j \\
  \cdots & \cdots & \cdots & \cdots \\
  \mathbf{y}_{i - 1} & \mathbf{y}_i & \cdots & \mathbf{y}_{i+j-2} \\
  \hline
  \mathbf{y}_i & \mathbf{y}_{i+1} & \cdots & \mathbf{y}_{i+j-1} \\
  \mathbf{y}_{i+1} & \mathbf{y}_{i+2} & \cdots & \mathbf{y}_{i+j} \\
  \cdots & \cdots & \cdots & \cdots \\
  \mathbf{y}_{2i - 1} & \mathbf{y}_{2i} & \cdots & \mathbf{y}_{2i+j-2}
  \end{bmatrix} = \begin{bmatrix}
  \mathbf{Y}_p \\
  \hline
  \mathbf{Y}_f
  \end{bmatrix}
  $$

    where $i$ is the number of block rows and $j$ is the number of columns of the Hankel matrix and $\mathbf{Y}_p$ and $\mathbf{Y}_f$ are the past and future output data matrices. respectively.

::: {.callout-note}
If a set of reference signals $\mathbf{y}_{ref}$ is provided, the past data matrix $\mathbf{Y}_p$ is constructed using the reference signals instead of the output signals.
:::

2. Construct the projection of the future output data onto the past output data:
  $$
  \mathbf{P} = \mathbf{Y}_f\, \mathbf{Y}_p^T\, (\mathbf{Y}_p\, \mathbf{Y}_p^T)^+\, \mathbf{Y}_p
  $$

3. Compute the observability matrix $\mathbf{O}$ from the SVD of $\mathbf{P}$.

4. Extract the system matrices $\mathbf{A}$ and $\mathbf{C}$ from the observability matrix as described in the Cov-SSI method.

## API

**Data types**

::: {.api}
```{julia}
#| echo: false
@doc OMAProblem
```
:::

::: {.api}
```{julia}
#| echo: false
@doc FSDD
```
:::

::: {.api}
```{julia}
#| echo: false
@doc CovSSI
```
:::

::: {.api}
```{julia}
#| echo: false
@doc DataSSI
```
:::

**Related functions**

::: {.api}
**xcorr**

---
```{julia}
#| echo: false
@doc xcorr
```
:::

::: {.api}
**half_csd**

---
```{julia}
#| echo: false
@doc half_csd
```
:::

::: {.api}
**csd_from_tf**

---
```{julia}
#| echo: false
@doc csd_from_tf
```
:::

::: {.api}
**convert_csd**

---
```{julia}
#| echo: false
@doc convert_csd
```
:::

::: {.api}
**poles_extraction**

---
```{julia}
#| echo: false
@doc poles_extraction(::OMAProblem, order::Int, method::StructuralVibration.MdofOMA)
```
:::

::: {.api}
**modes_extraction**

---
```{julia}
#| echo: false
@doc modes_extraction
```
:::

::: {.api}
**half_csd_reconstruction**

---
```{julia}
#| echo: false
@doc half_csd_reconstruction
```
:::

::: {.api}
**compute_residuals**

---
```{julia}
#| echo: false
@doc compute_residuals(::OMAProblem)
```
:::

## Example

### Data preparation

```{julia}
#| output: false
# Structure parameters of the beam
L = 1.        # Length
b = 0.03      # Width
h = 0.01      # Thickness
S = b*h       # Cross-section area
Iz = b*h^3/12 # Moment of inertia

# Material parameters
E = 2.1e11  # Young's modulus
ρ = 7850.   # Density
ξ = 0.01    # Damping ratio

# Mesh
x = 0:0.05:L

# Acquisition parameters
sample_rate = 4096
block_size = 4096
fft_params = FFTParameters(sample_rate, block_size)

freq = fft_params.freq
t = fft_params.t
dt = fft_params.dt

# Mode calculation - Simply supported boundary conditions
beam = Beam(L, S, Iz, E, ρ)
ωn, kn = modefreq(beam, 2freq[end])
ms_ref = modeshape(beam, kn, x)

# Chirp excitation
F0 = 10.
chirp = SweptSine(F0, t[1], 0.8t[end], freq[1], freq[end], zero_end = true)
force = zeros(length(x), length(t))
force[2, :] .= excitation(chirp, t)

# Response calculation
prob = ForcedModalTimeProblem(ωn, ms_ref, ξ*ones(length(kn)), ms_ref'force, (zeros(length(x)), zeros(length(x))), t)
y = solve(prob).u

# OMA problem definition
tukeywin(x) = tukey(x, 0.5)
prob_oma = OMAProblem(y, t, sample_rate, block_size, win = tukeywin, frange = [1., 1000.])
```

### Frequency-spatial Domain Decomposition

```{julia}
#| output: false

pks_indices = [23, 94, 211, 375, 586, 845]
p_fsdd, ms_fsdd = modes_extraction(prob_oma, FSDD(), pks_indices = pks_indices)
ms_fsdd_real = real_normalization(ms_fsdd)

# Mode shape scaling for comparison using the modal scale factor
scaling = msf(ms_fsdd_real, ms_ref[:, 1:size(ms_fsdd_real, 2)])
ms_fsdd_scaled = ms_fsdd_real .* scaling'
```

```{julia}
#| echo: false

# Natural frequencies and damping ratios
fn_fsdd, dr_fsdd = poles2modal(p_fsdd)

fig_f = Figure()
ax_f1 = Axis(fig_f[1, 1], title = "Natural frequencies", xlabel = "Mode ID", ylabel = "Natural frequency (Hz)")
ax_f2 = Axis(fig_f[1, 2], title = "Damping ratios", xlabel = "Mode ID", ylabel = "Damping ratio  (%)")

scatter!(ax_f1, 1:6, ωn[1:6]/2π, marker = :rect, markersize = 25, label = "Reference")
scatter!(ax_f1, 1:6, fn_fsdd, markersize = 20, label = "FSDD")
axislegend(ax_f1, position = :lt)

scatter!(ax_f2, 1:6, 100ξ*ones(6), marker = :rect, markersize = 25, label = "Reference")
scatter!(ax_f2, 1:6, 100dr_fsdd, markersize = 20, label = "FSDD")

display(fig_f);
```

```{julia}
#| echo: false

# Mode shapes
fig_mode = Figure()
ax_mode1 = Axis(fig_mode[1, 1], title = "Mode shape 1", ylabel = "Value")
ax_mode2 = Axis(fig_mode[1, 2], title = "Mode shape 2")
ax_mode3 = Axis(fig_mode[2, 1], title = "Mode shape 3", xlabel = "Position (m)", ylabel = "Value")
ax_mode4 = Axis(fig_mode[2, 2], title = "Mode shape 4", xlabel = "Position (m)")

lines!(ax_mode1, x, ms_ref[:, 1], label = "Reference")
lines!(ax_mode1, x, ms_fsdd_scaled[:, 1], linestyle = :dash, label = "Estimated")
xlims!(ax_mode1, 0, L)
axislegend(ax_mode1, position = :cb)

lines!(ax_mode2, x, ms_ref[:, 2], label = "Reference")
lines!(ax_mode2, x, ms_fsdd_scaled[:, 2], linestyle = :dash, label = "Estimated")
xlims!(ax_mode2, 0, L)

lines!(ax_mode3, x, ms_ref[:, 3], label = "Reference")
lines!(ax_mode3, x, ms_fsdd_scaled[:, 3], linestyle = :dash, label = "Estimated")
xlims!(ax_mode3, 0, L)

lines!(ax_mode4, x, ms_ref[:, 4], label = "Reference")
lines!(ax_mode4, x, ms_fsdd_scaled[:, 4], linestyle = :dash, label = "Estimated")
xlims!(ax_mode4, 0, L)

display(fig_mode);
```

### EMA-based OMA

#### Poles extraction using LSCF
```{julia}
#| output: false

# EMA-MDOF pole stability analysis
sol_stab = stabilization(prob_oma, 30, LSCF())

# Extraction of stable poles
stab_poles = sol_stab.poles[end][.!isnan.(sol_stab.poles[end])]

# Plot stabilization diagram
stabilization_plot(sol_stab)
```

```{julia}
#| echo: false
# Natural frequencies and damping ratios
fn_lscf, dr_lscf = poles2modal(stab_poles)

fig_f = Figure()
ax_f1 = Axis(fig_f[1, 1], title = "Natural frequencies", xlabel = "Mode ID", ylabel = "Natural frequency (Hz)")
ax_f2 = Axis(fig_f[1, 2], title = "Damping ratios", xlabel = "Mode ID", ylabel = "Damping ratio  (%)")

scatter!(ax_f1, 1:6, ωn[1:6]/2π, marker = :rect, markersize = 25, label = "Reference")
scatter!(ax_f1, 1:6, fn_lscf, markersize = 20, label = "LSCF")
axislegend(ax_f1, position = :lt)

scatter!(ax_f2, 1:6, 100ξ*ones(6), marker = :rect, markersize = 25, label = "Reference")
scatter!(ax_f2, 1:6, 100dr_lscf, markersize = 20, label = "LSCF")

display(fig_f);
```

#### Mode shapes extraction
```{julia}
#| output: false

# Computation of the mode residues
res = mode_residues(prob_oma, stab_poles)

# Extraction of the mode shapes
ms_ema = modeshape_extraction(res, stab_poles, LSCF(), modetype = :oma)[1]

# Convert to real mode shapes
ms_ema_real = real_normalization(ms_ema)

# Mode shape scaling for comparison using the modal scale factor
scaling = msf(ms_ema_real, ms_ref[:, 1:size(ms_ema_real, 2)])
ms_ema_scaled = ms_ema_real .* scaling'
```

```{julia}
#| echo: false

# Mode shapes
fig_mode = Figure()
ax_mode1 = Axis(fig_mode[1, 1], title = "Mode shape 1", ylabel = "Value")
ax_mode2 = Axis(fig_mode[1, 2], title = "Mode shape 2")
ax_mode3 = Axis(fig_mode[2, 1], title = "Mode shape 3", xlabel = "Position (m)", ylabel = "Value")
ax_mode4 = Axis(fig_mode[2, 2], title = "Mode shape 4", xlabel = "Position (m)")

lines!(ax_mode1, x, ms_ref[:, 1], label = "Reference")
lines!(ax_mode1, x, ms_ema_scaled[:, 1], linestyle = :dash, label = "Estimated")
xlims!(ax_mode1, 0, L)
axislegend(ax_mode1, position = :cb)

lines!(ax_mode2, x, ms_ref[:, 2], label = "Reference")
lines!(ax_mode2, x, ms_ema_scaled[:, 2], linestyle = :dash, label = "Estimated")
xlims!(ax_mode2, 0, L)

lines!(ax_mode3, x, ms_ref[:, 3], label = "Reference")
lines!(ax_mode3, x, ms_ema_scaled[:, 3], linestyle = :dash, label = "Estimated")
xlims!(ax_mode3, 0, L)

lines!(ax_mode4, x, ms_ref[:, 4], label = "Reference")
lines!(ax_mode4, x, ms_ema_scaled[:, 4], linestyle = :dash, label = "Estimated")
xlims!(ax_mode4, 0, L)

display(fig_mode);
```

#### Half-spectrum reconstruction

```{julia}
#| output: false

# Half-spectrum reconstruction - without residuals
Syy = half_csd_reconstruction(res, stab_poles, prob_oma.freq)

# Half-spectrum reconstruction - with residuals
lr, ur = compute_residuals(prob_oma, res, stab_poles)
Syy2 = half_csd_reconstruction(res, stab_poles, prob_oma.freq, lr = lr, ur = ur)
```

```{julia}
#| echo: false
fig = Figure()
ax = Axis(fig[1, 1], xlabel = "Frequency (Hz)", ylabel = "Half-spectrum (dB, ref: 1 m²)", title = "FRF Reconstruction using Sdof method")
lines!(ax, prob_oma.freq, 10log10.(abs.(prob_oma.halfspec[2, 2, :])), label = "Original Half-spectrum")
lines!(ax, prob_oma.freq, 10log10.(abs.(Syy[2, 2, :])); linestyle = :dash, label = "Reconstructed Half-spectrum (no residuals)")
lines!(ax, prob_oma.freq, 10log10.(abs.(Syy2[2, 2, :])); linestyle = :dot, label = "Reconstructed Half-spectrum (with residuals)")
xlims!(ax, prob_oma.freq[1], prob_oma.freq[end])
axislegend(ax; position = :rt)

display(fig);
```

### Covariance-driven Stochastic Subspace Identification

```{julia}
# Stabilization analysis
sol_stab_cssi = stabilization(prob_oma, 30, CovSSI())

# Plot stabilization diagram
stabilization_plot(sol_stab_cssi)
```


```{julia}
#| output: false

# Extraction of stable modes
p_cssi, ms_cssi = modes_extraction(prob_oma, 30, CovSSI())
ms_cssi_real = real_normalization(ms_cssi)

# Mode shape scaling for comparison using the modal scale factor
scaling = msf(ms_cssi_real, ms_ref[:, 1:size(ms_cssi_real, 2)])
ms_cssi_scaled = ms_cssi_real .* scaling'
```

```{julia}
#| echo: false

# Natural frequencies and damping ratios
fn_cssi, dr_cssi = poles2modal(p_cssi)

fig_f = Figure()
ax_f1 = Axis(fig_f[1, 1], title = "Natural frequencies", xlabel = "Mode ID", ylabel = "Natural frequency (Hz)")
ax_f2 = Axis(fig_f[1, 2], title = "Damping ratios", xlabel = "Mode ID", ylabel = "Damping ratio  (%)")

scatter!(ax_f1, 1:6, ωn[1:6]/2π, marker = :rect, markersize = 25, label = "Reference")
scatter!(ax_f1, 1:6, fn_cssi, markersize = 20, label = "Cov-SSI")
axislegend(ax_f1, position = :lt)

scatter!(ax_f2, 1:6, 100ξ*ones(6), marker = :rect, markersize = 25, label = "Reference")
scatter!(ax_f2, 1:6, 100dr_cssi, markersize = 20, label = "Cov-SSI")

display(fig_f);
```

```{julia}
#| echo: false

# Mode shapes
fig_mode = Figure()
ax_mode1 = Axis(fig_mode[1, 1], title = "Mode shape 1", ylabel = "Value")
ax_mode2 = Axis(fig_mode[1, 2], title = "Mode shape 2")
ax_mode3 = Axis(fig_mode[2, 1], title = "Mode shape 3", xlabel = "Position (m)", ylabel = "Value")
ax_mode4 = Axis(fig_mode[2, 2], title = "Mode shape 4", xlabel = "Position (m)")

lines!(ax_mode1, x, ms_ref[:, 1], label = "Reference")
lines!(ax_mode1, x, ms_cssi_scaled[:, 1], linestyle = :dash, label = "Estimated")
xlims!(ax_mode1, 0, L)
axislegend(ax_mode1, position = :cb)

lines!(ax_mode2, x, ms_ref[:, 2], label = "Reference")
lines!(ax_mode2, x, ms_cssi_scaled[:, 2], linestyle = :dash, label = "Estimated")
xlims!(ax_mode2, 0, L)

lines!(ax_mode3, x, ms_ref[:, 3], label = "Reference")
lines!(ax_mode3, x, ms_cssi_scaled[:, 3], linestyle = :dash, label = "Estimated")
xlims!(ax_mode3, 0, L)

lines!(ax_mode4, x, ms_ref[:, 4], label = "Reference")
lines!(ax_mode4, x, ms_cssi_scaled[:, 4], linestyle = :dash, label = "Estimated")
xlims!(ax_mode4, 0, L)

display(fig_mode);
```

### Data-driven Stochastic Subspace Identification

```{julia}
# Stabilization analysis
sol_stab_dssi = stabilization(prob_oma, 30, DataSSI())

# Plot stabilization diagram
stabilization_plot(sol_stab_dssi)
```


```{julia}
#| output: false

# Extraction of stable modes
p_dssi, ms_dssi = modes_extraction(prob_oma, 30, DataSSI())
ms_dssi_real = real_normalization(ms_dssi)

# Mode shape scaling for comparison using the modal scale factor
scaling = msf(ms_dssi_real, ms_ref[:, 1:size(ms_dssi_real, 2)])
ms_dssi_scaled = ms_dssi_real .* scaling'
```

```{julia}
#| echo: false

# Natural frequencies and damping ratios
fn_dssi, dr_dssi = poles2modal(p_dssi)

fig_f = Figure()
ax_f1 = Axis(fig_f[1, 1], title = "Natural frequencies", xlabel = "Mode ID", ylabel = "Natural frequency (Hz)")
ax_f2 = Axis(fig_f[1, 2], title = "Damping ratios", xlabel = "Mode ID", ylabel = "Damping ratio  (%)")

scatter!(ax_f1, 1:6, ωn[1:6]/2π, marker = :rect, markersize = 25, label = "Reference")
scatter!(ax_f1, 1:6, fn_dssi, markersize = 20, label = "Data-SSI")
axislegend(ax_f1, position = :lt)

scatter!(ax_f2, 1:6, 100ξ*ones(6), marker = :rect, markersize = 25, label = "Reference")
scatter!(ax_f2, 1:6, 100dr_dssi, markersize = 20, label = "Cov-SSI")

display(fig_f);
```

```{julia}
#| echo: false

# Mode shapes
fig_mode = Figure()
ax_mode1 = Axis(fig_mode[1, 1], title = "Mode shape 1", ylabel = "Value")
ax_mode2 = Axis(fig_mode[1, 2], title = "Mode shape 2")
ax_mode3 = Axis(fig_mode[2, 1], title = "Mode shape 3", xlabel = "Position (m)", ylabel = "Value")
ax_mode4 = Axis(fig_mode[2, 2], title = "Mode shape 4", xlabel = "Position (m)")

lines!(ax_mode1, x, ms_ref[:, 1], label = "Reference")
lines!(ax_mode1, x, ms_dssi_scaled[:, 1], linestyle = :dash, label = "Estimated")
xlims!(ax_mode1, 0, L)
axislegend(ax_mode1, position = :cb)

lines!(ax_mode2, x, ms_ref[:, 2], label = "Reference")
lines!(ax_mode2, x, ms_dssi_scaled[:, 2], linestyle = :dash, label = "Estimated")
xlims!(ax_mode2, 0, L)

lines!(ax_mode3, x, ms_ref[:, 3], label = "Reference")
lines!(ax_mode3, x, ms_dssi_scaled[:, 3], linestyle = :dash, label = "Estimated")
xlims!(ax_mode3, 0, L)

lines!(ax_mode4, x, ms_ref[:, 4], label = "Reference")
lines!(ax_mode4, x, ms_dssi_scaled[:, 4], linestyle = :dash, label = "Estimated")
xlims!(ax_mode4, 0, L)

display(fig_mode);
```