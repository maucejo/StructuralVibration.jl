{
    "cells": [
        {
            "id": "1",
            "cell_type": "markdown",
            "metadata": {
            },
            "source": [
                "---\n",
                "title: Experimental Modal Analysis\n",
                "format:\n",
                "  html:\n",
                "    toc: true\n",
                "    number-sections: true\n",
                "engine: julia\n",
                "execute:\n",
                "  freeze: auto\n",
                "  cache: true\n",
                "---"
            ]
        },
        {
            "id": "2",
            "cell_type": "code",
            "metadata": {
            },
            "source": [
                "#| echo: false\n",
                "#| output: false\n",
                "using StructuralVibration, ShareAdd\n",
                "@usingany CairoMakie"
            ],
            "outputs": [
                {
                    "output_type": "stream",
                    "name": "stdout",
                    "text": "\u001b[91m\u001b[1m┌ \u001b[22m\u001b[39m\u001b[91m\u001b[1mError: \u001b[22m\u001b[39mError during loading of extension QuartoNotebookWorkerMakieExt of QuartoNotebookWorker, use `Base.retry_load_extensions()` to retry.\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m  exception =\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[0m1-element ExceptionStack:\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   InitError: MethodError: no method matching isless(::Nothing, ::VersionNumber)\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   The function `isless` exists, but no method is defined for this combination of argument types.\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[0mClosest candidates are:\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[0m  isless(\u001b[91m::VersionNumber\u001b[39m, ::VersionNumber)\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[0m\u001b[90m   @\u001b[39m \u001b[90mBase\u001b[39m \u001b[90m\u001b[4mversion.jl:201\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[0m  isless(\u001b[91m::Missing\u001b[39m, ::Any)\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[0m\u001b[90m   @\u001b[39m \u001b[90mBase\u001b[39m \u001b[90m\u001b[4mmissing.jl:87\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[0m  isless(::Any, \u001b[91m::Missing\u001b[39m)\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[0m\u001b[90m   @\u001b[39m \u001b[90mBase\u001b[39m \u001b[90m\u001b[4mmissing.jl:88\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[0m  ...\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   Stacktrace:\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m     [1] \u001b[0m\u001b[1m<\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[90mx\u001b[39m::\u001b[0mNothing, \u001b[90my\u001b[39m::\u001b[0mVersionNumber\u001b[0m\u001b[1m)\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[90mBase\u001b[39m \u001b[90m./\u001b[39m\u001b[90m\u001b[4moperators.jl:399\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m     [2] \u001b[0m\u001b[1mconfigure\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[0m\u001b[1m)\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[36mQuartoNotebookWorkerMakieExt\u001b[39m \u001b[90m~/.julia/packages/QuartoNotebookRunner/7xf1K/src/QuartoNotebookWorker/ext/\u001b[39m\u001b[90m\u001b[4mQuartoNotebookWorkerMakieExt.jl:22\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m     [3] \u001b[0m\u001b[1m__init__\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[0m\u001b[1m)\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[36mQuartoNotebookWorkerMakieExt\u001b[39m \u001b[90m~/.julia/packages/QuartoNotebookRunner/7xf1K/src/QuartoNotebookWorker/ext/\u001b[39m\u001b[90m\u001b[4mQuartoNotebookWorkerMakieExt.jl:32\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m     [4] \u001b[0m\u001b[1mrun_module_init\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[90mmod\u001b[39m::\u001b[0mModule, \u001b[90mi\u001b[39m::\u001b[0mInt64\u001b[0m\u001b[1m)\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[90mBase\u001b[39m \u001b[90m./\u001b[39m\u001b[90m\u001b[4mloading.jl:1415\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m     [5] \u001b[0m\u001b[1mregister_restored_modules\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[90msv\u001b[39m::\u001b[0mCore.SimpleVector, \u001b[90mpkg\u001b[39m::\u001b[0mBase.PkgId, \u001b[90mpath\u001b[39m::\u001b[0mString\u001b[0m\u001b[1m)\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[90mBase\u001b[39m \u001b[90m./\u001b[39m\u001b[90m\u001b[4mloading.jl:1403\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m     [6] \u001b[0m\u001b[1m_include_from_serialized\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[90mpkg\u001b[39m::\u001b[0mBase.PkgId, \u001b[90mpath\u001b[39m::\u001b[0mString, \u001b[90mocachepath\u001b[39m::\u001b[0mString, \u001b[90mdepmods\u001b[39m::\u001b[0mVector\u001b[90m{Any}\u001b[39m; \u001b[90mregister\u001b[39m::\u001b[0mBool\u001b[0m\u001b[1m)\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[90mBase\u001b[39m \u001b[90m./\u001b[39m\u001b[90m\u001b[4mloading.jl:1291\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m     [7] \u001b[0m\u001b[1m_include_from_serialized\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[90m./\u001b[39m\u001b[90m\u001b[4mloading.jl:1246\u001b[24m\u001b[39m\u001b[90m [inlined]\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m     [8] \u001b[0m\u001b[1m_require_search_from_serialized\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[90mpkg\u001b[39m::\u001b[0mBase.PkgId, \u001b[90msourcepath\u001b[39m::\u001b[0mString, \u001b[90mbuild_id\u001b[39m::\u001b[0mUInt128, \u001b[90mstalecheck\u001b[39m::\u001b[0mBool; \u001b[90mreasons\u001b[39m::\u001b[0mDict\u001b[90m{String, Int64}\u001b[39m, \u001b[90mDEPOT_PATH\u001b[39m::\u001b[0mVector\u001b[90m{String}\u001b[39m\u001b[0m\u001b[1m)\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[90mBase\u001b[39m \u001b[90m./\u001b[39m\u001b[90m\u001b[4mloading.jl:2087\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m     [9] \u001b[0m\u001b[1m__require_prelocked\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[90mpkg\u001b[39m::\u001b[0mBase.PkgId, \u001b[90menv\u001b[39m::\u001b[0mNothing\u001b[0m\u001b[1m)\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[90mBase\u001b[39m \u001b[90m./\u001b[39m\u001b[90m\u001b[4mloading.jl:2599\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [10] \u001b[0m\u001b[1m_require_prelocked\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[90muuidkey\u001b[39m::\u001b[0mBase.PkgId, \u001b[90menv\u001b[39m::\u001b[0mNothing\u001b[0m\u001b[1m)\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[90mBase\u001b[39m \u001b[90m./\u001b[39m\u001b[90m\u001b[4mloading.jl:2465\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [11] \u001b[0m\u001b[1m_require_prelocked\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[90muuidkey\u001b[39m::\u001b[0mBase.PkgId\u001b[0m\u001b[1m)\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[90mBase\u001b[39m \u001b[90m./\u001b[39m\u001b[90m\u001b[4mloading.jl:2459\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [12] \u001b[0m\u001b[1mrun_extension_callbacks\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[90mextid\u001b[39m::\u001b[0mBase.ExtensionId\u001b[0m\u001b[1m)\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[90mBase\u001b[39m \u001b[90m./\u001b[39m\u001b[90m\u001b[4mloading.jl:1579\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [13] \u001b[0m\u001b[1mrun_extension_callbacks\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[90mpkgid\u001b[39m::\u001b[0mBase.PkgId\u001b[0m\u001b[1m)\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[90mBase\u001b[39m \u001b[90m./\u001b[39m\u001b[90m\u001b[4mloading.jl:1616\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [14] \u001b[0m\u001b[1mrun_package_callbacks\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[90mmodkey\u001b[39m::\u001b[0mBase.PkgId\u001b[0m\u001b[1m)\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[90mBase\u001b[39m \u001b[90m./\u001b[39m\u001b[90m\u001b[4mloading.jl:1432\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [15] \u001b[0m\u001b[1m_require_search_from_serialized\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[90mpkg\u001b[39m::\u001b[0mBase.PkgId, \u001b[90msourcepath\u001b[39m::\u001b[0mString, \u001b[90mbuild_id\u001b[39m::\u001b[0mUInt128, \u001b[90mstalecheck\u001b[39m::\u001b[0mBool; \u001b[90mreasons\u001b[39m::\u001b[0mDict\u001b[90m{String, Int64}\u001b[39m, \u001b[90mDEPOT_PATH\u001b[39m::\u001b[0mVector\u001b[90m{String}\u001b[39m\u001b[0m\u001b[1m)\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[90mBase\u001b[39m \u001b[90m./\u001b[39m\u001b[90m\u001b[4mloading.jl:2106\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [16] \u001b[0m\u001b[1m_require_search_from_serialized\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[90m./\u001b[39m\u001b[90m\u001b[4mloading.jl:1981\u001b[24m\u001b[39m\u001b[90m [inlined]\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [17] \u001b[0m\u001b[1m__require_prelocked\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[90mpkg\u001b[39m::\u001b[0mBase.PkgId, \u001b[90menv\u001b[39m::\u001b[0mString\u001b[0m\u001b[1m)\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[90mBase\u001b[39m \u001b[90m./\u001b[39m\u001b[90m\u001b[4mloading.jl:2599\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [18] \u001b[0m\u001b[1m_require_prelocked\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[90muuidkey\u001b[39m::\u001b[0mBase.PkgId, \u001b[90menv\u001b[39m::\u001b[0mString\u001b[0m\u001b[1m)\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[90mBase\u001b[39m \u001b[90m./\u001b[39m\u001b[90m\u001b[4mloading.jl:2465\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [19] \u001b[0m\u001b[1mmacro expansion\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[90m./\u001b[39m\u001b[90m\u001b[4mloading.jl:2393\u001b[24m\u001b[39m\u001b[90m [inlined]\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [20] \u001b[0m\u001b[1mmacro expansion\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[90m./\u001b[39m\u001b[90m\u001b[4mlock.jl:376\u001b[24m\u001b[39m\u001b[90m [inlined]\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [21] \u001b[0m\u001b[1m__require\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[90minto\u001b[39m::\u001b[0mModule, \u001b[90mmod\u001b[39m::\u001b[0mSymbol\u001b[0m\u001b[1m)\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[90mBase\u001b[39m \u001b[90m./\u001b[39m\u001b[90m\u001b[4mloading.jl:2358\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [22] \u001b[0m\u001b[1mrequire\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[90minto\u001b[39m::\u001b[0mModule, \u001b[90mmod\u001b[39m::\u001b[0mSymbol\u001b[0m\u001b[1m)\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[90mBase\u001b[39m \u001b[90m./\u001b[39m\u001b[90m\u001b[4mloading.jl:2334\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [23] top-level scope\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[90m~/Documents/01_Recherche/04_Projets/Codes/Julia/StructuralVibration/docs/modal_extraction/\u001b[39m\u001b[90m\u001b[4mindex.qmd:17\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [24] \u001b[0m\u001b[1meval\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[90mm\u001b[39m::\u001b[0mModule, \u001b[90me\u001b[39m::\u001b[0mAny\u001b[0m\u001b[1m)\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[90mCore\u001b[39m \u001b[90m./\u001b[39m\u001b[90m\u001b[4mboot.jl:489\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [25] \u001b[0m\u001b[1m(::QuartoNotebookWorker.var\"#21#22\"{Module, Expr})\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[0m\u001b[1m)\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[32mQuartoNotebookWorker\u001b[39m \u001b[90m~/.julia/packages/QuartoNotebookRunner/7xf1K/src/QuartoNotebookWorker/src/\u001b[39m\u001b[90m\u001b[4mrender.jl:222\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [26] \u001b[0m\u001b[1m(::QuartoNotebookWorker.Packages.IOCapture.var\"#12#13\"{Type{InterruptException}, QuartoNotebookWorker.var\"#21#22\"{Module, Expr}, IOContext{Base.PipeEndpoint}, IOContext{Base.PipeEndpoint}, IOContext{Base.PipeEndpoint}, IOContext{Base.PipeEndpoint}})\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[0m\u001b[1m)\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[32mQuartoNotebookWorker.Packages.IOCapture\u001b[39m \u001b[90m~/.julia/packages/QuartoNotebookRunner/7xf1K/src/QuartoNotebookWorker/src/vendor/IOCapture/src/\u001b[39m\u001b[90m\u001b[4mIOCapture.jl:170\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [27] \u001b[0m\u001b[1mwith_logstate\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[90mf\u001b[39m::\u001b[0mQuartoNotebookWorker.Packages.IOCapture.var\"#12#13\"\u001b[90m{Type{InterruptException}, QuartoNotebookWorker.var\"#21#22\"{Module, Expr}, IOContext{Base.PipeEndpoint}, IOContext{Base.PipeEndpoint}, IOContext{Base.PipeEndpoint}, IOContext{Base.PipeEndpoint}}\u001b[39m, \u001b[90mlogstate\u001b[39m::\u001b[0mBase.CoreLogging.LogState\u001b[0m\u001b[1m)\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[90mBase.CoreLogging\u001b[39m \u001b[90m./logging/\u001b[39m\u001b[90m\u001b[4mlogging.jl:540\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [28] \u001b[0m\u001b[1mwith_logger\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[90mf\u001b[39m::\u001b[0mFunction, \u001b[90mlogger\u001b[39m::\u001b[0mBase.CoreLogging.ConsoleLogger\u001b[0m\u001b[1m)\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[90mBase.CoreLogging\u001b[39m \u001b[90m./logging/\u001b[39m\u001b[90m\u001b[4mlogging.jl:651\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [29] \u001b[0m\u001b[1mcapture\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[90mf\u001b[39m::\u001b[0mQuartoNotebookWorker.var\"#21#22\"\u001b[90m{Module, Expr}\u001b[39m; \u001b[90mrethrow\u001b[39m::\u001b[0mType, \u001b[90mcolor\u001b[39m::\u001b[0mBool, \u001b[90mpassthrough\u001b[39m::\u001b[0mBool, \u001b[90mcapture_buffer\u001b[39m::\u001b[0mIOBuffer, \u001b[90mio_context\u001b[39m::\u001b[0mVector\u001b[90m{Pair{Symbol, Any}}\u001b[39m\u001b[0m\u001b[1m)\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[32mQuartoNotebookWorker.Packages.IOCapture\u001b[39m \u001b[90m~/.julia/packages/QuartoNotebookRunner/7xf1K/src/QuartoNotebookWorker/src/vendor/IOCapture/src/\u001b[39m\u001b[90m\u001b[4mIOCapture.jl:167\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [30] \u001b[0m\u001b[1mcapture\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[90m~/.julia/packages/QuartoNotebookRunner/7xf1K/src/QuartoNotebookWorker/src/\u001b[39m\u001b[90m\u001b[4mrender.jl:248\u001b[24m\u001b[39m\u001b[90m [inlined]\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [31] \u001b[0m\u001b[1mio_capture\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[90mf\u001b[39m::\u001b[0mFunction; \u001b[90mcell_options\u001b[39m::\u001b[0mDict\u001b[90m{Any, Any}\u001b[39m, \u001b[90mkws\u001b[39m::\u001b[0m@Kwargs\u001b[90m{rethrow::DataType, color::Bool, io_context::Vector{Pair{Symbol, Any}}}\u001b[39m\u001b[0m\u001b[1m)\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[32mQuartoNotebookWorker\u001b[39m \u001b[90m~/.julia/packages/QuartoNotebookRunner/7xf1K/src/QuartoNotebookWorker/src/\u001b[39m\u001b[90m\u001b[4mrender.jl:250\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [32] \u001b[0m\u001b[1mio_capture\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[90m~/.julia/packages/QuartoNotebookRunner/7xf1K/src/QuartoNotebookWorker/src/\u001b[39m\u001b[90m\u001b[4mrender.jl:246\u001b[24m\u001b[39m\u001b[90m [inlined]\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [33] \u001b[0m\u001b[1minclude_str\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[90mmod\u001b[39m::\u001b[0mModule, \u001b[90mcode\u001b[39m::\u001b[0mString; \u001b[90mfile\u001b[39m::\u001b[0mString, \u001b[90mline\u001b[39m::\u001b[0mInt64, \u001b[90mcell_options\u001b[39m::\u001b[0mDict\u001b[90m{Any, Any}\u001b[39m\u001b[0m\u001b[1m)\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[32mQuartoNotebookWorker\u001b[39m \u001b[90m~/.julia/packages/QuartoNotebookRunner/7xf1K/src/QuartoNotebookWorker/src/\u001b[39m\u001b[90m\u001b[4mrender.jl:201\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [34] \u001b[0m\u001b[1m#invokelatest_gr#232\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[90m./\u001b[39m\u001b[90m\u001b[4mreflection.jl:1282\u001b[24m\u001b[39m\u001b[90m [inlined]\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [35] \u001b[0m\u001b[1minvokelatest_gr\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[90m./\u001b[39m\u001b[90m\u001b[4mreflection.jl:1274\u001b[24m\u001b[39m\u001b[90m [inlined]\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [36] \u001b[0m\u001b[1m#7\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[90m~/.julia/packages/QuartoNotebookRunner/7xf1K/src/QuartoNotebookWorker/src/\u001b[39m\u001b[90m\u001b[4mrender.jl:18\u001b[24m\u001b[39m\u001b[90m [inlined]\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [37] \u001b[0m\u001b[1mwith_inline_display\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[90mf\u001b[39m::\u001b[0mQuartoNotebookWorker.var\"#7#8\"\u001b[90m{String, String, Int64, Dict{Any, Any}}\u001b[39m, \u001b[90mcell_options\u001b[39m::\u001b[0mDict\u001b[90m{Any, Any}\u001b[39m\u001b[0m\u001b[1m)\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[32mQuartoNotebookWorker\u001b[39m \u001b[90m~/.julia/packages/QuartoNotebookRunner/7xf1K/src/QuartoNotebookWorker/src/\u001b[39m\u001b[90m\u001b[4mInlineDisplay.jl:31\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [38] \u001b[0m\u001b[1m_render_thunk\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[90mthunk\u001b[39m::\u001b[0mFunction, \u001b[90mcode\u001b[39m::\u001b[0mString, \u001b[90mcell_options\u001b[39m::\u001b[0mDict\u001b[90m{Any, Any}\u001b[39m, \u001b[90mis_expansion_ref\u001b[39m::\u001b[0mBase.RefValue\u001b[90m{Bool}\u001b[39m; \u001b[90minline\u001b[39m::\u001b[0mBool\u001b[0m\u001b[1m)\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[32mQuartoNotebookWorker\u001b[39m \u001b[90m~/.julia/packages/QuartoNotebookRunner/7xf1K/src/QuartoNotebookWorker/src/\u001b[39m\u001b[90m\u001b[4mrender.jl:43\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [39] \u001b[0m\u001b[1m_render_thunk\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[90m~/.julia/packages/QuartoNotebookRunner/7xf1K/src/QuartoNotebookWorker/src/\u001b[39m\u001b[90m\u001b[4mrender.jl:35\u001b[24m\u001b[39m\u001b[90m [inlined]\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [40] \u001b[0m\u001b[1mrender\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[90mcode\u001b[39m::\u001b[0mString, \u001b[90mfile\u001b[39m::\u001b[0mString, \u001b[90mline\u001b[39m::\u001b[0mInt64, \u001b[90mcell_options\u001b[39m::\u001b[0mDict\u001b[90m{Any, Any}\u001b[39m; \u001b[90minline\u001b[39m::\u001b[0mBool\u001b[0m\u001b[1m)\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[32mQuartoNotebookWorker\u001b[39m \u001b[90m~/.julia/packages/QuartoNotebookRunner/7xf1K/src/QuartoNotebookWorker/src/\u001b[39m\u001b[90m\u001b[4mrender.jl:15\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [41] \u001b[0m\u001b[1mrender\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[90mcode\u001b[39m::\u001b[0mString, \u001b[90mfile\u001b[39m::\u001b[0mString, \u001b[90mline\u001b[39m::\u001b[0mInt64, \u001b[90mcell_options\u001b[39m::\u001b[0mDict\u001b[90m{Any, Any}\u001b[39m\u001b[0m\u001b[1m)\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[32mQuartoNotebookWorker\u001b[39m \u001b[90m~/.julia/packages/QuartoNotebookRunner/7xf1K/src/QuartoNotebookWorker/src/\u001b[39m\u001b[90m\u001b[4mrender.jl:1\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [42] \u001b[0m\u001b[1mrender\u001b[22m\u001b[0m\u001b[1m(\u001b[22m::\u001b[0mString, ::\u001b[0mVararg\u001b[90m{Any}\u001b[39m; \u001b[90mkwargs\u001b[39m::\u001b[0m@Kwargs\u001b[90m{}\u001b[39m\u001b[0m\u001b[1m)\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[33mMain\u001b[39m \u001b[90m~/.julia/packages/QuartoNotebookRunner/7xf1K/src/\u001b[39m\u001b[90m\u001b[4mstartup.jl:145\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [43] top-level scope\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[90m\u001b[4mnone:1\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [44] \u001b[0m\u001b[1meval\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[90mm\u001b[39m::\u001b[0mModule, \u001b[90me\u001b[39m::\u001b[0mAny\u001b[0m\u001b[1m)\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[90mCore\u001b[39m \u001b[90m./\u001b[39m\u001b[90m\u001b[4mboot.jl:489\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [45] \u001b[0m\u001b[1m(::Main.var\"#22#23\")\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[90mchan\u001b[39m::\u001b[0mChannel\u001b[90m{Any}\u001b[39m\u001b[0m\u001b[1m)\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[33mMain\u001b[39m \u001b[90m~/.julia/packages/QuartoNotebookRunner/7xf1K/src/\u001b[39m\u001b[90m\u001b[4mstartup.jl:158\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [46] \u001b[0m\u001b[1m(::Base.var\"#562#563\"{Main.var\"#22#23\", Channel{Any}})\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[0m\u001b[1m)\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[90mBase\u001b[39m \u001b[90m./\u001b[39m\u001b[90m\u001b[4mchannels.jl:141\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   during initialization of module QuartoNotebookWorkerMakieExt\n\u001b[91m\u001b[1m└ \u001b[22m\u001b[39m\u001b[90m@ Base loading.jl:1589\u001b[39m\n"
                }
            ],
            "execution_count": 1
        },
        {
            "id": "3",
            "cell_type": "markdown",
            "metadata": {
            },
            "source": [
                "\n",
                "The modal approach enables the dynamic behavior of a structure to be predicted based on knowledge of its natural modes of vibration, which are intrinsic to the system. From a practical point of view, this information can be used to determine the frequencies at which the structure is most likely to vibrate. For industry, this information is invaluable, as vibrations can cause discomfort, noise, premature wear and tear, or even damage to a system. This is where **Experimental Modal Analysis** (EMA) comes in. Experimental identification of vibration modes can also be used to calibrate a finite element model or certify a product (e.g. ground vibration testing or regulations related to the modal behavior of the structure).\n",
                "\n",
                "EMA aims to estimate the natural frequencies of the system and other characteristic parameters (e.g. damping ratios and mode shapes) from the vibration measurements in order to obtain a modal model of the system under consideration. This model can then be used to determine the structure's dynamic behaviour for a given excitation.\n",
                "\n",
                "To reach these goals, it is supposed that:\n",
                "\n",
                "* the system is **linear and time-invariant** ;\n",
                "* the modal damping is of **viscous** type.\n",
                "\n",
                "EMA is a family of **inverse methods** attempting to determine the modal characteristics of a structure from the responses measured at each point of the mesh.\n",
                "\n",
                "## General principles\n",
                "\n",
                "To identify the modal parameters of a structure or mechanical system, EMA relies on the measurement of the structure's transfer function matrix. By definition, the transfer function $H_{pq}(\\omega)$ can be seen as the frequency response of the system at a point $x_p$ to an excitation of unit amplitude at a point $x_q$. Classically, the transfer function matrix (here the admittance) is given by the relation\n",
                "\n",
                "$$\n",
                "H_{pq}(\\omega) = \\sum_{i = 1}^{+\\infty} \\frac{\\phi_i(x_p)\\, \\phi_i(x_q)}{M_i(\\omega_i^2 - \\omega^2 + 2j\\xi_i\\omega_i\\omega)} = \\sum_{i = 1}^{+\\infty} \\left[\\frac{{}_i R_{pq}}{(j\\omega - \\lambda_i)} + \\frac{{}_i R_{pq}^\\ast}{(j\\omega - \\lambda_i^\\ast)}\\right],\n",
                "$$\n",
                "where:\n",
                "\n",
                "* $\\lambda_i = -\\xi_i + j\\,\\Omega_i$ is the pole related to the mode $i$, with:\n",
                "    * $\\Omega_i = \\omega_i\\sqrt{1 - \\xi_i^2}$ is the damped natural frequency of the mode $i$, with $\\omega_i = \\vert \\lambda_i\\vert$.\n",
                "    * $\\xi_i = -\\frac{\\text{Re}(\\lambda_i)}{\\omega_i}$ the modal damping factor of the mode $i$ <br></br>\n",
                "\n",
                "* ${}_i R_{pq} = c_i\\, \\phi_i(x_p)\\, \\phi_i(x_q)$ is the residue of the mode $i$, with:\n",
                "    * $\\phi_i(x_p)$ the mode shape of the mode $i$ at point $x_p$\n",
                "    * $c_i = \\frac{1}{2jM_i\\Omega_i}$ the normalization constant of the mode shape of the mode $i$\n",
                "\n",
                "The objective of an EMA is therefore to identify the residuals ${}_i R_{pq}$ and the poles $\\lambda_i$ of the transfer function $H_{pq}(\\omega)$ in order to extract, in a second step, the modal parameters of the system under study (natural angular frequencies $\\omega_i$, modal damping factors $\\xi_i$ and mode shapes $\\phi_i$).\n",
                "\n",
                "In `StructuralVibration.jl`, two families of modal extraction methods are implemented:\n",
                "\n",
                "* methods based on the use of single degree of freedom (sdof) models, known as **Sdof methods**. These methods seek to adjust ideal transfer functions of Sdof systems to experimental curves around their resonances. These methods therefore consist of identifying the modal parameters mode by mode. To do this, the operator must select a frequency band around each resonance to perform the extraction.\n",
                "\n",
                "* methods based on the use of multiple degree of freedom (mdof) models, known as **Mdof methods**. These methods consider that the system can be represented as a multiple degree of freedom system. They are generally based on the construction of a high-order polynomial matrix whose coefficients are estimated from the measured transfer functions.\n",
                "\n",
                "## Sdof methods\n",
                "\n",
                "The Sdof methods are based on the assumption that the system can be represented as a single degree of freedom system. This means that the system can be described by a single natural frequency, damping ratio, and mode shape. The Sdof methods are typically used for systems that are lightly damped and for which the modes are well separated.\n",
                "\n",
                "For these methods, it is assumed that the FRF (admittance) is given by:\n",
                "$$\n",
                "H_{pq}(\\omega) = \\sum_{i = 1}^N\\frac{_{i}R_{pq}}{\\omega_i^2 - \\omega^2 + j\\eta_i\\omega_i^2}\n",
                "$$\n",
                "where, for a mode $i$, $_{i}R_{pq} = \\phi_i(x_p)\\phi_i(x_q)$ is the residue, $\\omega_i$ is the natural frequency, $\\eta_i$ is the modal damping factor, and $\\phi_i(x_p)$ is the mass-normalized mode shape at the point $x_p$.\n",
                "\n",
                "When the natural frequencies of the modes are sufficiently spaced and the damping is low, one can write at a frequency $\\omega$ close to the natural frequency $\\omega_i$:\n",
                "$$\n",
                "H_{pq}(\\omega) \\approx \\frac{\\phi_i(x_p)\\phi_i(x_q)}{\\omega_i^2 - \\omega^2 + j\\eta_i\\omega_i^2}.\n",
                "$$\n",
                "\n",
                "::: {.callout-note}\n",
                "One can note that the modal damping factor $\\eta_i$ is related to the damping ratio $\\xi_i$ by the relation:\n",
                "$$\n",
                "\\eta_i = 2\\xi_i.\n",
                "$$\n",
                ":::\n",
                "\n",
                "### Poles extraction\n",
                "\n",
                "`StructuralDynamics.jl` provides three SDOF methods for extracting the poles of a system from its frequency response function (FRF):\n",
                "\n",
                "- Peak picking method\n",
                "- Circle fit method\n",
                "- Least squares fit method\n",
                "\n",
                "#### Peak picking method\n",
                "\n",
                "The peak picking method is a simple and effective way to extract the natural frequencies and damping ratios of a system. The method consists of the following steps:\n",
                "\n",
                "1. **Identification of natural frequencies**\n",
                "\n",
                "    They are identified from the peaks of the amplitude of the FRF. The natural frequencies are identified as the frequencies at which the FRF has a local maximum. The local maxima are determined using `Peaks.jl`.\n",
                "\n",
                "2. **Estimation of modal damping factors**\n",
                "\n",
                "    To estimate the value of the damping factor for mode $i$, the half power bandwidth method is used. This procedure, valid for low damping ($\\eta_i < 0.1$), first determines the frequencies $\\omega_1$ and $\\omega_2$ such that:\n",
                "    $$\n",
                "    \\vert H_{pq}(\\omega_1)\\vert = \\vert H_{pq}(\\omega_2)\\vert = \\frac{\\vert H_{pq}(\\omega_i)\\vert}{\\sqrt{2}},\n",
                "    $$\n",
                "    with $\\omega_i \\in [\\omega_1, \\omega_2]$.\n",
                "\n",
                "    Knowing the values of $\\omega_i$, $\\omega_1$, and $\\omega_2$, the damping ratio for mode $i$ is determined using the formula:\n",
                "    $$\n",
                "    \\eta_i = \\frac{\\omega_2^2 - \\omega_1^2}{2\\omega_i^2}.\n",
                "    $$\n",
                "\n",
                "::: {.callout-note}\n",
                "If we consider that the shape of a resonance peak is symmetric then $\\omega_i = \\frac{\\omega_1 + \\omega_2}{2}$.\n",
                "\n",
                "It comes that:\n",
                "$$\n",
                "\\omega_2^2 - \\omega_1^2 \\approx 2\\omega_i(\\omega_2 - \\omega_1).\n",
                "$$\n",
                "\n",
                "Hence, the damping ratio can be approximated as:\n",
                "$$\n",
                "\\eta_i \\approx \\frac{\\omega_2 - \\omega_1}{\\omega_i}.\n",
                "$$\n",
                "\n",
                "This formula is often given in textbooks when dealing with the half power bandwidth method.\n",
                ":::\n",
                "\n",
                "Once the natural frequencies and damping ratios have been determined, the poles are recovered using the relation:\n",
                "$$\n",
                "\\lambda_i = -\\xi_i \\omega_i + j\\omega_i\\sqrt{1 - \\xi_i^2}.\n",
                "$$\n",
                "\n",
                "::: {.callout-warning}\n",
                "Thanks to its extreme simplicity, this method allows for quick analysis. However, this method generally does not provide satisfactory results, as it relies on measuring the resonance peak, which is very difficult to measure precisely. This is why this method is mainly applicable to lightly damped structures with well-separated modes, whose transfer functions have been measured with good frequency resolution.\n",
                ":::\n",
                "\n",
                "#### Circle fit method\n",
                "\n",
                "The circle fit method is a more sophisticated method for extracting the natural frequencies and damping ratios of a system. It allows for more accurate results than the peak picking method. It is based on the fact that the admittance forms a circle (Nyquist circle) when plotted in the complex plane (see @fig-cfm). Indeed, assuming that the modes are mass-normalized, it can be shown that:\n",
                "$$\n",
                "Re\\left[H_{pq}(\\omega)\\right]^2 + \\left(Im\\left[H_{pq}(\\omega)\\right] + \\frac{\\Phi_i(x_p)\\Phi_i(x_q)}{2\\eta_i\\omega_i^2}\\right)^2 = \\left(\\frac{\\Phi_i(x_p)\\Phi_i(x_q)}{2\\eta_i\\omega_i^2}\\right)^2,\n",
                "$$\n",
                "which is the equation of a circle of radius $R = \\frac{\\vert\\Phi_i(x_p)\\Phi_i(x_q)\\vert}{2\\eta_i\\omega_i^2}$ and center $(x_c,y_c) = \\Bigl(0,-\\frac{\\Phi_i(x_p)\\Phi_i(x_q)}{2\\eta_i\\omega_i^2}\\Bigr)$.\n",
                "\n",
                "::: {#fig-cfm}\n",
                "![](../assets/images/cercle_nyquist.png){width=75%}\n",
                "\n",
                "Typical Nyquist circle of an admittance $H_{pq}(\\omega)$\n",
                ":::\n",
                "\n",
                "The circle fit method consists of the following steps:\n",
                "\n",
                "1. **Identification of natural frequencies**\n",
                "\n",
                "    To identify the natural frequency of a mode $i$, we start by parameterizing the Nyquist circle by defining the angles $\\psi$ and $\\theta$ as shown in @fig-cfm. Mathematically, it can then be shown that:\n",
                "    $$\n",
                "    \\omega_i^2 = \\frac{\\omega_1^2\\tan\\frac{\\theta_2}{2} - \\omega_2^2\\tan\\frac{\\theta_1}{2}}{\\tan\\frac{\\theta_2}{2} - \\tan\\frac{\\theta_1}{2}},\n",
                "    $$\n",
                "    where $\\omega_1$ and $\\omega_2$ are the angular frequencies such that $\\omega_1 < \\omega_i < \\omega_2$, while $\\theta_1$ and $\\theta_2$ are the corresponding angles of the Nyquist circle.\n",
                "\n",
                "2. **Estimation of modal damping factors**\n",
                "\n",
                "    The damping ratio is estimated using the following formula:\n",
                "    $$\n",
                "    \\eta_i = \\frac{\\omega_2^2 - \\omega_1^2}{\\omega_i^2}\\frac{1}{\\tan\\frac{\\theta_1}{2} - \\tan\\frac{\\theta_2}{2}}.\n",
                "    $$\n",
                "\n",
                "::: {.callout-note}\n",
                "Generally, the angles $\\theta_1$ and $\\theta_2$ are chosen so that:\n",
                "$$\n",
                "\\theta_1 = \\frac{\\pi}{2} \\text{ and } \\theta_2 = -\\frac{\\pi}{2}.\n",
                "$$\n",
                "\n",
                "In doing so, we have:\n",
                "$$\n",
                "\\omega_i^2 = \\frac{\\omega_1^2 + \\omega_2^2}{2} \\text{ and } \\eta_i = \\frac{\\omega_2^2 - \\omega_1^2}{2\\omega_i^2}.\n",
                "$$\n",
                ":::\n",
                "\n",
                "#### Least squares fit method\n",
                "\n",
                "The least squares fit method is based on the idea of fitting the frequency response function (FRF) around the resonance peaks using a least squares approach[^1].\n",
                "\n",
                "[^1]: A. Brandt. \"Noise and Vibration Analysis: Signal Analysis and Experimental Procedures\", Wiley, 2011.\n",
                "\n",
                "When the natural frequencies of the modes are sufficiently spaced and the damping is low, one can write at a frequency $\\omega$ close to the natural frequency $f_i$:\n",
                "$$\n",
                "H_{pq}(f) \\approx \\frac{_{i}A_{pq}}{f_i^2 - f^2 + 2j\\xi_i f_i f}.\n",
                "$$\n",
                "\n",
                "The least squares fit method consists of the following steps:\n",
                "\n",
                "1. **Definition of the system matrices**\n",
                "\n",
                "    To construct the system matrices, we start by rewriting the previous equation as:\n",
                "    $$\n",
                "    H_{pq}(f) \\left(f_i^2 - f^2 + 2j\\xi_i f_i f\\right) - _{i}A_{pq} = 0.\n",
                "    $$\n",
                "\n",
                "    This equation can be rewritten as:\n",
                "    $$\n",
                "    \\begin{bmatrix}\n",
                "    H_{pq}(f) & 2jfH_{pq}(f) & -1\n",
                "    \\end{bmatrix} \\begin{bmatrix}\n",
                "    f_i^2 \\\\\n",
                "    \\xi_i f_i \\\\\n",
                "    _{i}A_{pq}\n",
                "    \\end{bmatrix} = f^2 H_{pq}(f).\n",
                "    $$\n",
                "\n",
                "    If we consider $M$ frequency points around the resonance peak, we can construct the following system of equations:\n",
                "    $$\n",
                "    \\begin{bmatrix}\n",
                "    H_{pq}(f_1) & 2jf_1H_{pq}(f_1) & -1 \\\\\n",
                "    H_{pq}(f_2) & 2jf_2H_{pq}(f_2) & -1 \\\\\n",
                "    \\vdots & \\vdots & \\vdots \\\\\n",
                "    H_{pq}(f_M) & 2jf_MH_{pq}(f_M) & -1\n",
                "    \\end{bmatrix} \\begin{bmatrix}\n",
                "    f_i^2 \\\\\n",
                "    \\xi_i f_i \\\\\n",
                "    _{i}A_{pq}\n",
                "    \\end{bmatrix} = \\begin{bmatrix}\n",
                "    f_1^2 H_{pq}(f_1) \\\\\n",
                "    f_2^2 H_{pq}(f_2) \\\\\n",
                "    \\vdots \\\\\n",
                "    f_M^2 H_{pq}(f_M)\n",
                "    \\end{bmatrix}.\n",
                "    $$\n",
                "\n",
                "2. **Least squares solution**\n",
                "\n",
                "    The least squares solution of the previous system of equations is given by:\n",
                "    $$\n",
                "    \\begin{bmatrix}\n",
                "    f_i^2 \\\\\n",
                "    \\xi_i f_i \\\\\n",
                "    _{i}A_{pq}\n",
                "    \\end{bmatrix} = \\left(\\mathbf{A}^H\\mathbf{A}\\right)^{-1}\\mathbf{A}^H\\mathbf{b},\n",
                "    $$\n",
                "    where $\\mathbf{A}$ is the matrix on the left-hand side of the system of equations, $\\mathbf{b}$ is the vector on the right-hand side, and $\\mathbf{A}^H$ is the conjugate transpose of $\\mathbf{A}$.\n",
                "\n",
                "::: {.callout-note}\n",
                "\n",
                "In practice, the least squares solution is not directly computed using complex numbers, as this can lead to numerical issues. Instead, the real and imaginary parts are separated to solve a real system of double size.\n",
                "\n",
                ":::\n",
                "\n",
                "### Mode shape extraction\n",
                "\n",
                "The mode shapes are extracted from the admittance matrix at the resonance frequency $\\omega_i$. In this situation, the admittance matrix is defined as:\n",
                "$$\n",
                "\\mathbf{H} = \\frac{1}{j\\eta_i\\omega_i^2}\n",
                "  \\begin{bmatrix}\n",
                "    \\Phi_i(x_1)^2 & \\Phi_i(x_1)\\Phi_i(x_2) & \\ldots\\ & \\Phi_i(x_1)\\Phi_i(x_N) \\\\\n",
                "    \\Phi_i(x_2)\\Phi_i(x_1) & \\Phi_i(x_2)^2 &  & \\Phi_i(x_2)\\Phi_i(x_N) \\\\\n",
                "    \\vdots & & \\ddots & \\vdots \\\\\n",
                "    \\Phi_i(x_N)\\Phi_i(x_1) & \\ldots & \\ldots & \\Phi_i(x_N)^2\n",
                "  \\end{bmatrix},\n",
                "$$\n",
                "where $\\omega_i$ and $\\eta_i$ have been determined using the peak picking method or the circle fit method.\n",
                "\n",
                "To determine the mode shapes from the knowledge of a column $q$ (or a row $p$), proceed as follows:\n",
                "\n",
                "* From the measurement of an input admittance (diagonal term of the admittance matrix), the mode shape value at point $x_q$ is obtained:\n",
                "  $$\n",
                "  \\Phi_i(x_q)^2 = -\\eta_i\\omega_i^2 \\text{Im}(H_{qq}(\\omega_i)).\n",
                "  $$\n",
                "\n",
                "* From the cross-admittances (off-diagonal terms of the admittance matrix), the mode shape value at a point $x_p$ is calculated:\n",
                "  $$\n",
                "  \\Phi_i(x_p)\\Phi_i(x_q) = -\\eta_i\\omega_i^2 \\text{Im}(H_{pq}(\\omega_i))\n",
                "  $$\n",
                "\n",
                "## Mdof methods\n",
                "\n",
                "The Mdof methods are based on the assumption that the system can be represented as a multiple degree of freedom system. They are generally based on the construction of a high-order polynomial matrix whose coefficients are estimated from the measured FRFs. As for the SDOF methods, the estimation of the modal parameters is divided into two steps:\n",
                "\n",
                "1. estimation of the poles of the system to extract the natural frequencies and modal damping ratios,\n",
                "2. estimation of the residues to extract the mode shapes.\n",
                "\n",
                "\n",
                "### Poles extraction\n",
                "\n",
                "The poles of the system are then obtained as the roots of the characteristic polynomial associated with this polynomial matrix. Three methods are implemented in this package:\n",
                "\n",
                "- the Least-Squares Complex Exponential (LSCE) method\n",
                "- the Least-Squares Complex Frequency-domain (LSCF) method\n",
                "- the Polyreference Least-Squares Complex Frequency-domain (pLSCF) method\n",
                "\n",
                "#### LSCE method\n",
                "\n",
                "The LSCE method is based on the assumption that the system can be modeled as a sum of complex exponentials in the time domain. The impulse response function (IRF) between an output $o$ ($o = 1, \\ldots, n_o$) and an input $i$ ($i = 1, \\ldots, n_i$) can be modeled as:\n",
                "$$\n",
                "h_{oi}(t) = \\sum_{k = 1}^n \\left(c_k e^{\\lambda_k t} + c_k^\\ast e^{-\\lambda_k^\\ast t}\\right) = 2 Re\\left(\\sum_{k = 1}^n c_k e^{\\lambda_k t}\\right).\n",
                "$$\n",
                "\n",
                "When sampling the IRF at a sampling period $T_s$, one obtains the following discrete-time model:\n",
                "$$\n",
                "h_{oi}[m] = 2 Re\\left(\\sum_{k = 1}^n c_k z_k^m\\right) \\text{ with } z_k = e^{\\lambda_k T_s},\n",
                "$$\n",
                "for $m = 0, 1, \\ldots, 2n$, ($n$ is the model order). According to the Prony's method, the poles $\\lambda_k$ can be calculated from the roots of the following characteristic polynomial:\n",
                "$$\n",
                "\\sum_{m = 0}^{2n} \\beta_m z_k^m = 0 \\text{ with } \\beta_{2n} = 1.\n",
                "$$\n",
                "\n",
                "The coefficients $\\beta_l$ of the characteristic polynomial can be estimated from the sampled IRF $h_{oi}[m]$. Todo so, one first multiply $h_{oi}[m]$ by the corresponding coefficients $\\beta_m$ and then sums the resulting equations for $m = 0, 1, \\ldots, 2n$. This leads to the following homogeneous set of equations:\n",
                "$$\n",
                "\\sum_{m = 0}^{2n} \\beta_m h_{oi}[m] = 2 Re\\left(\\sum_{k = 1}^{n} c_k \\sum_{m = 0}^{2n} \\beta_m z_k^m\\right).\n",
                "$$\n",
                "\n",
                "When $z_k$ is a root of the characteristic polynomial, the right-hand side of the previous equation is equal to zero. Therefore, one can estimate the coefficients $\\beta_m$ by solving the following set of linear equations:\n",
                "$$\n",
                "\\sum_{m = 0}^{2n} \\beta_m h_{oi}[m] = 0.\n",
                "$$\n",
                "\n",
                "The previous equation can be derived using different set of data points, $h_{oi}[m]$, $h_{oi}[m+1]$, $\\ldots$, $h_{oi}[m + 2n]$  to obtain an overdetermined set of linear equations that can be solved in the least-squares sense[^2]. In this package, the coefficients $\\beta_m$ are estimated by solving the following set of equations:\n",
                "$$\n",
                "\\begin{bmatrix}\n",
                "h_{oi}[0] & h_{oi}[1] & \\ldots & h_{oi}[2n-1] \\\\\n",
                "h_{oi}[1] & h_{oi}[2] & \\ldots & h_{oi}[2n] \\\\\n",
                "\\vdots & \\vdots & \\ddots & \\vdots \\\\\n",
                "h_{oi}[2n-1] & h_{oi}[2n] & \\ldots & h_{oi}[4n-2]\n",
                "\\end{bmatrix}\n",
                "\\begin{bmatrix}\n",
                "\\beta_0 \\\\\n",
                "\\beta_1 \\\\\n",
                "\\vdots \\\\\n",
                "\\beta_{2n-1}\n",
                "\\end{bmatrix}\n",
                "= -\\begin{bmatrix}\n",
                "h_{oi}[2n] \\\\\n",
                "h_{oi}[2n+1] \\\\\n",
                "\\vdots \\\\\n",
                "h_{oi}[4n-1]\n",
                "\\end{bmatrix}\n",
                "$$\n",
                "\n",
                "Once the coefficients $\\beta_m$ are estimated, the poles $\\lambda_k$ can be obtained from the roots $z_k$ of the characteristic polynomial.\n",
                "\n",
                "[^2]: D. Brown, R. Allemang and R. Zimmerman and M. Mergeay. \"Parameter estimation techniques for modal analysis\". SAE Technical Paper 790221, 1979.\n",
                "\n",
                "#### LSCF method\n",
                "\n",
                "According to Guillaume et al. [^3], the transfer function between an output $o$ ($o = 1, \\ldots, n_o$)  and an input $i$ ($i = 1, \\ldots, n_i$) can be modeled in the frequency domain as:\n",
                "$$\n",
                "\\widehat{H}_k(\\omega) = \\frac{N_k(\\omega)}{d(\\omega)},\n",
                "$$\n",
                "where $k = 1, \\ldots, n_o n_i$ ($k = (o - 1) n_i + i$). Here, $N_k(\\omega)$ is the $k$-th element of the numerator matrix defined as:\n",
                "$$\n",
                "N_k(\\omega) = \\mathbf{\\Omega}(\\omega)^T \\boldsymbol{\\beta}_k,\n",
                "$$\n",
                "while $d(\\omega)$ is the common denominator polynomial defined as:\n",
                "$$\n",
                "d(\\omega) = \\mathbf{\\Omega}(\\omega)^T \\boldsymbol{\\alpha}.\n",
                "$$\n",
                "\n",
                "In the previous equations, $\\mathbf{\\Omega}(\\omega)$ is the vector of polynomial basis functions defined as:\n",
                "$$\n",
                "\\mathbf{\\Omega}(\\omega)^T = [1, \\Omega_1(\\omega), \\ldots, \\Omega_n(\\omega)] \\text{ with } \\Omega_n(\\omega) = \\exp(-i\\omega n T_s),\n",
                "$$\n",
                "where $n$ is the order of the denominator polynomial (a.k.a the model order) and $T_s$ is the sampling period. The vectors $\\boldsymbol{\\beta}_k$ and $\\boldsymbol{\\alpha}$ contain the coefficients of the numerator and denominator polynomials, respectively.\n",
                "\n",
                "Based on the previous formulation of the FRFs, the LSCF method consists in estimating the coefficients of the numerator $\\boldsymbol{\\beta}_k$ and denominator $\\boldsymbol{\\alpha}$ polynomials by minimizing the following functional:\n",
                "$$\n",
                "J(\\boldsymbol{\\theta}) = \\sum_{k=1}^{n_o n_i} \\sum_{j=1}^{n_f} \\left| W_k(\\omega_j)\\left[H_k(\\omega_j) d(\\omega_j) - N_k(\\omega_j)\\right] \\right|^2,\n",
                "$$\n",
                "where $\\boldsymbol{\\theta} = [\\boldsymbol{\\beta}_1^T, \\ldots, \\boldsymbol{\\beta}_{n_o n_i}^T, \\boldsymbol{\\alpha}^T]^T$ is the vector of unknown parameters to be estimated, $H_k(\\omega_j)$ is the measured FRF at frequency $\\omega_j$, $n_f$ is the number of frequency lines used for the identification and $W_k(\\omega_j)$ is an arbitrary weighting function. In the package, two weighting functions can be use: either a unitary weighting function is used, i.e. $W_k(\\omega_j) = 1$ or the inverse of the noise variance estimate on each measured FRF is used, i.e. $W_k(\\omega_j) = 1/\\sigma_k$.\n",
                "\n",
                "The poles of the transfer function are obtained from the roots of the characteristic polynomial associated with the denominator polynomial $d(\\omega)$, which are computed after having estimated the coefficients $\\boldsymbol{\\alpha}$ as the argument of the minimum of the functional $J(\\boldsymbol{\\theta})$ (see Ref. [2] for details).\n",
                "\n",
                "[^3]: P. Guillaume, P. Verboven, S. Vanlanduit, H. Van der Auweraer and B. Peeters, \"A poly-reference implementation of the least-squares complex frequency-domain estimator\". Proceedings of the 21st International Modal Analysis Conference, IMAC, 2003.\n",
                "\n",
                "#### pLSCF method\n",
                "\n",
                "The pLSCF method is an extension of the LSCF method that makes it possible to take into account multiple reference sensors simultaneously (see Ref. [3] for details). When using only one reference sensor, the pLSCF method is equivalent to the LSCF method.\n",
                "\n",
                "In this approach, the transfer function $\\widehat{\\mathbf{H}}_o(\\omega) \\in \\mathbb{C}^{1 \\times n_i}$ between an output $o$ ($o = 1, \\ldots, n_o$) and a set of $n_i$ inputs can be modeled in the frequency domain as:\n",
                "$$\n",
                "\\widehat{\\mathbf{H}}_o(\\omega) = \\mathbf{N}_o(\\omega) \\mathbf{D}(\\omega)^{-1},\n",
                "$$,\n",
                "where $\\mathbf{N}_o(\\omega) \\in \\mathbb{C}^{1 \\times n_i}$ is the numerator matrix defined as:\n",
                "$$\n",
                "\\mathbf{N}_o(\\omega) = \\mathbf{\\Omega}(\\omega)^T \\boldsymbol{\\beta}_o,\n",
                "$$\n",
                "while $\\mathbf{D}(\\omega) \\in \\mathbb{C}^{n_i \\times n_i}$ is the denominator matrix defined as:\n",
                "$$\n",
                "\\mathbf{D}(\\omega) = \\mathbf{\\Omega}(\\omega)^T \\boldsymbol{\\alpha}.\n",
                "$$\n",
                "\n",
                "Based on the previous formulation of the FRFs, the pLSCF method consists in estimating the coefficients of the numerator $\\boldsymbol{\\beta}_o$ and denominator $\\boldsymbol{\\alpha}$ polynomials. To this end, one defines the weighted error between the measured and modeled FRFs as:\n",
                "$$\n",
                "\\boldsymbol{\\varepsilon}_o(\\omega_j, \\boldsymbol{\\theta}) = W_o(\\omega_j)\\left[\\mathbf{H}_o(\\omega_j) \\mathbf{D}(\\omega_j) - \\mathbf{N}_o(\\omega_j)\\right]\n",
                "$$\n",
                "\n",
                "Then, an error matrix $\\mathbf{E}_o(\\boldsymbol{\\theta}) \\in \\mathbb{C}^{n_f \\times n_i}$ is constructed by stacking the weighted errors $\\boldsymbol{\\varepsilon}_o(\\omega_j, \\boldsymbol{\\theta}) \\in \\mathbb{C}^{1 \\times n_i}$ for all frequency lines, that is:\n",
                "$$\n",
                "\\mathbf{E}_o(\\boldsymbol{\\theta}) = \\begin{bmatrix}\n",
                "\\boldsymbol{\\varepsilon}_o(\\omega_1, \\boldsymbol{\\theta}) \\\\\n",
                "\\vdots \\\\\n",
                "\\boldsymbol{\\varepsilon}_o(\\omega_{n_f}, \\boldsymbol{\\theta})\n",
                "\\end{bmatrix}\n",
                "$$\n",
                "\n",
                "Finally, the coefficients of the numerator and denominator polynomials are estimated by minimizing the following functional:\n",
                "$$\n",
                "J(\\boldsymbol{\\theta}) = \\sum_{o=1}^{n_o} \\Vert\\mathbf{E}_o(\\boldsymbol{\\theta})\\Vert^2.\n",
                "$$\n",
                "\n",
                "The poles of the transfer function are obtained from the characteristic polynomial associated with the denominator matrix $\\mathbf{D}(\\omega)$, by computing the eigenvalues of the so-called companion matrix[^4].\n",
                "\n",
                "[^4]: M. El-Kafafy, P. Guillaume, B. Peeters, F. Marra, G. Coppotelli. \"Advanced Frequency-Domain Modal Analysis for Dealing with Measurement Noise and Parameter Uncertainty\". In: Allemang R., De Clerck J., Niezrecki C., Blough J. (eds) Topics in Modal Analysis I, Volume 5. Conference Proceedings of the Society for Experimental Mechanics Series. 2012.\n",
                "\n",
                "#### Stabilization diagram\n",
                "\n",
                "When carrying out an EMA, the main question that arises is how many modes (or, more precisely, poles) are contained within the frequency band of interest. Analyzing the frequency response functions (transfer functions) provides an initial estimate. However, it is difficult to distinguish between multiple or nearby modes.\n",
                "\n",
                "The stabilisation diagram is a fundamental EMA tool as it provides a clear and concise presentation of the poles of the system under study. The idea is to adjust the transfer function model by increasing the number of poles and displaying the results on a graph. Broadly speaking, increasing the order of the model (i.e. the number of poles) causes the true vibration modes to converge to a stable value, whereas the numerical modes appear inconsistently or randomly on the graph. Thus, as the poles converge to stable ones, markers appear on the graph to indicate the identified poles, as the order of the model is gradually increased. The selection of poles is generally based on the stability of natural frequencies, modal damping and/or mode shapes, moving from a model order $n$ to an order $n + 1$. In this package, the stability of the natural frequencies and damping ratios is used to identify the physical poles of the system. The stability criterion is set to 1% for the natural frequencies and 5% for the damping ratios, following common practice in the EMA field.\n",
                "\n",
                "In `StructuralVibration.jl`, the stabilization diagram can be obtained using the `stabilization` function along with any of the Mdof methods described above. The identified stable poles can then be visualized using the `stabilization_plot` function. The `stabilization` function returns an `StabilizationAnalysis` structure that contains all the information related to the stabilization analysis, which allows the user to manually select the appropriate poles and to further analyze (e.g. by using quality and analysis indicators) and visualize the results.\n",
                "\n",
                "### Mode shape extraction\n",
                "\n",
                "Once the poles of the system have been identified using one of the Mdof methods described above, the residues can be computed to extract the mode shapes. In this package, the residues are computed using a least-squares approach based on the formulation of the FRFs as a sum of rational functions. The FRF between an output $p$ ($p = 1, \\ldots, n_o$) and an input $q$ ($q = 1, \\ldots, n_i$) can be expressed as:\n",
                "$$\n",
                "H_{pq}(\\omega) = \\sum_{i = 1}^n \\left(\\frac{{}_iR_{pq}}{j\\omega - \\lambda_i} + \\frac{{}_iR_{pq}^\\ast}{j\\omega - \\lambda_i^\\ast}\\right),\n",
                "$$\n",
                "where $R_{k, pq}$ is the residue associated with the pole $\\lambda_k$.\n",
                "\n",
                "At a frequency line $\\omega$, the previous equation can be rewritten in matrix form as:\n",
                "$$\n",
                "H_{pq}(\\omega) = \\begin{bmatrix}\n",
                "\\frac{1}{j\\omega - \\lambda_1} & \\ldots & \\frac{1}{j\\omega - \\lambda_n} & \\frac{1}{j\\omega - \\lambda_1^\\ast} & \\ldots & \\frac{1}{j\\omega - \\lambda_n^\\ast}\n",
                "\\end{bmatrix}\n",
                "\\begin{bmatrix}\n",
                "{}_1R_{pq} \\\\\n",
                "\\vdots \\\\\n",
                "{}_nR_{pq} \\\\\n",
                "{}_1R_{pq}^\\ast \\\\\n",
                "\\vdots \\\\\n",
                "{}_nR_{pq}^\\ast\n",
                "\\end{bmatrix}\n",
                "$$\n",
                "\n",
                "Repeating the previous equation for all frequency lines leads to the following system of equations:\n",
                "$$\n",
                "\\begin{bmatrix}\n",
                "H_{pq}(\\omega_1) \\\\\n",
                "H_{pq}(\\omega_2) \\\\\n",
                "\\vdots \\\\\n",
                "H_{pq}(\\omega_{n_f})\n",
                "\\end{bmatrix}\n",
                "= \\begin{bmatrix}\n",
                "\\frac{1}{j\\omega_1 - \\lambda_1} & \\ldots & \\frac{1}{j\\omega_1 - \\lambda_n} & \\frac{1}{j\\omega_1 - \\lambda_1^\\ast} & \\ldots & \\frac{1}{j\\omega_1 - \\lambda_n^\\ast} \\\\\n",
                "\\frac{1}{j\\omega_2 - \\lambda_1} & \\ldots & \\frac{1}{j\\omega_2 - \\lambda_n} & \\frac{1}{j\\omega_2 - \\lambda_1^\\ast} & \\ldots & \\frac{1}{j\\omega_2 - \\lambda_n^\\ast} \\\\\n",
                "\\vdots & \\vdots & \\vdots & \\vdots & \\vdots & \\vdots & \\vdots & \\vdots \\\\\n",
                "\\frac{1}{j\\omega_{n_f} - \\lambda_1} & \\ldots & \\frac{1}{j\\omega_{n_f} - \\lambda_n} & \\frac{1}{j\\omega_{n_f} - \\lambda_1^\\ast} & \\ldots & \\frac{1}{j\\omega_{n_f} - \\lambda_n^\\ast}\n",
                "\\end{bmatrix}\n",
                "\\begin{bmatrix}\n",
                "{}_1R_{pq} \\\\\n",
                "\\vdots \\\\\n",
                "{}_nR_{pq} \\\\\n",
                "{}_1R_{pq}^\\ast \\\\\n",
                "\\vdots \\\\\n",
                "{}_nR_{pq}^\\ast\n",
                "\\end{bmatrix}\n",
                "$$\n",
                "\n",
                "This system of equations can be solved in the least-squares sense to estimate the residues ${}_iR_{pq}$. This procedure is implemented in the `mode_residues` function.\n",
                "\n",
                "From the estimated residues, the mode shapes can be extracted using the following relation:\n",
                "$$\n",
                "{}_iR_{pq} = c_i \\phi_{p,i} \\phi_{q,i},\n",
                "$$\n",
                "where $c_i$ is a scaling factor, $\\phi_{p,i}$ (resp. nd $\\phi_{q,i}$) is the $p$-th (resp. $q$-th) component of the mode shape associated with the $i$-th mode.\n",
                "\n",
                "To solve for the mode shapes, a collocated measurement is required, i.e. $p = q$. Thus, the mode shape components can be obtained as:\n",
                "$$\n",
                "\\phi_{p,i} = \\sqrt{\\frac{{}_iR_{pp}}{c_i}} \\; \\text{ and } \\; \\phi_{q,i} = \\frac{{}_iR_{pq}}{\\sqrt{c_i\\; {}_iR_{pp}}}.\n",
                "$$\n",
                "\n",
                "Here, the scaling factors $c_i$ can be computed based on a normalization criterion. In this package, the scaling factors are computed such that the modal mass of each mode shape is equal to one (mass normalization). The mode shapes can then be extracted using the `modeshape_extraction` function.\n",
                "\n",
                "## FRF reconstruction\n",
                "\n",
                "From the identified modal parameters (poles and residues), it is possible to reconstruct the frequency response functions (FRFs) of the system under study using the `frf_reconstruction` function. This function implements the following relation for a number $M$ of identified modes:\n",
                "\n",
                "$$\n",
                "H_{pq}(\\omega) = \\sum_{i = 1}^{M} \\left[\\frac{{}_i R_{pq}}{(j\\omega - \\lambda_i)} + \\frac{{}_i R_{pq}^\\ast}{(j\\omega - \\lambda_i^\\ast)}\\right],\n",
                "$$\n",
                "where:\n",
                "\n",
                "* $\\lambda_i = -\\xi_i + j\\,\\Omega_i$ is the pole related to the mode $i$, with:\n",
                "    * $\\Omega_i = \\omega_i\\sqrt{1 - \\xi_i^2}$ is the damped natural frequency of the mode $i$, with $\\omega_i = \\vert \\lambda_i\\vert$.\n",
                "    * $\\xi_i = -\\frac{\\text{Re}(\\lambda_i)}{\\omega_i}$ the modal damping factor of the mode $i$ <br></br>\n",
                "\n",
                "* ${}_i R_{pq} = c_i\\, \\phi_i(x_p)\\, \\phi_i(x_q)$ is the residue of the mode $i$, with:\n",
                "    * $\\phi_i(x_p)$ the mode shape of the mode $i$ at point $x_p$\n",
                "    * $c_i = \\frac{1}{2jM_i\\Omega_i}$ the normalization constant of the mode shape of the mode $i$\n",
                "\n",
                "In practice, however, the reconstructed FRF may not perfectly match the experimental FRF due to the unmodeled contribution of the modes outside the frequency range of interest. To account for this, it is common to include lower and upper residuals in the FRF reconstruction. This means that the admittance matrix can be expressed as:\n",
                "$$\n",
                "H_{pq}(\\omega) = \\sum_{i = 1}^{M} \\left[\\frac{{}_i R_{pq}}{(j\\omega - \\lambda_i)} + \\frac{{}_i R_{pq}^\\ast}{(j\\omega - \\lambda_i^\\ast)}\\right] - \\frac{L_{pq}}{\\omega^2} + U_{pq},\n",
                "$$\n",
                "where $L_{pq}$ and $U_{pq}$ are the lower and upper residuals, respectively. These residuals can be computed using the `compute_residuals` function.\n",
                "\n",
                "::: {.callout-note}\n",
                "Theoretically, the residuals can be computed in conjunction with the estimation of the residues using a least-squares approach. However, we observed that this often leads to inaccurate estimates of the residuals. Therefore, in `StructuralVibration.jl`, the computation of the residuals is performed separately after estimating the residues and poles.\n",
                ":::\n",
                "\n",
                "Finally, when only real mode shapes are available, it is possible to compute the residues from the modal parameters using the `mode2residues` function. This function implements the following relation:\n",
                "$$\n",
                "{}_i R_{pq} = c_i\\, \\phi_i(x_p)\\, \\phi_i(x_q),\n",
                "$$\n",
                "where $\\phi_i(x_p)$ is the mode shape of the mode $i$ at point $x_p$ and $c_i = \\frac{1}{2jM_i\\Omega_i}$ is the normalization constant of the mode shape of the mode $i$. Here, $M_i = 1$, since the mode shapes are mass-normalized. during the extraction process.\n",
                "\n",
                "## API\n",
                "\n",
                "**Data types**\n",
                "\n",
                "::: {.api}\n",
                "**EMAProblem**\n",
                "\n",
                "---"
            ]
        },
        {
            "id": "4",
            "cell_type": "code",
            "metadata": {
            },
            "source": [
                "#| echo: false\n",
                "@doc EMAProblem"
            ],
            "outputs": [
                {
                    "output_type": "execute_result",
                    "execution_count": 1,
                    "data": {
                        "text/plain": "  \u001b[36mEMAProblem(frf, freq; frange, type_frf)\u001b[39m\n\n  Data structure defining the inputs for EMA modal extraction methods.\n\n  \u001b[1mConstructor parameters\u001b[22m\n\n    \u001b[34m• \u001b[39m \u001b[36mfrf::Array{Complex, 3}\u001b[39m: 3D FRF matrix (array nm x ne x nf)\n    \u001b[34m• \u001b[39m \u001b[36mfreq::AbstractArray{Real}\u001b[39m: Vector of frequency values (Hz)\n    \u001b[34m• \u001b[39m \u001b[36mfrange::Vector{Real}\u001b[39m: Frequency range for analysis (default:\n       [freq[1], freq[end]])\n    \u001b[34m• \u001b[39m \u001b[36mtype_frf::Symbol\u001b[39m: Type of FRF used in the analysis\n       \n       \u001b[34m• \u001b[39m \u001b[36m:dis\u001b[39m: Admittance (default)\n       \u001b[34m• \u001b[39m \u001b[36m:vel\u001b[39m: Mobility\n       \u001b[34m• \u001b[39m \u001b[36m:acc\u001b[39m: Accelerance\n\n  \u001b[1mFields\u001b[22m\n\n    \u001b[34m• \u001b[39m \u001b[36mfrf::Array{Complex, 3}\u001b[39m: 3D admittance matrix (array nm x ne x nf)\n    \u001b[34m• \u001b[39m \u001b[36mfreq::AbstractArray{Real}\u001b[39m: Vector of frequency values (Hz)\n    \u001b[34m• \u001b[39m \u001b[36mtype_frf::Symbol\u001b[39m: Type of FRF used in the analysis\n\n  \u001b[1mNote\u001b[22m The FRF is internally converted to admittance if needed.",
                        "text/markdown": "```julia\nEMAProblem(frf, freq; frange, type_frf)\n```\n\nData structure defining the inputs for EMA modal extraction methods.\n\n**Constructor parameters**\n\n  * `frf::Array{Complex, 3}`: 3D FRF matrix (array nm x ne x nf)\n  * `freq::AbstractArray{Real}`: Vector of frequency values (Hz)\n  * `frange::Vector{Real}`: Frequency range for analysis (default: [freq[1], freq[end]])\n  * `type_frf::Symbol`: Type of FRF used in the analysis\n\n      * `:dis`: Admittance (default)\n      * `:vel`: Mobility\n      * `:acc`: Accelerance\n\n**Fields**\n\n  * `frf::Array{Complex, 3}`: 3D admittance matrix (array nm x ne x nf)\n  * `freq::AbstractArray{Real}`: Vector of frequency values (Hz)\n  * `type_frf::Symbol`: Type of FRF used in the analysis\n\n**Note** The FRF is internally converted to admittance if needed.\n",
                        "text/html": "<div class=\"markdown\"><pre><code class=\"language-julia\">EMAProblem&#40;frf, freq; frange, type_frf&#41;</code></pre>\n<p>Data structure defining the inputs for EMA modal extraction methods.</p>\n<p><strong>Constructor parameters</strong></p>\n<ul>\n<li><p><code>frf::Array&#123;Complex, 3&#125;</code>: 3D FRF matrix &#40;array nm x ne x nf&#41;</p>\n</li>\n<li><p><code>freq::AbstractArray&#123;Real&#125;</code>: Vector of frequency values &#40;Hz&#41;</p>\n</li>\n<li><p><code>frange::Vector&#123;Real&#125;</code>: Frequency range for analysis &#40;default: &#91;freq&#91;1&#93;, freq&#91;end&#93;&#93;&#41;</p>\n</li>\n<li><p><code>type_frf::Symbol</code>: Type of FRF used in the analysis</p>\n<ul>\n<li><p><code>:dis</code>: Admittance &#40;default&#41;</p>\n</li>\n<li><p><code>:vel</code>: Mobility</p>\n</li>\n<li><p><code>:acc</code>: Accelerance</p>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>Fields</strong></p>\n<ul>\n<li><p><code>frf::Array&#123;Complex, 3&#125;</code>: 3D admittance matrix &#40;array nm x ne x nf&#41;</p>\n</li>\n<li><p><code>freq::AbstractArray&#123;Real&#125;</code>: Vector of frequency values &#40;Hz&#41;</p>\n</li>\n<li><p><code>type_frf::Symbol</code>: Type of FRF used in the analysis</p>\n</li>\n</ul>\n<p><strong>Note</strong> The FRF is internally converted to admittance if needed.</p>\n\n\n</div>",
                        "text/latex": "\\begin{verbatim}\nEMAProblem(frf, freq; frange, type_frf)\n\\end{verbatim}\nData structure defining the inputs for EMA modal extraction methods.\n\n\\textbf{Constructor parameters}\n\n\\begin{itemize}\n\\item \\texttt{frf::Array\\{Complex, 3\\}}: 3D FRF matrix (array nm x ne x nf)\n\n\n\\item \\texttt{freq::AbstractArray\\{Real\\}}: Vector of frequency values (Hz)\n\n\n\\item \\texttt{frange::Vector\\{Real\\}}: Frequency range for analysis (default: [freq[1], freq[end]])\n\n\n\\item \\texttt{type\\_frf::Symbol}: Type of FRF used in the analysis\n\n\\begin{itemize}\n\\item \\texttt{:dis}: Admittance (default)\n\n\n\\item \\texttt{:vel}: Mobility\n\n\n\\item \\texttt{:acc}: Accelerance\n\n\\end{itemize}\n\\end{itemize}\n\\textbf{Fields}\n\n\\begin{itemize}\n\\item \\texttt{frf::Array\\{Complex, 3\\}}: 3D admittance matrix (array nm x ne x nf)\n\n\n\\item \\texttt{freq::AbstractArray\\{Real\\}}: Vector of frequency values (Hz)\n\n\n\\item \\texttt{type\\_frf::Symbol}: Type of FRF used in the analysis\n\n\\end{itemize}\n\\textbf{Note} The FRF is internally converted to admittance if needed.\n\n"
                    },
                    "metadata": {
                    }
                }
            ],
            "execution_count": 1
        },
        {
            "id": "5",
            "cell_type": "markdown",
            "metadata": {
            },
            "source": [
                ":::\n",
                "\n",
                "::: {.api}\n",
                "**AutoEMASdofProblem**\n",
                "\n",
                "---"
            ]
        },
        {
            "id": "6",
            "cell_type": "code",
            "metadata": {
            },
            "source": [
                "#| echo: false\n",
                "@doc AutoEMASdofProblem"
            ],
            "outputs": [
                {
                    "output_type": "execute_result",
                    "execution_count": 1,
                    "data": {
                        "text/plain": "  \u001b[36mAutoEMASdofProblem(prob, dpi, alg)\u001b[39m\n\n  Structure containing the input data for automatic experimental modal\n  analysis using Sdof methods\n\n  \u001b[1mFields\u001b[22m\n\n    \u001b[34m• \u001b[39m \u001b[36mprob::EMASdofProblem\u001b[39m: EMA-SDOF problem containing FRF data and\n       frequency vector\n    \u001b[34m• \u001b[39m \u001b[36mdpi::Vector{Int}\u001b[39m: Driving point indices - default = [1, 1]\n       \n       \u001b[34m• \u001b[39m \u001b[36mdpi[1]\u001b[39m: Driving point index on the measurement mesh\n       \u001b[34m• \u001b[39m \u001b[36mdpi[2]\u001b[39m: Driving point index on the excitation mesh\n    \u001b[34m• \u001b[39m \u001b[36malg::SdofModalExtraction\u001b[39m: Method to extract the poles\n       \n       \u001b[34m• \u001b[39m \u001b[36mPeakPicking\u001b[39m: Peak picking method (default)\n       \u001b[34m• \u001b[39m \u001b[36mCircleFit\u001b[39m: Circle fitting method\n       \u001b[34m• \u001b[39m \u001b[36mLSFit\u001b[39m: Least squares fitting method",
                        "text/markdown": "```julia\nAutoEMASdofProblem(prob, dpi, alg)\n```\n\nStructure containing the input data for automatic experimental modal analysis using Sdof methods\n\n**Fields**\n\n  * `prob::EMASdofProblem`: EMA-SDOF problem containing FRF data and frequency vector\n  * `dpi::Vector{Int}`: Driving point indices - default = [1, 1]\n\n      * `dpi[1]`: Driving point index on the measurement mesh\n      * `dpi[2]`: Driving point index on the excitation mesh\n  * `alg::SdofModalExtraction`: Method to extract the poles\n\n      * `PeakPicking`: Peak picking method (default)\n      * `CircleFit`: Circle fitting method\n      * `LSFit`: Least squares fitting method\n",
                        "text/html": "<div class=\"markdown\"><pre><code class=\"language-julia\">AutoEMASdofProblem&#40;prob, dpi, alg&#41;</code></pre>\n<p>Structure containing the input data for automatic experimental modal analysis using Sdof methods</p>\n<p><strong>Fields</strong></p>\n<ul>\n<li><p><code>prob::EMASdofProblem</code>: EMA-SDOF problem containing FRF data and frequency vector</p>\n</li>\n<li><p><code>dpi::Vector&#123;Int&#125;</code>: Driving point indices - default &#61; &#91;1, 1&#93;</p>\n<ul>\n<li><p><code>dpi&#91;1&#93;</code>: Driving point index on the measurement mesh</p>\n</li>\n<li><p><code>dpi&#91;2&#93;</code>: Driving point index on the excitation mesh</p>\n</li>\n</ul>\n</li>\n<li><p><code>alg::SdofModalExtraction</code>: Method to extract the poles</p>\n<ul>\n<li><p><code>PeakPicking</code>: Peak picking method &#40;default&#41;</p>\n</li>\n<li><p><code>CircleFit</code>: Circle fitting method</p>\n</li>\n<li><p><code>LSFit</code>: Least squares fitting method</p>\n</li>\n</ul>\n</li>\n</ul>\n\n\n</div>",
                        "text/latex": "\\begin{verbatim}\nAutoEMASdofProblem(prob, dpi, alg)\n\\end{verbatim}\nStructure containing the input data for automatic experimental modal analysis using Sdof methods\n\n\\textbf{Fields}\n\n\\begin{itemize}\n\\item \\texttt{prob::EMASdofProblem}: EMA-SDOF problem containing FRF data and frequency vector\n\n\n\\item \\texttt{dpi::Vector\\{Int\\}}: Driving point indices - default = [1, 1]\n\n\\begin{itemize}\n\\item \\texttt{dpi[1]}: Driving point index on the measurement mesh\n\n\n\\item \\texttt{dpi[2]}: Driving point index on the excitation mesh\n\n\\end{itemize}\n\n\\item \\texttt{alg::SdofModalExtraction}: Method to extract the poles\n\n\\begin{itemize}\n\\item \\texttt{PeakPicking}: Peak picking method (default)\n\n\n\\item \\texttt{CircleFit}: Circle fitting method\n\n\n\\item \\texttt{LSFit}: Least squares fitting method\n\n\\end{itemize}\n\\end{itemize}\n"
                    },
                    "metadata": {
                    }
                }
            ],
            "execution_count": 1
        },
        {
            "id": "7",
            "cell_type": "markdown",
            "metadata": {
            },
            "source": [
                ":::\n",
                "\n",
                "::: {.api}\n",
                "**EMASdofSolution**\n",
                "\n",
                "---"
            ]
        },
        {
            "id": "8",
            "cell_type": "code",
            "metadata": {
            },
            "source": [
                "#| echo: false\n",
                "@doc EMASdofSolution"
            ],
            "outputs": [
                {
                    "output_type": "execute_result",
                    "execution_count": 1,
                    "data": {
                        "text/plain": "  \u001b[36mEMASdofSolution(poles, ϕn)\u001b[39m\n\n  Structure containing the solution of the automatic experimental modal\n  analysis using Sdof methods\n\n  \u001b[1mFields\u001b[22m\n\n    \u001b[34m• \u001b[39m \u001b[36mpoles\u001b[39m: Extracted poles\n    \u001b[34m• \u001b[39m \u001b[36mms\u001b[39m: Mode shapes",
                        "text/markdown": "```julia\nEMASdofSolution(poles, ϕn)\n```\n\nStructure containing the solution of the automatic experimental modal analysis using Sdof methods\n\n**Fields**\n\n  * `poles`: Extracted poles\n  * `ms`: Mode shapes\n",
                        "text/html": "<div class=\"markdown\"><pre><code class=\"language-julia\">EMASdofSolution&#40;poles, ϕn&#41;</code></pre>\n<p>Structure containing the solution of the automatic experimental modal analysis using Sdof methods</p>\n<p><strong>Fields</strong></p>\n<ul>\n<li><p><code>poles</code>: Extracted poles</p>\n</li>\n<li><p><code>ms</code>: Mode shapes</p>\n</li>\n</ul>\n\n\n</div>",
                        "text/latex": "\\begin{verbatim}\nEMASdofSolution(poles, ϕn)\n\\end{verbatim}\nStructure containing the solution of the automatic experimental modal analysis using Sdof methods\n\n\\textbf{Fields}\n\n\\begin{itemize}\n\\item \\texttt{poles}: Extracted poles\n\n\n\\item \\texttt{ms}: Mode shapes\n\n\\end{itemize}\n"
                    },
                    "metadata": {
                    }
                }
            ],
            "execution_count": 1
        },
        {
            "id": "9",
            "cell_type": "markdown",
            "metadata": {
            },
            "source": [
                ":::\n",
                "\n",
                "::: {.api}\n",
                "**AutoEMAMdofProblem**\n",
                "\n",
                "---"
            ]
        },
        {
            "id": "10",
            "cell_type": "code",
            "metadata": {
            },
            "source": [
                "#| echo: false\n",
                "@doc AutoEMAMdofProblem"
            ],
            "outputs": [
                {
                    "output_type": "execute_result",
                    "execution_count": 1,
                    "data": {
                        "text/plain": "  \u001b[36mAutoEMAMdofProblem(prob, dpi, method; modetype)\u001b[39m\n\n  Structure containing the input data for automatic experimental modal\n  analysis using Mdof methods\n\n  \u001b[1mFields\u001b[22m\n\n    \u001b[34m• \u001b[39m \u001b[36mprob::EMAProblem\u001b[39m: EMA problem containing FRF data and frequency\n       vector\n    \u001b[34m• \u001b[39m \u001b[36morder::Int\u001b[39m: Model order (number of poles to extract)\n    \u001b[34m• \u001b[39m \u001b[36mdpi::Vector{Int}\u001b[39m: Driving point indices - default = [1, 1]\n       \n       \u001b[34m• \u001b[39m \u001b[36mdpi[1]\u001b[39m: Driving point index on the measurement mesh\n       \u001b[34m• \u001b[39m \u001b[36mdpi[2]\u001b[39m: Driving point index on the excitation mesh\n    \u001b[34m• \u001b[39m \u001b[36malg::MdofModalExtraction\u001b[39m: Method to extract the poles\n       \n       \u001b[34m• \u001b[39m \u001b[36mLSCE\u001b[39m: Least Squares Complex Exponential method\n       \u001b[34m• \u001b[39m \u001b[36mLSCF\u001b[39m`: Least Squares Complex Frequency method (default)\n       \u001b[34m• \u001b[39m \u001b[36mPLSCF\u001b[39m: Polyreference Least Squares Complex Frequency\n       method\n    \u001b[34m• \u001b[39m \u001b[36mmodetype::Symbol\u001b[39m: Type of mode shapes to extract\n       \n       \u001b[34m• \u001b[39m \u001b[36m:real\u001b[39m: Real mode shapes (default)\n       \u001b[34m• \u001b[39m \u001b[36m:complex\u001b[39m: Complex mode shapes",
                        "text/markdown": "```julia\nAutoEMAMdofProblem(prob, dpi, method; modetype)\n```\n\nStructure containing the input data for automatic experimental modal analysis using Mdof methods\n\n**Fields**\n\n  * `prob::EMAProblem`: EMA problem containing FRF data and frequency vector\n  * `order::Int`: Model order (number of poles to extract)\n  * `dpi::Vector{Int}`: Driving point indices - default = [1, 1]\n\n      * `dpi[1]`: Driving point index on the measurement mesh\n      * `dpi[2]`: Driving point index on the excitation mesh\n  * `alg::MdofModalExtraction`: Method to extract the poles\n\n      * `LSCE`: Least Squares Complex Exponential method\n      * `LSCF``: Least Squares Complex Frequency method (default)\n      * `PLSCF`: Polyreference Least Squares Complex Frequency method\n  * `modetype::Symbol`: Type of mode shapes to extract\n\n      * `:real`: Real mode shapes (default)\n      * `:complex`: Complex mode shapes\n",
                        "text/html": "<div class=\"markdown\"><pre><code class=\"language-julia\">AutoEMAMdofProblem&#40;prob, dpi, method; modetype&#41;</code></pre>\n<p>Structure containing the input data for automatic experimental modal analysis using Mdof methods</p>\n<p><strong>Fields</strong></p>\n<ul>\n<li><p><code>prob::EMAProblem</code>: EMA problem containing FRF data and frequency vector</p>\n</li>\n<li><p><code>order::Int</code>: Model order &#40;number of poles to extract&#41;</p>\n</li>\n<li><p><code>dpi::Vector&#123;Int&#125;</code>: Driving point indices - default &#61; &#91;1, 1&#93;</p>\n<ul>\n<li><p><code>dpi&#91;1&#93;</code>: Driving point index on the measurement mesh</p>\n</li>\n<li><p><code>dpi&#91;2&#93;</code>: Driving point index on the excitation mesh</p>\n</li>\n</ul>\n</li>\n<li><p><code>alg::MdofModalExtraction</code>: Method to extract the poles</p>\n<ul>\n<li><p><code>LSCE</code>: Least Squares Complex Exponential method</p>\n</li>\n<li><p><code>LSCF</code>&#96;: Least Squares Complex Frequency method &#40;default&#41;</p>\n</li>\n<li><p><code>PLSCF</code>: Polyreference Least Squares Complex Frequency method</p>\n</li>\n</ul>\n</li>\n<li><p><code>modetype::Symbol</code>: Type of mode shapes to extract</p>\n<ul>\n<li><p><code>:real</code>: Real mode shapes &#40;default&#41;</p>\n</li>\n<li><p><code>:complex</code>: Complex mode shapes</p>\n</li>\n</ul>\n</li>\n</ul>\n\n\n</div>",
                        "text/latex": "\\begin{verbatim}\nAutoEMAMdofProblem(prob, dpi, method; modetype)\n\\end{verbatim}\nStructure containing the input data for automatic experimental modal analysis using Mdof methods\n\n\\textbf{Fields}\n\n\\begin{itemize}\n\\item \\texttt{prob::EMAProblem}: EMA problem containing FRF data and frequency vector\n\n\n\\item \\texttt{order::Int}: Model order (number of poles to extract)\n\n\n\\item \\texttt{dpi::Vector\\{Int\\}}: Driving point indices - default = [1, 1]\n\n\\begin{itemize}\n\\item \\texttt{dpi[1]}: Driving point index on the measurement mesh\n\n\n\\item \\texttt{dpi[2]}: Driving point index on the excitation mesh\n\n\\end{itemize}\n\n\\item \\texttt{alg::MdofModalExtraction}: Method to extract the poles\n\n\\begin{itemize}\n\\item \\texttt{LSCE}: Least Squares Complex Exponential method\n\n\n\\item \\texttt{LSCF}`: Least Squares Complex Frequency method (default)\n\n\n\\item \\texttt{PLSCF}: Polyreference Least Squares Complex Frequency method\n\n\\end{itemize}\n\n\\item \\texttt{modetype::Symbol}: Type of mode shapes to extract\n\n\\begin{itemize}\n\\item \\texttt{:real}: Real mode shapes (default)\n\n\n\\item \\texttt{:complex}: Complex mode shapes\n\n\\end{itemize}\n\\end{itemize}\n"
                    },
                    "metadata": {
                    }
                }
            ],
            "execution_count": 1
        },
        {
            "id": "11",
            "cell_type": "markdown",
            "metadata": {
            },
            "source": [
                ":::\n",
                "\n",
                "::: {.api}\n",
                "**EMAMdofSolution**\n",
                "\n",
                "---"
            ]
        },
        {
            "id": "12",
            "cell_type": "code",
            "metadata": {
            },
            "source": [
                "#| echo: false\n",
                "@doc EMAMdofSolution"
            ],
            "outputs": [
                {
                    "output_type": "execute_result",
                    "execution_count": 1,
                    "data": {
                        "text/plain": "  \u001b[36mEMAMdofSolution(poles, ms, ci, res, lr, ur)\u001b[39m\n\n  Structure containing the solution of the automatic experimental modal\n  analysis using Mdof methods\n\n  \u001b[1mFields\u001b[22m\n\n    \u001b[34m• \u001b[39m \u001b[36mpoles::Vector{Complex}\u001b[39m: Extracted poles\n    \u001b[34m• \u001b[39m \u001b[36mms::AbstractArray{Real}\u001b[39m: Mode shapes\n    \u001b[34m• \u001b[39m \u001b[36mci::Vector{Complex}\u001b[39m: Scaling constants for each mode\n    \u001b[34m• \u001b[39m \u001b[36mres::AbstractArray{Complex}\u001b[39m: Residues for each mode\n    \u001b[34m• \u001b[39m \u001b[36mlr::Matrix{Complex}\u001b[39m: Lower residual\n    \u001b[34m• \u001b[39m \u001b[36mur::Matrix{Complex}\u001b[39m: Upper residual",
                        "text/markdown": "```julia\nEMAMdofSolution(poles, ms, ci, res, lr, ur)\n```\n\nStructure containing the solution of the automatic experimental modal analysis using Mdof methods\n\n**Fields**\n\n  * `poles::Vector{Complex}`: Extracted poles\n  * `ms::AbstractArray{Real}`: Mode shapes\n  * `ci::Vector{Complex}`: Scaling constants for each mode\n  * `res::AbstractArray{Complex}`: Residues for each mode\n  * `lr::Matrix{Complex}`: Lower residual\n  * `ur::Matrix{Complex}`: Upper residual\n",
                        "text/html": "<div class=\"markdown\"><pre><code class=\"language-julia\">EMAMdofSolution&#40;poles, ms, ci, res, lr, ur&#41;</code></pre>\n<p>Structure containing the solution of the automatic experimental modal analysis using Mdof methods</p>\n<p><strong>Fields</strong></p>\n<ul>\n<li><p><code>poles::Vector&#123;Complex&#125;</code>: Extracted poles</p>\n</li>\n<li><p><code>ms::AbstractArray&#123;Real&#125;</code>: Mode shapes</p>\n</li>\n<li><p><code>ci::Vector&#123;Complex&#125;</code>: Scaling constants for each mode</p>\n</li>\n<li><p><code>res::AbstractArray&#123;Complex&#125;</code>: Residues for each mode</p>\n</li>\n<li><p><code>lr::Matrix&#123;Complex&#125;</code>: Lower residual</p>\n</li>\n<li><p><code>ur::Matrix&#123;Complex&#125;</code>: Upper residual</p>\n</li>\n</ul>\n\n\n</div>",
                        "text/latex": "\\begin{verbatim}\nEMAMdofSolution(poles, ms, ci, res, lr, ur)\n\\end{verbatim}\nStructure containing the solution of the automatic experimental modal analysis using Mdof methods\n\n\\textbf{Fields}\n\n\\begin{itemize}\n\\item \\texttt{poles::Vector\\{Complex\\}}: Extracted poles\n\n\n\\item \\texttt{ms::AbstractArray\\{Real\\}}: Mode shapes\n\n\n\\item \\texttt{ci::Vector\\{Complex\\}}: Scaling constants for each mode\n\n\n\\item \\texttt{res::AbstractArray\\{Complex\\}}: Residues for each mode\n\n\n\\item \\texttt{lr::Matrix\\{Complex\\}}: Lower residual\n\n\n\\item \\texttt{ur::Matrix\\{Complex\\}}: Upper residual\n\n\\end{itemize}\n"
                    },
                    "metadata": {
                    }
                }
            ],
            "execution_count": 1
        },
        {
            "id": "13",
            "cell_type": "markdown",
            "metadata": {
            },
            "source": [
                ":::\n",
                "\n",
                "::: {.api}\n",
                "**StabilizationAnalysis**\n",
                "\n",
                "---"
            ]
        },
        {
            "id": "14",
            "cell_type": "code",
            "metadata": {
            },
            "source": [
                "#| echo: false\n",
                "@doc StabilizationAnalysis"
            ],
            "outputs": [
                {
                    "output_type": "execute_result",
                    "execution_count": 1,
                    "data": {
                        "text/plain": "  \u001b[36mStabilizationAnalysis(prob, poles, modefn, mode_stabfn, mode_stabdr)\u001b[39m\n\n  Data structure summarizing the results of the stabilization analysis.\n\n  \u001b[1mFields\u001b[22m\n\n    \u001b[34m• \u001b[39m \u001b[36mprob::MdofProblem\u001b[39m: EMA-MDOF problem containing FRF data and\n       frequency vector\n    \u001b[34m• \u001b[39m \u001b[36mfrange::Vector{Real}\u001b[39m: Frequency range used for the stabilization\n       analysis\n    \u001b[34m• \u001b[39m \u001b[36mpoles::Vector{Vector{Complex}}\u001b[39m: Vector of vectors containing\n       extracted poles at each model order\n    \u001b[34m• \u001b[39m \u001b[36mmodefn::Matrix{Real}\u001b[39m: Matrix containing the natural frequencies\n       (useful for plotting)\n    \u001b[34m• \u001b[39m \u001b[36mmode_stabfn::Matrix{Bool}\u001b[39m: Matrix indicating the stability of\n       natural frequencies\n    \u001b[34m• \u001b[39m \u001b[36mmode_stabdr::Matrix{Bool}\u001b[39m: Matrix indicating the stability of\n       damping ratios\n\n  \u001b[1mNote\u001b[22m\n\n  This structure is returned by the \u001b[36mstabilization\u001b[39m function after performing a\n  stabilization diagram analysis and used by \u001b[36mstabilization_plot\u001b[39m for\n  visualization.",
                        "text/markdown": "```julia\nStabilizationAnalysis(prob, poles, modefn, mode_stabfn, mode_stabdr)\n```\n\nData structure summarizing the results of the stabilization analysis.\n\n**Fields**\n\n  * `prob::MdofProblem`: EMA-MDOF problem containing FRF data and frequency vector\n  * `frange::Vector{Real}`: Frequency range used for the stabilization analysis\n  * `poles::Vector{Vector{Complex}}`: Vector of vectors containing extracted poles at each model order\n  * `modefn::Matrix{Real}`: Matrix containing the natural frequencies (useful for plotting)\n  * `mode_stabfn::Matrix{Bool}`: Matrix indicating the stability of natural frequencies\n  * `mode_stabdr::Matrix{Bool}`: Matrix indicating the stability of damping ratios\n\n**Note**\n\nThis structure is returned by the `stabilization` function after performing a stabilization diagram analysis and used by `stabilization_plot` for visualization.\n",
                        "text/html": "<div class=\"markdown\"><pre><code class=\"language-julia\">StabilizationAnalysis&#40;prob, poles, modefn, mode_stabfn, mode_stabdr&#41;</code></pre>\n<p>Data structure summarizing the results of the stabilization analysis.</p>\n<p><strong>Fields</strong></p>\n<ul>\n<li><p><code>prob::MdofProblem</code>: EMA-MDOF problem containing FRF data and frequency vector</p>\n</li>\n<li><p><code>frange::Vector&#123;Real&#125;</code>: Frequency range used for the stabilization analysis</p>\n</li>\n<li><p><code>poles::Vector&#123;Vector&#123;Complex&#125;&#125;</code>: Vector of vectors containing extracted poles at each model order</p>\n</li>\n<li><p><code>modefn::Matrix&#123;Real&#125;</code>: Matrix containing the natural frequencies &#40;useful for plotting&#41;</p>\n</li>\n<li><p><code>mode_stabfn::Matrix&#123;Bool&#125;</code>: Matrix indicating the stability of natural frequencies</p>\n</li>\n<li><p><code>mode_stabdr::Matrix&#123;Bool&#125;</code>: Matrix indicating the stability of damping ratios</p>\n</li>\n</ul>\n<p><strong>Note</strong></p>\n<p>This structure is returned by the <code>stabilization</code> function after performing a stabilization diagram analysis and used by <code>stabilization_plot</code> for visualization.</p>\n\n\n</div>",
                        "text/latex": "\\begin{verbatim}\nStabilizationAnalysis(prob, poles, modefn, mode_stabfn, mode_stabdr)\n\\end{verbatim}\nData structure summarizing the results of the stabilization analysis.\n\n\\textbf{Fields}\n\n\\begin{itemize}\n\\item \\texttt{prob::MdofProblem}: EMA-MDOF problem containing FRF data and frequency vector\n\n\n\\item \\texttt{frange::Vector\\{Real\\}}: Frequency range used for the stabilization analysis\n\n\n\\item \\texttt{poles::Vector\\{Vector\\{Complex\\}\\}}: Vector of vectors containing extracted poles at each model order\n\n\n\\item \\texttt{modefn::Matrix\\{Real\\}}: Matrix containing the natural frequencies (useful for plotting)\n\n\n\\item \\texttt{mode\\_stabfn::Matrix\\{Bool\\}}: Matrix indicating the stability of natural frequencies\n\n\n\\item \\texttt{mode\\_stabdr::Matrix\\{Bool\\}}: Matrix indicating the stability of damping ratios\n\n\\end{itemize}\n\\textbf{Note}\n\nThis structure is returned by the \\texttt{stabilization} function after performing a stabilization diagram analysis and used by \\texttt{stabilization\\_plot} for visualization.\n\n"
                    },
                    "metadata": {
                    }
                }
            ],
            "execution_count": 1
        },
        {
            "id": "15",
            "cell_type": "markdown",
            "metadata": {
            },
            "source": [
                ":::\n",
                "\n",
                "**Related functions**\n",
                "\n",
                "::: {.api}\n",
                "**poles_extraction**\n",
                "\n",
                "---"
            ]
        },
        {
            "id": "16",
            "cell_type": "code",
            "metadata": {
            },
            "source": [
                "#| echo: false\n",
                "@doc poles_extraction(::EMAProblem, ::CircleFit)"
            ],
            "outputs": [
                {
                    "output_type": "execute_result",
                    "execution_count": 1,
                    "data": {
                        "text/plain": "  \u001b[36mpoles_extraction(prob::EMAProblem, alg)\u001b[39m\n  \u001b[36mpoles_extraction(prob::MdofProblem, order, alg; stabdiag, weighting)\u001b[39m\n\n  Extract poles from the Bode diagram fitting method\n\n  \u001b[1mInputs\u001b[22m\n\n    \u001b[34m• \u001b[39m \u001b[36mprob::EMAProblem\u001b[39m or \u001b[36mprob::MdofProblem\u001b[39m: EMA problem containing FRF\n       data and frequency vector\n    \u001b[34m• \u001b[39m \u001b[36morder\u001b[39m: Order of the model (only for Mdof methods)\n    \u001b[34m• \u001b[39m \u001b[36malg\u001b[39m: Algorithm to extract the poles\n       \n       \u001b[34m• \u001b[39m Sdof methods:\n       \n       \u001b[34m• \u001b[39m \u001b[36mPeakPicking\u001b[39m: Peak picking method (default for\n       Sdof methods)\n       \u001b[34m• \u001b[39m \u001b[36mCircleFit\u001b[39m: Circle fitting method\n       \u001b[34m• \u001b[39m \u001b[36mLSFit\u001b[39m: Least squares fitting method\n       \u001b[34m• \u001b[39m Mdof methods:\n       \n       \u001b[34m• \u001b[39m \u001b[36mLSCF\u001b[39m: Least Squares Complex Frequency method\n       (default for Mdof methods)\n       \u001b[34m• \u001b[39m \u001b[36mPLSCF\u001b[39m: Polyreference Least Squares Complex\n       Frequency method\n       \u001b[34m• \u001b[39m \u001b[36mLSCE\u001b[39m: Least Squares Complex Exponential method\n       (only for Mdof methods)\n    \u001b[34m• \u001b[39m \u001b[36mstabdiag::Bool\u001b[39m: Boolean to indicate the function is used to build\n       a stability diagram (Only for Mdof methods, default: false)\n    \u001b[34m• \u001b[39m \u001b[36mweighting::Bool\u001b[39m: Boolean to indicate whether to apply weighting of\n       the FRF (Not applicable to Sdof methods and LSCE, default: true)\n\n  \u001b[1mOutputs\u001b[22m\n\n    \u001b[34m• \u001b[39m \u001b[36mpoles\u001b[39m: Vector of extracted complex poles\n\n  \u001b[1mNote\u001b[22m\n\n    \u001b[34m• \u001b[39m For Sdof methods, the natural frequencies and damping ratios are\n       extracted from each FRF (each row of the matrix) and then\n       averaged. The number of FRF used for averaging are those having\n       the maximum (and same) number of peaks detected.",
                        "text/markdown": "```julia\npoles_extraction(prob::EMAProblem, alg)\npoles_extraction(prob::MdofProblem, order, alg; stabdiag, weighting)\n```\n\nExtract poles from the Bode diagram fitting method\n\n**Inputs**\n\n  * `prob::EMAProblem` or `prob::MdofProblem`: EMA problem containing FRF data and frequency vector\n  * `order`: Order of the model (only for Mdof methods)\n  * `alg`: Algorithm to extract the poles\n\n      * Sdof methods:\n\n          * `PeakPicking`: Peak picking method (default for Sdof methods)\n          * `CircleFit`: Circle fitting method\n          * `LSFit`: Least squares fitting method\n      * Mdof methods:\n\n          * `LSCF`: Least Squares Complex Frequency method (default for Mdof methods)\n          * `PLSCF`: Polyreference Least Squares Complex Frequency method\n          * `LSCE`: Least Squares Complex Exponential method (only for Mdof methods)\n  * `stabdiag::Bool`: Boolean to indicate the function is used to build a stability diagram (Only for Mdof methods, default: false)\n  * `weighting::Bool`: Boolean to indicate whether to apply weighting of the FRF (Not applicable to Sdof methods and LSCE, default: true)\n\n**Outputs**\n\n  * `poles`: Vector of extracted complex poles\n\n**Note**\n\n  * For Sdof methods, the natural frequencies and damping ratios are extracted from each FRF (each row of the matrix) and then averaged. The number of FRF used for averaging are those having the maximum (and same) number of peaks detected.\n",
                        "text/html": "<div class=\"markdown\"><pre><code class=\"language-julia\">poles_extraction&#40;prob::EMAProblem, alg&#41;\npoles_extraction&#40;prob::MdofProblem, order, alg; stabdiag, weighting&#41;</code></pre>\n<p>Extract poles from the Bode diagram fitting method</p>\n<p><strong>Inputs</strong></p>\n<ul>\n<li><p><code>prob::EMAProblem</code> or <code>prob::MdofProblem</code>: EMA problem containing FRF data and frequency vector</p>\n</li>\n<li><p><code>order</code>: Order of the model &#40;only for Mdof methods&#41;</p>\n</li>\n<li><p><code>alg</code>: Algorithm to extract the poles</p>\n<ul>\n<li><p>Sdof methods:</p>\n<ul>\n<li><p><code>PeakPicking</code>: Peak picking method &#40;default for Sdof methods&#41;</p>\n</li>\n<li><p><code>CircleFit</code>: Circle fitting method</p>\n</li>\n<li><p><code>LSFit</code>: Least squares fitting method</p>\n</li>\n</ul>\n</li>\n<li><p>Mdof methods:</p>\n<ul>\n<li><p><code>LSCF</code>: Least Squares Complex Frequency method &#40;default for Mdof methods&#41;</p>\n</li>\n<li><p><code>PLSCF</code>: Polyreference Least Squares Complex Frequency method</p>\n</li>\n<li><p><code>LSCE</code>: Least Squares Complex Exponential method &#40;only for Mdof methods&#41;</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><code>stabdiag::Bool</code>: Boolean to indicate the function is used to build a stability diagram &#40;Only for Mdof methods, default: false&#41;</p>\n</li>\n<li><p><code>weighting::Bool</code>: Boolean to indicate whether to apply weighting of the FRF &#40;Not applicable to Sdof methods and LSCE, default: true&#41;</p>\n</li>\n</ul>\n<p><strong>Outputs</strong></p>\n<ul>\n<li><p><code>poles</code>: Vector of extracted complex poles</p>\n</li>\n</ul>\n<p><strong>Note</strong></p>\n<ul>\n<li><p>For Sdof methods, the natural frequencies and damping ratios are extracted from each FRF &#40;each row of the matrix&#41; and then averaged. The number of FRF used for averaging are those having the maximum &#40;and same&#41; number of peaks detected.</p>\n</li>\n</ul>\n\n\n</div>",
                        "text/latex": "\\begin{verbatim}\npoles_extraction(prob::EMAProblem, alg)\npoles_extraction(prob::MdofProblem, order, alg; stabdiag, weighting)\n\\end{verbatim}\nExtract poles from the Bode diagram fitting method\n\n\\textbf{Inputs}\n\n\\begin{itemize}\n\\item \\texttt{prob::EMAProblem} or \\texttt{prob::MdofProblem}: EMA problem containing FRF data and frequency vector\n\n\n\\item \\texttt{order}: Order of the model (only for Mdof methods)\n\n\n\\item \\texttt{alg}: Algorithm to extract the poles\n\n\\begin{itemize}\n\\item Sdof methods:\n\n\\begin{itemize}\n\\item \\texttt{PeakPicking}: Peak picking method (default for Sdof methods)\n\n\n\\item \\texttt{CircleFit}: Circle fitting method\n\n\n\\item \\texttt{LSFit}: Least squares fitting method\n\n\\end{itemize}\n\n\\item Mdof methods:\n\n\\begin{itemize}\n\\item \\texttt{LSCF}: Least Squares Complex Frequency method (default for Mdof methods)\n\n\n\\item \\texttt{PLSCF}: Polyreference Least Squares Complex Frequency method\n\n\n\\item \\texttt{LSCE}: Least Squares Complex Exponential method (only for Mdof methods)\n\n\\end{itemize}\n\\end{itemize}\n\n\\item \\texttt{stabdiag::Bool}: Boolean to indicate the function is used to build a stability diagram (Only for Mdof methods, default: false)\n\n\n\\item \\texttt{weighting::Bool}: Boolean to indicate whether to apply weighting of the FRF (Not applicable to Sdof methods and LSCE, default: true)\n\n\\end{itemize}\n\\textbf{Outputs}\n\n\\begin{itemize}\n\\item \\texttt{poles}: Vector of extracted complex poles\n\n\\end{itemize}\n\\textbf{Note}\n\n\\begin{itemize}\n\\item For Sdof methods, the natural frequencies and damping ratios are extracted from each FRF (each row of the matrix) and then averaged. The number of FRF used for averaging are those having the maximum (and same) number of peaks detected.\n\n\\end{itemize}\n"
                    },
                    "metadata": {
                    }
                }
            ],
            "execution_count": 1
        },
        {
            "id": "17",
            "cell_type": "markdown",
            "metadata": {
            },
            "source": [
                ":::\n",
                "\n",
                "::: {.api}\n",
                "**modeshape_extraction**\n",
                "\n",
                "---"
            ]
        },
        {
            "id": "18",
            "cell_type": "code",
            "metadata": {
            },
            "source": [
                "#| echo: false\n",
                "@doc modeshape_extraction(::EMAProblem, ::Vector{T}, ::CircleFit; ::Symbol) where {T <: Complex}"
            ],
            "outputs": [
                {
                    "output_type": "execute_result",
                    "execution_count": 1,
                    "data": {
                        "text/plain": "  \u001b[36mmodeshape_extraction(prob, poles, alg; dpi)\u001b[39m\n  \u001b[36mmodeshape_extraction(residues, poles, alg; dpi, modetype)\u001b[39m\n\n  Extract mode shapes using Sdof approximation\n\n  \u001b[1mInputs\u001b[22m\n\n    \u001b[34m• \u001b[39m \u001b[36mprob::EMAProblem\u001b[39m: EMA problem containing FRF data and frequency\n       vector\n    \u001b[34m• \u001b[39m \u001b[36mpoles\u001b[39m: Vector of complex poles\n    \u001b[34m• \u001b[39m \u001b[36malg::SdofModalExtraction\u001b[39m or \u001b[36malg::MdofModalExtraction\u001b[39m: Modal\n       extraction algorithm\n    \u001b[34m• \u001b[39m \u001b[36mdpi\u001b[39m: Driving point indices - default = [1, 1]\n       \n       \u001b[34m• \u001b[39m \u001b[36mdpi[1]\u001b[39m: Driving point index on the measurement mesh\n       \u001b[34m• \u001b[39m \u001b[36mdpi[2]\u001b[39m: Driving point index on the excitation mesh\n    \u001b[34m• \u001b[39m \u001b[36mmodetype\u001b[39m: Type of mode shape (only for Mdof methods)\n       \n       \u001b[34m• \u001b[39m \u001b[36m:emac\u001b[39m: EMA - Complex mode shapes (default)\n       \u001b[34m• \u001b[39m \u001b[36m:emar\u001b[39m: EMA - Real mode shapes\n       \u001b[34m• \u001b[39m \u001b[36m:oma\u001b[39m: OMA\n\n  \u001b[1mOutput\u001b[22m\n\n    \u001b[34m• \u001b[39m \u001b[36mms\u001b[39m: Mode shapes\n    \u001b[34m• \u001b[39m \u001b[36mci\u001b[39m: Scaling factors vector (only for Mdof methods)\n\n  \u001b[1mNote\u001b[22m\n\n    \u001b[34m• \u001b[39m If the number of measurement points is less than the number of\n       excitation points, the mode shapes are estimated at the excitation\n       points (roving hammer test). Otherwise, the mode shapes are\n       estimated at the measurement points (roving accelerometer test).\n    \u001b[34m• \u001b[39m The \u001b[36malg\u001b[39m argument is here for performing multiple dispatch but is\n       not used in the function.\n\n  \u001b[1mReferences\u001b[22m [1] M. Géradin and D. J. Rixen. \"Mechanical Vibrations: Theory\n  and Application to Structural Dynamics\". 3rd. Edition, Wiley, 2015.\n\n  [2] C. Ranieri and G. Fabbrocino. \"Operational Modal Analysis of Civil\n  Engineering Structures: An Introduction and Guide for Applications\".\n  Springer, 2014.",
                        "text/markdown": "```julia\nmodeshape_extraction(prob, poles, alg; dpi)\nmodeshape_extraction(residues, poles, alg; dpi, modetype)\n```\n\nExtract mode shapes using Sdof approximation\n\n**Inputs**\n\n  * `prob::EMAProblem`: EMA problem containing FRF data and frequency vector\n  * `poles`: Vector of complex poles\n  * `alg::SdofModalExtraction` or `alg::MdofModalExtraction`: Modal extraction algorithm\n  * `dpi`: Driving point indices - default = [1, 1]\n\n      * `dpi[1]`: Driving point index on the measurement mesh\n      * `dpi[2]`: Driving point index on the excitation mesh\n  * `modetype`: Type of mode shape (only for Mdof methods)\n\n      * `:emac`: EMA - Complex mode shapes (default)\n      * `:emar`: EMA - Real mode shapes\n      * `:oma`: OMA\n\n**Output**\n\n  * `ms`: Mode shapes\n  * `ci`: Scaling factors vector (only for Mdof methods)\n\n**Note**\n\n  * If the number of measurement points is less than the number of excitation points, the mode shapes are estimated at the excitation points (roving hammer test). Otherwise, the mode shapes are estimated at the measurement points (roving accelerometer test).\n  * The `alg` argument is here for performing multiple dispatch but is not used in the function.\n\n**References** [1] M. Géradin and D. J. Rixen. \"Mechanical Vibrations: Theory and Application to Structural Dynamics\". 3rd. Edition, Wiley, 2015.\n\n[2] C. Ranieri and G. Fabbrocino. \"Operational Modal Analysis of Civil Engineering Structures: An Introduction and Guide for Applications\". Springer, 2014.\n",
                        "text/html": "<div class=\"markdown\"><pre><code class=\"language-julia\">modeshape_extraction&#40;prob, poles, alg; dpi&#41;\nmodeshape_extraction&#40;residues, poles, alg; dpi, modetype&#41;</code></pre>\n<p>Extract mode shapes using Sdof approximation</p>\n<p><strong>Inputs</strong></p>\n<ul>\n<li><p><code>prob::EMAProblem</code>: EMA problem containing FRF data and frequency vector</p>\n</li>\n<li><p><code>poles</code>: Vector of complex poles</p>\n</li>\n<li><p><code>alg::SdofModalExtraction</code> or <code>alg::MdofModalExtraction</code>: Modal extraction algorithm</p>\n</li>\n<li><p><code>dpi</code>: Driving point indices - default &#61; &#91;1, 1&#93;</p>\n<ul>\n<li><p><code>dpi&#91;1&#93;</code>: Driving point index on the measurement mesh</p>\n</li>\n<li><p><code>dpi&#91;2&#93;</code>: Driving point index on the excitation mesh</p>\n</li>\n</ul>\n</li>\n<li><p><code>modetype</code>: Type of mode shape &#40;only for Mdof methods&#41;</p>\n<ul>\n<li><p><code>:emac</code>: EMA - Complex mode shapes &#40;default&#41;</p>\n</li>\n<li><p><code>:emar</code>: EMA - Real mode shapes</p>\n</li>\n<li><p><code>:oma</code>: OMA</p>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>Output</strong></p>\n<ul>\n<li><p><code>ms</code>: Mode shapes</p>\n</li>\n<li><p><code>ci</code>: Scaling factors vector &#40;only for Mdof methods&#41;</p>\n</li>\n</ul>\n<p><strong>Note</strong></p>\n<ul>\n<li><p>If the number of measurement points is less than the number of excitation points, the mode shapes are estimated at the excitation points &#40;roving hammer test&#41;. Otherwise, the mode shapes are estimated at the measurement points &#40;roving accelerometer test&#41;.</p>\n</li>\n<li><p>The <code>alg</code> argument is here for performing multiple dispatch but is not used in the function.</p>\n</li>\n</ul>\n<p><strong>References</strong> &#91;1&#93; M. Géradin and D. J. Rixen. &quot;Mechanical Vibrations: Theory and Application to Structural Dynamics&quot;. 3rd. Edition, Wiley, 2015.</p>\n<p>&#91;2&#93; C. Ranieri and G. Fabbrocino. &quot;Operational Modal Analysis of Civil Engineering Structures: An Introduction and Guide for Applications&quot;. Springer, 2014.</p>\n\n\n</div>",
                        "text/latex": "\\begin{verbatim}\nmodeshape_extraction(prob, poles, alg; dpi)\nmodeshape_extraction(residues, poles, alg; dpi, modetype)\n\\end{verbatim}\nExtract mode shapes using Sdof approximation\n\n\\textbf{Inputs}\n\n\\begin{itemize}\n\\item \\texttt{prob::EMAProblem}: EMA problem containing FRF data and frequency vector\n\n\n\\item \\texttt{poles}: Vector of complex poles\n\n\n\\item \\texttt{alg::SdofModalExtraction} or \\texttt{alg::MdofModalExtraction}: Modal extraction algorithm\n\n\n\\item \\texttt{dpi}: Driving point indices - default = [1, 1]\n\n\\begin{itemize}\n\\item \\texttt{dpi[1]}: Driving point index on the measurement mesh\n\n\n\\item \\texttt{dpi[2]}: Driving point index on the excitation mesh\n\n\\end{itemize}\n\n\\item \\texttt{modetype}: Type of mode shape (only for Mdof methods)\n\n\\begin{itemize}\n\\item \\texttt{:emac}: EMA - Complex mode shapes (default)\n\n\n\\item \\texttt{:emar}: EMA - Real mode shapes\n\n\n\\item \\texttt{:oma}: OMA\n\n\\end{itemize}\n\\end{itemize}\n\\textbf{Output}\n\n\\begin{itemize}\n\\item \\texttt{ms}: Mode shapes\n\n\n\\item \\texttt{ci}: Scaling factors vector (only for Mdof methods)\n\n\\end{itemize}\n\\textbf{Note}\n\n\\begin{itemize}\n\\item If the number of measurement points is less than the number of excitation points, the mode shapes are estimated at the excitation points (roving hammer test). Otherwise, the mode shapes are estimated at the measurement points (roving accelerometer test).\n\n\n\\item The \\texttt{alg} argument is here for performing multiple dispatch but is not used in the function.\n\n\\end{itemize}\n\\textbf{References} [1] M. Géradin and D. J. Rixen. \"Mechanical Vibrations: Theory and Application to Structural Dynamics\". 3rd. Edition, Wiley, 2015.\n\n[2] C. Ranieri and G. Fabbrocino. \"Operational Modal Analysis of Civil Engineering Structures: An Introduction and Guide for Applications\". Springer, 2014.\n\n"
                    },
                    "metadata": {
                    }
                }
            ],
            "execution_count": 1
        },
        {
            "id": "19",
            "cell_type": "markdown",
            "metadata": {
            },
            "source": [
                ":::\n",
                "\n",
                "::: {.api}\n",
                "**modal2poles**\n",
                "\n",
                "---"
            ]
        },
        {
            "id": "20",
            "cell_type": "code",
            "metadata": {
            },
            "source": [
                "#| echo: false\n",
                "@doc modal2poles"
            ],
            "outputs": [
                {
                    "output_type": "execute_result",
                    "execution_count": 1,
                    "data": {
                        "text/plain": "  \u001b[36mmodal2poles(fn, ξn)\u001b[39m\n\n  Convert natural frequencies and damping ratios to complex poles.\n\n  \u001b[1mInputs\u001b[22m\n\n    \u001b[34m• \u001b[39m \u001b[36mfn\u001b[39m: Vector of natural frequencies (Hz)\n    \u001b[34m• \u001b[39m \u001b[36mξn\u001b[39m: Vector of damping ratios\n\n  \u001b[1mOutput\u001b[22m\n\n    \u001b[34m• \u001b[39m \u001b[36mpoles\u001b[39m: Vector of complex poles",
                        "text/markdown": "```julia\nmodal2poles(fn, ξn)\n```\n\nConvert natural frequencies and damping ratios to complex poles.\n\n**Inputs**\n\n  * `fn`: Vector of natural frequencies (Hz)\n  * `ξn`: Vector of damping ratios\n\n**Output**\n\n  * `poles`: Vector of complex poles\n",
                        "text/html": "<div class=\"markdown\"><pre><code class=\"language-julia\">modal2poles&#40;fn, ξn&#41;</code></pre>\n<p>Convert natural frequencies and damping ratios to complex poles.</p>\n<p><strong>Inputs</strong></p>\n<ul>\n<li><p><code>fn</code>: Vector of natural frequencies &#40;Hz&#41;</p>\n</li>\n<li><p><code>ξn</code>: Vector of damping ratios</p>\n</li>\n</ul>\n<p><strong>Output</strong></p>\n<ul>\n<li><p><code>poles</code>: Vector of complex poles</p>\n</li>\n</ul>\n\n\n</div>",
                        "text/latex": "\\begin{verbatim}\nmodal2poles(fn, ξn)\n\\end{verbatim}\nConvert natural frequencies and damping ratios to complex poles.\n\n\\textbf{Inputs}\n\n\\begin{itemize}\n\\item \\texttt{fn}: Vector of natural frequencies (Hz)\n\n\n\\item \\texttt{ξn}: Vector of damping ratios\n\n\\end{itemize}\n\\textbf{Output}\n\n\\begin{itemize}\n\\item \\texttt{poles}: Vector of complex poles\n\n\\end{itemize}\n"
                    },
                    "metadata": {
                    }
                }
            ],
            "execution_count": 1
        },
        {
            "id": "21",
            "cell_type": "markdown",
            "metadata": {
            },
            "source": [
                ":::\n",
                "\n",
                "::: {.api}\n",
                "**poles2modal**\n",
                "\n",
                "---"
            ]
        },
        {
            "id": "22",
            "cell_type": "code",
            "metadata": {
            },
            "source": [
                "#| echo: false\n",
                "@doc poles2modal"
            ],
            "outputs": [
                {
                    "output_type": "execute_result",
                    "execution_count": 1,
                    "data": {
                        "text/plain": "  \u001b[36mpoles2modal(poles)\u001b[39m\n\n  Convert complex poles to natural frequencies and damping ratios.\n\n  \u001b[1mInput\u001b[22m\n\n    \u001b[34m• \u001b[39m \u001b[36mpoles\u001b[39m: Vector of complex poles\n\n  \u001b[1mOutputs\u001b[22m\n\n    \u001b[34m• \u001b[39m \u001b[36mfn\u001b[39m: Vector of natural frequencies (Hz)\n    \u001b[34m• \u001b[39m \u001b[36mξn\u001b[39m: Vector of damping ratios",
                        "text/markdown": "```julia\npoles2modal(poles)\n```\n\nConvert complex poles to natural frequencies and damping ratios.\n\n**Input**\n\n  * `poles`: Vector of complex poles\n\n**Outputs**\n\n  * `fn`: Vector of natural frequencies (Hz)\n  * `ξn`: Vector of damping ratios\n",
                        "text/html": "<div class=\"markdown\"><pre><code class=\"language-julia\">poles2modal&#40;poles&#41;</code></pre>\n<p>Convert complex poles to natural frequencies and damping ratios.</p>\n<p><strong>Input</strong></p>\n<ul>\n<li><p><code>poles</code>: Vector of complex poles</p>\n</li>\n</ul>\n<p><strong>Outputs</strong></p>\n<ul>\n<li><p><code>fn</code>: Vector of natural frequencies &#40;Hz&#41;</p>\n</li>\n<li><p><code>ξn</code>: Vector of damping ratios</p>\n</li>\n</ul>\n\n\n</div>",
                        "text/latex": "\\begin{verbatim}\npoles2modal(poles)\n\\end{verbatim}\nConvert complex poles to natural frequencies and damping ratios.\n\n\\textbf{Input}\n\n\\begin{itemize}\n\\item \\texttt{poles}: Vector of complex poles\n\n\\end{itemize}\n\\textbf{Outputs}\n\n\\begin{itemize}\n\\item \\texttt{fn}: Vector of natural frequencies (Hz)\n\n\n\\item \\texttt{ξn}: Vector of damping ratios\n\n\\end{itemize}\n"
                    },
                    "metadata": {
                    }
                }
            ],
            "execution_count": 1
        },
        {
            "id": "23",
            "cell_type": "markdown",
            "metadata": {
            },
            "source": [
                ":::"
            ]
        }
    ],
    "timestamp": "2025-11-12T16:50:57.001",
    "file": "/Users/maucejo/Documents/01_Recherche/04_Projets/Codes/Julia/StructuralVibration/docs/modal_extraction/index.qmd",
    "qnr_schema_version": "1.0.0"
}