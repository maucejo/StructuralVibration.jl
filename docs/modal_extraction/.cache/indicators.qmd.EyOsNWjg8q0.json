{
    "cells": [
        {
            "id": "1",
            "cell_type": "markdown",
            "metadata": {
            },
            "source": [
                "---\n",
                "title: Quality and analysis indicators\n",
                "format:\n",
                "  html:\n",
                "    toc: true\n",
                "    number-sections: true\n",
                "engine: julia\n",
                "execute:\n",
                "  freeze: auto\n",
                "  cache: true\n",
                "---"
            ]
        },
        {
            "id": "2",
            "cell_type": "code",
            "metadata": {
            },
            "source": [
                "#| echo: false\n",
                "#| output: false\n",
                "using StructuralVibration, ShareAdd\n",
                "@usingany CairoMakie"
            ],
            "outputs": [
                {
                    "output_type": "stream",
                    "name": "stdout",
                    "text": "\u001b[91m\u001b[1m┌ \u001b[22m\u001b[39m\u001b[91m\u001b[1mError: \u001b[22m\u001b[39mError during loading of extension QuartoNotebookWorkerMakieExt of QuartoNotebookWorker, use `Base.retry_load_extensions()` to retry.\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m  exception =\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[0m1-element ExceptionStack:\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   InitError: MethodError: no method matching isless(::Nothing, ::VersionNumber)\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   The function `isless` exists, but no method is defined for this combination of argument types.\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[0mClosest candidates are:\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[0m  isless(\u001b[91m::VersionNumber\u001b[39m, ::VersionNumber)\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[0m\u001b[90m   @\u001b[39m \u001b[90mBase\u001b[39m \u001b[90m\u001b[4mversion.jl:201\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[0m  isless(\u001b[91m::Missing\u001b[39m, ::Any)\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[0m\u001b[90m   @\u001b[39m \u001b[90mBase\u001b[39m \u001b[90m\u001b[4mmissing.jl:87\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[0m  isless(::Any, \u001b[91m::Missing\u001b[39m)\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[0m\u001b[90m   @\u001b[39m \u001b[90mBase\u001b[39m \u001b[90m\u001b[4mmissing.jl:88\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[0m  ...\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   Stacktrace:\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m     [1] \u001b[0m\u001b[1m<\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[90mx\u001b[39m::\u001b[0mNothing, \u001b[90my\u001b[39m::\u001b[0mVersionNumber\u001b[0m\u001b[1m)\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[90mBase\u001b[39m \u001b[90m./\u001b[39m\u001b[90m\u001b[4moperators.jl:399\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m     [2] \u001b[0m\u001b[1mconfigure\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[0m\u001b[1m)\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[36mQuartoNotebookWorkerMakieExt\u001b[39m \u001b[90m~/.julia/packages/QuartoNotebookRunner/7xf1K/src/QuartoNotebookWorker/ext/\u001b[39m\u001b[90m\u001b[4mQuartoNotebookWorkerMakieExt.jl:22\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m     [3] \u001b[0m\u001b[1m__init__\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[0m\u001b[1m)\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[36mQuartoNotebookWorkerMakieExt\u001b[39m \u001b[90m~/.julia/packages/QuartoNotebookRunner/7xf1K/src/QuartoNotebookWorker/ext/\u001b[39m\u001b[90m\u001b[4mQuartoNotebookWorkerMakieExt.jl:32\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m     [4] \u001b[0m\u001b[1mrun_module_init\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[90mmod\u001b[39m::\u001b[0mModule, \u001b[90mi\u001b[39m::\u001b[0mInt64\u001b[0m\u001b[1m)\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[90mBase\u001b[39m \u001b[90m./\u001b[39m\u001b[90m\u001b[4mloading.jl:1415\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m     [5] \u001b[0m\u001b[1mregister_restored_modules\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[90msv\u001b[39m::\u001b[0mCore.SimpleVector, \u001b[90mpkg\u001b[39m::\u001b[0mBase.PkgId, \u001b[90mpath\u001b[39m::\u001b[0mString\u001b[0m\u001b[1m)\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[90mBase\u001b[39m \u001b[90m./\u001b[39m\u001b[90m\u001b[4mloading.jl:1403\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m     [6] \u001b[0m\u001b[1m_include_from_serialized\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[90mpkg\u001b[39m::\u001b[0mBase.PkgId, \u001b[90mpath\u001b[39m::\u001b[0mString, \u001b[90mocachepath\u001b[39m::\u001b[0mString, \u001b[90mdepmods\u001b[39m::\u001b[0mVector\u001b[90m{Any}\u001b[39m; \u001b[90mregister\u001b[39m::\u001b[0mBool\u001b[0m\u001b[1m)\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[90mBase\u001b[39m \u001b[90m./\u001b[39m\u001b[90m\u001b[4mloading.jl:1291\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m     [7] \u001b[0m\u001b[1m_include_from_serialized\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[90m./\u001b[39m\u001b[90m\u001b[4mloading.jl:1246\u001b[24m\u001b[39m\u001b[90m [inlined]\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m     [8] \u001b[0m\u001b[1m_require_search_from_serialized\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[90mpkg\u001b[39m::\u001b[0mBase.PkgId, \u001b[90msourcepath\u001b[39m::\u001b[0mString, \u001b[90mbuild_id\u001b[39m::\u001b[0mUInt128, \u001b[90mstalecheck\u001b[39m::\u001b[0mBool; \u001b[90mreasons\u001b[39m::\u001b[0mDict\u001b[90m{String, Int64}\u001b[39m, \u001b[90mDEPOT_PATH\u001b[39m::\u001b[0mVector\u001b[90m{String}\u001b[39m\u001b[0m\u001b[1m)\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[90mBase\u001b[39m \u001b[90m./\u001b[39m\u001b[90m\u001b[4mloading.jl:2087\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m     [9] \u001b[0m\u001b[1m__require_prelocked\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[90mpkg\u001b[39m::\u001b[0mBase.PkgId, \u001b[90menv\u001b[39m::\u001b[0mNothing\u001b[0m\u001b[1m)\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[90mBase\u001b[39m \u001b[90m./\u001b[39m\u001b[90m\u001b[4mloading.jl:2599\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [10] \u001b[0m\u001b[1m_require_prelocked\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[90muuidkey\u001b[39m::\u001b[0mBase.PkgId, \u001b[90menv\u001b[39m::\u001b[0mNothing\u001b[0m\u001b[1m)\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[90mBase\u001b[39m \u001b[90m./\u001b[39m\u001b[90m\u001b[4mloading.jl:2465\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [11] \u001b[0m\u001b[1m_require_prelocked\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[90muuidkey\u001b[39m::\u001b[0mBase.PkgId\u001b[0m\u001b[1m)\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[90mBase\u001b[39m \u001b[90m./\u001b[39m\u001b[90m\u001b[4mloading.jl:2459\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [12] \u001b[0m\u001b[1mrun_extension_callbacks\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[90mextid\u001b[39m::\u001b[0mBase.ExtensionId\u001b[0m\u001b[1m)\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[90mBase\u001b[39m \u001b[90m./\u001b[39m\u001b[90m\u001b[4mloading.jl:1579\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [13] \u001b[0m\u001b[1mrun_extension_callbacks\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[90mpkgid\u001b[39m::\u001b[0mBase.PkgId\u001b[0m\u001b[1m)\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[90mBase\u001b[39m \u001b[90m./\u001b[39m\u001b[90m\u001b[4mloading.jl:1616\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [14] \u001b[0m\u001b[1mrun_package_callbacks\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[90mmodkey\u001b[39m::\u001b[0mBase.PkgId\u001b[0m\u001b[1m)\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[90mBase\u001b[39m \u001b[90m./\u001b[39m\u001b[90m\u001b[4mloading.jl:1432\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [15] \u001b[0m\u001b[1m_require_search_from_serialized\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[90mpkg\u001b[39m::\u001b[0mBase.PkgId, \u001b[90msourcepath\u001b[39m::\u001b[0mString, \u001b[90mbuild_id\u001b[39m::\u001b[0mUInt128, \u001b[90mstalecheck\u001b[39m::\u001b[0mBool; \u001b[90mreasons\u001b[39m::\u001b[0mDict\u001b[90m{String, Int64}\u001b[39m, \u001b[90mDEPOT_PATH\u001b[39m::\u001b[0mVector\u001b[90m{String}\u001b[39m\u001b[0m\u001b[1m)\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[90mBase\u001b[39m \u001b[90m./\u001b[39m\u001b[90m\u001b[4mloading.jl:2106\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [16] \u001b[0m\u001b[1m_require_search_from_serialized\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[90m./\u001b[39m\u001b[90m\u001b[4mloading.jl:1981\u001b[24m\u001b[39m\u001b[90m [inlined]\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [17] \u001b[0m\u001b[1m__require_prelocked\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[90mpkg\u001b[39m::\u001b[0mBase.PkgId, \u001b[90menv\u001b[39m::\u001b[0mString\u001b[0m\u001b[1m)\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[90mBase\u001b[39m \u001b[90m./\u001b[39m\u001b[90m\u001b[4mloading.jl:2599\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [18] \u001b[0m\u001b[1m_require_prelocked\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[90muuidkey\u001b[39m::\u001b[0mBase.PkgId, \u001b[90menv\u001b[39m::\u001b[0mString\u001b[0m\u001b[1m)\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[90mBase\u001b[39m \u001b[90m./\u001b[39m\u001b[90m\u001b[4mloading.jl:2465\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [19] \u001b[0m\u001b[1mmacro expansion\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[90m./\u001b[39m\u001b[90m\u001b[4mloading.jl:2393\u001b[24m\u001b[39m\u001b[90m [inlined]\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [20] \u001b[0m\u001b[1mmacro expansion\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[90m./\u001b[39m\u001b[90m\u001b[4mlock.jl:376\u001b[24m\u001b[39m\u001b[90m [inlined]\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [21] \u001b[0m\u001b[1m__require\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[90minto\u001b[39m::\u001b[0mModule, \u001b[90mmod\u001b[39m::\u001b[0mSymbol\u001b[0m\u001b[1m)\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[90mBase\u001b[39m \u001b[90m./\u001b[39m\u001b[90m\u001b[4mloading.jl:2358\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [22] \u001b[0m\u001b[1mrequire\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[90minto\u001b[39m::\u001b[0mModule, \u001b[90mmod\u001b[39m::\u001b[0mSymbol\u001b[0m\u001b[1m)\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[90mBase\u001b[39m \u001b[90m./\u001b[39m\u001b[90m\u001b[4mloading.jl:2334\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [23] top-level scope\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[90m~/Documents/01_Recherche/04_Projets/Codes/Julia/StructuralVibration/docs/modal_extraction/\u001b[39m\u001b[90m\u001b[4mindicators.qmd:17\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [24] \u001b[0m\u001b[1meval\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[90mm\u001b[39m::\u001b[0mModule, \u001b[90me\u001b[39m::\u001b[0mAny\u001b[0m\u001b[1m)\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[90mCore\u001b[39m \u001b[90m./\u001b[39m\u001b[90m\u001b[4mboot.jl:489\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [25] \u001b[0m\u001b[1m(::QuartoNotebookWorker.var\"#21#22\"{Module, Expr})\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[0m\u001b[1m)\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[32mQuartoNotebookWorker\u001b[39m \u001b[90m~/.julia/packages/QuartoNotebookRunner/7xf1K/src/QuartoNotebookWorker/src/\u001b[39m\u001b[90m\u001b[4mrender.jl:222\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [26] \u001b[0m\u001b[1m(::QuartoNotebookWorker.Packages.IOCapture.var\"#12#13\"{Type{InterruptException}, QuartoNotebookWorker.var\"#21#22\"{Module, Expr}, IOContext{Base.PipeEndpoint}, IOContext{Base.PipeEndpoint}, IOContext{Base.PipeEndpoint}, IOContext{Base.PipeEndpoint}})\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[0m\u001b[1m)\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[32mQuartoNotebookWorker.Packages.IOCapture\u001b[39m \u001b[90m~/.julia/packages/QuartoNotebookRunner/7xf1K/src/QuartoNotebookWorker/src/vendor/IOCapture/src/\u001b[39m\u001b[90m\u001b[4mIOCapture.jl:170\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [27] \u001b[0m\u001b[1mwith_logstate\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[90mf\u001b[39m::\u001b[0mQuartoNotebookWorker.Packages.IOCapture.var\"#12#13\"\u001b[90m{Type{InterruptException}, QuartoNotebookWorker.var\"#21#22\"{Module, Expr}, IOContext{Base.PipeEndpoint}, IOContext{Base.PipeEndpoint}, IOContext{Base.PipeEndpoint}, IOContext{Base.PipeEndpoint}}\u001b[39m, \u001b[90mlogstate\u001b[39m::\u001b[0mBase.CoreLogging.LogState\u001b[0m\u001b[1m)\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[90mBase.CoreLogging\u001b[39m \u001b[90m./logging/\u001b[39m\u001b[90m\u001b[4mlogging.jl:540\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [28] \u001b[0m\u001b[1mwith_logger\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[90mf\u001b[39m::\u001b[0mFunction, \u001b[90mlogger\u001b[39m::\u001b[0mBase.CoreLogging.ConsoleLogger\u001b[0m\u001b[1m)\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[90mBase.CoreLogging\u001b[39m \u001b[90m./logging/\u001b[39m\u001b[90m\u001b[4mlogging.jl:651\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [29] \u001b[0m\u001b[1mcapture\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[90mf\u001b[39m::\u001b[0mQuartoNotebookWorker.var\"#21#22\"\u001b[90m{Module, Expr}\u001b[39m; \u001b[90mrethrow\u001b[39m::\u001b[0mType, \u001b[90mcolor\u001b[39m::\u001b[0mBool, \u001b[90mpassthrough\u001b[39m::\u001b[0mBool, \u001b[90mcapture_buffer\u001b[39m::\u001b[0mIOBuffer, \u001b[90mio_context\u001b[39m::\u001b[0mVector\u001b[90m{Pair{Symbol, Any}}\u001b[39m\u001b[0m\u001b[1m)\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[32mQuartoNotebookWorker.Packages.IOCapture\u001b[39m \u001b[90m~/.julia/packages/QuartoNotebookRunner/7xf1K/src/QuartoNotebookWorker/src/vendor/IOCapture/src/\u001b[39m\u001b[90m\u001b[4mIOCapture.jl:167\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [30] \u001b[0m\u001b[1mcapture\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[90m~/.julia/packages/QuartoNotebookRunner/7xf1K/src/QuartoNotebookWorker/src/\u001b[39m\u001b[90m\u001b[4mrender.jl:248\u001b[24m\u001b[39m\u001b[90m [inlined]\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [31] \u001b[0m\u001b[1mio_capture\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[90mf\u001b[39m::\u001b[0mFunction; \u001b[90mcell_options\u001b[39m::\u001b[0mDict\u001b[90m{Any, Any}\u001b[39m, \u001b[90mkws\u001b[39m::\u001b[0m@Kwargs\u001b[90m{rethrow::DataType, color::Bool, io_context::Vector{Pair{Symbol, Any}}}\u001b[39m\u001b[0m\u001b[1m)\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[32mQuartoNotebookWorker\u001b[39m \u001b[90m~/.julia/packages/QuartoNotebookRunner/7xf1K/src/QuartoNotebookWorker/src/\u001b[39m\u001b[90m\u001b[4mrender.jl:250\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [32] \u001b[0m\u001b[1mio_capture\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[90m~/.julia/packages/QuartoNotebookRunner/7xf1K/src/QuartoNotebookWorker/src/\u001b[39m\u001b[90m\u001b[4mrender.jl:246\u001b[24m\u001b[39m\u001b[90m [inlined]\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [33] \u001b[0m\u001b[1minclude_str\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[90mmod\u001b[39m::\u001b[0mModule, \u001b[90mcode\u001b[39m::\u001b[0mString; \u001b[90mfile\u001b[39m::\u001b[0mString, \u001b[90mline\u001b[39m::\u001b[0mInt64, \u001b[90mcell_options\u001b[39m::\u001b[0mDict\u001b[90m{Any, Any}\u001b[39m\u001b[0m\u001b[1m)\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[32mQuartoNotebookWorker\u001b[39m \u001b[90m~/.julia/packages/QuartoNotebookRunner/7xf1K/src/QuartoNotebookWorker/src/\u001b[39m\u001b[90m\u001b[4mrender.jl:201\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [34] \u001b[0m\u001b[1m#invokelatest_gr#232\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[90m./\u001b[39m\u001b[90m\u001b[4mreflection.jl:1282\u001b[24m\u001b[39m\u001b[90m [inlined]\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [35] \u001b[0m\u001b[1minvokelatest_gr\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[90m./\u001b[39m\u001b[90m\u001b[4mreflection.jl:1274\u001b[24m\u001b[39m\u001b[90m [inlined]\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [36] \u001b[0m\u001b[1m#7\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[90m~/.julia/packages/QuartoNotebookRunner/7xf1K/src/QuartoNotebookWorker/src/\u001b[39m\u001b[90m\u001b[4mrender.jl:18\u001b[24m\u001b[39m\u001b[90m [inlined]\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [37] \u001b[0m\u001b[1mwith_inline_display\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[90mf\u001b[39m::\u001b[0mQuartoNotebookWorker.var\"#7#8\"\u001b[90m{String, String, Int64, Dict{Any, Any}}\u001b[39m, \u001b[90mcell_options\u001b[39m::\u001b[0mDict\u001b[90m{Any, Any}\u001b[39m\u001b[0m\u001b[1m)\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[32mQuartoNotebookWorker\u001b[39m \u001b[90m~/.julia/packages/QuartoNotebookRunner/7xf1K/src/QuartoNotebookWorker/src/\u001b[39m\u001b[90m\u001b[4mInlineDisplay.jl:31\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [38] \u001b[0m\u001b[1m_render_thunk\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[90mthunk\u001b[39m::\u001b[0mFunction, \u001b[90mcode\u001b[39m::\u001b[0mString, \u001b[90mcell_options\u001b[39m::\u001b[0mDict\u001b[90m{Any, Any}\u001b[39m, \u001b[90mis_expansion_ref\u001b[39m::\u001b[0mBase.RefValue\u001b[90m{Bool}\u001b[39m; \u001b[90minline\u001b[39m::\u001b[0mBool\u001b[0m\u001b[1m)\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[32mQuartoNotebookWorker\u001b[39m \u001b[90m~/.julia/packages/QuartoNotebookRunner/7xf1K/src/QuartoNotebookWorker/src/\u001b[39m\u001b[90m\u001b[4mrender.jl:43\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [39] \u001b[0m\u001b[1m_render_thunk\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[90m~/.julia/packages/QuartoNotebookRunner/7xf1K/src/QuartoNotebookWorker/src/\u001b[39m\u001b[90m\u001b[4mrender.jl:35\u001b[24m\u001b[39m\u001b[90m [inlined]\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [40] \u001b[0m\u001b[1mrender\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[90mcode\u001b[39m::\u001b[0mString, \u001b[90mfile\u001b[39m::\u001b[0mString, \u001b[90mline\u001b[39m::\u001b[0mInt64, \u001b[90mcell_options\u001b[39m::\u001b[0mDict\u001b[90m{Any, Any}\u001b[39m; \u001b[90minline\u001b[39m::\u001b[0mBool\u001b[0m\u001b[1m)\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[32mQuartoNotebookWorker\u001b[39m \u001b[90m~/.julia/packages/QuartoNotebookRunner/7xf1K/src/QuartoNotebookWorker/src/\u001b[39m\u001b[90m\u001b[4mrender.jl:15\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [41] \u001b[0m\u001b[1mrender\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[90mcode\u001b[39m::\u001b[0mString, \u001b[90mfile\u001b[39m::\u001b[0mString, \u001b[90mline\u001b[39m::\u001b[0mInt64, \u001b[90mcell_options\u001b[39m::\u001b[0mDict\u001b[90m{Any, Any}\u001b[39m\u001b[0m\u001b[1m)\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[32mQuartoNotebookWorker\u001b[39m \u001b[90m~/.julia/packages/QuartoNotebookRunner/7xf1K/src/QuartoNotebookWorker/src/\u001b[39m\u001b[90m\u001b[4mrender.jl:1\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [42] \u001b[0m\u001b[1mrender\u001b[22m\u001b[0m\u001b[1m(\u001b[22m::\u001b[0mString, ::\u001b[0mVararg\u001b[90m{Any}\u001b[39m; \u001b[90mkwargs\u001b[39m::\u001b[0m@Kwargs\u001b[90m{}\u001b[39m\u001b[0m\u001b[1m)\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[33mMain\u001b[39m \u001b[90m~/.julia/packages/QuartoNotebookRunner/7xf1K/src/\u001b[39m\u001b[90m\u001b[4mstartup.jl:145\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [43] top-level scope\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[90m\u001b[4mnone:1\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [44] \u001b[0m\u001b[1meval\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[90mm\u001b[39m::\u001b[0mModule, \u001b[90me\u001b[39m::\u001b[0mAny\u001b[0m\u001b[1m)\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[90mCore\u001b[39m \u001b[90m./\u001b[39m\u001b[90m\u001b[4mboot.jl:489\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [45] \u001b[0m\u001b[1m(::Main.var\"#22#23\")\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[90mchan\u001b[39m::\u001b[0mChannel\u001b[90m{Any}\u001b[39m\u001b[0m\u001b[1m)\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[33mMain\u001b[39m \u001b[90m~/.julia/packages/QuartoNotebookRunner/7xf1K/src/\u001b[39m\u001b[90m\u001b[4mstartup.jl:158\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m    [46] \u001b[0m\u001b[1m(::Base.var\"#562#563\"{Main.var\"#22#23\", Channel{Any}})\u001b[22m\u001b[0m\u001b[1m(\u001b[22m\u001b[0m\u001b[1m)\u001b[22m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   \u001b[90m    @\u001b[39m \u001b[90mBase\u001b[39m \u001b[90m./\u001b[39m\u001b[90m\u001b[4mchannels.jl:141\u001b[24m\u001b[39m\n\u001b[91m\u001b[1m│ \u001b[22m\u001b[39m   during initialization of module QuartoNotebookWorkerMakieExt\n\u001b[91m\u001b[1m└ \u001b[22m\u001b[39m\u001b[90m@ Base loading.jl:1589\u001b[39m\n"
                }
            ],
            "execution_count": 1
        },
        {
            "id": "3",
            "cell_type": "markdown",
            "metadata": {
            },
            "source": [
                "\n",
                "## Mode complexity indicators\n",
                "\n",
                "The following indicators can be used to assess the complexity of the identified modes.\n",
                "\n",
                "### Mode Overcomplexity Value\n",
                "\n",
                "The Mode Overcomplexity Value (MOV) of a mode $i$ is defined as:\n",
                "$$\n",
                "MOV_i = \\frac{\\sum_{n = 1}^N s_{ni} \\vert\\phi_{ni}\\vert^2}{\\sum_{n = 1}^N \\vert\\phi_{ni}\\vert^2},\n",
                "$$\n",
                "where $\\phi_{ni}$ is the mode shape value at degree of freedom $n$ for mode $i$, and $s_{ni}$ is a weighted factor. The latter is given by:\n",
                "$$\n",
                "s_{ni} = \\begin{cases}\n",
                "0 & \\text{if } \\text{Im}(-\\lambda_i^2\\phi_{ni}^2 Q_i) > 0 \\\\\n",
                "1 & \\text{if } \\text{Im}(-\\lambda_i^2\\phi_{ni}^2 Q_i) \\leq 0\n",
                "\\end{cases},\n",
                "$$\n",
                "where $\\lambda_i$ is the complex eigenvalue for mode $i$, and $Q_i$ is the corresponding scaling factor.\n",
                "\n",
                "A value close to 1 indicates physical modes, while a value close to 0 indicates spurious modes (or computational modes).\n",
                "\n",
                "::: {.api}\n",
                "**mov**\n",
                "\n",
                "---"
            ]
        },
        {
            "id": "4",
            "cell_type": "code",
            "metadata": {
            },
            "source": [
                "#| echo: false\n",
                "@doc mov"
            ],
            "outputs": [
                {
                    "output_type": "execute_result",
                    "execution_count": 1,
                    "data": {
                        "text/plain": "  \u001b[36mmov(poles, ms, Q)\u001b[39m\n\n  Compute the mode overcomplexity value\n\n  This indicator is a weighted percentage of the degrees of freedom of the\n  response for which adding mass leads to a negative frequency shift. A value\n  close to 1 indicates physical modes, while a low value indicates\n  non-physical modes (numerical or noise-related)\n\n  \u001b[1mInputs\u001b[22m\n\n    \u001b[34m• \u001b[39m \u001b[36mpoles\u001b[39m: Poles of the system\n    \u001b[34m• \u001b[39m \u001b[36mms\u001b[39m: Mode shapes (each column corresponds to a mode)\n    \u001b[34m• \u001b[39m \u001b[36mQ\u001b[39m: Scaling factors associated to the mode shapes\n\n  \u001b[1mOutput\u001b[22m\n\n    \u001b[34m• \u001b[39m \u001b[36mmov\u001b[39m: Mode overcomplexity values\n\n  \u001b[1mReference\u001b[22m\n\n  [1] M+P Analyzer manual. Rev. 5.1. 2017",
                        "text/markdown": "```julia\nmov(poles, ms, Q)\n```\n\nCompute the mode overcomplexity value\n\nThis indicator is a weighted percentage of the degrees of freedom of the response for which adding mass leads to a negative frequency shift. A value close to 1 indicates physical modes, while a low value indicates non-physical modes (numerical or noise-related)\n\n**Inputs**\n\n  * `poles`: Poles of the system\n  * `ms`: Mode shapes (each column corresponds to a mode)\n  * `Q`: Scaling factors associated to the mode shapes\n\n**Output**\n\n  * `mov`: Mode overcomplexity values\n\n**Reference**\n\n[1] M+P Analyzer manual. Rev. 5.1. 2017\n",
                        "text/html": "<div class=\"markdown\"><pre><code class=\"language-julia\">mov&#40;poles, ms, Q&#41;</code></pre>\n<p>Compute the mode overcomplexity value</p>\n<p>This indicator is a weighted percentage of the degrees of freedom of the response for which adding mass leads to a negative frequency shift. A value close to 1 indicates physical modes, while a low value indicates non-physical modes &#40;numerical or noise-related&#41;</p>\n<p><strong>Inputs</strong></p>\n<ul>\n<li><p><code>poles</code>: Poles of the system</p>\n</li>\n<li><p><code>ms</code>: Mode shapes &#40;each column corresponds to a mode&#41;</p>\n</li>\n<li><p><code>Q</code>: Scaling factors associated to the mode shapes</p>\n</li>\n</ul>\n<p><strong>Output</strong></p>\n<ul>\n<li><p><code>mov</code>: Mode overcomplexity values</p>\n</li>\n</ul>\n<p><strong>Reference</strong></p>\n<p>&#91;1&#93; M&#43;P Analyzer manual. Rev. 5.1. 2017</p>\n\n\n</div>",
                        "text/latex": "\\begin{verbatim}\nmov(poles, ms, Q)\n\\end{verbatim}\nCompute the mode overcomplexity value\n\nThis indicator is a weighted percentage of the degrees of freedom of the response for which adding mass leads to a negative frequency shift. A value close to 1 indicates physical modes, while a low value indicates non-physical modes (numerical or noise-related)\n\n\\textbf{Inputs}\n\n\\begin{itemize}\n\\item \\texttt{poles}: Poles of the system\n\n\n\\item \\texttt{ms}: Mode shapes (each column corresponds to a mode)\n\n\n\\item \\texttt{Q}: Scaling factors associated to the mode shapes\n\n\\end{itemize}\n\\textbf{Output}\n\n\\begin{itemize}\n\\item \\texttt{mov}: Mode overcomplexity values\n\n\\end{itemize}\n\\textbf{Reference}\n\n[1] M+P Analyzer manual. Rev. 5.1. 2017\n\n"
                    },
                    "metadata": {
                    }
                }
            ],
            "execution_count": 1
        },
        {
            "id": "5",
            "cell_type": "markdown",
            "metadata": {
            },
            "source": [
                ":::\n",
                "\n",
                "### Mode Phase Collinearity\n",
                "\n",
                "The Mode Phase Collinearity (MPC)aims at determining whether a mode is real or complex. It is an indicator defined in $[0, 1]$. For a mode $i$, it is given by:\n",
                "$$\n",
                "  MPC_i = \\left[2\\left(\\frac{\\vert\\lambda_1\\vert}{\\vert\\lambda_1\\vert + \\vert\\lambda_2\\vert} - 0.5\\right)\\right]^2,\n",
                "$$\n",
                "where $\\lambda_1 = \\frac{S_{xx} + S_{yy}}{2} + \\sqrt{\\left(\\frac{S_{xx} - S_{yy}}{2}\\right)^2 + S_{xy}^2}$ and $\\lambda_2 = \\frac{S_{xx} + S_{yy}}{2} - \\sqrt{\\left(\\frac{S_{xx} - S_{yy}}{2}\\right)^2 + S_{xy}^2}$ are the eigenvalues of the covariance matrix $\\mathbf{S}$:\n",
                "$$\n",
                "\\mathbf{S} = \\begin{bmatrix}\n",
                "S_{xx} & S_{xy} \\\\\n",
                "S_{xy} & S_{yy}\n",
                "\\end{bmatrix} \\text{ with } \\begin{cases}\n",
                "S_{xx} = \\text{Re}(\\tilde{\\phi}_i)^T\\text{Re}(\\tilde{\\phi}_i) \\\\\n",
                "S_{yy} = \\text{Im}(\\tilde{\\phi}_i)^T\\text{Im}(\\tilde{\\phi}_i) \\\\\n",
                "S_{xy} = \\text{Re}(\\tilde{\\phi}_i)^T\\text{Im}(\\tilde{\\phi}_i)\n",
                "\\end{cases}\n",
                "$$\n",
                "Here, $\\tilde{\\phi}_i$ is the corrected mode shape vector for the mode $i$ such that:\n",
                "$$\n",
                "\\tilde{\\phi}_{ni} = \\phi_{ni} - \\frac{\\sum_{m = 1}^N \\phi_{mi}}{N}.\n",
                "$$\n",
                "\n",
                "A value close to 1 indicates a real mode, while a value close to 0 indicates a complex mode.\n",
                "\n",
                "::: {.api}\n",
                "**mpc**\n",
                "\n",
                "---"
            ]
        },
        {
            "id": "6",
            "cell_type": "code",
            "metadata": {
            },
            "source": [
                "#| echo: false\n",
                "@doc mpc"
            ],
            "outputs": [
                {
                    "output_type": "execute_result",
                    "execution_count": 1,
                    "data": {
                        "text/plain": "  \u001b[36mmpc(ms)\u001b[39m\n\n  Compute the mode phase collinearity.\n\n  This indicator aims to measure the complexity of a mode. Its value ranges\n  from 0 (no collinearity) to 1 (perfect collinearity). For real modes, mpc\n  tends towards 1.\n\n  \u001b[1mInput\u001b[22m\n\n    \u001b[34m• \u001b[39m \u001b[36mms\u001b[39m: Mode shapes (each column corresponds to a mode)\n\n  \u001b[1mOutput\u001b[22m\n\n    \u001b[34m• \u001b[39m \u001b[36mmpc\u001b[39m: Mode phase collinearity values\n\n  \u001b[1mReferences\u001b[22m\n\n  [1] J.-N. Juang and R. Pappa: \"An eigensystem realization algorithm for\n  modal parameter identification and model reduction\", Journal of Guidance,\n  Control, and Dynamics, Vol. 8, No. 5, Sept.-Oct. 1985, pp. 620-627.\n\n  [2] M+P Analyzer manual. Rev. 5.1. 2017",
                        "text/markdown": "```julia\nmpc(ms)\n```\n\nCompute the mode phase collinearity.\n\nThis indicator aims to measure the complexity of a mode. Its value ranges from 0 (no collinearity) to 1 (perfect collinearity). For real modes, mpc tends towards 1.\n\n**Input**\n\n  * `ms`: Mode shapes (each column corresponds to a mode)\n\n**Output**\n\n  * `mpc`: Mode phase collinearity values\n\n**References**\n\n[1] J.-N. Juang and R. Pappa: \"An eigensystem realization algorithm for modal parameter identification and model reduction\", Journal of Guidance, Control, and Dynamics, Vol. 8, No. 5, Sept.-Oct. 1985, pp. 620-627.\n\n[2] M+P Analyzer manual. Rev. 5.1. 2017\n",
                        "text/html": "<div class=\"markdown\"><pre><code class=\"language-julia\">mpc&#40;ms&#41;</code></pre>\n<p>Compute the mode phase collinearity.</p>\n<p>This indicator aims to measure the complexity of a mode. Its value ranges from 0 &#40;no collinearity&#41; to 1 &#40;perfect collinearity&#41;. For real modes, mpc tends towards 1.</p>\n<p><strong>Input</strong></p>\n<ul>\n<li><p><code>ms</code>: Mode shapes &#40;each column corresponds to a mode&#41;</p>\n</li>\n</ul>\n<p><strong>Output</strong></p>\n<ul>\n<li><p><code>mpc</code>: Mode phase collinearity values</p>\n</li>\n</ul>\n<p><strong>References</strong></p>\n<p>&#91;1&#93; J.-N. Juang and R. Pappa: &quot;An eigensystem realization algorithm for modal parameter identification and model reduction&quot;, Journal of Guidance, Control, and Dynamics, Vol. 8, No. 5, Sept.-Oct. 1985, pp. 620-627.</p>\n<p>&#91;2&#93; M&#43;P Analyzer manual. Rev. 5.1. 2017</p>\n\n\n</div>",
                        "text/latex": "\\begin{verbatim}\nmpc(ms)\n\\end{verbatim}\nCompute the mode phase collinearity.\n\nThis indicator aims to measure the complexity of a mode. Its value ranges from 0 (no collinearity) to 1 (perfect collinearity). For real modes, mpc tends towards 1.\n\n\\textbf{Input}\n\n\\begin{itemize}\n\\item \\texttt{ms}: Mode shapes (each column corresponds to a mode)\n\n\\end{itemize}\n\\textbf{Output}\n\n\\begin{itemize}\n\\item \\texttt{mpc}: Mode phase collinearity values\n\n\\end{itemize}\n\\textbf{References}\n\n[1] J.-N. Juang and R. Pappa: \"An eigensystem realization algorithm for modal parameter identification and model reduction\", Journal of Guidance, Control, and Dynamics, Vol. 8, No. 5, Sept.-Oct. 1985, pp. 620-627.\n\n[2] M+P Analyzer manual. Rev. 5.1. 2017\n\n"
                    },
                    "metadata": {
                    }
                }
            ],
            "execution_count": 1
        },
        {
            "id": "7",
            "cell_type": "markdown",
            "metadata": {
            },
            "source": [
                ":::\n",
                "\n",
                "### Mode Complexity Factor\n",
                "\n",
                "The Mode Complexity Factor (MCF) for a mode $i$ is defined as:\n",
                "$$\n",
                "MCF_i = 1 - \\frac{(S_{xx} - S_{yy})^2 + 4S_{xy}^2}{(S_{xx} + S_{yy})^2}\n",
                "$$\n",
                "\n",
                "A value close to 0 indicates a real mode, while a value close to 1 indicates a complex mode.\n",
                "\n",
                "### Mean Phase Deviation\n",
                "\n",
                "The Mean Phase Deviation (MPD) indicator aims to measure the complexity of a mode. Its value is close to 0 for real modes, and increases as the mode becomes more complex. It is defined as:\n",
                "$$\n",
                "MPD_i = \\frac{\\sum_{n = 1}^N\\vert\\phi_{ni}\\vert\\; \\text{acos}\\left\\vert\\frac{\\text{Re}(\\phi_{ni})V_{22} - \\text{Im}(\\phi_{ni})V_{12}}{\\sqrt{V_{12}^2 + V_{22}^2}\\;\\vert\\phi_{ni}\\vert}\\right\\vert}{\\sum_{n = 1}^N \\vert\\phi_{ni}\\vert},\n",
                "$$\n",
                "where $V_{12}$ and $V_{22}$ are the components of the right singular vector associated to the singular value decomposition of the 2 $\\times$ 2 matrix $\\mathbf{P}$ expressed as:\n",
                "$$\n",
                "\\mathbf{P} = \\begin{bmatrix}\n",
                "\\text{Re}(\\tilde{\\phi}_i) &\n",
                "\\text{Im}(\\tilde{\\phi}_i)\n",
                "\\end{bmatrix}.\n",
                "$$\n",
                "\n",
                "For real modes, the indicator is close to 0, while it increases for complex modes.\n",
                "\n",
                "::: {.api}\n",
                "**mpd**\n",
                "\n",
                "---"
            ]
        },
        {
            "id": "8",
            "cell_type": "code",
            "metadata": {
            },
            "source": [
                "#| echo: false\n",
                "@doc mpd"
            ],
            "outputs": [
                {
                    "output_type": "execute_result",
                    "execution_count": 1,
                    "data": {
                        "text/plain": "  \u001b[36mmpd(ms)\u001b[39m\n\n  Compute the mode phase deviation.\n\n  This indicator aims to measure the complexity of a mode. Its value is close\n  to 0 for real modes, and increases as the mode becomes more complex.\n\n  \u001b[1mInput\u001b[22m\n\n    \u001b[34m• \u001b[39m \u001b[36mms\u001b[39m: Mode shapes (each column corresponds to a mode)\n\n  \u001b[1mOutput\u001b[22m\n\n    \u001b[34m• \u001b[39m \u001b[36mmpd\u001b[39m: Mode phase deviation values\n\n  \u001b[1mReference\u001b[22m\n\n  [1] E. Reynders, J. Houbrechts and G. De Roeck. Fully automated\n  (operational) modal analysis. Mechanical Systems and Signal Processing. 29:\n  228-250. 2012\n\n  [2] A. C. Dederichs and O. Oiseth. Experimental comparison of automatic\n  operational modal analysis algorithms for application to long-span road\n  bridges. Mechanical Systems and Signal Processing. 199: 110485. 2023",
                        "text/markdown": "```julia\nmpd(ms)\n```\n\nCompute the mode phase deviation.\n\nThis indicator aims to measure the complexity of a mode. Its value is close to 0 for real modes, and increases as the mode becomes more complex.\n\n**Input**\n\n  * `ms`: Mode shapes (each column corresponds to a mode)\n\n**Output**\n\n  * `mpd`: Mode phase deviation values\n\n**Reference**\n\n[1] E. Reynders, J. Houbrechts and G. De Roeck. Fully automated (operational) modal analysis. Mechanical Systems and Signal Processing. 29: 228-250. 2012\n\n[2] A. C. Dederichs and O. Oiseth. Experimental comparison of automatic operational modal analysis algorithms for application to long-span road bridges. Mechanical Systems and Signal Processing. 199: 110485. 2023\n",
                        "text/html": "<div class=\"markdown\"><pre><code class=\"language-julia\">mpd&#40;ms&#41;</code></pre>\n<p>Compute the mode phase deviation.</p>\n<p>This indicator aims to measure the complexity of a mode. Its value is close to 0 for real modes, and increases as the mode becomes more complex.</p>\n<p><strong>Input</strong></p>\n<ul>\n<li><p><code>ms</code>: Mode shapes &#40;each column corresponds to a mode&#41;</p>\n</li>\n</ul>\n<p><strong>Output</strong></p>\n<ul>\n<li><p><code>mpd</code>: Mode phase deviation values</p>\n</li>\n</ul>\n<p><strong>Reference</strong></p>\n<p>&#91;1&#93; E. Reynders, J. Houbrechts and G. De Roeck. Fully automated &#40;operational&#41; modal analysis. Mechanical Systems and Signal Processing. 29: 228-250. 2012</p>\n<p>&#91;2&#93; A. C. Dederichs and O. Oiseth. Experimental comparison of automatic operational modal analysis algorithms for application to long-span road bridges. Mechanical Systems and Signal Processing. 199: 110485. 2023</p>\n\n\n</div>",
                        "text/latex": "\\begin{verbatim}\nmpd(ms)\n\\end{verbatim}\nCompute the mode phase deviation.\n\nThis indicator aims to measure the complexity of a mode. Its value is close to 0 for real modes, and increases as the mode becomes more complex.\n\n\\textbf{Input}\n\n\\begin{itemize}\n\\item \\texttt{ms}: Mode shapes (each column corresponds to a mode)\n\n\\end{itemize}\n\\textbf{Output}\n\n\\begin{itemize}\n\\item \\texttt{mpd}: Mode phase deviation values\n\n\\end{itemize}\n\\textbf{Reference}\n\n[1] E. Reynders, J. Houbrechts and G. De Roeck. Fully automated (operational) modal analysis. Mechanical Systems and Signal Processing. 29: 228-250. 2012\n\n[2] A. C. Dederichs and O. Oiseth. Experimental comparison of automatic operational modal analysis algorithms for application to long-span road bridges. Mechanical Systems and Signal Processing. 199: 110485. 2023\n\n"
                    },
                    "metadata": {
                    }
                }
            ],
            "execution_count": 1
        },
        {
            "id": "9",
            "cell_type": "markdown",
            "metadata": {
            },
            "source": [
                ":::\n",
                "\n",
                "## Correlation indicators\n",
                "\n",
                "The following indicators can be used to assess the correlation between measured and reconstructed quantities.\n",
                "\n",
                "### Modal Assurance Criterion\n",
                "\n",
                "The Modal Assurance Criterion (MAC) is a widely used indicator to quantify the correlation between two sets mode shapes. For two mode shapes $\\phi_i$ and $\\psi_j$ (column vectors), it is defined as:\n",
                "$$\n",
                "MAC_{ij} = \\frac{\\vert\\psi_j^H\\phi_i\\vert^2}{(\\phi_i^H\\phi_i) (\\psi_j^H\\psi_j)},\n",
                "$$\n",
                "where the superscript $H$ denotes the Hermitian transpose.\n",
                "\n",
                "A value close to 1 indicates a strong correlation between the two mode shapes, while a value close to 0 indicates no correlation.\n",
                "\n",
                "::: {.api}\n",
                "**mac**\n",
                "\n",
                "---"
            ]
        },
        {
            "id": "10",
            "cell_type": "code",
            "metadata": {
            },
            "source": [
                "#| echo: false\n",
                "@doc mac"
            ],
            "outputs": [
                {
                    "output_type": "execute_result",
                    "execution_count": 1,
                    "data": {
                        "text/plain": "  \u001b[36mmac(ms_exp, ms_th)\u001b[39m\n\n  Compute the modal assurance criterion (MAC) between experimental and\n  theoretical mode shapes.\n\n  \u001b[1mInputs\u001b[22m\n\n    \u001b[34m• \u001b[39m \u001b[36mms_exp\u001b[39m: Experimental mode shapes (nmes x nmodes array)\n    \u001b[34m• \u001b[39m \u001b[36mms_th\u001b[39m: Theoretical mode shapes (nmes x nmodes array)\n\n  \u001b[1mOutput\u001b[22m\n\n    \u001b[34m• \u001b[39m \u001b[36mmac\u001b[39m: Modal assurance criterion values (nmodes x nmodes array)\n\n  \u001b[1mReference\u001b[22m\n\n  [1] R. J. Allemang. The modal assurance criterion twenty years of use and\n  abuse. Sound & Vibration. 37 (8): 14-23. 2003",
                        "text/markdown": "```julia\nmac(ms_exp, ms_th)\n```\n\nCompute the modal assurance criterion (MAC) between experimental and theoretical mode shapes.\n\n**Inputs**\n\n  * `ms_exp`: Experimental mode shapes (nmes x nmodes array)\n  * `ms_th`: Theoretical mode shapes (nmes x nmodes array)\n\n**Output**\n\n  * `mac`: Modal assurance criterion values (nmodes x nmodes array)\n\n**Reference**\n\n[1] R. J. Allemang. The modal assurance criterion twenty years of use and abuse. Sound & Vibration. 37 (8): 14-23. 2003\n",
                        "text/html": "<div class=\"markdown\"><pre><code class=\"language-julia\">mac&#40;ms_exp, ms_th&#41;</code></pre>\n<p>Compute the modal assurance criterion &#40;MAC&#41; between experimental and theoretical mode shapes.</p>\n<p><strong>Inputs</strong></p>\n<ul>\n<li><p><code>ms_exp</code>: Experimental mode shapes &#40;nmes x nmodes array&#41;</p>\n</li>\n<li><p><code>ms_th</code>: Theoretical mode shapes &#40;nmes x nmodes array&#41;</p>\n</li>\n</ul>\n<p><strong>Output</strong></p>\n<ul>\n<li><p><code>mac</code>: Modal assurance criterion values &#40;nmodes x nmodes array&#41;</p>\n</li>\n</ul>\n<p><strong>Reference</strong></p>\n<p>&#91;1&#93; R. J. Allemang. The modal assurance criterion twenty years of use and abuse. Sound &amp; Vibration. 37 &#40;8&#41;: 14-23. 2003</p>\n\n\n</div>",
                        "text/latex": "\\begin{verbatim}\nmac(ms_exp, ms_th)\n\\end{verbatim}\nCompute the modal assurance criterion (MAC) between experimental and theoretical mode shapes.\n\n\\textbf{Inputs}\n\n\\begin{itemize}\n\\item \\texttt{ms\\_exp}: Experimental mode shapes (nmes x nmodes array)\n\n\n\\item \\texttt{ms\\_th}: Theoretical mode shapes (nmes x nmodes array)\n\n\\end{itemize}\n\\textbf{Output}\n\n\\begin{itemize}\n\\item \\texttt{mac}: Modal assurance criterion values (nmodes x nmodes array)\n\n\\end{itemize}\n\\textbf{Reference}\n\n[1] R. J. Allemang. The modal assurance criterion twenty years of use and abuse. Sound \\& Vibration. 37 (8): 14-23. 2003\n\n"
                    },
                    "metadata": {
                    }
                }
            ],
            "execution_count": 1
        },
        {
            "id": "11",
            "cell_type": "markdown",
            "metadata": {
            },
            "source": [
                ":::\n",
                "\n",
                "### Coordinate Modal Assurance Criterion\n",
                "\n",
                "The Coordinate Modal Assurance Criterion (COMAC) is a variant of the MAC that considers the correlation between the coordinates of two mode shapes. For a coordinate $p$ of two mode shapes $\\phi_p$ and $\\psi_p$ (row vectors), it is defined as:\n",
                "$$\n",
                "COMAC_p = \\frac{\\vert\\phi_{pi}\\psi_{pi}^H\\vert^2}{(\\phi_{pi}\\phi_{pi}^H) (\\psi_{pi}\n",
                "\\psi_{pi}^H)},\n",
                "$$\n",
                "where the superscript $H$ denotes the Hermitian transpose.\n",
                "\n",
                "::: {.callout-note}\n",
                "The computation of the COMAC indicator requires that the two mode shapes have the same number of coordinates and similar scaling. For the the latter, one of the mode shapes is multiplied by the modal scaling factor:\n",
                "$$\n",
                "MSF_i = \\frac{\\phi_i^H\\psi_i}{\\phi_i^H\\phi_i}.\n",
                "$$\n",
                "The previous equation assumes that $\\phi_i$ is the reference mode shape to which $\\psi_i$ is scaled.\n",
                ":::\n",
                "\n",
                "A value close to 1 indicates a strong correlation between the two mode shapes, while a value close to 0 indicates no correlation.\n",
                "\n",
                "::: {.api}\n",
                "**comac**\n",
                "\n",
                "---"
            ]
        },
        {
            "id": "12",
            "cell_type": "code",
            "metadata": {
            },
            "source": [
                "#| echo: false\n",
                "@doc comac"
            ],
            "outputs": [
                {
                    "output_type": "execute_result",
                    "execution_count": 1,
                    "data": {
                        "text/plain": "  \u001b[36mcomac(ms_exp, ms_th)\u001b[39m\n\n  Compute the coordinate modal assurance criterion (COMAC) between\n  experimental and theoretical mode shapes.\n\n  \u001b[1mInputs\u001b[22m\n\n    \u001b[34m• \u001b[39m \u001b[36mms_exp\u001b[39m: Experimental mode shapes (nmes x nmodes array)\n    \u001b[34m• \u001b[39m \u001b[36mms_th\u001b[39m: Theoretical mode shapes (nmes x nmodes array)\n\n  \u001b[1mOutput\u001b[22m\n\n    \u001b[34m• \u001b[39m \u001b[36mcomac\u001b[39m: Coordinate modal assurance criterion values (nmes array)\n\n  \u001b[1mReference\u001b[22m\n\n  [1] R. J. Allemang. The modal assurance criterion twenty years of use and\n  abuse. Sound & Vibration. 37 (8): 14-23. 2003",
                        "text/markdown": "```julia\ncomac(ms_exp, ms_th)\n```\n\nCompute the coordinate modal assurance criterion (COMAC) between experimental and theoretical mode shapes.\n\n**Inputs**\n\n  * `ms_exp`: Experimental mode shapes (nmes x nmodes array)\n  * `ms_th`: Theoretical mode shapes (nmes x nmodes array)\n\n**Output**\n\n  * `comac`: Coordinate modal assurance criterion values (nmes array)\n\n**Reference**\n\n[1] R. J. Allemang. The modal assurance criterion twenty years of use and abuse. Sound & Vibration. 37 (8): 14-23. 2003\n",
                        "text/html": "<div class=\"markdown\"><pre><code class=\"language-julia\">comac&#40;ms_exp, ms_th&#41;</code></pre>\n<p>Compute the coordinate modal assurance criterion &#40;COMAC&#41; between experimental and theoretical mode shapes.</p>\n<p><strong>Inputs</strong></p>\n<ul>\n<li><p><code>ms_exp</code>: Experimental mode shapes &#40;nmes x nmodes array&#41;</p>\n</li>\n<li><p><code>ms_th</code>: Theoretical mode shapes &#40;nmes x nmodes array&#41;</p>\n</li>\n</ul>\n<p><strong>Output</strong></p>\n<ul>\n<li><p><code>comac</code>: Coordinate modal assurance criterion values &#40;nmes array&#41;</p>\n</li>\n</ul>\n<p><strong>Reference</strong></p>\n<p>&#91;1&#93; R. J. Allemang. The modal assurance criterion twenty years of use and abuse. Sound &amp; Vibration. 37 &#40;8&#41;: 14-23. 2003</p>\n\n\n</div>",
                        "text/latex": "\\begin{verbatim}\ncomac(ms_exp, ms_th)\n\\end{verbatim}\nCompute the coordinate modal assurance criterion (COMAC) between experimental and theoretical mode shapes.\n\n\\textbf{Inputs}\n\n\\begin{itemize}\n\\item \\texttt{ms\\_exp}: Experimental mode shapes (nmes x nmodes array)\n\n\n\\item \\texttt{ms\\_th}: Theoretical mode shapes (nmes x nmodes array)\n\n\\end{itemize}\n\\textbf{Output}\n\n\\begin{itemize}\n\\item \\texttt{comac}: Coordinate modal assurance criterion values (nmes array)\n\n\\end{itemize}\n\\textbf{Reference}\n\n[1] R. J. Allemang. The modal assurance criterion twenty years of use and abuse. Sound \\& Vibration. 37 (8): 14-23. 2003\n\n"
                    },
                    "metadata": {
                    }
                }
            ],
            "execution_count": 1
        },
        {
            "id": "13",
            "cell_type": "markdown",
            "metadata": {
            },
            "source": [
                ":::\n",
                "\n",
                "### Enhanced Coordinate Modal Assurance Criterion\n",
                "\n",
                "The Enhanced Coordinate Modal Assurance Criterion (ECOMAC) extends the COMAC to take into account potential calibration scaling errors and/or sensor orientation errors by compouting the mean deviations of mode amplitudes of each coordinate. It is defined as:\n",
                "$$\n",
                "ECOMAC_p = \\frac{\\sum_{i=1}^N \\vert \\phi_{pi} - \\psi_{pi} \\vert}{2 N},\n",
                "$$\n",
                "where $N$ is the number of modes.\n",
                "\n",
                "::: {.callout-note}\n",
                "As for the COMAC indicator, the computation of the ECOMAC indicator requires that the two mode shapes have the same number of coordinates and similar scaling.\n",
                ":::\n",
                "\n",
                "Low values of the indicator indicates a strong correlation between the two mode shapes, while high values indicate very little correlation.\n",
                "\n",
                "::: {.api}\n",
                "**ecomac**\n",
                "\n",
                "---"
            ]
        },
        {
            "id": "14",
            "cell_type": "code",
            "metadata": {
            },
            "source": [
                "#| echo: false\n",
                "@doc ecomac"
            ],
            "outputs": [
                {
                    "output_type": "execute_result",
                    "execution_count": 1,
                    "data": {
                        "text/plain": "  \u001b[36mecomac(ms_exp, ms_th)\u001b[39m\n\n  Compute the enhanced coordinate modal assurance criterion (eCOMAC) between\n  experimental and theoretical mode shapes.\n\n  \u001b[1mInputs\u001b[22m\n\n    \u001b[34m• \u001b[39m \u001b[36mms_exp\u001b[39m: Experimental mode shapes (nmes x nmodes array)\n    \u001b[34m• \u001b[39m \u001b[36mms_th\u001b[39m: Theoretical mode shapes (nmes x nmodes array)\n\n  \u001b[1mOutput\u001b[22m\n\n    \u001b[34m• \u001b[39m \u001b[36mecomac\u001b[39m: Enhanced coordinate modal assurance criterion values (nmes\n       array)\n\n  \u001b[1mReference\u001b[22m [1] D. L. Hunt. Application of an Enhanced Coordinate Modal\n  Assurance Criterion (ECOMAC). Proceedings of International Modal Analysis\n  Conference, pp. 66-71, 1992.\n\n  [2] G. Martin, E. Balmes and T. Chancelier. Improved Modal Assurance\n  Criterion using a quantification of identification errors per mode/sensor.\n  Proceedings of ISMA 2014, pp. 2509-2519. 2014.",
                        "text/markdown": "```julia\necomac(ms_exp, ms_th)\n```\n\nCompute the enhanced coordinate modal assurance criterion (eCOMAC) between experimental and theoretical mode shapes.\n\n**Inputs**\n\n  * `ms_exp`: Experimental mode shapes (nmes x nmodes array)\n  * `ms_th`: Theoretical mode shapes (nmes x nmodes array)\n\n**Output**\n\n  * `ecomac`: Enhanced coordinate modal assurance criterion values (nmes array)\n\n**Reference** [1] D. L. Hunt. Application of an Enhanced Coordinate Modal Assurance Criterion (ECOMAC). Proceedings of International Modal Analysis Conference, pp. 66-71, 1992.\n\n[2] G. Martin, E. Balmes and T. Chancelier. Improved Modal Assurance Criterion using a quantification of identification errors per mode/sensor. Proceedings of ISMA 2014, pp. 2509-2519. 2014.\n",
                        "text/html": "<div class=\"markdown\"><pre><code class=\"language-julia\">ecomac&#40;ms_exp, ms_th&#41;</code></pre>\n<p>Compute the enhanced coordinate modal assurance criterion &#40;eCOMAC&#41; between experimental and theoretical mode shapes.</p>\n<p><strong>Inputs</strong></p>\n<ul>\n<li><p><code>ms_exp</code>: Experimental mode shapes &#40;nmes x nmodes array&#41;</p>\n</li>\n<li><p><code>ms_th</code>: Theoretical mode shapes &#40;nmes x nmodes array&#41;</p>\n</li>\n</ul>\n<p><strong>Output</strong></p>\n<ul>\n<li><p><code>ecomac</code>: Enhanced coordinate modal assurance criterion values &#40;nmes array&#41;</p>\n</li>\n</ul>\n<p><strong>Reference</strong> &#91;1&#93; D. L. Hunt. Application of an Enhanced Coordinate Modal Assurance Criterion &#40;ECOMAC&#41;. Proceedings of International Modal Analysis Conference, pp. 66-71, 1992.</p>\n<p>&#91;2&#93; G. Martin, E. Balmes and T. Chancelier. Improved Modal Assurance Criterion using a quantification of identification errors per mode/sensor. Proceedings of ISMA 2014, pp. 2509-2519. 2014.</p>\n\n\n</div>",
                        "text/latex": "\\begin{verbatim}\necomac(ms_exp, ms_th)\n\\end{verbatim}\nCompute the enhanced coordinate modal assurance criterion (eCOMAC) between experimental and theoretical mode shapes.\n\n\\textbf{Inputs}\n\n\\begin{itemize}\n\\item \\texttt{ms\\_exp}: Experimental mode shapes (nmes x nmodes array)\n\n\n\\item \\texttt{ms\\_th}: Theoretical mode shapes (nmes x nmodes array)\n\n\\end{itemize}\n\\textbf{Output}\n\n\\begin{itemize}\n\\item \\texttt{ecomac}: Enhanced coordinate modal assurance criterion values (nmes array)\n\n\\end{itemize}\n\\textbf{Reference} [1] D. L. Hunt. Application of an Enhanced Coordinate Modal Assurance Criterion (ECOMAC). Proceedings of International Modal Analysis Conference, pp. 66-71, 1992.\n\n[2] G. Martin, E. Balmes and T. Chancelier. Improved Modal Assurance Criterion using a quantification of identification errors per mode/sensor. Proceedings of ISMA 2014, pp. 2509-2519. 2014.\n\n"
                    },
                    "metadata": {
                    }
                }
            ],
            "execution_count": 1
        },
        {
            "id": "15",
            "cell_type": "markdown",
            "metadata": {
            },
            "source": [
                ":::\n",
                "\n",
                "### Frequency response assurance criterion\n",
                "\n",
                "The Frequency Response Assurance Criterion (FRAC) is an indicator that quantifies the correlation between two frequency response functions (FRFs) over a given frequency range for a given measurement point $p$ and a given excitation point $q$. For two FRFs $H_{pq}(\\omega)$ and $G_{pq}(\\omega)$, it is defined as:\n",
                "$$\n",
                "FRAC_{pq} = \\frac{\\vert \\sum_{\\omega = \\omega_1}^{\\omega_2} H_{pq}(\\omega) G_{pq}^\\ast(\\omega) \\, \\vert^2}{\\left( \\sum_{\\omega = \\omega_1}^{\\omega_2} \\vert H_{pq}(\\omega) \\vert^2\\right) \\left( \\sum_{\\omega = \\omega_1}^{\\omega_2} \\vert G_{pq}(\\omega) \\vert^2 \\right)},\n",
                "$$\n",
                "$G_{pq}^\\ast(\\omega)$ is the complex conjugate of $G_{pq}(\\omega)$, and $\\omega_1$ and $\\omega_2$ define the frequency range of interest.\n",
                "\n",
                "::: {.api}\n",
                "**frac**\n",
                "\n",
                "---"
            ]
        },
        {
            "id": "16",
            "cell_type": "code",
            "metadata": {
            },
            "source": [
                "#| echo: false\n",
                "@doc frac"
            ],
            "outputs": [
                {
                    "output_type": "execute_result",
                    "execution_count": 1,
                    "data": {
                        "text/plain": "  \u001b[36mfrac(frf_exp, frf_th)\u001b[39m\n\n  Compute the frequency response assurance criterion (FRAC) between\n  experimental and theoretical frequency response functions.\n\n  \u001b[1mInputs\u001b[22m\n\n    \u001b[34m• \u001b[39m \u001b[36mfrf_exp\u001b[39m: Experimental frequency response functions (nmes x nexc x\n       nf array\n    \u001b[34m• \u001b[39m \u001b[36mfrf_th\u001b[39m: Theoretical frequency response functions (nmes x nexc x nf\n       array)\n\n  \u001b[1mOutput\u001b[22m\n\n    \u001b[34m• \u001b[39m \u001b[36mfrac\u001b[39m: Frequency response assurance criterion values (nmes x nexc\n       array)\n\n  \u001b[1mReference\u001b[22m\n\n  [1] R. J. Allemang. The modal assurance criterion twenty years of use and\n  abuse. Sound & Vibration. 37 (8): 14-23. 2003",
                        "text/markdown": "```julia\nfrac(frf_exp, frf_th)\n```\n\nCompute the frequency response assurance criterion (FRAC) between experimental and theoretical frequency response functions.\n\n**Inputs**\n\n  * `frf_exp`: Experimental frequency response functions (nmes x nexc x nf array\n  * `frf_th`: Theoretical frequency response functions (nmes x nexc x nf array)\n\n**Output**\n\n  * `frac`: Frequency response assurance criterion values (nmes x nexc array)\n\n**Reference**\n\n[1] R. J. Allemang. The modal assurance criterion twenty years of use and abuse. Sound & Vibration. 37 (8): 14-23. 2003\n",
                        "text/html": "<div class=\"markdown\"><pre><code class=\"language-julia\">frac&#40;frf_exp, frf_th&#41;</code></pre>\n<p>Compute the frequency response assurance criterion &#40;FRAC&#41; between experimental and theoretical frequency response functions.</p>\n<p><strong>Inputs</strong></p>\n<ul>\n<li><p><code>frf_exp</code>: Experimental frequency response functions &#40;nmes x nexc x nf array</p>\n</li>\n<li><p><code>frf_th</code>: Theoretical frequency response functions &#40;nmes x nexc x nf array&#41;</p>\n</li>\n</ul>\n<p><strong>Output</strong></p>\n<ul>\n<li><p><code>frac</code>: Frequency response assurance criterion values &#40;nmes x nexc array&#41;</p>\n</li>\n</ul>\n<p><strong>Reference</strong></p>\n<p>&#91;1&#93; R. J. Allemang. The modal assurance criterion twenty years of use and abuse. Sound &amp; Vibration. 37 &#40;8&#41;: 14-23. 2003</p>\n\n\n</div>",
                        "text/latex": "\\begin{verbatim}\nfrac(frf_exp, frf_th)\n\\end{verbatim}\nCompute the frequency response assurance criterion (FRAC) between experimental and theoretical frequency response functions.\n\n\\textbf{Inputs}\n\n\\begin{itemize}\n\\item \\texttt{frf\\_exp}: Experimental frequency response functions (nmes x nexc x nf array\n\n\n\\item \\texttt{frf\\_th}: Theoretical frequency response functions (nmes x nexc x nf array)\n\n\\end{itemize}\n\\textbf{Output}\n\n\\begin{itemize}\n\\item \\texttt{frac}: Frequency response assurance criterion values (nmes x nexc array)\n\n\\end{itemize}\n\\textbf{Reference}\n\n[1] R. J. Allemang. The modal assurance criterion twenty years of use and abuse. Sound \\& Vibration. 37 (8): 14-23. 2003\n\n"
                    },
                    "metadata": {
                    }
                }
            ],
            "execution_count": 1
        },
        {
            "id": "17",
            "cell_type": "markdown",
            "metadata": {
            },
            "source": [
                ":::\n",
                "\n",
                "## Indicator functions\n",
                "\n",
                "The following indicator functions can be used to estimate the number of modes of a structure.\n",
                "\n",
                "### Complex Mode Indicator Function\n",
                "\n",
                "The Complex Mode Indicator Function (CMIF) is a global indicator that helps identify the number of modes in a system. It is defined as the singular values of the frequency response function (FRF) matrix $\\mathbf{H}(\\omega)$ over a frequency range of interest. The FRF matrix is constructed by stacking the FRFs for all measurement points and excitation points.\n",
                "\n",
                "When admittance or accelerance are used, the CMIF is computed as the singular values of the imaginary part of the FRF matrix, while for mobility, the real part is used. From a general standpoint, the CMIF is given by:\n",
                "$$\n",
                "CMIF(\\omega) = \\mathbf{\\Sigma}(\\omega),\n",
                "$$\n",
                "where $\\mathbf{\\Sigma}(\\omega)$ is the vector of singular values obtained from the singular value decomposition of the FRF matrix.\n",
                "\n",
                "::: {.api}\n",
                "**cmif**\n",
                "\n",
                "---"
            ]
        },
        {
            "id": "18",
            "cell_type": "code",
            "metadata": {
            },
            "source": [
                "#| echo: false\n",
                "@doc cmif"
            ],
            "outputs": [
                {
                    "output_type": "execute_result",
                    "execution_count": 1,
                    "data": {
                        "text/plain": "  \u001b[36mcmif(frf; type = :dis)\u001b[39m\n\n  Compute the complex mode indicator function (CMIF)\n\n  \u001b[1mInputs\u001b[22m\n\n    \u001b[34m• \u001b[39m \u001b[36mfrf\u001b[39m: Frequency response functions (nmes x nexc x nf array)\n    \u001b[34m• \u001b[39m \u001b[36mtype\u001b[39m: Type of FRF (:dis for displacement, :vel for velocity, :acc\n       for acceleration)\n\n  \u001b[1mOutput\u001b[22m\n\n    \u001b[34m• \u001b[39m \u001b[36mcmif\u001b[39m: Complex mode indicator function (min(nmes, nexc) x nf array)\n\n  \u001b[1mReference\u001b[22m\n\n  [1] R. J. Allemang and D. L. Brown. A Complete Review of the Complex Mode\n  Indicator Function (CMIF) with Applications. ISMA 2006. 2006",
                        "text/markdown": "```julia\ncmif(frf; type = :dis)\n```\n\nCompute the complex mode indicator function (CMIF)\n\n**Inputs**\n\n  * `frf`: Frequency response functions (nmes x nexc x nf array)\n  * `type`: Type of FRF (:dis for displacement, :vel for velocity, :acc for acceleration)\n\n**Output**\n\n  * `cmif`: Complex mode indicator function (min(nmes, nexc) x nf array)\n\n**Reference**\n\n[1] R. J. Allemang and D. L. Brown. A Complete Review of the Complex Mode  Indicator Function (CMIF) with Applications. ISMA 2006. 2006\n",
                        "text/html": "<div class=\"markdown\"><pre><code class=\"language-julia\">cmif&#40;frf; type &#61; :dis&#41;</code></pre>\n<p>Compute the complex mode indicator function &#40;CMIF&#41;</p>\n<p><strong>Inputs</strong></p>\n<ul>\n<li><p><code>frf</code>: Frequency response functions &#40;nmes x nexc x nf array&#41;</p>\n</li>\n<li><p><code>type</code>: Type of FRF &#40;:dis for displacement, :vel for velocity, :acc for acceleration&#41;</p>\n</li>\n</ul>\n<p><strong>Output</strong></p>\n<ul>\n<li><p><code>cmif</code>: Complex mode indicator function &#40;min&#40;nmes, nexc&#41; x nf array&#41;</p>\n</li>\n</ul>\n<p><strong>Reference</strong></p>\n<p>&#91;1&#93; R. J. Allemang and D. L. Brown. A Complete Review of the Complex Mode  Indicator Function &#40;CMIF&#41; with Applications. ISMA 2006. 2006</p>\n\n\n</div>",
                        "text/latex": "\\begin{verbatim}\ncmif(frf; type = :dis)\n\\end{verbatim}\nCompute the complex mode indicator function (CMIF)\n\n\\textbf{Inputs}\n\n\\begin{itemize}\n\\item \\texttt{frf}: Frequency response functions (nmes x nexc x nf array)\n\n\n\\item \\texttt{type}: Type of FRF (:dis for displacement, :vel for velocity, :acc for acceleration)\n\n\\end{itemize}\n\\textbf{Output}\n\n\\begin{itemize}\n\\item \\texttt{cmif}: Complex mode indicator function (min(nmes, nexc) x nf array)\n\n\\end{itemize}\n\\textbf{Reference}\n\n[1] R. J. Allemang and D. L. Brown. A Complete Review of the Complex Mode  Indicator Function (CMIF) with Applications. ISMA 2006. 2006\n\n"
                    },
                    "metadata": {
                    }
                }
            ],
            "execution_count": 1
        },
        {
            "id": "19",
            "cell_type": "markdown",
            "metadata": {
            },
            "source": [
                ":::\n",
                "\n",
                "### Power spectrum indicator function\n",
                "\n",
                "The Power Spectrum Indicator Function (PSIF) is another global indicator that helps identify the number of modes in a system. It is defined as the sum of the squared magnitudes of the FRFs over all measurement points and excitation points. The PSIF is given by:\n",
                "$$\n",
                "PSIF(\\omega) = \\sum_{p=1}^{N_p} \\sum_{q=1}^{N_q} \\vert H_{pq}(\\omega) \\vert^2,\n",
                "$$\n",
                "where $N_p$ is the number of measurement points, $N_q$ is the number of excitation points, and $H_{pq}(\\omega)$ is the FRF between measurement point $p$ and excitation point $q$.\n",
                "\n",
                "::: {.api}\n",
                "**psif**\n",
                "\n",
                "---"
            ]
        },
        {
            "id": "20",
            "cell_type": "code",
            "metadata": {
            },
            "source": [
                "#| echo: false\n",
                "@doc psif"
            ],
            "outputs": [
                {
                    "output_type": "execute_result",
                    "execution_count": 1,
                    "data": {
                        "text/plain": "  \u001b[36mpsif(frf)\u001b[39m\n\n  Compute the power spectrum indicator function (PSIF).\n\n  \u001b[1mInput\u001b[22m\n\n    \u001b[34m• \u001b[39m \u001b[36mfrf\u001b[39m: Frequency response functions (nmes x nexc x nf array or nmes\n       x nf array)\n\n  \u001b[1mOutput\u001b[22m\n\n    \u001b[34m• \u001b[39m \u001b[36mpsif\u001b[39m: Power spectrum indicator function (nf array)\n\n  \u001b[1mReference\u001b[22m\n\n  [1] M+P Analyzer manual. Rev. 5.1. 2017",
                        "text/markdown": "```julia\npsif(frf)\n```\n\nCompute the power spectrum indicator function (PSIF).\n\n**Input**\n\n  * `frf`: Frequency response functions (nmes x nexc x nf array or nmes x nf array)\n\n**Output**\n\n  * `psif`: Power spectrum indicator function (nf array)\n\n**Reference**\n\n[1] M+P Analyzer manual. Rev. 5.1. 2017\n",
                        "text/html": "<div class=\"markdown\"><pre><code class=\"language-julia\">psif&#40;frf&#41;</code></pre>\n<p>Compute the power spectrum indicator function &#40;PSIF&#41;.</p>\n<p><strong>Input</strong></p>\n<ul>\n<li><p><code>frf</code>: Frequency response functions &#40;nmes x nexc x nf array or nmes x nf array&#41;</p>\n</li>\n</ul>\n<p><strong>Output</strong></p>\n<ul>\n<li><p><code>psif</code>: Power spectrum indicator function &#40;nf array&#41;</p>\n</li>\n</ul>\n<p><strong>Reference</strong></p>\n<p>&#91;1&#93; M&#43;P Analyzer manual. Rev. 5.1. 2017</p>\n\n\n</div>",
                        "text/latex": "\\begin{verbatim}\npsif(frf)\n\\end{verbatim}\nCompute the power spectrum indicator function (PSIF).\n\n\\textbf{Input}\n\n\\begin{itemize}\n\\item \\texttt{frf}: Frequency response functions (nmes x nexc x nf array or nmes x nf array)\n\n\\end{itemize}\n\\textbf{Output}\n\n\\begin{itemize}\n\\item \\texttt{psif}: Power spectrum indicator function (nf array)\n\n\\end{itemize}\n\\textbf{Reference}\n\n[1] M+P Analyzer manual. Rev. 5.1. 2017\n\n"
                    },
                    "metadata": {
                    }
                }
            ],
            "execution_count": 1
        },
        {
            "id": "21",
            "cell_type": "markdown",
            "metadata": {
            },
            "source": [
                ":::"
            ]
        }
    ],
    "timestamp": "2025-10-22T15:17:28.889",
    "file": "/Users/maucejo/Documents/01_Recherche/04_Projets/Codes/Julia/StructuralVibration/docs/modal_extraction/indicators.qmd",
    "qnr_schema_version": "1.0.0"
}