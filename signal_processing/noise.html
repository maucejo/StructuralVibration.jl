<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Noise estimation &amp; denoising – StructuralVibration.jl</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script><script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../signal_processing/other.html" rel="next">
<link href="../signal_processing/index.html" rel="prev">
<link href="../assets/logo/doclogo.svg" rel="icon" type="image/svg+xml">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-4d04b275c36bd460889107e331013233.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-585a77d67552b4a34eb0de6c9603dd02.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>html{ scroll-behavior: smooth; }</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>



<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>


  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../assets/logo/doclogo.svg" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">StructuralVibration.jl</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Overview</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../models/index.html"> 
<span class="menu-text">Models</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../solvers/index.html"> 
<span class="menu-text">Solvers</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../modal_extraction/index.html"> 
<span class="menu-text">Modal extraction</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="../signal_processing/index.html" aria-current="page"> 
<span class="menu-text">Signal processing</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../visualization/index.html"> 
<span class="menu-text">Visualization</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/maucejo/StructuralVibration.jl"> <i class="bi bi-github" role="img" aria-label="GitHub">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../signal_processing/noise.html">Noise estimation &amp; denoising</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../signal_processing/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Digital Signal Processing</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../signal_processing/noise.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Noise estimation &amp; denoising</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../signal_processing/other.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Other processing</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#noise-estimation" id="toc-noise-estimation" class="nav-link active" data-scroll-target="#noise-estimation"><span class="header-section-number">1</span> Noise estimation</a>
  <ul class="collapse">
  <li><a href="#estimation-methods" id="toc-estimation-methods" class="nav-link" data-scroll-target="#estimation-methods"><span class="header-section-number">1.1</span> Estimation methods</a></li>
  <li><a href="#api" id="toc-api" class="nav-link" data-scroll-target="#api"><span class="header-section-number">1.2</span> API</a></li>
  <li><a href="#example" id="toc-example" class="nav-link" data-scroll-target="#example"><span class="header-section-number">1.3</span> Example</a></li>
  </ul></li>
  <li><a href="#signal-denoising" id="toc-signal-denoising" class="nav-link" data-scroll-target="#signal-denoising"><span class="header-section-number">2</span> Signal denoising</a>
  <ul class="collapse">
  <li><a href="#denoising-methods" id="toc-denoising-methods" class="nav-link" data-scroll-target="#denoising-methods"><span class="header-section-number">2.1</span> Denoising methods</a></li>
  <li><a href="#api-1" id="toc-api-1" class="nav-link" data-scroll-target="#api-1"><span class="header-section-number">2.2</span> API</a></li>
  <li><a href="#example-1" id="toc-example-1" class="nav-link" data-scroll-target="#example-1"><span class="header-section-number">2.3</span> Example</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Noise estimation &amp; denoising</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>Noise estimation and denoising are important steps in signal processing, especially in the context of structural vibration analysis. Noise can obscure the underlying signal, making it difficult to extract meaningful information. For instance, in inverse problems, noise can significantly affects the accuracy of the estimated solution when the system is ill-posed. Another example is Kalman filtering for which the noise covariance matrix is a key parameter.</p>
<p><code>StructuralVibration.jl</code> provides a set of tools for estimating noise in signals and for denoising them. The implemented methods can be applied to real or complex signals.</p>
<p>Here, it is assumed that the noise is additive and Gaussian. This means that the noisy signal on a sensor <span class="math inline">\(i\)</span>, <span class="math inline">\(\mathbf{y}_i\)</span>, can thus be modeled as the sum of a noise-free signal <span class="math inline">\(\mathbf{x}_i\)</span> and a noise term <span class="math inline">\(\mathbf{n}_i\)</span>: <span class="math display">\[
\mathbf{y}_i = \mathbf{x}_i + \mathbf{n}_i,
\]</span> where <span class="math inline">\(\mathbf{n}_i\)</span> is a zero-mean Gaussian noise with covariance matrix <span class="math inline">\(\mathbf{R}_i\)</span>. A common assumption is that the noise covariance matrix is isotropic, implying that: <span class="math display">\[
\mathbf{R}_i = \sigma_i^2 \mathbf{I}_n,
\]</span> where <span class="math inline">\(\sigma_i^2\)</span> is the noise variance on the channel <span class="math inline">\(i\)</span> and <span class="math inline">\(\mathbf{I}\)</span> is the identity matrix of size <span class="math inline">\(n\)</span> (the number of samples in the signal).</p>
<section id="noise-estimation" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="noise-estimation"><span class="header-section-number">1</span> Noise estimation</h2>
<p>Noise estimation is the process of quantifying the level of noise present in a signal. This can be done using various methods, such as statistical analysis, spectral analysis, or model-based approaches. In <code>StructuralVibration.jl</code>, two main strategies are available for noise estimation:</p>
<ul>
<li>Regularization-based : These methods involve the resolution of an optimization problem.</li>
<li>Filtering-based : These methods are based on a careful analysis of the statistics of a noisy signal and do not involve optimization.</li>
</ul>
<section id="estimation-methods" class="level3" data-number="1.1">
<h3 data-number="1.1" class="anchored" data-anchor-id="estimation-methods"><span class="header-section-number">1.1</span> Estimation methods</h3>
<section id="sec-reg" class="level4" data-number="1.1.1">
<h4 data-number="1.1.1" class="anchored" data-anchor-id="sec-reg"><span class="header-section-number">1.1.1</span> Regularization-based noise estimation</h4>
<p>Regularization-based noise estimation methods involve solving an optimization problem to estimate the noise variance associated to each measurement channel. The optimization problem is typically formulated as a minimization of a cost function that balances the fidelity to the data and a regularization term.</p>
<p>From a general perspective, the denoising problem can be formulated as: <span class="math display">\[
\widehat{\mathbf{x}}_i = \underset{\mathbf{x}_i}{\text{argmin}} \Vert \mathbf{y}_i - \mathbf{x}_i \Vert_2^2 + \lambda \Vert \mathbf{D} \mathbf{x}_i \Vert_2^2,
\]</span> where <span class="math inline">\(\mathbf{D}\)</span> is generally the second order finite difference operator, <span class="math inline">\(\lambda\)</span> is a regularization parameter.</p>
<p>The solution of the previous optimization problem is given by: <span class="math display">\[
\widehat{\mathbf{x}}_i = \left( \mathbf{I} + \lambda \mathbf{D}^\mathsf{T} \mathbf{D} \right)^{-1} \mathbf{y}_i,
\]</span></p>
<p>A classical estimator of the noise variance is the biased sample variance given by: <span class="math display">\[
\widehat{\sigma}_i^2 = \frac{1}{n} \Vert \mathbf{y}_i - \widehat{\mathbf{x}}_i \Vert_2^2.
\]</span></p>
<p>The main point here is to find an appropriate regularization parameter <span class="math inline">\(\lambda\)</span>. In the literature, several methods have been proposed to estimate the regularization parameter. In this package, the following methods are implemented:</p>
<ul>
<li>Generalized Cross Validation (GCV)<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></li>
<li>L-curve method<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></li>
</ul>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>In practice, this estimator can be computed without computing the denoised signal <span class="math inline">\(\widehat{\mathbf{x}}_i\)</span> explicitly. To do so, the implementation makes use of the discrete cosine transform (DCT).</p>
</div>
</div>
</section>
<section id="filtering-based-noise-estimation" class="level4" data-number="1.1.2">
<h4 data-number="1.1.2" class="anchored" data-anchor-id="filtering-based-noise-estimation"><span class="header-section-number">1.1.2</span> Filtering-based noise estimation</h4>
<p>Heuristic-based noise estimation methods are based on a careful analysis of the statistics of a noisy signal and often rely on the assumption that the noise is Gaussian. These methods do not involve optimization and are typically faster than regularization-based methods. They can be used to estimate the noise variance directly from the noisy signal. <code>StructuralVibration.jl</code> implements the method proposed John D’Errico in the Matlab function <code>estimatenoise.m</code><a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></p>
</section>
</section>
<section id="api" class="level3" data-number="1.2">
<h3 data-number="1.2" class="anchored" data-anchor-id="api"><span class="header-section-number">1.2</span> API</h3>
<p><strong>Data types</strong></p>
<div class="api">
<p><strong>GCVEst</strong></p>
<hr>
<div id="4" class="cell" data-execution_count="1">
<div class="cell-output cell-output-display" data-execution_count="1">
<div class="markdown"><pre><code>GCVEst</code></pre>
<p>Generalized Cross-Validation (GCV) noise estimation</p>
<p>This method has been proposed by Garcia in [1]</p>
<p><strong>Fields</strong></p>
<ul>
<li><p><code>nothing</code></p>
</li>
</ul>
<p><strong>Reference</strong></p>
<p>[1] Garcia, D. (2010). Robust smoothing of gridded data in one and higher dimensions with missing values. Computational Statistics and Data Analysis, 54(5), 1167-1178</p>


</div>
</div>
</div>
</div>
<div class="api">
<p><strong>LCurveEst</strong></p>
<hr>
<div id="6" class="cell" data-execution_count="1">
<div class="cell-output cell-output-display" data-execution_count="1">
<div class="markdown"><pre><code>LCurveEst</code></pre>
<p>L-curve noise estimation</p>
<p>This method is based on the method proposed by Hansen in [1]</p>
<p><strong>Fields</strong></p>
<ul>
<li><p><code>nothing</code></p>
</li>
</ul>
<p><strong>Reference</strong></p>
<p>[1] Hansen, P. C. (1999). The L-curve and its use in the numerical treatment of inverse problems. Computational Inverse Problems in Electrocardiology, 119-142</p>


</div>
</div>
</div>
</div>
<div class="api">
<p><strong>DerricoEst</strong></p>
<hr>
<div id="8" class="cell" data-execution_count="1">
<div class="cell-output cell-output-display" data-execution_count="1">
<div class="markdown"><pre><code>DerricoEst</code></pre>
<p>D'Errico noise estimation</p>
<p>This method has been proposed by John D'Errico in [1]</p>
<p><strong>Fields</strong></p>
<ul>
<li><p><code>nothing</code></p>
</li>
</ul>
<p><strong>Reference</strong></p>
<p>[1] John D'Errico (2023). Estimatenoise, MATLAB Central File Exchange. Retrieved December 7, 2023. (https://www.mathworks.com/matlabcentral/fileexchange/16683-estimatenoise)</p>


</div>
</div>
</div>
</div>
<p><strong>Related function</strong></p>
<div class="api">
<p><strong>varest</strong></p>
<hr>
<div id="10" class="cell" data-execution_count="1">
<div class="cell-output cell-output-display" data-execution_count="1">
<div class="markdown"><pre><code>varest(x, method::NoiseEstimation; batch_size = 0, summary = mean)</code></pre>
<p>Estimates the noise variance of a signal <code>x</code> using a given method</p>
<p><strong>Inputs</strong></p>
<ul>
<li><p><code>x</code>: Signal</p>
</li>
<li><p><code>method</code>: Noise estimation method</p>
<ul>
<li><p><code>BayesianEst</code>: Bayesian noise estimation (To be implemented)</p>
</li>
<li><p><code>GCVEst</code>: Generalized Cross-Validation (GCV) noise estimation</p>
</li>
<li><p><code>LCurveEst</code>: L-curve noise estimation</p>
</li>
<li><p><code>DerricoEst</code>: D'Errico noise estimation</p>
</li>
</ul>
</li>
<li><p><code>batch_size</code>: Batch size for batch processing (default = 0)</p>
</li>
<li><p><code>summary</code>: Summary function for batch processing (default = mean)</p>
</li>
</ul>


</div>
</div>
</div>
</div>
</section>
<section id="example" class="level3" data-number="1.3">
<h3 data-number="1.3" class="anchored" data-anchor-id="example"><span class="header-section-number">1.3</span> Example</h3>
<div id="12" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Beam definition</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>L <span class="op">=</span> <span class="fl">1</span>.</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> <span class="fl">3e-2</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>h <span class="op">=</span> <span class="fl">1e-2</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>E <span class="op">=</span> <span class="fl">2.1e11</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>ρ <span class="op">=</span> <span class="fl">7850</span>.</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>ξn <span class="op">=</span> <span class="fl">1e-2</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>S <span class="op">=</span> b<span class="op">*</span>h</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>Iz <span class="op">=</span> b<span class="op">*</span>h<span class="op">^</span><span class="fl">3</span><span class="op">/</span><span class="fl">12</span>.</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>beam <span class="op">=</span> <span class="fu">Beam</span>(L, S, Iz, E, ρ)</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Measurement mesh</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>Δx <span class="op">=</span> <span class="fl">5e-2</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>Npoint <span class="op">=</span> <span class="fl">20</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>Xm <span class="op">=</span> <span class="fu">LinRange</span>(Δx, L <span class="op">-</span> Δx, Npoint)</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Modes calculation</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>ωn, kn <span class="op">=</span> <span class="fu">modefreq</span>(beam, <span class="fl">2000</span>.)</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>ϕm <span class="op">=</span> <span class="fu">modeshape</span>(beam, kn, Xm)</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>ϕe <span class="op">=</span> <span class="fu">modeshape</span>(beam, kn, Xm[<span class="fl">13</span>])</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a><span class="co"># Modal model</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>Kn, Mn, Cn <span class="op">=</span> <span class="fu">modal_matrices</span>(ωn, ξn)</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a><span class="co"># Excitation</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>tmax <span class="op">=</span> <span class="fl">0.5</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>nt <span class="op">=</span> <span class="fl">10_000</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> <span class="fu">LinRange</span>(<span class="fl">0</span>., tmax, nt)</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>harmo <span class="op">=</span> <span class="fu">SineWave</span>(<span class="fl">1e4</span>, <span class="fl">0</span>., tmax, <span class="fl">2</span>π<span class="op">*</span><span class="fl">10</span>.)</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>F <span class="op">=</span> <span class="fu">excitation</span>(harmo, t)</span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>Fn <span class="op">=</span> ϕe<span class="op">'*</span>F<span class="op">'</span></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a><span class="co"># Solution calculation</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>u0 <span class="op">=</span> (<span class="fu">zeros</span>(<span class="fu">length</span>(ωn)), <span class="fu">zeros</span>(<span class="fu">length</span>(ωn)))</span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>prob <span class="op">=</span> <span class="fu">DirectTimeProblem</span>(Kn, Mn, Cn, Fn, u0, t)</span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>u <span class="op">=</span> <span class="fu">ϕm*solve</span>(prob).u</span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a><span class="co"># Signal corruption - Additive Gaussian White Noise</span></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>SNR_ref <span class="op">=</span> <span class="fl">25</span>.</span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> <span class="fu">agwn</span>(u, SNR_ref)</span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a><span class="co"># Variance estimation - Average over all channels</span></span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>v1 <span class="op">=</span> <span class="fu">varest</span>(y, <span class="fu">GCVEst</span>())</span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>SNR_est1 <span class="op">=</span> <span class="fu">mean</span>(<span class="fu">estimated_SNR</span>(y, v1))</span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a>v2 <span class="op">=</span> <span class="fu">varest</span>(y, <span class="fu">LCurveEst</span>())</span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>SNR_est2 <span class="op">=</span> <span class="fu">mean</span>(<span class="fu">estimated_SNR</span>(y, v2))</span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a>v3 <span class="op">=</span> <span class="fu">varest</span>(y, <span class="fu">DerricoEst</span>())</span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a>SNR_est3 <span class="op">=</span> <span class="fu">mean</span>(<span class="fu">estimated_SNR</span>(y, v3))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="1">
<div class="cell-output cell-output-display" data-execution_count="1">
<div class="markdown">
<table class="caption-top table table-sm table-striped small" data-quarto-postprocess="true">
<caption>Noise variance estimation</caption>
<tbody>
<tr class="odd">
<td style="text-align: center;" data-quarto-table-cell-role="th">Reference</td>
<td style="text-align: center;" data-quarto-table-cell-role="th">GCV</td>
<td style="text-align: center;" data-quarto-table-cell-role="th">L-curve</td>
<td style="text-align: center;" data-quarto-table-cell-role="th">D'Errico</td>
</tr>
<tr class="even">
<td style="text-align: center;">25.0 dB</td>
<td style="text-align: center;">25.16 dB</td>
<td style="text-align: center;">25.1 dB</td>
<td style="text-align: center;">25.05 dB</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
</section>
</section>
<section id="signal-denoising" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="signal-denoising"><span class="header-section-number">2</span> Signal denoising</h2>
<p>Signal denoising is the process of removing noise from a signal to recover the underlying clean signal. This can be done using various methods, such as filtering, wavelet transforms, or model-based approaches. In <code>StructuralVibration.jl</code>, the denoising process is typically performed using the same methods as those used for noise estimation. As for noise estimation, the proposed methods can be applied to real or complex signals.</p>
<section id="denoising-methods" class="level3" data-number="2.1">
<h3 data-number="2.1" class="anchored" data-anchor-id="denoising-methods"><span class="header-section-number">2.1</span> Denoising methods</h3>
<p><code>StructuralVibration.jl</code> proposes two main methods for denoising signals:</p>
<ul>
<li><p>Regularization-based denoising: This method involves solving an optimization problem to estimate the noise-free signal. The optimization problem is typically formulated as a minimization of a cost function that balances the fidelity to the data and a regularization term.</p></li>
<li><p>Filtering-based denoising: This method is based on the implementation of a Kalman filter, which is a recursive algorithm that estimates the state of a dynamic system from a series of noisy measurements.</p></li>
</ul>
<section id="regularization-based-denoising" class="level4" data-number="2.1.1">
<h4 data-number="2.1.1" class="anchored" data-anchor-id="regularization-based-denoising"><span class="header-section-number">2.1.1</span> Regularization-based denoising</h4>
<p>Regularization-based denoising consists in solving the minimization problem defined in <a href="#sec-reg" class="quarto-xref">Section&nbsp;1.1.1</a>. This implies a proper estimation of the regularization parameter <span class="math inline">\(\lambda\)</span>. Similar to the noise estimation process, two methods are available for estimating the regularization parameter, namely GCV and L-curve methods.</p>
</section>
<section id="filtering-based-denoising" class="level4" data-number="2.1.2">
<h4 data-number="2.1.2" class="anchored" data-anchor-id="filtering-based-denoising"><span class="header-section-number">2.1.2</span> Filtering-based denoising</h4>
<p>As stated above, filtering-based denoising is based on the implementation of a Kalman filter. For denoising problems, the Kalman filter is based on the following state-space model: <span class="math display">\[
\begin{cases}
\mathbf{x}_{k+1} = \mathbf{x}_k + \mathbf{w}_k \\
\mathbf{y}_k = \mathbf{x}_k + \mathbf{n}_k
\end{cases},
\]</span> where <span class="math inline">\(\mathbf{x}_k\)</span> is the state vector (clean signal) at time <span class="math inline">\(k\)</span>, <span class="math inline">\(\mathbf{y}_k\)</span> is the measurement vector at time <span class="math inline">\(k\)</span>, <span class="math inline">\(\mathbf{w}_k\)</span> is the process noise, and <span class="math inline">\(\mathbf{n}_k\)</span> is the measurement noise. The process noise is assumed to be zero-mean Gaussian with constant covariance matrix <span class="math inline">\(\mathbf{Q}\)</span>, and the measurement noise is assumed to be zero-mean Gaussian with constant covariance matrix <span class="math inline">\(\mathbf{R}\)</span>.</p>
<p>Practically, a Kalman filter is implemented in two steps:</p>
<ol type="1">
<li><p><strong>Prediction step</strong>: The state vector and its covariance matrix are predicted based on the knowledge of the solution at the previous step. <span class="math display">\[
\begin{align*}
\widetilde{\mathbf{x}}_{k} &amp;= \widehat{\mathbf{x}}_{k-1} \\
\widetilde{\mathbf{P}}_{k} &amp;= \widehat{\mathbf{P}}_{k-1} + \mathbf{Q}
\end{align*},
\]</span> where <span class="math inline">\(\widetilde{\mathbf{x}}_{k}\)</span> is the predicted state vector, <span class="math inline">\(\widehat{\mathbf{x}}_{k-1}\)</span> is the estimated state vector at step <span class="math inline">\(k-1\)</span>, <span class="math inline">\(\widetilde{\mathbf{P}}_{k}\)</span> is the predicted covariance matrix, and <span class="math inline">\(\widehat{\mathbf{P}}_{k-1}\)</span> is the estimated covariance matrix at step <span class="math inline">\(k-1\)</span>.</p></li>
<li><p><strong>Update step</strong>: The state vector and its covariance matrix are updated based on the measurement at the current step. <span class="math display">\[
\begin{align*}
\mathbf{i}_k &amp;= \mathbf{y}_k - \widetilde{\mathbf{x}}_{k} \\
\mathbf{S}_k &amp;= \widetilde{\mathbf{P}}_{k} + \mathbf{R} \\
\mathbf{K}_{k} &amp;= \widetilde{\mathbf{P}}_{k} \mathbf{S}_k^{-1} \\
\widehat{\mathbf{x}}_{k} &amp;= \widetilde{\mathbf{x}}_{k} + \mathbf{K}_{k} \mathbf{i}_k \\
\widehat{\mathbf{P}}_{k} &amp;= \left( \mathbf{I} - \mathbf{K}_{k}\right) \widetilde{\mathbf{P}}_{k}
\end{align*},
\]</span> where <span class="math inline">\(\widehat{\mathbf{x}}_{k}\)</span> is the updated state vector, <span class="math inline">\(\widehat{\mathbf{P}}_{k}\)</span> is the updated covariance matrix and <span class="math inline">\(\mathbf{K}_{k}\)</span> is the Kalman gain, <span class="math inline">\(\mathbf{i}_k\)</span> is the innovation vector and <span class="math inline">\(\mathbf{S}_k\)</span> is the innovation covariance matrix.</p></li>
</ol>
<p>For a successful denoising process, the Kalman filter requires a proper tuning of the noise covariance matrices <span class="math inline">\(\mathbf{Q}\)</span> and <span class="math inline">\(\mathbf{R}\)</span> as wel as a proper initialization of the state vector and its covariance matrix.</p>
<p>Here, the measurement noise covariance matrix <span class="math inline">\(\mathbf{R}\)</span> is estimated using the methods described in the previous section. The process noise covariance matrix <span class="math inline">\(\mathbf{Q}\)</span> is assumed to be isotropic and its variance <span class="math inline">\(\sigma_x^2\)</span> results from the resolution of the following optimization problem: <span class="math display">\[
\widehat{\sigma}_x^2 = \underset{\sigma_x^2}{\text{argmin}} \sum_{i = 1}^N \left[\log|\mathbf{S}_k| + \mathbf{i}_k^\mathsf{T}\mathbf{S}_k^{-1}\mathbf{i}_k\right],
\]</span> where <span class="math inline">\(N\)</span> is the length of the measurement sequence.</p>
<p>In addition to the filtering step, a smoothing step can be added. In the present case, a Rauch-Tung-Striebel (RTS) smoother is used. From a practical point of view, the RTS smoother is implemented as a post-processing step that uses the Kalman filter output to improve the estimate of the state vector. The RTS smoother is based on the following equations: <span class="math display">\[
\begin{align*}
\widehat{\mathbf{x}}_k^s &amp;= \widehat{\mathbf{x}}_k + \mathbf{K}_k \left( \widehat{\mathbf{x}}_{k+1}^s - \widehat{\mathbf{x}}_k \right) \\
\widehat{\mathbf{P}}_k^s &amp;= \widehat{\mathbf{P}}_k + \mathbf{K}_k \left( \widehat{\mathbf{P}}_{k+1}^s - \widehat{\mathbf{P}}_k \right) \mathbf{K}_k^\mathsf{T} \\
\mathbf{K}_k &amp;= \widehat{\mathbf{P}}_k (\widehat{\mathbf{P}}_k + \mathbf{Q})^{-1} \\
\end{align*},
\]</span> where <span class="math inline">\(\widehat{\mathbf{x}}_k^s\)</span> is the smoothed state vector, <span class="math inline">\(\widehat{\mathbf{P}}_k^s\)</span> is the smoothed covariance matrix, and <span class="math inline">\(\mathbf{K}_k\)</span> is the Kalman gain.</p>
</section>
</section>
<section id="api-1" class="level3" data-number="2.2">
<h3 data-number="2.2" class="anchored" data-anchor-id="api-1"><span class="header-section-number">2.2</span> API</h3>
<p><strong>Data types</strong></p>
<div class="api">
<p><strong>GCVDenoising</strong></p>
<hr>
<div id="16" class="cell" data-execution_count="1">
<div class="cell-output cell-output-display" data-execution_count="1">
<div class="markdown"><pre><code>GCVDenoising()</code></pre>
<p>Regularization-based denoising method using the GCV method for estimating the regularization parameter</p>
<p><strong>Fields</strong></p>
<ul>
<li><p><code>nothing</code></p>
</li>
</ul>
<p><strong>Reference</strong></p>
<p>[1] Garcia, D. (2010). Robust smoothing of gridded data in one and higher dimensions with missing values. Computational Statistics and Data Analysis, 54(5), 1167-1178</p>


</div>
</div>
</div>
</div>
<div class="api">
<p><strong>LCurveDenoising</strong></p>
<hr>
<div id="18" class="cell" data-execution_count="1">
<div class="cell-output cell-output-display" data-execution_count="1">
<div class="markdown"><pre><code>LCurveDenoising()</code></pre>
<p>Regularization-based denoising method using the L-curve method for estimating the regularization parameter</p>
<p><strong>Fields</strong></p>
<ul>
<li><p><code>nothing</code></p>
</li>
</ul>
<p><strong>Reference</strong></p>
<p>[1] Hansen, P. C. (1999). The L-curve and its use in the numerical treatment of inverse problems. Computational Inverse Problems in Electrocardiology, 119-142</p>


</div>
</div>
</div>
</div>
<div class="api">
<p><strong>KalmanDenoising</strong></p>
<hr>
<div id="20" class="cell" data-execution_count="1">
<div class="cell-output cell-output-display" data-execution_count="1">
<div class="markdown"><pre><code>KalmanDenoising(; rts = false)</code></pre>
<p>Kalman filter denoising method</p>
<p><strong>Fields</strong></p>
<ul>
<li><p><code>rts</code>: Flag to enable the Rauch-Tung-Striebel smoother</p>
</li>
</ul>


</div>
</div>
</div>
</div>
<p><strong>Related function</strong></p>
<div class="api">
<p><strong>denoising</strong></p>
<hr>
<div id="22" class="cell" data-execution_count="1">
<div class="cell-output cell-output-display" data-execution_count="1">
<div class="markdown"><pre><code>denoising(y::AbstractArray, alg)</code></pre>
<p>Denoises a signal <code>y</code></p>
<p><strong>Inputs</strong></p>
<ul>
<li><p><code>y</code>: Noisy signal</p>
</li>
<li><p><code>alg</code>: Denoising method</p>
<ul>
<li><p><code>BayesDenoising</code>: Bayesian Regularization denoising method (to be implemented)</p>
</li>
<li><p><code>GCVDenoising</code>: GCV denoising method</p>
</li>
<li><p><code>LCurveDenoising</code>: L-curve denoising method</p>
</li>
<li><p><code>KalmanDenoising</code>: Kalman filter denoising method</p>
</li>
</ul>
</li>
</ul>
<p><strong>Output</strong></p>
<ul>
<li><p><code>x</code>: Denoised signal</p>
</li>
</ul>


</div>
</div>
</div>
</div>
</section>
<section id="example-1" class="level3" data-number="2.3">
<h3 data-number="2.3" class="anchored" data-anchor-id="example-1"><span class="header-section-number">2.3</span> Example</h3>
<div id="24" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Beam definition</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>L <span class="op">=</span> <span class="fl">1</span>.</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> <span class="fl">3e-2</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>h <span class="op">=</span> <span class="fl">1e-2</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>E <span class="op">=</span> <span class="fl">2.1e11</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>ρ <span class="op">=</span> <span class="fl">7850</span>.</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>ξn <span class="op">=</span> <span class="fl">1e-2</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>S <span class="op">=</span> b<span class="op">*</span>h</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>Iz <span class="op">=</span> b<span class="op">*</span>h<span class="op">^</span><span class="fl">3</span><span class="op">/</span><span class="fl">12</span>.</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>beam <span class="op">=</span> <span class="fu">Beam</span>(L, S, Iz, E, ρ)</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Measurement mesh</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>Δx <span class="op">=</span> <span class="fl">5e-2</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>Npoint <span class="op">=</span> <span class="fl">20</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>Xm <span class="op">=</span> <span class="fu">LinRange</span>(Δx, L <span class="op">-</span> Δx, Npoint)</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Modes calculation</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>ωn, kn <span class="op">=</span> <span class="fu">modefreq</span>(beam, <span class="fl">2000</span>.)</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>ϕm <span class="op">=</span> <span class="fu">modeshape</span>(beam, kn, Xm)</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>ϕe <span class="op">=</span> <span class="fu">modeshape</span>(beam, kn, Xm[<span class="fl">13</span>])</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a><span class="co"># Modal model</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>Kn, Mn, Cn <span class="op">=</span> <span class="fu">modal_matrices</span>(ωn, ξn)</span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a><span class="co"># Problem definition &amp; solution</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>tmax <span class="op">=</span> <span class="fl">0.1</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>nt <span class="op">=</span> <span class="fl">5_000</span></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> <span class="fu">LinRange</span>(<span class="fl">0</span>., tmax, nt)</span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>harmo <span class="op">=</span> <span class="fu">SineWave</span>(<span class="fl">1e4</span>, <span class="fl">0</span>., tmax, <span class="fl">2</span>π<span class="op">*</span><span class="fl">10</span>.)</span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>F <span class="op">=</span> <span class="fu">excitation</span>(harmo, t)</span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a>Fn <span class="op">=</span> ϕe<span class="op">'*</span>F<span class="op">'</span></span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a>u0 <span class="op">=</span> (<span class="fu">zeros</span>(<span class="fu">length</span>(ωn)), <span class="fu">zeros</span>(<span class="fu">length</span>(ωn)))</span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a>prob <span class="op">=</span> <span class="fu">DirectTimeProblem</span>(Kn, Mn, Cn, Fn, u0, t)</span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a>sol <span class="op">=</span> <span class="fu">solve</span>(prob)</span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a>u <span class="op">=</span> ϕm<span class="op">*</span>sol.u</span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a><span class="co"># Gaussian White Noise</span></span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a>snr_dB <span class="op">=</span> <span class="fl">10</span>.</span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> <span class="fu">agwn</span>(u, snr_dB)</span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true" tabindex="-1"></a><span class="co"># Regularization denoising</span></span>
<span id="cb2-46"><a href="#cb2-46" aria-hidden="true" tabindex="-1"></a>yc_gcv <span class="op">=</span> <span class="fu">denoising</span>(y, <span class="fu">GCVDenoising</span>())</span>
<span id="cb2-47"><a href="#cb2-47" aria-hidden="true" tabindex="-1"></a>yc_lcurve <span class="op">=</span> <span class="fu">denoising</span>(y, <span class="fu">LCurveDenoising</span>())</span>
<span id="cb2-48"><a href="#cb2-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-49"><a href="#cb2-49" aria-hidden="true" tabindex="-1"></a><span class="co"># Kalman denoising</span></span>
<span id="cb2-50"><a href="#cb2-50" aria-hidden="true" tabindex="-1"></a>yc_kalman <span class="op">=</span> <span class="fu">denoising</span>(y, <span class="fu">KalmanDenoising</span>())</span>
<span id="cb2-51"><a href="#cb2-51" aria-hidden="true" tabindex="-1"></a>yc_rts <span class="op">=</span> <span class="fu">denoising</span>(y, <span class="fu">KalmanDenoising</span>(rts <span class="op">=</span> <span class="cn">true</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="26" class="cell" data-execution_count="1">
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="noise_files/figure-html/cell-14-output-1.svg" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="noise_files/figure-html/cell-14-output-2.svg" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>


</section>
</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>D. Garcia. “Robust smoothing of gridded data in one and higher dimensions with missing values”. Computational Statistics &amp; Data Analysis, 54(5), pp.&nbsp;1167-1178, 2010.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>P. C. Hansen. “The L-curve and its use in the numerical treatment of inverse problems”. Computational Inverse Problems in Electrocardiology, pp.&nbsp;119-142, 2001.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>John D’Errico. “Estimatenoise”, MATLAB Central File Exchange. Retrieved December 7, 2023. <a href="https://www.mathworks.com/matlabcentral/fileexchange/16683-estimatenoise">Link</a><a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/maucejo\.github\.io\/StructuralVibration\.jl\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../signal_processing/index.html" class="pagination-link" aria-label="Digital Signal Processing">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text">Digital Signal Processing</span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../signal_processing/other.html" class="pagination-link" aria-label="Other processing">
        <span class="nav-page-text">Other processing</span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p>2025 Mathieu Aucejo ∙ Powered by <a href="https://quarto.org"><img src="..\assets/logo/quarto.png" class="img-fluid" style="width:4mm"></a> and <a href="https://julialang.org"><img src="..\assets/logo/julia.svg" class="img-fluid" style="width:4mm"></a></p>
</div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




<script src="../site_libs/quarto-html/zenscroll-min.js"></script>
</body></html>